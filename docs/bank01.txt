.include "header.inc"

.define r_math_divide_16bit_arg_1           $001C ; $7E001C.001D
.define r_math_divide_16bit_arg_2           $001E ; $7E001E.001F
.define r_math_divide_16bit_result          $0020 ; $7E0020.0021
.define r_math_divide_16bit_remainder       $0022 ; $7E0022.0023

.bank 1 slot 1
.section "Bank" namespace "bank01"

; menu_main ($01:8000)
;
; Proxy function to call _menu_main from another bank.
menu_main:
    JSR _menu_main                                                              ; $018000
    RTL                                                                         ; $018003

; unused_menu_namingway ($01:8004)
;
; Unused proxy function to call _menu_namingway from another bank.
unused_menu_namingway:
    JSR _menu_namingway                                                         ; $018004
    RTL                                                                         ; $018007

; menu_shop ($01:8008)
;
; Proxy function to call _menu_shop from another bank.
menu_shop:
    JSR _menu_shop                                                              ; $018008
    RTL                                                                         ; $01800B

; menu_load_game ($01:800C)
;
; Proxy function to call _menu_load_game from another bank.
menu_load_game:
    JSR _menu_load_game                                                         ; $01800C
    RTL                                                                         ; $01800F

; joypad_disable_multi ($01:8010)
;
; Proxy function to call _joypad_disable_multi from another bank.
joypad_disable_multi:
    JSR _joypad_disable_multi                                                   ; $018010
    RTL                                                                         ; $018013

; unused_menu_chocobo ($01:8014)
;
; Unused proxy function to call _menu_big_chocobo from another bank.
unused_menu_chocobo:
    JSR _menu_big_chocobo                                                       ; $018014
    RTL                                                                         ; $018017

; menu_namingway ($01:8018)
;
; Proxy function to call _menu_namingway from another bank.
menu_namingway:
    JSR _menu_namingway                                                         ; $018018
    RTL                                                                         ; $01801B

; initialize_joypad_maps ($01:801C)
;
; Proxy function to call _initialize_joypad_maps from another bank.
initialize_joypad_maps:
    JSR _initialize_joypad_maps                                                 ; $01801C
    RTL                                                                         ; $01801F

; menu_spoils ($01:8020)
;
; Proxy function to call _menu_spoils from another bank.
menu_spoils:
    JSR _menu_spoils                                                            ; $018020
    RTL                                                                         ; $018023

; menu_big_chocobo ($01:8024)
;
; Proxy function to call _menu_big_chocobo from another bank.
menu_big_chocobo:
    JSR _menu_big_chocobo                                                       ; $018024
    RTL                                                                         ; $018027

; update_joypad ($01:8028)
;
; Proxy function to call _update_joypad from another bank, which updates the
; joypad values at $00 through $03, relative to the direct register, while
; preserving the accumulator.
update_joypad:
    JSR _update_joypad                                                          ; $018028
    RTL                                                                         ; $01802B

; _menu_main ($01:802C)
;
; Excutes the main menu.
_menu_main:
    PHB                                                                         ; $01802C |\ Back up the direct and data bank registers.
    PHD                                                                         ; $01802D |/
    TDC                                                                         ; $01802E |\ BUG: Presumably this was meant to write to $2100 to set the PPU
    STA $004100.l                                                               ; $01802F |/      brightness to zero and disable forced blanking.
    LDA #$7E.b                                                                  ; $018033 |\
    PHA                                                                         ; $018035 | | Set the data bank register to $7E.
    PLB                                                                         ; $018036 |/
    JSR _menu_main_prepare_and_execute                                          ; $018037 | Execute the main menu.
    LDA #%10000000.b                                                            ; $01803A |\ Set forced blanking on the PPU.
    STA reg_ppu_inidisp.l                                                       ; $01803C |/
    TDC                                                                         ; $018040 |\ Zero out the high byte of the accumulator.
    XBA                                                                         ; $018041 |/
    PLD                                                                         ; $018042 |\ Restore the direct and data bank registers.
    PLB                                                                         ; $018043 |/
    RTS                                                                         ; $018044

; _menu_main_prepare_and_execute ($01:8045)
;
; Does some basic preparation for the main menu and then executes the core main
; menu handler.
_menu_main_prepare_and_execute:
    JSR _menu_backup_vram_tiles                                                 ; $018045 | Backup some VRAM tiles that will be overwritten.
    JSR _menu_init                                                              ; $018048 | Initialize the menu system.
    TSX                                                                         ; $01804B |\
    DEX                                                                         ; $01804C | | Calculate a pointer that called routines can set the stack to to
    DEX                                                                         ; $01804D | | return directly from this routine.
    STX r_menu_return_stack_pointer.w                                           ; $01804E |/
    JSR _menu_main_core                                                         ; $018051 | Execute the core menu routine.
    JSR _menu_ppu_fade_out                                                      ; $018054 | Fade out the PPU.
    JMP _menu_restore_vram_tiles                                                ; $018057 | Restore the backed up VRAM tiles and return.

; unused_start_battle ($01:805A)
;
; Unused proxy function to call start_battle in bank $03.
unused_start_battle:
    JML bank03.start_battle                                                     ; $01805A

; _joypad_disable_multi ($01:805E)
;
; Resets the multi active flag.
_joypad_disable_multi:
    PHA                                                                         ; $01805E | Preserve the value in the accumulator.
    LDA #0.b                                                                    ; $01805F |\ Reset the multi joypad active.
    STA r_multi_active.l & $FFFF                                                ; $018061 |/
    JSL bank14.update_joypad_proxy                                              ; $018065 | Update the joypad values.
    LDA #0.b                                                                    ; $018069 |\ Zero out the high byte of the accumulator.
    XBA                                                                         ; $01806B |/
    PLA                                                                         ; $01806C | Restore the accumulator value.
    RTS                                                                         ; $01806D

; _update_joypad ($01:806E)
;
; Proxy function to call the joypad update routine. The primary difference with
; this version is that it takes care to preserve the accumulator, while the
; default routine does not.
_update_joypad:
    PHA                                                                         ; $01806E | Preserve the value in the accumulator.
    JSL bank14.update_joypad_proxy                                              ; $01806F | Update the current joypad values.
    LDA #$00.b                                                                  ; $018073 |\ Set the high byte of the accumulator to zero.
    XBA                                                                         ; $018075 |/
    PLA                                                                         ; $018076 | Restore the low byte of the accumulator.
    RTS                                                                         ; $018077

; _menu_copy_to_vram ($01:8078)
;
; Given a 16-bit target VRAM address in $011D, a 16-bit source address in $011F,
; a 8-bit source bank in $0121 and a 16-bit number of bytes to transfer in
; $0122, initiates a DMA transfer in channel 0 to copy the specified number of
; bytes to VRAM. The code itself is not particularly exclusive to the menu
; system, but so far is only used by menu code.
_menu_copy_to_vram:
    PHB                                                                         ; $018078 |\
    TDC                                                                         ; $018079 | | Preserve the existing data bank register and set the register to
    PHA                                                                         ; $01807A | | zero.
    PLB                                                                         ; $01807B |/
    LDA #%10000000.b                                                            ; $01807C |\ Set the VRAM increment to 1 by 1 after two bytes.
    STA reg_ppu_vmainc.w                                                        ; $01807E |/
    TDC                                                                         ; $018081 |\ Disable any currently active HDMA.
    STA reg_cpu_hdmaen.w                                                        ; $018082 |/
    LDY r_menu_copy_to_vram_arg_target_vram_address.w                           ; $018085 |\ Set the target VRAM address to the value passed in the parameter.
    STY reg_ppu_vmadd.w                                                         ; $018088 |/
    LDA #%00000001.b                                                            ; $01808B |\ Configure the DMA from CPU to PPU, writing two addresses with auto
    STA reg_cpu_dmap0.w                                                         ; $01808D |/ increment.
    LDA #<reg_ppu_vmdatal_write.b                                               ; $018090 |\ Set the target DMA address to the VRAM write address.
    STA reg_cpu_bbad0.w                                                         ; $018092 |/
    REP #FLAG_P_ACCUMULATOR.b                                                   ; $018095 |\
    LDA r_menu_copy_to_vram_arg_source_address.w                                ; $018097 | | Set the source address and bank to the values passed in the
    STA reg_cpu_a1t0.w                                                          ; $01809A | | parameters. This also writes the low byte of the bytes to be
    LDA r_menu_copy_to_vram_arg_source_bank.w                                   ; $01809D | | transferred.
    STA reg_cpu_a1b0.w                                                          ; $0180A0 | |
    SEP #FLAG_P_ACCUMULATOR.b                                                   ; $0180A3 |/
    LDA r_menu_copy_to_vram_arg_bytes_hi.w                                      ; $0180A5 |\ Write the high byte of the bytes to be transferred.
    STA reg_cpu_das0h.w                                                         ; $0180A8 |/
    LDA #%00000001.b                                                            ; $0180AB |\ Enable the DMA on channel 0.
    STA reg_cpu_mdmaen.w                                                        ; $0180AD |/
    PLB                                                                         ; $0180B0 | Restore the original data bank register value.
    RTS                                                                         ; $0180B1

; _menu_copy_palette_to_cgram ($01:80B2)
;
; Transfer the menu CG-RAM mirror from $A000 to CG-RAM.
_menu_copy_palette_to_cgram:
    PHD                                                                         ; $0180B2 | Preserve the current value of the direct register.
    LDX #reg_cpu_dmap0.w & $FF00                                                ; $0180B3 |\
    PHX                                                                         ; $0180B6 | | Set the direct register to $4300 to simply DMA register access.
    PLD                                                                         ; $0180B7 |/
    TDC                                                                         ; $0180B8 |\ Set the CG-RAM write address to zero.
    STA reg_ppu_cgadd.l                                                         ; $0180B9 |/
    STA <reg_cpu_dmap0                                                          ; $0180BD |\
    LDA #<reg_ppu_cgdata                                                        ; $0180BF | | Configure DMA channel 0 to transfer the menu CG-RAM mirror from
    STA <reg_cpu_bbad0                                                          ; $0180C1 | | RAM to CG-RAM.
    LDX #r_menu_cgram_data.w                                                    ; $0180C3 | |
    STX <reg_cpu_a1t0                                                           ; $0180C6 | |
    LDA #:r_menu_cgram_data.b                                                   ; $0180C8 | |
    STA <reg_cpu_a1b0                                                           ; $0180CA | |
    LDX #_sizeof_r_menu_cgram_data.w                                            ; $0180CC | |
    STX <reg_cpu_das0                                                           ; $0180CF |/
    LDA #%00000001.b                                                            ; $0180D1 |\ Execute the DMA on channel 0.
    STA reg_cpu_mdmaen.l                                                        ; $0180D3 |/
    PLD                                                                         ; $0180D7 | Restore the original value of the direct register.
    RTS                                                                         ; $0180D8

; _menu_configure_and_draw_window ($01:80D9)
;
; Given a 16-bit target base address in $29, an 8-bit tile flags value in $34
; and the offset to a four byte array in the Y register, writes the tilemap for
; a window to RAM. The four byte array should consist of a 16-bit offset
; relative to the base address, an 8-bit border-exclusive width in tiles, and
; an 8-bit border-exclusive height in tiles.
_menu_configure_and_draw_window:
    PHY                                                                         ; $0180D9 | Preserve the Y register.
    PHB                                                                         ; $0180DA | Preserve the data bank register.
    PHK                                                                         ; $0180DB |\ Set the data bank register to the current value of the program bank
    PLB                                                                         ; $0180DC |/ register.
    REP #FLAG_P_ACCUMULATOR                                                     ; $0180DD |\
    LDA 0.w,Y                                                                   ; $0180DF | | Set the target offset to the first two bytes in the passed array.
    STA <r_menu_draw_window_arg_target_offset                                   ; $0180E2 |/
    LDA 2.w,Y                                                                   ; $0180E4 |\
    STA <r_menu_draw_window_arg_size                                            ; $0180E7 | | Set the size to the second set of two bytes in the passed array.
    SEP #FLAG_P_ACCUMULATOR                                                     ; $0180E9 |/
    LDA <r_menu_current_tilemap_base_tile_flags                                 ; $0180EB |\ Set the tile flags argument.
    STA <r_menu_draw_window_arg_tile_flags                                      ; $0180ED |/
    PLB                                                                         ; $0180EF | Restore the data bank register.
    JSR _menu_draw_window                                                       ; $0180F0 | Draw the window.
    PLY                                                                         ; $0180F3 | Restore the Y register.
    RTS                                                                         ; $0180F4

; _menu_draw_window ($01:80F5)
;
; Given a 16-bit base address in $29, a 16-bit address offset in $2B, an 8-bit
; border-exclusive width in $2D, an 8-bit border-exclusive height in $2E, 8-bit
; tile flags in $2F, and an 8-bit top row flag in $33, writes the tilemap
; necessary to draw a window to the address plus the offset. The top row flag
; will result in only the top row being drawn.
_menu_draw_window:
    REP #FLAG_P_ACCUMULATOR                                                     ; $0180F5 |\
    LDA <r_menu_current_tilemap_base_address                                    ; $0180F7 | | Set the Y register to the complete target address, calculated by
    CLC                                                                         ; $0180F9 | | adding the offset to the base address.
    ADC <r_menu_draw_window_arg_target_offset                                   ; $0180FA | |
    TAY                                                                         ; $0180FC |/
    LDA <r_menu_draw_window_arg_size                                            ; $0180FD |\ Copy the size to a temporary variable.
    STA <r_menu_draw_window_tmp_size                                            ; $0180FF |/
    SEP #FLAG_P_ACCUMULATOR                                                     ; $018101 |\
    LDA #TILE_MENU_WINDOW_FULL_TOP_ROW_BASE.b                                   ; $018103 | | Draw the top row of the window to the specified location.
    JSR _menu_draw_window_border_row                                            ; $018105 |/
    PHA                                                                         ; $018108 |\
    LDA <r_menu_draw_window_arg_top_row_only                                    ; $018109 | | If configured to only do the top row, return at this point.
    BEQ +                                                                       ; $01810B | |
    PLA                                                                         ; $01810D | |
    RTS                                                                         ; $01810E |/
+   PLA                                                                         ; $01810F |\
-   JSR _menu_draw_window_middle_row                                            ; $018110 | | Draw a number of middle rows equal to the passed height.
    DEC <r_menu_draw_window_tmp_size.height                                     ; $018113 | |
    BNE -                                                                       ; $018115 |/
    LDA #TILE_MENU_WINDOW_BOTTOM_ROW_BASE.b                                     ; $018117 |\ Draw the bottom row and return.
    JMP _menu_draw_window_border_row                                            ; $018119 |/

; _menu_draw_window_border_row ($01:811C)
;
; Draws a border row for a menu window at the address passed in the Y register.
; (This writes the tilemap data to RAM, which should then be copied to VRAM
; manually.) The 8-bit number of central tiles is passed in $2D and the base
; tile number is passed in the accumulator. The other two tiles are assumed to
; be the next two tiles.
_menu_draw_window_border_row:
    PHY                                                                         ; $01811C | Preserve the value in the Y register.
    STA <r_menu_draw_window_tmp_tile                                            ; $01811D | Save the passed parameter as the current tile number.
    LDA <r_menu_draw_window_tmp_tile                                            ; $01811F |\
    STA 0.w,Y                                                                   ; $018121 | | Set the first tile in the row to the passed value.
    INY                                                                         ; $018124 |/
    LDA <r_menu_draw_window_arg_tile_flags                                      ; $018125 |\
    STA 0.w,Y                                                                   ; $018127 | | Set the tile flags for the first tile.
    INY                                                                         ; $01812A |/
    LDA <r_menu_draw_window_arg_size.width                                      ; $01812B |\ Copy the width to a temporary variable.
    STA <r_menu_draw_window_tmp_size.width                                      ; $01812D |/
    INC <r_menu_draw_window_tmp_tile                                            ; $01812F | Increment the tile number to move to the center tile.
-   LDA <r_menu_draw_window_tmp_tile                                            ; $018131 |\
    STA 0.w,Y                                                                   ; $018133 | | Set the tile number for the current tile.
    INY                                                                         ; $018136 |/
    LDA <r_menu_draw_window_arg_tile_flags                                      ; $018137 |\
    STA 0.w,Y                                                                   ; $018139 | | Set the flags for the current tile.
    INY                                                                         ; $01813C |/
    DEC <r_menu_draw_window_tmp_size.width                                      ; $01813D |\ Decrement the width and loop until it reaches zero.
    BNE -                                                                       ; $01813F |/
    INC <r_menu_draw_window_tmp_tile                                            ; $018141 | Increment the tile number to move to the right border tile.
    LDA <r_menu_draw_window_tmp_tile                                            ; $018143 |\
    STA 0.w,Y                                                                   ; $018145 | | Set the tile number for the last tile.
    INY                                                                         ; $018148 |/
    LDA <r_menu_draw_window_arg_tile_flags                                      ; $018149 |\ Set the flags for the last tile.
    STA 0.w,Y                                                                   ; $01814B |/
    PLY                                                                         ; $01814E | Restore the original value of the Y register.
    JMP _increment_y_by_64                                                      ; $01814F | Increment Y by 64 to move to the next row and return.

; _menu_draw_window_middle_row ($01:8152)
;
; Draws a middle row for a menu window at the address passed in the Y register.
; (This writes the tilemap data to RAM, which should then be copied to VRAM
; manually.) The 8-bit number of central tiles is passed in $2D.
_menu_draw_window_middle_row:
    PHY                                                                         ; $018152 | Preserve the value in the Y register.
    STA <r_menu_draw_window_tmp_tile                                            ; $018153 | Save the passed value as the unused tile.
    LDA #TILE_MENU_WINDOW_MIDDLE_ROW_LEFT.b                                     ; $018155 |\
    STA 0.w,Y                                                                   ; $018157 | | Write the left tile and its flags.
    INY                                                                         ; $01815A | |
    LDA <r_menu_draw_window_arg_tile_flags                                      ; $01815B | |
    STA 0.w,Y                                                                   ; $01815D | |
    INY                                                                         ; $018160 |/
    LDA <r_menu_draw_window_arg_size.width                                      ; $018161 |\ Copy the size to a temporary variable.
    STA <r_menu_draw_window_tmp_size.width                                      ; $018163 |/
    INC <r_menu_draw_window_tmp_tile                                            ; $018165 | Pointlessly increment the unused tile variable.
-   LDA #TILE_MENU_WINDOW_BLANK.b                                               ; $018167 |\
    STA 0.w,Y                                                                   ; $018169 | | Write a number of blank tiles equal the width parameter.
    INY                                                                         ; $01816C | |
    LDA <r_menu_draw_window_arg_tile_flags                                      ; $01816D | |
    STA 0.w,Y                                                                   ; $01816F | |
    INY                                                                         ; $018172 | |
    DEC <r_menu_draw_window_tmp_size.width                                      ; $018173 | |
    BNE -                                                                       ; $018175 |/
    LDA #TILE_MENU_WINDOW_MIDDLE_ROW_RIGHT.b                                    ; $018177 |\
    STA 0.w,Y                                                                   ; $018179 | | Write the right tile and its flags.
    INY                                                                         ; $01817C | |
    LDA <r_menu_draw_window_arg_tile_flags                                      ; $01817D | |
    STA 0.w,Y                                                                   ; $01817F |/
    PLY                                                                         ; $018182 | Restore the original value of the Y register.
    JMP _increment_y_by_64                                                      ; $018183 | Increment the Y register by 64 to move to the next row.

; menu_wait_for_vblank ($01:8186)
;
; Proxy function to call _menu_wait_for_vblank from another bank.
menu_wait_for_vblank:
    JSR _menu_wait_for_vblank                                                   ; $018186
    RTL                                                                         ; $018189

; _menu_wait_for_vblank ($01:818A)
;
; Increments the game timer and then waits for the next vblank to begin.
_menu_wait_for_vblank:
    PHA                                                                         ; $01818A | Preserve the value in the accumulator.
    INC r_game_time.frames.w                                                    ; $01818B | Increment the game timer frame counter.
    LDA r_game_time.frames.w                                                    ; $01818E |\
    CMP #60.b                                                                   ; $018191 | | If the new value is less than 60, branch to start the loop.
    BCC @loop_start                                                             ; $018193 |/
    STZ r_game_time.frames.w                                                    ; $018195 |\
    INC r_game_time.seconds_lo.w                                                ; $018198 | | Otherwise, reset the frames to zero and increment the seconds.
    BNE @loop_start                                                             ; $01819B | |
    INC r_game_time.seconds_md.w                                                ; $01819D | |
    BNE @loop_start                                                             ; $0181A0 | |
    INC r_game_time.seconds_hi.w                                                ; $0181A2 |/
@loop_start:
    LDA reg_cpu_rdnmi.l                                                         ; $0181A5 |\
    AND #%10000000.b                                                            ; $0181A9 | | Loop until vblank has ended.
    BNE @loop_start                                                             ; $0181AB |/
-   LDA reg_cpu_rdnmi.l                                                         ; $0181AD |\
    AND #%10000000.b                                                            ; $0181B1 | | Loop until vblank has started.
    BEQ -                                                                       ; $0181B3 |/
    LDA <r_menu_ppu_inidisp                                                     ; $0181B5 |\ Transfer the current desired value of the inidisp register.
    STA reg_ppu_inidisp.l                                                       ; $0181B7 |/
    PLA                                                                         ; $0181BB | Restore the value of the accumulator.
    RTS                                                                         ; $0181BC

; _menu_format_two_digit_number ($01:81BD)
;
; Given an 8-bit number in the accumulator, returns the tiles for the number in
; the accumulator, with the ones digit in the high byte and the tens digit in
; the low byte. The value is assumed to be 99 or less. Other values will not
; work as expected.
_menu_format_two_digit_number:
    STZ <r_menu_generic_tmp_count                                               ; $0181BD | Initialize the tens digit to zero.
-   SEC                                                                         ; $0181BF |\
    SBC #10.b                                                                   ; $0181C0 | | Subtract ten from the passed value until it goes negative, adding
    BCC +                                                                       ; $0181C2 | | 1 to the tens digit each time it does not go negative.
    INC <r_menu_generic_tmp_count                                               ; $0181C4 | |
    BRA -                                                                       ; $0181C6 |/
+   ADC #TILE_MENU_NUMBER_BASE.b + 10                                           ; $0181C8 |\ Add the base tile number plus ten to the resulting value to set the
    XBA                                                                         ; $0181CA |/ ones digit tile number. Move to the high byte of the accumulator.
    LDA <r_menu_generic_tmp_count                                               ; $0181CB |\
    BNE +                                                                       ; $0181CD | | Set the tens digit tile to the count plus the tile base, or $FF
    LDA #TILE_MENU_WINDOW_BLANK.b                                               ; $0181CF | | if the value is zero.
    RTS                                                                         ; $0181D1 | |
+   CLC                                                                         ; $0181D2 | |
    ADC #TILE_MENU_NUMBER_BASE.b                                                ; $0181D3 |/
    RTS                                                                         ; $0181D5

; _menu_format_four_digit_number ($01:81D6)
;
; Given a 16-bit number in the accumulator, converts that number to decimal and
; returns the four digits in $5A, $5B, $5D and $5E. The leading digits are
; converted to spaces if zeroes.
_menu_format_four_digit_number:
    PHX                                                                         ; $0181D6 |\ Preserve the values in the X and Y registers.
    PHY                                                                         ; $0181D7 |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $0181D8 |\
    LDX #TILE_MENU_NUMBER_BASE.w - 1                                            ; $0181DA | | Calculate the first digit by initializing the first tile to one
    STX <r_menu_format_four_digit_number_result + 0                             ; $0181DD | | less than the tile number for zero, and then subtracting 1000
-   INC <r_menu_format_four_digit_number_result + 0                             ; $0181DF | | repeatedly (while incrementing the tile) until the value goes
    SEC                                                                         ; $0181E1 | | negative.
    SBC #1000.w                                                                 ; $0181E2 | |
    BPL -                                                                       ; $0181E5 |/
    CLC                                                                         ; $0181E7 |\ Add 1000 to end up with the value below 1000.
    ADC #1000.w                                                                 ; $0181E8 |/
    PHD                                                                         ; $0181EB |\
    LDX #$4200.w                                                                ; $0181EC | | Preserve the existing direct register and set it to $4200.
    PHX                                                                         ; $0181EF | |
    PLD                                                                         ; $0181F0 |/
    STA <reg_cpu_wrdiv                                                          ; $0181F1 |\
    SEP #FLAG_P_ACCUMULATOR                                                     ; $0181F3 | | Divide the remaining value by 100.
    LDA #100.b                                                                  ; $0181F5 | |
    STA <reg_cpu_wrdivb                                                         ; $0181F7 | |
    JSR _wait_for_math                                                          ; $0181F9 | |
    LDA <reg_cpu_rddiv                                                          ; $0181FC |/
    CLC                                                                         ; $0181FE |\
    ADC #TILE_MENU_NUMBER_BASE.b                                                ; $0181FF | | Write the second digit.
    STA (r_menu_format_four_digit_number_result.l & $FFFF) + 1                  ; $018201 |/
    LDA <reg_cpu_rdmpy                                                          ; $018205 |\
    STA <reg_cpu_wrdivl                                                         ; $018207 | | Divide the remainder by 10, and use that result to determine the
    TDC                                                                         ; $018209 | | third digit.
    STA <reg_cpu_wrdivh                                                         ; $01820A | |
    LDA #10.b                                                                   ; $01820C | |
    STA <reg_cpu_wrdivb                                                         ; $01820E | |
    JSR _wait_for_math                                                          ; $018210 | |
    LDA <reg_cpu_rddiv                                                          ; $018213 | |
    CLC                                                                         ; $018215 | |
    ADC #TILE_MENU_NUMBER_BASE.b                                                ; $018216 | |
    STA (r_menu_format_four_digit_number_result.l & $FFFF) + 3                  ; $018218 |/
    LDA <reg_cpu_rdmpy                                                          ; $01821C |\
    PLD                                                                         ; $01821E | | Write the remainder as the final digit.
    CLC                                                                         ; $01821F | |
    ADC #TILE_MENU_NUMBER_BASE.b                                                ; $018220 | |
    STA <r_menu_format_four_digit_number_result + 4                             ; $018222 |/
    LDA <r_menu_format_four_digit_number_result + 0                             ; $018224 |\
    CMP #TILE_MENU_NUMBER_BASE.b                                                ; $018226 | | If the first digit is a zero, replace it with a blank tile.
    BNE +                                                                       ; $018228 | | Otherwise, branch to the end.
    LDA #TILE_MENU_WINDOW_BLANK.b                                               ; $01822A | |
    STA <r_menu_format_four_digit_number_result + 0                             ; $01822C |/
    LDA <r_menu_format_four_digit_number_result + 1                             ; $01822E |\
    CMP #TILE_MENU_NUMBER_BASE.b                                                ; $018230 | | If the second digit is a zero, replace it with a blank tile.
    BNE +                                                                       ; $018232 | | Otherwise, branch to the end.
    LDA #TILE_MENU_WINDOW_BLANK.b                                               ; $018234 | |
    STA <r_menu_format_four_digit_number_result + 1                             ; $018236 |/
    LDA <r_menu_format_four_digit_number_result + 3                             ; $018238 |\
    CMP #TILE_MENU_NUMBER_BASE.b                                                ; $01823A | | If the third digit is a zero, replace it with a blank tile.
    BNE +                                                                       ; $01823C | | Otherwise, branch to the end.
    LDA #TILE_MENU_WINDOW_BLANK.b                                               ; $01823E | |
    STA <r_menu_format_four_digit_number_result + 3                             ; $018240 |/
+   PLY                                                                         ; $018242 |\ Restore the X and Y registers.
    PLX                                                                         ; $018243 |/
    RTS                                                                         ; $018244

; _wait_for_math ($01:8245)
;
; This routine does nothing more than several NOP instructions to burn a few
; cycles. It's used for the necessary wait between setting the multiplication or
; division registers and reading the result.
_wait_for_math:
    NOP                                                                         ; $018245
    NOP                                                                         ; $018246
    NOP                                                                         ; $018247
    NOP                                                                         ; $018248
    NOP                                                                         ; $018249
    NOP                                                                         ; $01824A
    RTS                                                                         ; $01824B

; _menu_wait_for_vblank_copy_oam_to_ppu ($01:824C)
;
; Waits for the next vblank and then copies the current OAM data to the PPU.
; Falls through to the next function to handle the OAM portion.
_menu_wait_for_vblank_copy_oam_to_ppu:
    JSR _menu_wait_for_vblank                                                   ; $01824C

; _menu_copy_oam_to_ppu ($01:824F)
;
; Transfers the OAM data stored at $0300 to the actual OAM.
_menu_copy_oam_to_ppu:
    PHX                                                                         ; $01824F |\ Preserve the existing values of the X register and the direct
    PHD                                                                         ; $018250 |/ register.
    LDX #reg_cpu_dmap0.w & $FF00                                                ; $018251 |\
    PHX                                                                         ; $018254 | | Set the direct register to $4300 for easy register access.
    PLD                                                                         ; $018255 |/
    TDC                                                                         ; $018256 |\
    STA reg_ppu_oamaddl.l                                                       ; $018257 | | Set the OAM write address to zero.
    STA reg_ppu_oamaddh.l                                                       ; $01825B |/
    STA <reg_cpu_dmap0                                                          ; $01825F |\
    LDA #<reg_ppu_oamdata_write                                                 ; $018261 | | Configure DMA channel 0 to transfer the OAM staging area in RAM
    STA <reg_cpu_bbad0                                                          ; $018263 | | to the actual OAM.
    LDX #r_oam.w                                                                ; $018265 | |
    STX <reg_cpu_a1t0                                                           ; $018268 | |
    LDA #$00.b                                                                  ; $01826A | |
    STA <reg_cpu_a1b0                                                           ; $01826C | |
    LDX #_sizeof_r_oam.w + _sizeof_r_oam_hi                                     ; $01826E | |
    STX <reg_cpu_das0                                                           ; $018271 |/
    LDA #%00000001.b                                                            ; $018273 |\ Execute the DMA.
    STA reg_cpu_mdmaen.l                                                        ; $018275 |/
    PLD                                                                         ; $018279 |\ Restore the original values of the X register and direct register.
    PLX                                                                         ; $01827A |/
    RTS                                                                         ; $01827B

; _menu_draw_cursor_x ($01:827C)
;
; Given a set of coordinates in $45, draws either the first or second menu
; cursor (depending on entry point) to those coordinates by setting the
; appropriate OAM entries in the OAM mirror. The _direct entry point allows the
; caller to directly set the coordinates in the X register and the OAM offset in
; the Y register. The _direct_memory entry point allows the caller to directly
; set the OAM offset in the Y register, but to pass the coordinates in memory.
_menu_draw_cursor_2:
    LDY #r_oam.5.w                                                              ; $01827C | Set the Y register to the second cursor's OAM offset.
    BRA _menu_draw_cursor_direct_memory                                         ; $01827F | Branch to the common code.
_menu_draw_cursor_1:
    LDY #r_oam.1.w                                                              ; $018281 | Set the Y register to the first cursor's OAM offset.
_menu_draw_cursor_direct_memory:
    LDX <r_menu_draw_cursor_arg_coordinates                                     ; $018284 | Load the coordinates into the X register.
_menu_draw_cursor_direct:
    LDA #$0A.b                                                                  ; $018286 | Load the tile number for the cursor to the accumulator.
    PHB                                                                         ; $018288 |\
    PHA                                                                         ; $018289 | | Preserve the existing data bank register and set it to $7E.
    LDA #$7E.b                                                                  ; $01828A | |
    PHA                                                                         ; $01828C | |
    PLB                                                                         ; $01828D | |
    PLA                                                                         ; $01828E |/
    STA oam_sprite.tile.w,Y                                                     ; $01828F | Save the cursor tile number as the sprite tile number.
    REP #FLAG_P_ACCUMULATOR                                                     ; $018292 |\
    TXA                                                                         ; $018294 | | Transfer the coordinates to the accumulator.
    SEP #FLAG_P_ACCUMULATOR                                                     ; $018295 |/
    STA oam_sprite.x.w,Y                                                        ; $018297 | Set the X coordinate from the low byte.
    XBA                                                                         ; $01829A |\ Set the Y coordinate from the high byte.
    STA oam_sprite.y.w,Y                                                        ; $01829B |/
    LDA <r_menu_cursor_sprite_flags                                             ; $01829E |\ Set the tile flags.
    STA oam_sprite.flags.w,Y                                                    ; $0182A0 |/
    PLB                                                                         ; $0182A3 | Restore the original value of the data bank register.
    RTS                                                                         ; $0182A4

; _menu_input_check_left_right ($01:82A5)
;
; Checks to see if either the left or right d-pad button was set in the joypad
; repeat value at the last update. If so, sets the carry flag and returns.
; Otherwise, updates the joypad values immediately, plays the appropriate sound
; effect, and then immediately transfers the hi joypad pressed byte into the
; repeat byte (which overrides the built-in input repeat system and allows
; inputs to be registered on every frame, but only after the initial delay).
; The carry flag will essentially be set if either left or right is pressed and
; they are officially repeating this frame.
_menu_input_check_left_right:
    LDA <r_menu_joypad_repeat.hi                                                ; $0182A5 |\
    AND #(JOYPAD_H_LEFT | JOYPAD_H_RIGHT).b                                     ; $0182A7 | | If either left or right is pressed, branch to set the carry flag.
    BNE +                                                                       ; $0182A9 |/
    JSR _menu_update_joypad_and_play_sound_effect                               ; $0182AB | Update the joypad and play any associated sound effect.
    LDA <r_menu_joypad_pressed.hi                                               ; $0182AE |\
    STA <r_menu_joypad_repeat.hi                                                ; $0182B0 | | Transfer the current pressed joypad value into the repeated joypad
    CLC                                                                         ; $0182B2 | | value, clear the carry flag and return.
    RTS                                                                         ; $0182B3 |/
+   SEC                                                                         ; $0182B4 | Set the carry flag.
    RTS                                                                         ; $0182B5

; _update_joypad_2 ($01:82B6)
;
; Proxy function to call update_joypad in bank $14.
_update_joypad_2:
    JSL bank14.update_joypad_proxy.l                                            ; $0182B6
    RTS                                                                         ; $0182BA

; _initialize_joypad_maps ($01:82BB)
;
; Proxy function to call initialize_joypad_maps in bank $14.
_initialize_joypad_maps:
    JSL bank14.initialize_joypad_maps_proxy                                     ; $0182BB
    RTS                                                                         ; $0182BF

; _menu_update_joypad_and_play_sound_effect ($01:82C0)
;
; Updates the joypad values and plays a cursor sound effect if a button is
; currently pressed (according to the repeating data).
_menu_update_joypad_and_play_sound_effect:
    JSR _update_joypad_2                                                        ; $0182C0 | Update the joypad values.
    LDA <r_menu_joypad_repeat.lo                                                ; $0182C3 |\
    ORA <r_menu_joypad_repeat.hi                                                ; $0182C5 | | Play a cursor sound effect if any button is pressed.
    BEQ +                                                                       ; $0182C7 | |
    JSR _play_sound_effect_cursor                                               ; $0182C9 |/
+   RTS                                                                         ; $0182CC

; _menu_draw_text_* ($01:82CD)
;
; This family of functions draws text to a tilemap in RAM. The 16-bit base
; address for the tilemap should be passed in $29.
;
; The _direct variant passes the offset within the tilemap directly in the X
; register. The _indirect variant instead includes the offset as the first two
; bytes of the data array. The data array's offset should be passed in the Y
; register. The _indirect_plus_window variant is the same as the _indirect
; variant, except that the array referred to by the Y register should include
; as its first four bytes the parameters necessary to draw a window (a 16-bit
; offset followed by an 8-bit border-exclusive width in tiles and an 8-bit
; border-exclusive height in tiles).
;
; The _direct_other_bank variant is similar to the previous one, except that
; it allows the caller to specify the source bank in the accumulator.
;
; Regardless of the variant, the common data should be formatted as follows:
; The first two bytes are a 16-bit offset to add to the base address. Each
; additional byte is the code for the character to draw at that location. There
; are two opcode bytes: $00 signals that the text is complete. $01, followed by
; a 16-bit offset, changes the target address to the new value plus the original
; base address.
_menu_draw_text_direct:
    PHB                                                                         ; $0182CD |\
    PHD                                                                         ; $0182CE | | Preserve the data bank, direct and X registers.
    PHX                                                                         ; $0182CF |/
    PHX                                                                         ; $0182D0 |\
    LDX #$0100.w                                                                ; $0182D1 | | Set the direct register to $0100, preserving the X register value.
    PHX                                                                         ; $0182D4 | |
    PLD                                                                         ; $0182D5 | |
    PLX                                                                         ; $0182D6 |/
    PHK                                                                         ; $0182D7 |\ Set the data bank register to the current value of the program bank
    PLB                                                                         ; $0182D8 |/ register.
    REP #FLAG_P_ACCUMULATOR                                                     ; $0182D9 |\
    TXA                                                                         ; $0182DB | | Set the X register to the value passed in the X register plus the
    CLC                                                                         ; $0182DC | | configured base address.
    ADC <r_menu_current_tilemap_base_address                                    ; $0182DD | |
    TAX                                                                         ; $0182DF | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $0182E0 |/
    BRA __menu_draw_text_process_text                                           ; $0182E2 | Branch ahead to process the text.
_menu_draw_text_direct_other_bank:
    PHB                                                                         ; $0182E4 |\
    PHD                                                                         ; $0182E5 | | Preserve the data bank, direct and X registers.
    PHX                                                                         ; $0182E6 |/
    PHX                                                                         ; $0182E7 |\
    LDX #$0100.w                                                                ; $0182E8 | | Set the direct register to $0100, preserving the X register value.
    PHX                                                                         ; $0182EB | |
    PLD                                                                         ; $0182EC | |
    PLX                                                                         ; $0182ED |/
    PHA                                                                         ; $0182EE |\ Set the data bank register to the current value of the accumulator.
    PLB                                                                         ; $0182EF |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $0182F0 |\
    TXA                                                                         ; $0182F2 | | Set the X register to the value passed in the X register plus the
    CLC                                                                         ; $0182F3 | | configured base address.
    ADC <r_menu_current_tilemap_base_address                                    ; $0182F4 | |
    TAX                                                                         ; $0182F6 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $0182F7 |/
    BRA __menu_draw_text_process_text                                           ; $0182F9 | Branch ahead to process the text.
_menu_draw_text_indirect_plus_window:
    JSR _menu_configure_and_draw_window                                         ; $0182FB
    JSR _increment_y_by_4                                                       ; $0182FE
_menu_draw_text_indirect:
    PHB                                                                         ; $018301 |\
    PHD                                                                         ; $018302 | | Preserve the data bank, direct and X registers.
    PHX                                                                         ; $018303 |/
    LDX #$0100.w                                                                ; $018304 |\
    PHX                                                                         ; $018307 | | Set the direct register to $0100.
    PLD                                                                         ; $018308 |/
    PHK                                                                         ; $018309 |\ Set the data bank register to the current value of the program bank
    PLB                                                                         ; $01830A |/ register.
-   REP #FLAG_P_ACCUMULATOR                                                     ; $01830B |\
    LDA 0.w,Y                                                                   ; $01830D | | Set the X register to the base tilemap address plus the value read
    CLC                                                                         ; $018310 | | from the passed array to determine where in the tilemap to write.
    ADC <r_menu_current_tilemap_base_address                                    ; $018311 | |
    TAX                                                                         ; $018313 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $018314 |/
    INY                                                                         ; $018316 |\ Increment the Y register twice to move to the next set of data.
    INY                                                                         ; $018317 |/
__menu_draw_text_process_text:
    LDA 0.w,Y                                                                   ; $018318 |\ If the next byte is zero, the end has been reached, so branch to
    BEQ +                                                                       ; $01831B |/ the end.
    INY                                                                         ; $01831D | Increment the Y register to prepare to read the next byte.
    CMP #MENU_TEXT_OPCODE_NEW_TARGET.b                                          ; $01831E |\ If the currently read value calls for a new target, branch to load
    BEQ -                                                                       ; $018320 |/ a new target address from the next two bytes.
    JSR _menu_get_diacritic_tile                                                ; $018322 | Otherwise, fetch the base tile and diacritic tile for this opcode.
    STA $7E0000.l,X                                                             ; $018325 | Store the diacritic tile in the first row.
    XBA                                                                         ; $018329 |\ Store the main tile 64 bytes later, which is exactly one row of
    STA $7E0040.l,X                                                             ; $01832A |/ tiles.
    INX                                                                         ; $01832E |\
    INX                                                                         ; $01832F | | Increment the X register twice and loop back to read the next.
    BRA __menu_draw_text_process_text                                           ; $018330 |/
+   PLX                                                                         ; $018332 |\
    PLD                                                                         ; $018333 | | Restore the X register, direct register and data bank register.
    PLB                                                                         ; $018334 |/
    RTS                                                                         ; $018335

; _menu_wait_for_input ($01:8336)
;
; Loops until input is detected.
_menu_wait_for_input:
    PHA                                                                         ; $018336 |\
    PHX                                                                         ; $018337 | | Preserve the A, X, Y and data bank registers.
    PHY                                                                         ; $018338 | |
    PHB                                                                         ; $018339 |/
-   JSR _menu_wait_for_vblank                                                   ; $01833A | Wait for vblank.
    JSR _menu_update_joypad_and_play_sound_effect                               ; $01833D | Update the joypad values and play a sound effect if appropriate.
    LDA <r_menu_joypad_repeat.lo                                                ; $018340 |\
    ORA <r_menu_joypad_repeat.hi                                                ; $018342 | | Loop until a button has been pressed.
    BEQ -                                                                       ; $018344 |/
    PLB                                                                         ; $018346 |\
    PLY                                                                         ; $018347 | | Restore the saved registers.
    PLX                                                                         ; $018348 | |
    PLA                                                                         ; $018349 |/
    RTS                                                                         ; $01834A

; _menu_execute_jump ($01:834B)
;
; Given an offset within the current bank to a jump table of 16-bit addresses in
; the X register and an index within that table in the accumulator, loads the
; associated offset and jumps to it.
_menu_execute_jump:
    STA <r_menu_generic_tmp_ptr.address.lo                                      ; $01834B |\ Temporarily save the value passed in the accumulator.
    STZ <r_menu_generic_tmp_ptr.address.hi                                      ; $01834D |/
    PHK                                                                         ; $01834F |\
    PLA                                                                         ; $018350 | | Set the bank to the current program bank ($01).
    STA r_menu_generic_tmp_ptr.bank.w                                           ; $018351 |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $018354 |\
    LDA <r_menu_generic_tmp_ptr.address                                         ; $018356 | | Set the address to the value passed in the X register plus the
    STX <r_menu_generic_tmp_ptr.address                                         ; $018358 | | value passed in the accumulator times two.
    ASL A                                                                       ; $01835A | |
    ADC <r_menu_generic_tmp_ptr.address                                         ; $01835B | |
    STA <r_menu_generic_tmp_ptr.address                                         ; $01835D |/
    LDA [<r_menu_generic_tmp_ptr]                                               ; $01835F |\
    STA r_menu_generic_tmp_value.w                                              ; $018361 | | Load the offset at the determined address and jump to it.
    SEP #FLAG_P_ACCUMULATOR                                                     ; $018364 | |
    JMP (r_menu_generic_tmp_value.w)                                            ; $018366 |/

; _menu_draw_two_digit_number ($01:8369)
;
; Given a number of 99 or less in the accumulator, the current 16-bit base
; tilemap address in $29, and the offset within that tilemap in the Y register,
; draws the number to the tilemap. If a value of 100 or greater is passed, the
; results will not be as expected.
_menu_draw_two_digit_number:
    JSR _menu_format_two_digit_number                                           ; $018369 | Get the tiles for the number.
    REP #FLAG_P_ACCUMULATOR                                                     ; $01836C |\
    PHA                                                                         ; $01836E | | Add the current base tilemap address to the value in the Y
    TYA                                                                         ; $01836F | | register and store the result back in the Y register.
    CLC                                                                         ; $018370 | |
    ADC <r_menu_current_tilemap_base_address                                    ; $018371 | |
    TAY                                                                         ; $018373 | |
    PLA                                                                         ; $018374 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $018375 |/
    STA 0.w,Y                                                                   ; $018377 | Store the tens digit at the first location.
    XBA                                                                         ; $01837A |\ Store the ones digit at the next location.
    STA 2.w,Y                                                                   ; $01837B |/
    RTS                                                                         ; $01837E

; _menu_draw_four_digit_number ($01:837F)
;
; Given a 16-bit number in the accumulator and an offset for the current tilemap
; in the Y register, draws that number as four decimal digits to the tilemap.
; The _8bit variant automatically ensures the high byte of the accumulator is
; zeroed.
_menu_draw_four_digit_number_8bit:
    XBA                                                                         ; $01837F |\
    LDA #0.b                                                                    ; $018380 | | Zero the high byte of the accumulator.
    XBA                                                                         ; $018382 |/
_menu_draw_four_digit_number:
    PHP                                                                         ; $018383 |\ Preserve the processor flags register and the X register.
    PHX                                                                         ; $018384 |/
    SEP #FLAG_P_ACCUMULATOR                                                     ; $018385 |\ Preserve the tilemap address in the Y register.
    PHY                                                                         ; $018387 |/
    JSR _menu_format_four_digit_number                                          ; $018388 |\ Format the number in the accumulator.
    REP #FLAG_P_ACCUMULATOR                                                     ; $01838B |/
    PLA                                                                         ; $01838D |\
    CLC                                                                         ; $01838E | | Add the passed tilemap address to the base tilemap address.
    ADC <r_menu_current_tilemap_base_address                                    ; $01838F | |
    TAY                                                                         ; $018391 |/
    SEP #FLAG_P_ACCUMULATOR                                                     ; $018392 |\
    LDA <r_menu_format_four_digit_number_result + 0                             ; $018394 | | Copy the four digits to the tilemap at the target location.
    STA 0.w,Y                                                                   ; $018396 | |
    LDA <r_menu_format_four_digit_number_result + 1                             ; $018399 | |
    STA 2.w,Y                                                                   ; $01839B | |
    LDA <r_menu_format_four_digit_number_result + 3                             ; $01839E | |
    STA 4.w,Y                                                                   ; $0183A0 | |
    LDA <r_menu_format_four_digit_number_result + 4                             ; $0183A3 | |
    STA 6.w,Y                                                                   ; $0183A5 |/
    PLX                                                                         ; $0183A8 |\ Restore the X register and processor flags register.
    PLP                                                                         ; $0183A9 |/
    RTS                                                                         ; $0183AA

; _menu_draw_character_name ($01:83AB)
;
; Given the current 16-bit tilemap offset in $29, the offset within that tilemap
; in the Y register, and a character ID in the accumulator, draws that
; character's name to the tilemap at the given offset.
_menu_draw_character_name:
    AND #%00111111.b                                                            ; $0183AB |\
    BNE +                                                                       ; $0183AD | | Return if the character ID signifies an empty slot.
    RTS                                                                         ; $0183AF |/
+   DEC A                                                                       ; $0183B0 |\
    JSR _menu_transfer_a_to_x                                                   ; $0183B1 | | Set the X register to the character's name index times six to
    LDA character_id_to_name_index_data.l,X                                     ; $0183B4 | | index the name data.
    ASL A                                                                       ; $0183B8 | |
    STA <r_menu_generic_tmp_count                                               ; $0183B9 | |
    ASL A                                                                       ; $0183BB | |
    ADC <r_menu_generic_tmp_count                                               ; $0183BC | |
    JSR _menu_transfer_a_to_x                                                   ; $0183BE |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $0183C1 |\
    TYA                                                                         ; $0183C3 | | Add the offset passed in the Y register to the base tilemap
    CLC                                                                         ; $0183C4 | | address and store the result in the Y register.
    ADC <r_menu_current_tilemap_base_address                                    ; $0183C5 | |
    TAY                                                                         ; $0183C7 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $0183C8 |/
    LDA #6.b                                                                    ; $0183CA |\
    STA <r_menu_generic_tmp_count                                               ; $0183CC | | Copy the character name to the located tilemap location.
-   LDA r_character_names.w,X                                                   ; $0183CE | |
    INX                                                                         ; $0183D1 | |
    JSR _menu_get_diacritic_tile                                                ; $0183D2 | |
    STA 0.w,Y                                                                   ; $0183D5 | |
    XBA                                                                         ; $0183D8 | |
    STA 64.w,Y                                                                  ; $0183D9 | |
    INY                                                                         ; $0183DC | |
    INY                                                                         ; $0183DD | |
    DEC <r_menu_generic_tmp_count                                               ; $0183DE | |
    BNE -                                                                       ; $0183E0 |/
    RTS                                                                         ; $0183E2

; _menu_animate_current_tilemap_50_rows_to_vram ($01:83E3)
;
; Copies 50 rows of the current tilemap (configured in $29, among other places)
; to VRAM. While this isn't the entire tilemap, it is enough to transfer the
; entire inventory. Two rows are copied per frame, resulting in the data
; appearing to roll down from the top.
_menu_animate_current_tilemap_50_rows_to_vram:
    LDA #25.b                                                                   ; $0183E3 |\ Initialize the counter to 25, to copy a total of 50 rows.
    STA <r_menu_generic_tmp_count                                               ; $0183E5 |/
    LDX <r_menu_current_tilemap_vram_address                                    ; $0183E7 |\ Set the target VRAM address to the address of the current tilemap.
    STX <r_menu_copy_to_vram_arg_target_vram_address                            ; $0183E9 |/
    LDX <r_menu_current_tilemap_base_address                                    ; $0183EB |\ Set the source address to the tilemap address in RAM.
    STX <r_menu_copy_to_vram_arg_source_address                                 ; $0183ED |/
    LDA #:r_menu_current_tilemap_base_address                                   ; $0183EF |\ Set the source bank to $7E.
    STA <r_menu_copy_to_vram_arg_source_bank                                    ; $0183F1 |/
    LDX #(32 * 2 * 2).w                                                         ; $0183F3 |\ Set the number of bytes to copy to 128 to copy two rows of tiles.
    STX <r_menu_copy_to_vram_arg_bytes                                          ; $0183F6 |/
-   JSR _menu_wait_for_vblank                                                   ; $0183F8 | Wait for the next vblank.
    JSR _menu_copy_to_vram                                                      ; $0183FB | Copy the current two rows to VRAM.
    REP #FLAG_P_ACCUMULATOR                                                     ; $0183FE |\
    LDA <r_menu_copy_to_vram_arg_target_vram_address                            ; $018400 | | Increment the VRAM address by 64 and the source address by 128 to
    CLC                                                                         ; $018402 | | move to the next set of two rows.
    ADC #(32 * 2).w                                                             ; $018403 | |
    STA <r_menu_copy_to_vram_arg_target_vram_address                            ; $018406 | |
    LDA <r_menu_copy_to_vram_arg_source_address                                 ; $018408 | |
    CLC                                                                         ; $01840A | |
    ADC #(32 * 2 * 2).w                                                         ; $01840B | |
    STA <r_menu_copy_to_vram_arg_source_address                                 ; $01840E | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $018410 |/
    DEC <r_menu_generic_tmp_count                                               ; $018412 |\ Decrement the count and loop until all 50 rows have been copied.
    BNE -                                                                       ; $018414 |/
    RTS                                                                         ; $018416

; _menu_animate_current_tilemap_50_rows_to_vram_reversed ($01:8417)
;
; Copies 50 rows of the current tilemap (configured in $29, among other places)
; to VRAM. While this isn't the entire tilemap, it is enough to transfer the
; entire inventory. Two rows are copied per frame, resulting in the data
; appearing to roll up toward the top.
_menu_animate_current_tilemap_50_rows_to_vram_reversed:
    LDA #25.b                                                                   ; $018417 |\ Initialize the counter to 25, to copy a total of 50 rows.
    STA <r_menu_generic_tmp_count                                               ; $018419 |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $01841B |\
    LDA <r_menu_current_tilemap_vram_address                                    ; $01841D | | Set the target VRAM address to the address of the current tilemap
    CLC                                                                         ; $01841F | | plus 48 rows.
    ADC #(48 * 32).w                                                            ; $018420 | |
    STA <r_menu_copy_to_vram_arg_target_vram_address                            ; $018423 |/
    LDA <r_menu_current_tilemap_base_address                                    ; $018425 |\
    CLC                                                                         ; $018427 | | Set the source address to the tilemap address in RAM plus 48 rows.
    ADC #(48 * 32 * 2).w                                                        ; $018428 | |
    STA <r_menu_copy_to_vram_arg_source_address                                 ; $01842B | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01842D |/
    LDA #:r_menu_current_tilemap_base_address                                   ; $01842F |\ Set the source bank to $7E.
    STA <r_menu_copy_to_vram_arg_source_bank                                    ; $018431 |/
    LDX #(2 * 32 * 2).w                                                         ; $018433 |\ Set the number of bytes to copy to 128 to copy two rows of tiles.
    STX <r_menu_copy_to_vram_arg_bytes                                          ; $018436 |/
-   JSR _menu_wait_for_vblank                                                   ; $018438 | Wait for vblank.
    JSR _menu_copy_to_vram                                                      ; $01843B | Copy the current two rows to VRAM.
    REP #FLAG_P_ACCUMULATOR                                                     ; $01843E |\
    LDA <r_menu_copy_to_vram_arg_target_vram_address                            ; $018440 | | Decrement the VRAM address by 64 and the tilemap address by 128 to
    SEC                                                                         ; $018442 | | move to the next set of two rows.
    SBC #(2 * 32).w                                                             ; $018443 | |
    STA <r_menu_copy_to_vram_arg_target_vram_address                            ; $018446 | |
    LDA <r_menu_copy_to_vram_arg_source_address                                 ; $018448 | |
    SEC                                                                         ; $01844A | |
    SBC #(2 * 32 * 2).w                                                         ; $01844B | |
    STA <r_menu_copy_to_vram_arg_source_address                                 ; $01844E | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $018450 |/
    DEC <r_menu_generic_tmp_count                                               ; $018452 |\ Decrement the count and loop until it reaches zero.
    BNE -                                                                       ; $018454 |/
    RTS                                                                         ; $018456

; character_id_to_name_index_data ($01:8457)
;
; For each character ID, provides the index of the name to use for that
; character ID. One is subtracted from the character ID to index this table.
character_id_to_name_index_data:
    .db CHARACTER_NAME_CECIL                                                    ; $018457 | $01: Cecil (dark knight)
    .db CHARACTER_NAME_KAIN                                                     ; $018458 | $02: Kain (until Mist)
    .db CHARACTER_NAME_RYDIA                                                    ; $018459 | $03: Rydia (child)
    .db CHARACTER_NAME_TELLAH                                                   ; $01845A | $04: Tellah (until Damcyan)
    .db CHARACTER_NAME_EDWARD                                                   ; $01845B | $05: Edward
    .db CHARACTER_NAME_ROSA                                                     ; $01845C | $06: Rosa (until Fabul)
    .db CHARACTER_NAME_YANG                                                     ; $01845D | $07: Yang (until Leviatan)
    .db CHARACTER_NAME_PALOM                                                    ; $01845E | $08: Palom
    .db CHARACTER_NAME_POROM                                                    ; $01845F | $09: Porom
    .db CHARACTER_NAME_TELLAH                                                   ; $018460 | $0A: Tellah (until Cecil becomes a paladin)
    .db CHARACTER_NAME_CECIL                                                    ; $018461 | $0B: Cecil (paladin)
    .db CHARACTER_NAME_TELLAH                                                   ; $018462 | $0C: Tellah (final)
    .db CHARACTER_NAME_YANG                                                     ; $018463 | $0D: Yang (final)
    .db CHARACTER_NAME_CID                                                      ; $018464 | $0E: Cid
    .db CHARACTER_NAME_KAIN                                                     ; $018465 | $0F: Kain (until Sealed Cave)
    .db CHARACTER_NAME_ROSA                                                     ; $018466 | $10: Rosa (final)
    .db CHARACTER_NAME_RYDIA                                                    ; $018467 | $11: Rydia (adult)
    .db CHARACTER_NAME_EDGE                                                     ; $018468 | $12: Edge
    .db CHARACTER_NAME_FUSOYA                                                   ; $018469 | $13: FuSoYa
    .db CHARACTER_NAME_KAIN                                                     ; $01846A | $14: Kain (final)
    .db CHARACTER_NAME_GOLBEZ                                                   ; $01846B | $15: Golbez
    .db CHARACTER_NAME_ANNA                                                     ; $01846C | $16: Anna

; _menu_set_current_tilemap_bg3_* ($01:846D)
;
; Sets the current tilemap to BG3. The _and_initialize variant additionally
; initializes the tilemap to all zeroes.
_menu_set_current_tilemap_bg3_and_initialize:
    JSR _menu_initialize_tilemap_bg3                                            ; $01846D | Initialize BG3.
_menu_set_current_tilemap_bg3:
    PHA                                                                         ; $018470 |\ Preserve the values of the accumulator and X register.
    PHX                                                                         ; $018471 |/
    LDX #r_menu_tilemap_bg3.w                                                   ; $018472 |\ Set the base tilemap address to that of BG3.
    STX <r_menu_current_tilemap_base_address                                    ; $018475 |/
    LDX #VRAM_MENU_TILEMAP_BG3.w                                                ; $018477 |\ Set the current tilemap VRAM address to that of BG3.
    STX <r_menu_current_tilemap_vram_address                                    ; $01847A |/
    LDA #MENU_TILEMAP_INDEX_BG3.b                                               ; $01847C |\ Set the current tilemap index to BG3.
    STA <r_menu_current_tilemap_index                                           ; $01847E |/
    STZ <r_menu_current_tilemap_base_tile_flags                                 ; $018480 | Set the current tilemap base tile flags for priority 0.
    PLX                                                                         ; $018482 |\ Restore the saved registers.
    PLA                                                                         ; $018483 |/
    RTS                                                                         ; $018484

; _menu_set_current_tilemap_bg4_* ($01:8485)
;
; Sets the current tilemap to BG4. Various menu routines use the current setting
; to determine where to perform their work.
_menu_set_current_tilemap_bg4_and_initialize:
    JSR _menu_initialize_tilemap_bg4                                            ; $018485 | Initialize the BG4 tilemap.
_menu_set_current_tilemap_bg4:
    PHA                                                                         ; $018488 |\ Preserve the values of the accumulator and X register.
    PHX                                                                         ; $018489 |/
    LDX #r_menu_tilemap_bg4.w                                                   ; $01848A |\ Set the base tilemap address to that of BG4.
    STX <r_menu_current_tilemap_base_address                                    ; $01848D |/
    LDX #VRAM_MENU_TILEMAP_BG4.w                                                ; $01848F |\ Set the current tilemap VRAM address to that of BG4.
    STX <r_menu_current_tilemap_vram_address                                    ; $018492 |/
    LDA #MENU_TILEMAP_INDEX_BG4.b                                               ; $018494 |\ Set the current tilemap index to BG4.
    STA <r_menu_current_tilemap_index                                           ; $018496 |/
    LDA #%00100000.b                                                            ; $018498 |\ Set the current tilemap base tile flags for priority 1.
    STA <r_menu_current_tilemap_base_tile_flags                                 ; $01849A |/
    PLX                                                                         ; $01849C |\ Restore the saved registers.
    PLA                                                                         ; $01849D |/
    RTS                                                                         ; $01849E

; _menu_set_current_tilemap_bg1_* ($01:849F)
;
; Sets the current tilemap to BG1. The _and_initialize variant additionally
; initializes the tilemap to all zeroes.
_menu_set_current_tilemap_bg1_and_initialize:
    JSR _menu_initialize_tilemap_bg1                                            ; $01849F
_menu_set_current_tilemap_bg1:
    PHA                                                                         ; $0184A2 |\ Preserve the values of the accumulator and X register.
    PHX                                                                         ; $0184A3 |/
    LDX #r_menu_tilemap_bg1.w                                                   ; $0184A4 |\ Set the base tilemap address to that of BG1.
    STX <r_menu_current_tilemap_base_address                                    ; $0184A7 |/
    LDX #VRAM_MENU_TILEMAP_BG1.w                                                ; $0184A9 |\ Set the current tilemap VRAM address to that of BG1.
    STX <r_menu_current_tilemap_vram_address                                    ; $0184AC |/
    LDA #MENU_TILEMAP_INDEX_BG1.b                                               ; $0184AE |\ Set the current tilemap index to BG1.
    STA <r_menu_current_tilemap_index                                           ; $0184B0 |/
    STZ <r_menu_current_tilemap_base_tile_flags                                 ; $0184B2 | Set the current tilemap base tile flags for priority 0.
    PLX                                                                         ; $0184B4 |\ Restore the saved registers.
    PLA                                                                         ; $0184B5 |/
    RTS                                                                         ; $0184B6

; _menu_set_current_tilemap_bg2_* ($01:84B7)
;
; Sets the current tilemap to BG2. The _and_initialize variant additionally
; initializes the tilemap to all zeroes.
_menu_set_current_tilemap_bg2_and_initialize:
    JSR _menu_initialize_tilemap_bg2                                            ; $0184B7 | Initialize BG2.
_menu_set_current_tilemap_bg2:
    PHA                                                                         ; $0184BA |\ Preserve the values of the accumulator and X register.
    PHX                                                                         ; $0184BB |/
    LDX #r_menu_tilemap_bg2.w                                                   ; $0184BC |\ Set the base tilemap address to that of BG2.
    STX <r_menu_current_tilemap_base_address                                    ; $0184BF |/
    LDX #VRAM_MENU_TILEMAP_BG2.w                                                ; $0184C1 |\ Set the current tilemap VRAM address to that of BG2.
    STX <r_menu_current_tilemap_vram_address                                    ; $0184C4 |/
    TDC                                                                         ; $0184C6 |\ Set the current tilemap index to BG2.
    STA <r_menu_current_tilemap_index                                           ; $0184C7 |/
    LDA #%00100000.b                                                            ; $0184C9 |\ Set the current tilemap base tile flags for priority 2.
    STA <r_menu_current_tilemap_base_tile_flags                                 ; $0184CB |/
    PLX                                                                         ; $0184CD |\ Restore the saved registers.
    PLA                                                                         ; $0184CE |/
    RTS                                                                         ; $0184CF

; _menu_window_transition ($01:84D0)
;
; Given the offset to a source window definition in the Y register and the
; offset to a target window definition in the X register, transitions the first
; window to be the same size as the target. In addition, if background scroll
; deltas are set in the array at $01A1, the background scroll registers will be
; updated a number of times set in $01C2.
;
; This routine can call two custom functions configured by the user, stored at
; $01CC and $01CF. Generally, each consists of a JMP opcode as the first byte,
; followed by a location to jump to. The first (stored at $01CF) is called
; immediately before copying the tilemap to VRAM, and the second is called
; immediately after.
_menu_window_transition:
    PHB                                                                         ; $0184D0 |\
    PHK                                                                         ; $0184D1 | | Preserve the data bank register and set it to the program bank.
    PLB                                                                         ; $0184D2 |/
    LDA 0.w,Y                                                                   ; $0184D3 |\
    AND #%00111111.b                                                            ; $0184D6 | | Determine the left X coordinate of the source window by
    LSR A                                                                       ; $0184D8 | | calculating it from the tilemap address.
    STA <r_menu_transition_tmp_source_coordinate_left                           ; $0184D9 |/
    LDA 2.w,Y                                                                   ; $0184DB |\
    CLC                                                                         ; $0184DE | | Determine the right X coordinate by adding the border-exclusive
    ADC <r_menu_transition_tmp_source_coordinate_left                           ; $0184DF | | width plus one to the left coordinate.
    INC A                                                                       ; $0184E1 | |
    STA <r_menu_transition_tmp_source_coordinate_right                          ; $0184E2 |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $0184E4 |\
    LDA 0.w,Y                                                                   ; $0184E6 | | Calculate the source top coordinate from the tilemap address.
    LSR A                                                                       ; $0184E9 | |
    LSR A                                                                       ; $0184EA | |
    LSR A                                                                       ; $0184EB | |
    LSR A                                                                       ; $0184EC | |
    LSR A                                                                       ; $0184ED | |
    LSR A                                                                       ; $0184EE | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $0184EF | |
    STA <r_menu_transition_tmp_source_coordinate_top                            ; $0184F1 |/
    LDA 3.w,Y                                                                   ; $0184F3 |\
    CLC                                                                         ; $0184F6 | | Calculate the source bottom coordinate.
    ADC <r_menu_transition_tmp_source_coordinate_top                            ; $0184F7 | |
    INC A                                                                       ; $0184F9 | |
    STA <r_menu_transition_tmp_source_coordinate_bottom                         ; $0184FA |/
    LDA 0.w,X                                                                   ; $0184FC |\
    AND #%00111111.b                                                            ; $0184FF | | Calculate the target left coordinate.
    LSR A                                                                       ; $018501 | |
    STA <r_menu_transition_tmp_target_coordinate_left                           ; $018502 |/
    LDA 2.w,X                                                                   ; $018504 |\
    CLC                                                                         ; $018507 | | Calculate the target right coordinate.
    ADC <r_menu_transition_tmp_target_coordinate_left                           ; $018508 | |
    INC A                                                                       ; $01850A | |
    STA <r_menu_transition_tmp_target_coordinate_right                          ; $01850B |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $01850D |\
    LDA 0.w,X                                                                   ; $01850F | | Calculate the target top coordinate.
    LSR A                                                                       ; $018512 | |
    LSR A                                                                       ; $018513 | |
    LSR A                                                                       ; $018514 | |
    LSR A                                                                       ; $018515 | |
    LSR A                                                                       ; $018516 | |
    LSR A                                                                       ; $018517 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $018518 | |
    STA <r_menu_transition_tmp_target_coordinate_top                            ; $01851A |/
    LDA 3.w,X                                                                   ; $01851C |\
    CLC                                                                         ; $01851F | | Calculate the target bottom coordinate.
    ADC <r_menu_transition_tmp_target_coordinate_top                            ; $018520 | |
    INC A                                                                       ; $018522 | |
    STA <r_menu_transition_tmp_target_coordinate_bottom                         ; $018523 |/
    PLB                                                                         ; $018525 | Restore the data bank register to its original value.
@loop_start:
    LDA <r_menu_transition_tmp_source_coordinate_top                            ; $018526 |\
    CMP <r_menu_transition_tmp_target_coordinate_top                            ; $018528 | | If the two top coordinates are different, update the source to
    BEQ +                                                                       ; $01852A | | bring them one step closer.
    JSR _menu_transition_update_top_coordinate                                  ; $01852C |/
+   LDA <r_menu_transition_tmp_source_coordinate_bottom                         ; $01852F |\
    CMP <r_menu_transition_tmp_target_coordinate_bottom                         ; $018531 | | If the two bottom coordinates are different, update the source to
    BEQ +                                                                       ; $018533 | | bring them one step closer.
    JSR _menu_transition_update_bottom_coordinate                               ; $018535 |/
+   LDA <r_menu_transition_tmp_source_coordinate_left                           ; $018538 |\
    CMP <r_menu_transition_tmp_target_coordinate_left                           ; $01853A | | If the two left coordinates are differnet, update the source to
    BEQ +                                                                       ; $01853C | | bring them one step closer.
    JSR _menu_transition_update_left_coordinate                                 ; $01853E |/
+   LDA <r_menu_transition_tmp_source_coordinate_right                          ; $018541 |\
    CMP <r_menu_transition_tmp_target_coordinate_right                          ; $018543 | | If the two right coordinates are different, update the source to
    BEQ +                                                                       ; $018545 | | bring them one step closer.
    JSR _menu_transition_update_right_coordinate                                ; $018547 |/
+   LDA <r_menu_transition_scroll_frames                                        ; $01854A |\
    BEQ +                                                                       ; $01854C | | If the scroll frames value is greater than zero, loop through the
    DEC <r_menu_transition_scroll_frames                                        ; $01854E | | four backgrounds, updating their horizontal and vertical scroll
    LDY #(4 * 2).w                                                              ; $018550 | | values according to the set delta values.
    LDX <r_menu_zero                                                            ; $018553 | |
-   JSR _menu_update_bg_scroll_from_delta                                       ; $018555 | |
    INX                                                                         ; $018558 | |
    INX                                                                         ; $018559 | |
    INX                                                                         ; $01855A | |
    DEY                                                                         ; $01855B | |
    BNE -                                                                       ; $01855C |/
+   JSR r_menu_window_transition_custom_function_1                              ; $01855E | Call the first custom function.
    JSR _menu_wait_for_vblank                                                   ; $018561 | Wait for vblank.
    LDA <r_menu_current_tilemap_index                                           ; $018564 |\
    LDX #menu_copy_tilemap_to_vram_offset_data.w                                ; $018566 | | Copy the current tilemap to VRAM.
    JSR _menu_execute_jump                                                      ; $018569 |/
    JSR r_menu_window_transition_custom_function_2                              ; $01856C | Call the second custom function.
    JSR _menu_set_bg_scroll_proxy                                               ; $01856F | Set the current background scroll values.
    LDX <r_menu_transition_tmp_source_coordinate_left                           ; $018572 |\
    CPX <r_menu_transition_tmp_target_coordinate_left                           ; $018574 | | Loop until the source and target have identical coordinates and
    BNE @loop_start                                                             ; $018576 | | size. (Each comparison compares two coordinates.)
    LDX <r_menu_transition_tmp_source_coordinate_right                          ; $018578 | |
    CPX <r_menu_transition_tmp_target_coordinate_right                          ; $01857A | |
    BNE @loop_start                                                             ; $01857C |/
    LDA r_menu_transition_scroll_frames.w                                       ; $01857E |\ Loop until the number of remaining scroll frames reaches zero.
    BNE @loop_start                                                             ; $018581 |/
    LDX #@done.w                                                                ; $018583 |\
    STX r_menu_window_transition_custom_function_2.address.w                    ; $018586 | | Reset the custom window transition functions to noops.
    STX r_menu_window_transition_custom_function_1.address.w                    ; $018589 |/
@done:
    RTS                                                                         ; $01858C

; _menu_update_bg_scroll_from_delta ($01:858D)
;
; Given an offset to a BG scroll value in the X register (relative to the start
; of the array at $0189, where each background has a horizontal value followed
; by a  vertical offset, with each entry consisting of three bytes: a fractional
; component, and a 16-bit whole component, and the backgrounds are in the order
; BG2, BG1, BG4 and BG3), and the current delta values in the similarly
; structured array at $01A1, updates the scroll values by those deltas.
;
; Note that while the delta array also uses three bytes, only the low two appear
; to be relevant. The high byte is ignored entirely, while the low byte and
; fractional bytes are used. If the low byte's high bit is set, it's treated as
; a negative number by masking out the high bit and subtracting instead of
; adding.
_menu_update_bg_scroll_from_delta:
    LDA <r_menu_scroll_delta_bg2.horizontal.value.lo,X                          ; $01858D |\ If the delta value is positive, branch to the positive code.
    BPL ++                                                                      ; $01858F |/ NOTE: This assumes the high byte of the delta is unused.
    REP #FLAG_P_ACCUMULATOR                                                     ; $018591 |\
    LDA <r_menu_scroll_delta_bg2.horizontal.fraction,X                          ; $018593 | | Mask out the top bit of the 16-bit delta value (8 bits whole and
    AND #$7FFF.w                                                                ; $018595 | | 8 bits fractional).
    STA <r_menu_update_bg_scroll_from_delta_tmp                                 ; $018598 |/
    LDA <r_menu_scroll_bg2.horizontal.fraction,X                                ; $01859A |\
    SEC                                                                         ; $01859C | | Subtract the delta from the current scroll value.
    SBC <r_menu_update_bg_scroll_from_delta_tmp                                 ; $01859D | |
    STA <r_menu_scroll_bg2.horizontal.fraction,X                                ; $01859F |/
    SEP #FLAG_P_ACCUMULATOR                                                     ; $0185A1 |\
    BCS +                                                                       ; $0185A3 | | If there was an overflow, decrement the high byte as well, before
    DEC <r_menu_scroll_bg2.horizontal.value.hi,X                                ; $0185A5 | | returning.
+   RTS                                                                         ; $0185A7 |/
++  REP #FLAG_P_ACCUMULATOR                                                     ; $0185A8 |\
    LDA <r_menu_scroll_bg2.horizontal.fraction,X                                ; $0185AA | | If the value was positive, add the delta to the scroll value.
    CLC                                                                         ; $0185AC | |
    ADC <r_menu_scroll_delta_bg2.horizontal.fraction,X                          ; $0185AD | |
    STA <r_menu_scroll_bg2.horizontal.fraction,X                                ; $0185AF | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $0185B1 |/
    BCC +                                                                       ; $0185B3 |\ If there was an overflow, increment the high byte.
    INC <r_menu_scroll_bg2.horizontal.value.hi,X                                ; $0185B5 |/
+   RTS                                                                         ; $0185B7

; menu_copy_tilemap_to_vram_offset_data ($01:85B8)
;
; For each tilemap index, provides the offset to the routine to copy that
; tilemap's data to VRAM, without waiting for vblank.
menu_copy_tilemap_to_vram_offset_data:
    .addr _menu_copy_tilemap_to_vram_bg2_no_vblank                              ; $0185B8.85B9
    .addr _menu_copy_tilemap_to_vram_bg1_no_vblank                              ; $0185BA.85BB
    .addr _menu_copy_tilemap_to_vram_bg4_no_vblank                              ; $0185BC.85BD
    .addr _menu_copy_tilemap_to_vram_bg3_no_vblank                              ; $0185BE.85BF

; _menu_transition_update_top_coordinate ($01:85C0)
;
; This routine, part of the menu window transition effect, expects the carry
; flag to be set in a particular way. Before calling this routine, the source
; top coordinate should be compared with the target top coordinate. The source
; window will then be modified to move it one step closer to the target. Results
; will be odd if this is called when the two coordinates are equal.
_menu_transition_update_top_coordinate:
    BCC +                                                                       ; $0185C0 |\  If the source coordinate is greater than or equal to the target,
    JSR _menu_transition_update_tilemap_middle_top                              ; $0185C2 | | replace the top row with a middle row, decrement the source
    DEC <r_menu_transition_tmp_source_coordinate_top                            ; $0185C5 | | top coordinate, and then draw a new top row.
    JMP _menu_transition_update_tilemap_top_row                                 ; $0185C7 |/
+   JSR _menu_transition_update_tilemap_blank_top                               ; $0185CA |\  Otherwise, replace the top row with a blank row, increment the top
    INC <r_menu_transition_tmp_source_coordinate_top                            ; $0185CD | | coordinate, and then draw a new top row.
    JMP _menu_transition_update_tilemap_top_row                                 ; $0185CF |/

; _menu_transition_update_bottom_coordinate ($01:85D2)
;
; Part of the window transition effect, this routine expects the carry flag to
; be set by a comparison between the source and target bottom coordinates. It
; should only be called if they are not equal. The source window will be
; modified to move it one step closer to the target window.
_menu_transition_update_bottom_coordinate:
    BCC +                                                                       ; $0185D2 |\  If the source coordinate is greater than or equal to the target,
    JSR _menu_transition_update_tilemap_blank_bottom                            ; $0185D4 | | replace the bottom row with blank tiles, decrement the source
    DEC <r_menu_transition_tmp_source_coordinate_bottom                         ; $0185D7 | | bottom coordinate and then draw a new bottom row.
    JMP _menu_transition_update_tilemap_bottom_row                              ; $0185D9 |/
+   JSR _menu_transition_update_tilemap_middle_bottom                           ; $0185DC |\  Otherwise, replace the existing bottom row with a middle row,
    INC <r_menu_transition_tmp_source_coordinate_bottom                         ; $0185DF | | increment the bottom coordinate, and then draw a new bottom row.
    JMP _menu_transition_update_tilemap_bottom_row                              ; $0185E1 |/

; _menu_transition_update_left_coordinate ($01:85E4)
;
; Part of the window transition effect, this routine expects the carry flag to
; be set by a comparison between the source and target left coordinates. It
; should only be called if they are not equal. The source window will be
; modified to move it one step closer to the target window.
_menu_transition_update_left_coordinate:
    BCC +                                                                       ; $0185E4 |\  If the source coordinate is greater than or equal to the target,
    JSR _menu_transition_update_tilemap_column_left_middle                      ; $0185E6 | | replace the current left column with a middle column, decrement
    DEC <r_menu_transition_tmp_source_coordinate_left                           ; $0185E9 | | the left coordinate, and then draw a new left column.
    JMP _menu_transition_update_tilemap_column_left                             ; $0185EB |/
+   JSR _menu_transition_update_tilemap_column_blank_left                       ; $0185EE |\  Otherwise, erase the current left column, increment the left
    INC <r_menu_transition_tmp_source_coordinate_left                           ; $0185F1 | | coordinate, and then draw a new left column.
    JMP _menu_transition_update_tilemap_column_left                             ; $0185F3 |/

; _menu_transition_update_right_coordinate ($01:85F6)
;
; Part of the window transition effect, this routine expects the carry flag to
; be set by a comparison between the source and target right coordinates. It
; should only be called if they are not equal. The source window will be
; modified to move it one step closer to the target window.
_menu_transition_update_right_coordinate:
    BCC +                                                                       ; $0185F6 |\  If the source coordinate is greater than or equal to the target,
    JSR _menu_transition_update_tilemap_column_blank_right                      ; $0185F8 | | erase the current right column, decrement the right coordinate,
    DEC <r_menu_transition_tmp_source_coordinate_right                          ; $0185FB | | and draw a new right column.
    JMP _menu_transition_update_tilemap_column_right                            ; $0185FD |/
+   JSR _menu_transition_update_tilemap_column_right_middle                     ; $018600 |\  Otherwise, replace the current right column with a middle column,
    INC <r_menu_transition_tmp_source_coordinate_right                          ; $018603 | | increment the right coordinate, and then draw a new right column.
    JMP _menu_transition_update_tilemap_column_right                            ; $018605 |/

; _menu_transition_get_source_tilemap_address_* ($01:8608)
;
; Given the current source tilemap coordinates in a menu window transition, sets
; the X register to the tilemap address for the coordinate specified by the
; choice of entry point.
_menu_transition_get_source_tilemap_address_top_left:
    LDA <r_menu_transition_tmp_source_coordinate_left                           ; $018608 |\
    ASL A                                                                       ; $01860A | | Set a temporary variable to the left coordinate times two, load
    STA <r_menu_generic_tmp_offset.lo                                           ; $01860B | | the top coordinate into the accumulator and branch to the common
    LDA <r_menu_transition_tmp_source_coordinate_top                            ; $01860D | | code.
    BRA +                                                                       ; $01860F |/
_menu_transition_get_source_tilemap_address_bottom_left:
    LDA <r_menu_transition_tmp_source_coordinate_left                           ; $018611 |\
    ASL A                                                                       ; $018613 | | Set a temporary variable to the left coordinate times two, load
    STA <r_menu_generic_tmp_offset.lo                                           ; $018614 | | the bottom coordinate into the accumulator and branch to the
    LDA <r_menu_transition_tmp_source_coordinate_bottom                         ; $018616 | | common code.
    BRA +                                                                       ; $018618 |/
_menu_transition_get_source_tilemap_address_top_right:
    LDA <r_menu_transition_tmp_source_coordinate_right                          ; $01861A |\
    ASL A                                                                       ; $01861C | | Set a temporary variable to the right coordinate times two and
    STA <r_menu_generic_tmp_offset.lo                                           ; $01861D | | load the top coordinate into the accumulator.
    LDA <r_menu_transition_tmp_source_coordinate_top                            ; $01861F |/
+   XBA                                                                         ; $018621 |\
    LDA #0.b                                                                    ; $018622 | | Multiply the loaded value by 64, to convert to a tilemap offset.
    REP #FLAG_P_ACCUMULATOR                                                     ; $018624 | |
    LSR A                                                                       ; $018626 | |
    LSR A                                                                       ; $018627 |/
    CLC                                                                         ; $018628 |\ Add the X coordinate portion of the offset.
    ADC <r_menu_generic_tmp_offset                                              ; $018629 |/
    CLC                                                                         ; $01862B |\ Add the base tilemap address.
    ADC <r_menu_current_tilemap_base_address                                    ; $01862C |/
    TAX                                                                         ; $01862E |\ Store the result in the X register.
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01862F |/
    RTS                                                                         ; $018631

; _menu_transition_update_tilemap_middle_* ($01:8632)
;
; For the menu window transition effect, reads the coordinate of the source
; window and updates that row with middle window tiles to match those
; coordinates. This can either overwrite the top row or the bottom row,
; depending on the entry point.
_menu_transition_update_tilemap_middle_bottom:
    JSR _menu_transition_get_source_tilemap_address_bottom_left                 ; $018632
    BRA __menu_transition_update_tilemap_middle_common                          ; $018635
_menu_transition_update_tilemap_middle_top:
    JSR _menu_transition_get_source_tilemap_address_top_left                    ; $018637 | Set the X register to the tilemap address for the source window.
__menu_transition_update_tilemap_middle_common:
    LDA <r_menu_transition_tmp_source_coordinate_right                          ; $01863A |\
    SEC                                                                         ; $01863C | | Set a temporary variable to the width of the window, not including
    SBC <r_menu_transition_tmp_source_coordinate_left                           ; $01863D | | the border tiles.
    DEC A                                                                       ; $01863F | |
    STA <r_menu_transition_tmp_count                                            ; $018640 |/
    LDA #TILE_MENU_WINDOW_MIDDLE_ROW_LEFT.b                                     ; $018642 |\
    STA 0.w,X                                                                   ; $018644 | | Write the middle left tile to the tilemap.
    INX                                                                         ; $018647 | |
    INX                                                                         ; $018648 |/
    LDA #TILE_MENU_WINDOW_BLANK.b                                               ; $018649 |\
-   STA 0.w,X                                                                   ; $01864B | | Write the calculated number of blank tiles to the tilemap for the
    INX                                                                         ; $01864E | | middle.
    INX                                                                         ; $01864F | |
    DEC <r_menu_transition_tmp_count                                            ; $018650 | |
    BNE -                                                                       ; $018652 |/
    LDA #TILE_MENU_WINDOW_MIDDLE_ROW_RIGHT.b                                    ; $018654 |\ Write the middle right tile to the tilemap.
    STA 0.w,X                                                                   ; $018656 |/
    RTS                                                                         ; $018659

; _menu_transition_update_tilemap_blank_* ($01:865A)
;
; For the menu window transition effect, reads the coordinate of the source
; window and updates the row with zeroes to clear any existing tiles. This can
; overwrite either the top or the bottom row, depending on the entry point.
_menu_transition_update_tilemap_blank_bottom:
    JSR _menu_transition_get_source_tilemap_address_bottom_left                 ; $01865A | set the X register to the tilemap address for the bottom row.
    BRA __menu_transition_update_tilemap_blank_common                           ; $01865D
_menu_transition_update_tilemap_blank_top:
    JSR _menu_transition_get_source_tilemap_address_top_left                    ; $01865F | Set the X register to the tilemap address for the top row.
__menu_transition_update_tilemap_blank_common:
    LDA <r_menu_transition_tmp_source_coordinate_right                          ; $018662 |\
    SEC                                                                         ; $018664 | | Set a count variable to the total width of the window, including
    SBC <r_menu_transition_tmp_source_coordinate_left                           ; $018665 | | the border tiles.
    INC A                                                                       ; $018667 | |
    STA <r_menu_transition_tmp_count                                            ; $018668 |/
    TDC                                                                         ; $01866A |\
-   STA 0.w,X                                                                   ; $01866B | | Write zeroes to the tilemap to erase any tiles that may be there.
    INX                                                                         ; $01866E | |
    INX                                                                         ; $01866F | |
    DEC <r_menu_transition_tmp_count                                            ; $018670 | |
    BNE -                                                                       ; $018672 |/
    RTS                                                                         ; $018674

; _menu_transition_update_tilemap_top_row ($01:8675)
;
; For the menu window transition effect, reads the coordinate of the source
; window and updates that row with top window tiles to match those coordinates.
_menu_transition_update_tilemap_top_row:
    JSR _menu_transition_get_source_tilemap_address_top_left                    ; $018675 | Set the X register to the source tilemap address.
    LDA <r_menu_transition_tmp_source_coordinate_right                          ; $018678 |\
    SEC                                                                         ; $01867A | | Set a temporary counter to the width of the source window in
    SBC <r_menu_transition_tmp_source_coordinate_left                           ; $01867B | | tiles, excluding the two sides.
    DEC A                                                                       ; $01867D | |
    STA <r_menu_transition_tmp_count                                            ; $01867E |/
    LDA #TILE_MENU_WINDOW_TOP_ROW_LEFT.b                                        ; $018680 |\ Write the left top row tile to the first address.
    STA 0.w,X                                                                   ; $018682 |/
    INX                                                                         ; $018685 |\ Increment the X register twice to go to the next tile.
    INX                                                                         ; $018686 |/
    LDA #TILE_MENU_WINDOW_TOP_ROW_MIDDLE.b                                      ; $018687 |\
-   STA 0.w,X                                                                   ; $018689 | | Write the calculated number of top middle tiles.
    INX                                                                         ; $01868C | |
    INX                                                                         ; $01868D | |
    DEC <r_menu_transition_tmp_count                                            ; $01868E | |
    BNE -                                                                       ; $018690 |/
    LDA #TILE_MENU_WINDOW_TOP_ROW_RIGHT.b                                       ; $018692 |\ Write the top right tile.
    STA 0.w,X                                                                   ; $018694 |/
    RTS                                                                         ; $018697

; _menu_transition_update_tilemap_bottom_row ($01:8698)
;
; For the menu window transition effect, reads the coordinate of the bottom row
; of the source window and updates that row with bottom window tiles.
_menu_transition_update_tilemap_bottom_row:
    JSR _menu_transition_get_source_tilemap_address_bottom_left                 ; $018698 | Set the X register to the tilemap address for the bottom row.
    LDA <r_menu_transition_tmp_source_coordinate_right                          ; $01869B |\
    SEC                                                                         ; $01869D | | Set the count variable to the border-exclusive width of the
    SBC <r_menu_transition_tmp_source_coordinate_left                           ; $01869E | | window.
    DEC A                                                                       ; $0186A0 | |
    STA <r_menu_transition_tmp_count                                            ; $0186A1 |/
    LDA #TILE_MENU_WINDOW_BOTTOM_ROW_LEFT.b                                     ; $0186A3 |\
    STA 0.w,X                                                                   ; $0186A5 | | Write the bottom left tile.
    INX                                                                         ; $0186A8 | |
    INX                                                                         ; $0186A9 |/
    LDA #TILE_MENU_WINDOW_BOTTOM_ROW_MIDDLE.b                                   ; $0186AA |\
-   STA 0.w,X                                                                   ; $0186AC | | Write the bottom middle tiles.
    INX                                                                         ; $0186AF | |
    INX                                                                         ; $0186B0 | |
    DEC <r_menu_transition_tmp_count                                            ; $0186B1 | |
    BNE -                                                                       ; $0186B3 |/
    LDA #TILE_MENU_WINDOW_BOTTOM_ROW_RIGHT.b                                    ; $0186B5 |\ Write the bottom right tile.
    STA 0.w,X                                                                   ; $0186B7 |/
    RTS                                                                         ; $0186BA


; _menu_transition_update_tilemap_column_* ($01:86BB)
;
; Various routines to update the tilemap during the menu window transition
; effect. These routines are used to draw new columns for the window. Depending
; on the entry point, the routine can draw either a left or middle column to the
; current left column or draw a right or middle column to the current right
; column.
_menu_transition_update_tilemap_column_left_middle:
    LDA #TILE_MENU_WINDOW_TOP_ROW_MIDDLE.b                                      ; $0186BB |\
    STA <r_menu_transition_tmp_top_tile                                         ; $0186BD | | Set the tile values to draw a middle column and branch to the code
    LDA #TILE_MENU_WINDOW_BLANK.b                                               ; $0186BF | | to  load the left tilemap address.
    STA <r_menu_transition_tmp_middle_tile                                      ; $0186C1 | |
    LDA #TILE_MENU_WINDOW_BOTTOM_ROW_MIDDLE.b                                   ; $0186C3 | |
    STA <r_menu_transition_tmp_bottom_tile                                      ; $0186C5 | |
    BRA __menu_transition_update_tilemap_column_left                            ; $0186C7 |/
_menu_transition_update_tilemap_column_left:
    LDA #TILE_MENU_WINDOW_TOP_ROW_LEFT.b                                        ; $0186C9 |\
    STA <r_menu_transition_tmp_top_tile                                         ; $0186CB | | Set the tile values to draw a left column and branch to the code
    LDA #TILE_MENU_WINDOW_MIDDLE_ROW_LEFT.b                                     ; $0186CD | | to load the left tilemap address.
    STA <r_menu_transition_tmp_middle_tile                                      ; $0186CF | |
    LDA #TILE_MENU_WINDOW_BOTTOM_ROW_LEFT.b                                     ; $0186D1 | |
    STA <r_menu_transition_tmp_bottom_tile                                      ; $0186D3 | |
    BRA __menu_transition_update_tilemap_column_left                            ; $0186D5 |/
_menu_transition_update_tilemap_column_right:
    LDA #TILE_MENU_WINDOW_TOP_ROW_RIGHT.b                                       ; $0186D7 |\
    STA <r_menu_transition_tmp_top_tile                                         ; $0186D9 | | Set the tile values to draw a right column and branch to the code
    LDA #TILE_MENU_WINDOW_MIDDLE_ROW_RIGHT.b                                    ; $0186DB | | to load the right tilemap address.
    STA <r_menu_transition_tmp_middle_tile                                      ; $0186DD | |
    LDA #TILE_MENU_WINDOW_BOTTOM_ROW_RIGHT.b                                    ; $0186DF | |
    STA <r_menu_transition_tmp_bottom_tile                                      ; $0186E1 | |
    BRA __menu_transition_update_tilemap_column_right                           ; $0186E3 |/
_menu_transition_update_tilemap_column_right_middle:
    LDA #TILE_MENU_WINDOW_TOP_ROW_MIDDLE.b                                      ; $0186E5 |\
    STA <r_menu_transition_tmp_top_tile                                         ; $0186E7 | | Set the tile values to draw a middle column and branch to the code
    LDA #TILE_MENU_WINDOW_BLANK.b                                               ; $0186E9 | | to load the right tilemap address.
    STA <r_menu_transition_tmp_middle_tile                                      ; $0186EB | |
    LDA #TILE_MENU_WINDOW_BOTTOM_ROW_MIDDLE.b                                   ; $0186ED | |
    STA <r_menu_transition_tmp_bottom_tile                                      ; $0186EF | |
    BRA __menu_transition_update_tilemap_column_right                           ; $0186F1 |/
__menu_transition_update_tilemap_column_right:
    JSR _menu_transition_get_source_tilemap_address_top_right                   ; $0186F3 |\ Load the tilemap address for the right column.
    BRA __menu_transition_update_tilemap_column_common                          ; $0186F6 |/
__menu_transition_update_tilemap_column_left:
    JSR _menu_transition_get_source_tilemap_address_top_left                    ; $0186F8 | Load the tilemap address for the left column.
__menu_transition_update_tilemap_column_common:
    LDA <r_menu_transition_tmp_source_coordinate_bottom                         ; $0186FB |\
    SEC                                                                         ; $0186FD | | Set the counter to the border-exclusive height of the window.
    SBC <r_menu_transition_tmp_source_coordinate_top                            ; $0186FE | |
    DEC A                                                                       ; $018700 | |
    STA <r_menu_transition_tmp_count                                            ; $018701 |/
    LDA <r_menu_transition_tmp_top_tile                                         ; $018703 |\
    STA 0.w,X                                                                   ; $018705 | | Write the top tile to the column.
    JSR _increment_x_by_64                                                      ; $018708 |/
-   LDA <r_menu_transition_tmp_middle_tile                                      ; $01870B |\
    STA 0.w,X                                                                   ; $01870D | | Write the middle tiles to the column.
    JSR _increment_x_by_64                                                      ; $018710 | |
    DEC <r_menu_transition_tmp_count                                            ; $018713 | |
    BNE -                                                                       ; $018715 |/
    LDA <r_menu_transition_tmp_bottom_tile                                      ; $018717 |\ Write the bottom tile to the column.
    STA 0.w,X                                                                   ; $018719 |/
    RTS                                                                         ; $01871C

; _menu_transition_update_tilemap_column_blank_* ($01:871D)
;
; Part of the window transition effect, depending on the entry point, can erase
; either the current left column or right column of the window.
_menu_transition_update_tilemap_column_blank_right:
    JSR _menu_transition_get_source_tilemap_address_top_right                   ; $01871D |\ Set X to the tilemap address to the address for the right column
    BRA __menu_transition_update_tilemap_column_blank_common                    ; $018720 |/ and branch to the common code.
_menu_transition_update_tilemap_column_blank_left:
    JSR _menu_transition_get_source_tilemap_address_top_left                    ; $018722 | Set X to the tilemap address to the address for the left column.
__menu_transition_update_tilemap_column_blank_common:
    LDA <r_menu_transition_tmp_source_coordinate_bottom                         ; $018725 |\
    SEC                                                                         ; $018727 | | Set the counter to the border-inclusive height of the window.
    SBC <r_menu_transition_tmp_source_coordinate_top                            ; $018728 | |
    INC A                                                                       ; $01872A | |
    STA <r_menu_transition_tmp_count                                            ; $01872B |/
-   LDA #0.b                                                                    ; $01872D |\
    STA 0.w,X                                                                   ; $01872F | | Write zeroes to the column to erase it.
    JSR _increment_x_by_64                                                      ; $018732 | |
    DEC <r_menu_transition_tmp_count                                            ; $018735 | |
    BNE -                                                                       ; $018737 |/
    RTS                                                                         ; $018739

; _menu_backup_vram_tiles ($01:873A)
;
; Proxy function to call menu_backup_vram_tiles_proxy in bank $14, which backs
; up the area of VRAM the menu code uses for its text tiles.
_menu_backup_vram_tiles:
    JSL bank14.menu_backup_vram_tiles_proxy                                     ; $01873A
    RTS                                                                         ; $01873E

; _menu_restore_vram_tiles ($01:873F)
;
; Restores the previously backed up tile data, ultimate stored in VRAM at $2000.
_menu_restore_vram_tiles:
    PHB                                                                         ; $01873F | Preserve the data bank register.
    JSL bank14.menu_configure_restore_tile_backup.l                             ; $018740 |\ Restore the previously backed up tile data.
    JSR _menu_copy_to_vram                                                      ; $018744 |/
    PLB                                                                         ; $018747 | Restore the data bank register.
    RTS                                                                         ; $018748

; _menu_set_palette_window_color ($01:8749)
;
; Proxy function to call the similarly named function in bank 14, which updates
; the menu CG-RAM mirror to use the player's configured window color.
_menu_set_palette_window_color:
    JSL bank14.menu_set_palette_window_color_proxy                              ; $018749
    RTS                                                                         ; $01874D

; _play_sound_effect_* ($01:874E)
;
; Plays either a cursor sound effect or an error sound effect, depending on the
; entry point.
_play_sound_effect_cursor:
    LDA #AUDIO_MODE_EFFECT_CURSOR.b                                             ; $01874E | Load the cursor effect ID.
__play_sound_effect_common:
    STA r_play_audio_arg_mode.w                                                 ; $018750 |\ Play the specified sound effect.
    JSL bank04.play_audio                                                       ; $018753 |/
    RTS                                                                         ; $018757
_play_sound_effect_error:
    LDA #AUDIO_MODE_EFFECT_ERROR.b                                              ; $018758 | Load the error effect ID.
    BRA __play_sound_effect_common                                              ; $01875A | Branch to play the effect.

; play_sound_effect ($01:875C)
;
; Proxy function to call _play_sound_effect from another bank.
play_sound_effect:
    JSR _play_sound_effect                                                      ; $01875C
    RTL                                                                         ; $01875F

; _play_sound_effect_menu_chime ($01:8760)
;
; Plays the menu chime sound effect by loading the value and falling through to
; the next routine.
_play_sound_effect_menu_chime:
    LDA #AUDIO_EFFECT_MENU_CHIME.b                                              ; $018760

; _play_sound_effect ($01:8762)
;
; Given an effect number in the accumulator, plays that sound effect.
_play_sound_effect:
    STA r_play_audio_arg_track.w                                                ; $018762 | Save the parameter as the track number.
    LDA #AUDIO_MODE_EFFECT.b                                                    ; $018765 |\ Set the audio mode to effect.
    STA r_play_audio_arg_mode.w                                                 ; $018767 |/
    LDA #AUDIO_PAN_CENTER.b                                                     ; $01876A |\ Set the audio panning to the center.
    STA r_play_audio_arg_pan.w                                                  ; $01876C |/
    LDA #$FF.b                                                                  ; $01876F |\ TODO
    STA r_play_audio_arg_unknown.w                                              ; $018771 |/
    JSL bank04.play_audio                                                       ; $018774 | Play the audio.
    RTS                                                                         ; $018778

; _menu_erase_tiles ($01:8779)
;
; Proxy function to call menu_erase_tiles_proxy in bank $14.
_menu_erase_tiles:
    JSL bank14.menu_erase_tiles_proxy                                           ; $018779
    RTS                                                                         ; $01877D

; _increment_x_by_64 ($01:877E)
;
; Increments the X register by 64. Used in the menu code when writing tilemaps
; to advanced to the next row of tiles.
_increment_x_by_64:
    REP #FLAG_P_ACCUMULATOR                                                     ; $01877E |\
    PHA                                                                         ; $018780 | | Add 64 to the X register.
    TXA                                                                         ; $018781 | |
    CLC                                                                         ; $018782 | |
    ADC #(32 * 2).w                                                             ; $018783 | |
    TAX                                                                         ; $018786 | |
    PLA                                                                         ; $018787 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $018788 |/
    RTS                                                                         ; $01878A

; _increment_y_by_64 ($01:878B)
;
; Increments the Y register by 64. Used in the menu code when writing tilemaps
; to advance to the next row of tiles.
_increment_y_by_64:
    REP #FLAG_P_ACCUMULATOR                                                     ; $01878B |\
    PHA                                                                         ; $01878D | | Add 64 to the Y register.
    TYA                                                                         ; $01878E | |
    CLC                                                                         ; $01878F | |
    ADC #(32 * 2).w                                                             ; $018790 | |
    TAY                                                                         ; $018793 | |
    PLA                                                                         ; $018794 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $018795 |/
    RTS                                                                         ; $018797

; _menu_expand_tiles_to_tilemap ($01:8798)
;
; Given the address to a set of tile numbers in the Y register and the offset
; within the current tilemap (in $29) in the X register, copies the tiles to the
; tilemap, skipping the flags bytes in the tilemap.
_menu_expand_tiles_to_tilemap:
    PHB                                                                         ; $018798 | Preserve the current value of the data bank register.
    PHK                                                                         ; $018799 |\ Set the data bank register to the value of the program bank
    PLB                                                                         ; $01879A |/ register.
    REP #FLAG_P_ACCUMULATOR                                                     ; $01879B |\
    TXA                                                                         ; $01879D | | Set the X register to the value in the X register plus the current
    CLC                                                                         ; $01879E | | base tilemap address.
    ADC <r_menu_current_tilemap_base_address                                    ; $01879F | |
    TAX                                                                         ; $0187A1 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $0187A2 |/
-   LDA 0.w,Y                                                                   ; $0187A4 |\
    BEQ +                                                                       ; $0187A7 | | Copy the values at the address in the Y register to thhe address
    STA $7E0000.l,X                                                             ; $0187A9 | | now in the X register, incrementing the X register twice for each
    INX                                                                         ; $0187AD | | increment of the Y register (to skip the flags bytes).
    INX                                                                         ; $0187AE | |
    INY                                                                         ; $0187AF | |
    BRA -                                                                       ; $0187B0 |/
+   PLB                                                                         ; $0187B2 | Restore the original value of the data bank register.
    RTS                                                                         ; $0187B3

; _menu_transfer_a_to_x ($01:87B4)
;
; Transfers the 8-bit value in the accumulator to the X register. Note that this
; uses the 16-bit value at $43 as a staging area. In fact, the value at $44 is
; not written at all, so if that is preset to something other than zero, this
; routine will use that as the high byte.
_menu_transfer_a_to_x:
    STA <r_menu_generic_tmp_offset.lo                                           ; $0187B4
    LDX <r_menu_generic_tmp_offset                                              ; $0187B6
    RTS                                                                         ; $0187B8

; _increment_y_by_x ($01:87B9)
;
; Increments the Y register by the value specified by the entry point. The 8
; variant is only used in the Japanese version.
_increment_y_by_8:
    INY                                                                         ; $0187B9
    INY                                                                         ; $0187BA
    INY                                                                         ; $0187BB
    INY                                                                         ; $0187BC
_increment_y_by_4:
    INY                                                                         ; $0187BD
    INY                                                                         ; $0187BE
    INY                                                                         ; $0187BF
    INY                                                                         ; $0187C0
    RTS                                                                         ; $0187C1

; _menu_main_draw_time_and_gp ($01:87C2)
;
; Draws the party's GP and the game time to the tilemap for the main menu.
_menu_main_draw_time_and_gp:
    JSR _menu_set_current_tilemap_bg3                                           ; $0187C2 | Set the current tilemap to BG3.
    LDY #menu_text_time_direct_data.w                                           ; $0187C5 |\
    LDX #(23 * 2) + (20 * 32 * 2).w                                             ; $0187C8 | | Draw "Time" to the tilemap at 23, 20.
    JSR _menu_expand_tiles_to_tilemap                                           ; $0187CB |/
    LDY #menu_text_shop_party_gp_text_only_data.w                               ; $0187CE |\
    LDX #(27 * 2) + (25 * 32 * 2).w                                             ; $0187D1 | | Draw "GP" to the tilemap at 27, 25.
    JSR _menu_draw_text_direct                                                  ; $0187D4 |/
    JSR _menu_main_draw_game_time                                               ; $0187D7 | Draw the game time to the tilemap.
    LDY #(21 * 2) + (24 * 32 * 2).w                                             ; $0187DA |\
    LDA r_party_gp.hi.w                                                         ; $0187DD | | Draw the party's GP.
    LDX r_party_gp.lo.w                                                         ; $0187E0 | |
    JMP _menu_draw_number_as_decimal                                            ; $0187E3 |/

; _menu_main_fade_in ($01:87E6)
;
; Draws and fades in the main menu.
_menu_main_fade_in:
    JSR _menu_init_and_set_bg_scroll                                            ; $0187E6 | Initialize and set the background scroll values.
    JSR _menu_set_bg_scroll_proxy                                               ; $0187E9 | Set the background scroll values again. NOTE: Already done by above.
    JSR _menu_load_portraits                                                    ; $0187EC | Load the character portraits.
    JSR _menu_initialize_and_draw_main                                          ; $0187EF | Draw the main menu.
    JSR _menu_copy_tilemaps_to_vram                                             ; $0187F2 | Copy the tilemaps to VRAM.
    JSR _menu_copy_oam_to_ppu                                                   ; $0187F5 | Copy the OAM to the PPU.
    JMP _menu_ppu_fade_in                                                       ; $0187F8 | Fade in the menu.

; _menu_main_core ($01:87FB)
;
; Core input handler for the main menu.
_menu_main_core:
    LDA #$7E.b                                                                  ; $0187FB |\
    PHA                                                                         ; $0187FD | | Set the data bank register to $7E.
    PLB                                                                         ; $0187FE |/
    JSR _menu_reset_state                                                       ; $0187FF | Reset the menu state if memory is disabled.
    JSR _menu_main_fade_in                                                      ; $018802 | Draw and fade in the main menu.
    STZ r_menu_event.w                                                          ; $018805 | Set the menu event value to none.
    LDA r_config.memory.w                                                       ; $018808 |\
    BNE @loop_start                                                             ; $01880B | | If memory is not enabled, reset the cursor index to zero.
    STZ r_menu_main_command_cursor_index.w                                      ; $01880D | |
    STZ r_menu_main_command_selected_index.w                                    ; $018810 |/
@loop_start:
    LDA r_menu_main_command_cursor_index.w                                      ; $018813 |\
    ASL A                                                                       ; $018816 | | Draw the cursor at an X coordinate of 176 and a Y coordinate of
    ASL A                                                                       ; $018817 | | the cursor index times sixteen plus sixteen.
    ASL A                                                                       ; $018818 | |
    ASL A                                                                       ; $018819 | |
    ADC #16.b                                                                   ; $01881A | |
    STA <r_menu_draw_cursor_arg_coordinates.y                                   ; $01881C | |
    LDA #176.b                                                                  ; $01881E | |
    STA <r_menu_draw_cursor_arg_coordinates.x                                   ; $018820 | |
    JSR _menu_draw_cursor_1                                                     ; $018822 |/
    JSR _menu_main_draw_time_and_gp                                             ; $018825 | Draw the party's GP and the game time.
    JSR _menu_wait_for_vblank_copy_oam_to_ppu                                   ; $018828 | Wait for vblank and copy the OAM to the PPU.
    JSR _menu_copy_tilemap_to_vram_bg3_no_vblank                                ; $01882B | Copy the BG3 tilemap to VRAM.
    JSR _menu_copy_palette_to_cgram                                             ; $01882E | Copy the palette data to CG-RAM
    JSR _menu_update_joypad_and_play_sound_effect                               ; $018831 | Update the joypad values and play a sound effect if appropriate.
    LDA <r_menu_joypad_repeat.hi                                                ; $018834 |\
    AND #JOYPAD_H_UP.b                                                          ; $018836 | | If up is pressed on the d-pad, decrement the command cursor index.
    BEQ ++                                                                      ; $018838 | | If the result is negative, set it explicitly to seven to wrap
    LDA r_menu_main_command_cursor_index.w                                      ; $01883A | | around.
    DEC A                                                                       ; $01883D | |
    BPL +                                                                       ; $01883E | |
    LDA #7.b                                                                    ; $018840 | |
+   STA r_menu_main_command_cursor_index.w                                      ; $018842 |/
++  LDA <r_menu_joypad_repeat.hi                                                ; $018845 |\
    AND #JOYPAD_H_DOWN.b                                                        ; $018847 | | If down is pressed on the d-pad, increment the command cursor
    BEQ ++                                                                      ; $018849 | | index. If the result is 8 or greater, set it to zero.
    LDA r_menu_main_command_cursor_index.w                                      ; $01884B | |
    INC A                                                                       ; $01884E | |
    CMP #8.b                                                                    ; $01884F | |
    BCC +                                                                       ; $018851 | |
    TDC                                                                         ; $018853 | |
+   STA r_menu_main_command_cursor_index.w                                      ; $018854 |/
++  LDA <r_menu_joypad_repeat.lo                                                ; $018857 |\
    AND #JOYPAD_L_A.b                                                           ; $018859 | | If the A button is not pressed, skip this next block.
    BEQ ++                                                                      ; $01885B |/
    JSR _menu_erase_cursor_1                                                    ; $01885D | Erase the cursor.
    JSR _menu_wait_for_vblank_copy_oam_to_ppu                                   ; $018860 | Wait for vblank and copy the OAM to the PPU.
    LDA r_menu_main_command_cursor_index.w                                      ; $018863 |\
    CMP r_menu_main_command_selected_index.w                                    ; $018866 | | If the cursor does not match the previously selected index, reset
    BEQ +                                                                       ; $018869 | | the menu state.
    JSR _menu_reset_state                                                       ; $01886B |/
+   STA r_menu_main_command_selected_index.w                                    ; $01886E | Save the selected index.
    LDX #menu_command_handler_offset_data.w                                     ; $018871 |\ Execute the handler for this command.
    JSR _menu_execute_jump                                                      ; $018874 |/
    JSR _menu_reset_state                                                       ; $018877 | Reset the menu state.
    JMP @loop_start                                                             ; $01887A | Jump back to the next iteration of the loop.
++  LDA <r_menu_joypad_repeat.hi                                                ; $01887D |\
    AND #JOYPAD_H_B.b                                                           ; $01887F | | If B is pressed, return.
    BEQ +                                                                       ; $018881 | |
    RTS                                                                         ; $018883 |/
+   JMP @loop_start                                                             ; $018884 | Otherwise, loop back to the next iteration.

; menu_command_handler_offset_data ($01:8887)
;
; For each menu command, provides the offset of the handler for that command.
menu_command_handler_offset_data:
    .addr _menu_command_item                                                    ; $018887.8888 | $00: Item
    .addr _menu_command_magic                                                   ; $018889.888A | $01: Magic
    .addr _menu_command_equip                                                   ; $01888B.888C | $02: Equip
    .addr _menu_command_status                                                  ; $01888D.888E | $03: Status
    .addr _menu_command_form                                                    ; $01888F.8890 | $04: Form
    .addr _menu_command_change                                                  ; $018891.8892 | $05: Change
    .addr _menu_command_custom                                                  ; $018893.8894 | $06: Custom
    .addr _menu_command_save                                                    ; $018895.8896 | $07: Save

; _menu_draw_party_window ($01:8897)
;
; Draws the entire party details window, including the character portraits and
; the character stats.
_menu_draw_party_window:
    JSR _menu_draw_party_details_window                                         ; $018897 | Draw the party details window.
    JMP _menu_party_draw_character_portraits                                    ; $01889A | Draw the character portraits.

; _menu_draw_party_details_window ($01:889D)
;
; Draws the party details window including the text. The portraits are not
; included, as they are done with sprites. The window is drawn to BG3.
_menu_draw_party_details_window:
    JSR _menu_set_current_tilemap_bg3                                           ; $01889D | Set the current tilemap to BG3.
    LDY #menu_window_party_details_data.w                                       ; $0188A0 |\ Draw the party details window.
    JSR _menu_configure_and_draw_window                                         ; $0188A3 |/
    JSR _menu_party_draw_character_stats_slot_0                                 ; $0188A6 |\
    JSR _menu_party_draw_character_stats_slot_1                                 ; $0188A9 | | Draw the basic stats for the five character slots.
    JSR _menu_party_draw_character_stats_slot_2                                 ; $0188AC | |
    JSR _menu_party_draw_character_stats_slot_3                                 ; $0188AF | |
    JMP _menu_party_draw_character_stats_slot_4                                 ; $0188B2 |/

; menu_party_draw_character_stats_slot_offset_data ($01:88B5)
;
; For each character slot, contains a pointer to the function that will draw
; that slot's stats to the party window.
menu_party_draw_character_stats_slot_offset_data:
    .addr _menu_party_draw_character_stats_slot_0                               ; $0188B5.88B6
    .addr _menu_party_draw_character_stats_slot_1                               ; $0188B7.88B8
    .addr _menu_party_draw_character_stats_slot_2                               ; $0188B9.88BA
    .addr _menu_party_draw_character_stats_slot_3                               ; $0188BB.88BC
    .addr _menu_party_draw_character_stats_slot_4                               ; $0188BD.88BE

; _menu_party_draw_selected_character_stats ($01:88BF)
;
; Draws the party menu to BG3, and draws the stats associated with the currently
; selected character to that window. The _no_window variant skips drawing the
; window, and instead just draws the stats for the character.
_menu_party_draw_selected_character_stats:
    JSR _menu_set_current_tilemap_bg3                                           ; $0188BF | Set the current tilemap to BG3.
    LDY #menu_window_party_details_data.w                                       ; $0188C2 |\ Draw the party details window to BG3.
    JSR _menu_configure_and_draw_window                                         ; $0188C5 |/
_menu_party_draw_selected_character_stats_no_window:
    LDA <r_menu_current_selected_character_slot                                 ; $0188C8 |\
    LDX #menu_party_draw_character_stats_slot_offset_data.w                     ; $0188CA | | Draw the selected character's stats to the window.
    JMP _menu_execute_jump                                                      ; $0188CD |/

; _menu_party_draw_character_stats_slot_0 ($01:88D0)
;
; Draws the basic stats for the character in slot 0 to the current tilemap at
; coordinates 7, 11.
_menu_party_draw_character_stats_slot_0:
    LDX #(7 * 2 + 11 * 32 * 2).w                                                ; $0188D0 |\
    LDY #r_character_field.1.w                                                  ; $0188D3 | | Draw the character in slot zero's stats to 7, 11.
    JMP _menu_party_draw_character_basic_stats                                  ; $0188D6 |/

; _menu_party_draw_character_stats_slot_1 ($01:88D9)
;
; Draws the basic stats for the character in slot 1 to the current tilemap at
; coordinates 7, 1.
_menu_party_draw_character_stats_slot_1:
    LDX #(7 * 2 + 1 * 32 * 2).w                                                 ; $0188D9 |\
    LDY #r_character_field.2.w                                                  ; $0188DC | | Draw the character in slot 1's stats to 7, 1.
    JMP _menu_party_draw_character_basic_stats                                  ; $0188DF |/

; _menu_party_draw_character_stats_slot_2 ($01:88E2)
;
; Draws the basic stats for the character in slot 2 to the current tilemap at
; coordinates 7, 21.
_menu_party_draw_character_stats_slot_2:
    LDX #(7 * 2 + 21 * 32 * 2).w                                                ; $0188E2 |\
    LDY #r_character_field.3.w                                                  ; $0188E5 | | Draw the character in slot 2's stats to 7, 21.
    JMP _menu_party_draw_character_basic_stats                                  ; $0188E8 |/

; _menu_party_draw_character_stats_slot_3 ($01:88EB)
;
; Draws the basic stats for the character in slot 3 to the current tilemap at
; coordinates 7, 6.
_menu_party_draw_character_stats_slot_3:
    LDX #(7 * 2 + 6 * 32 * 2).w                                                 ; $0188EB |\
    LDY #r_character_field.4.w                                                  ; $0188EE | | Draw the character in slot 3's stats to 7, 6.
    JMP _menu_party_draw_character_basic_stats                                  ; $0188F1 |/

; _menu_party_draw_character_stats_slot_4 ($01:88F4)
;
; Draws the basic stats for the character in slot 4 to the current tilemap at
; coordinates 7, 16.
_menu_party_draw_character_stats_slot_4:
    LDX #(7 * 2 + 16 * 32 * 2).w                                                ; $0188F4 |\
    LDY #r_character_field.5.w                                                  ; $0188F7 | | Draw the character in slot 4's stats to 7, 16.
    JMP _menu_party_draw_character_basic_stats                                  ; $0188FA |/

; _menu_party_draw_character_portraits ($01:88FD)
;
; Draws the character portraits for the entire party.
_menu_party_draw_character_portraits:
    LDA #%00000000.b                                                            ; $0188FD |\ Set the tile flags for priority zero.
    STA <r_menu_character_sprite_base_tile_flags                                ; $0188FF |/
    TDC                                                                         ; $018901 |\ Draw the character portrait for slot zero.
    JSR _menu_party_draw_character_portrait                                     ; $018902 |/
    LDA #1.b                                                                    ; $018905 |\ Draw the character portrait for slot one.
    JSR _menu_party_draw_character_portrait                                     ; $018907 |/
    LDA #2.b                                                                    ; $01890A |\ Draw the character portrait for slot two.
    JSR _menu_party_draw_character_portrait                                     ; $01890C |/
    LDA #3.b                                                                    ; $01890F |\ Draw the character portrait for slot three.
    JSR _menu_party_draw_character_portrait                                     ; $018911 |/
    LDA #4.b                                                                    ; $018914 |\ Draw the character portrait for slot four.
    JMP _menu_party_draw_character_portrait                                     ; $018916 |/

; _menu_main_draw ($01:8919)
;
; Draws the main menu, including the party details, commands, game time, and
; GP. Does not actually draw either the GP or the time.
_menu_main_draw:
    JSR _menu_draw_party_window                                                 ; $018919 | Draw the party details window.
    JSR _menu_set_current_tilemap_bg3                                           ; $01891C |\
    LDY #menu_window_main_time_data.w                                           ; $01891F | | Draw the time and GP windows to BG3.
    JSR _menu_configure_and_draw_window                                         ; $018922 | |
    LDY #menu_window_main_gp_data.w                                             ; $018925 | |
    JSR _menu_configure_and_draw_window                                         ; $018928 |/
    JSR _menu_set_current_tilemap_bg4                                           ; $01892B |\
    LDY #menu_window_main_command_data.w                                        ; $01892E | | Draw the command window to BG4.
    JSR _menu_draw_text_indirect_plus_window                                    ; $018931 |/
    LDA r_saving_enabled.w                                                      ; $018934 |\
    BNE +                                                                       ; $018937 | | If saving is not enabled, adjust the tile flags for the "Save"
    LDA #%00100100.b                                                            ; $018939 | | text to use palette 1 (grey) and priority 1.
    STA r_menu_tilemap_bg4.w + (24 * 2) + (16 * 32 * 2) + 1                     ; $01893B | |
    STA r_menu_tilemap_bg4.w + (25 * 2) + (16 * 32 * 2) + 1                     ; $01893E | | The Japanese version modifies a diacritic character instead of a
    STA r_menu_tilemap_bg4.w + (26 * 2) + (16 * 32 * 2) + 1                     ; $018941 | | fourth letter.
.if FF4_REGION == "JAPAN"                                                       ;         | |
    STA r_menu_tilemap_bg4.w + (26 * 2) + (15 * 32 * 2) + 1                     ; $018944 | |
.else                                                                           ;         | |
    STA r_menu_tilemap_bg4.w + (27 * 2) + (16 * 32 * 2) + 1                     ; $018944 |/
.endif
+   RTS                                                                         ; $018947

; _menu_party_get_portrait_coordinates ($01:8948)
;
; Given a slot number in the accumulator, returns the coordinates for that
; slot's character portrait in the party menu in the Y register. The 16-bit
; slot number is returned in $60.
;
; NOTE: This routine also sets $48 ($0148 if the direct register is $0100) to
;       %0SSSCCCC where S is the slot number and C is the character ID. This
;       variable seems to be unused. Since the character ID may use up to five
;       bits, bit 4 is actually set if it's set in either the slot or the
;       character ID.
_menu_party_get_portrait_coordinates:
    STA <r_menu_generic_tmp_offset_2.lo                                         ; $018948 |\ Transfer the slot number into a temporary variable.
    STZ <r_menu_generic_tmp_offset_2.hi                                         ; $01894A |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $01894C |\
    LDA <r_menu_generic_tmp_offset_2                                            ; $01894E | | Set the Y register to the offset to the character record by adding
    ASL A                                                                       ; $018950 | | the base address to the slot number times 64.
    ASL A                                                                       ; $018951 | |
    ASL A                                                                       ; $018952 | |
    ASL A                                                                       ; $018953 | |
    ASL A                                                                       ; $018954 | |
    ASL A                                                                       ; $018955 | |
    ADC #r_character_field.w                                                    ; $018956 | |
    TAY                                                                         ; $018959 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01895A |/
    LDA <r_menu_generic_tmp_offset_2.lo                                         ; $01895C |\
    ASL A                                                                       ; $01895E | | Set a temporary variable to the slot number times sixteen.
    ASL A                                                                       ; $01895F | |
    ASL A                                                                       ; $018960 | |
    ASL A                                                                       ; $018961 | |
    STA <r_unknown_0148                                                         ; $018962 |/
    LDA character_field.id.w,Y                                                  ; $018964 |\
    AND #%00111111.b                                                            ; $018967 | | Return if the character slot is empty.
    BNE +                                                                       ; $018969 | |
    RTS                                                                         ; $01896B |/
+   ORA <r_unknown_0148                                                         ; $01896C |\ Combine the character ID with the shifted slot number.
    STA <r_unknown_0148                                                         ; $01896E |/ NOTE: This variable seems to be completely unused.
    LDA r_party_formation_two_front.w                                           ; $018970 |\
    BEQ +                                                                       ; $018973 | | Depending on the party formation, load the correct offset into the
    LDX #(5 * 2).w                                                              ; $018975 | | portrait data, using an offset of 10 if the two-front formation is
    BRA ++                                                                      ; $018978 | | being used, and an offset of zero otherwise.
+   LDX <r_menu_zero                                                            ; $01897A | |
++  STX <r_menu_generic_tmp_word                                                ; $01897C |/
    LDA <r_menu_generic_tmp_offset_2.lo                                         ; $01897E |\
    ASL A                                                                       ; $018980 | | Set the X register to the formation-specific offset plus the slot
    STA <r_menu_generic_tmp_offset.lo                                           ; $018981 | | times two.
    REP #FLAG_P_ACCUMULATOR                                                     ; $018983 | |
    LDA <r_menu_generic_tmp_offset                                              ; $018985 | |
    ADC <r_menu_generic_tmp_word                                                ; $018987 | |
    TAX                                                                         ; $018989 |/
    LDA bank1E.menu_party_portrait_coordinates_data.l,X                         ; $01898A |\ Load the portrait coordinates for this slot and transfer them to
    TAY                                                                         ; $01898E |/ the Y register.
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01898F | Switch back to 8-bit accumulator mode.
    RTS                                                                         ; $018991

; _menu_party_draw_character_portrait ($01:8992)
;
; Given a slot number in the accumulator, draws the character portrait for that
; slot in the appropriate location for the party menu.
_menu_party_draw_character_portrait:
    JSR _menu_party_get_portrait_coordinates                                    ; $018992 | Set the Y register to the portrait coordinates.
    LDA <r_menu_generic_tmp_offset_2.lo                                         ; $018995 |\ Draw the portrait for the character in the passed slot.
    JMP _menu_draw_portrait                                                     ; $018997 |/

; _menu_party_draw_character_basic_stats ($01:899B)
;
; Given the offset to a character's stat record in the Y register and the offset
; for the upper left coordinates of where to draw their data in the tilemap,
; draws the basic statistics about a character to the tilemap, including their
; name, class or status icons, level, HP and MP.
__menu_party_draw_character_basic_stats_return:
    RTS                                                                         ; $01899A
_menu_party_draw_character_basic_stats:
    LDA character_field.id.w,Y                                                  ; $01899B |\
    AND #%00111111.b                                                            ; $01899E | | Return if this character slot is empty.
    BEQ __menu_party_draw_character_basic_stats_return                          ; $0189A0 |/
    STY <r_menu_party_tmp_character_offset                                      ; $0189A2 |\ Save the character offset and tilemap offset to temporary
    STX <r_menu_party_tmp_tilemap_offset                                        ; $0189A4 |/ variables.
    JSR _menu_party_set_single_tile_flags                                       ; $0189A6 | Set the tile flags for this character (darker palette if swoon).
    TXY                                                                         ; $0189A9 |\ Draw the character name.
    JSR _menu_draw_character_name                                               ; $0189AA |/
    LDY <r_menu_party_tmp_tilemap_offset                                        ; $0189AD |\
    LDX <r_menu_party_tmp_character_offset                                      ; $0189AF | | Draw the character's status icons or class.
    JSR _menu_draw_status_class                                                 ; $0189B1 |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $0189B4 |\
    LDA <r_menu_party_tmp_tilemap_offset                                        ; $0189B6 | | Add to the tilemap offset to get to the location for the
    CLC                                                                         ; $0189B8 | | character's level.
    ADC #$0084.w                                                                ; $0189B9 | |
    STA <r_menu_party_tmp_tilemap_offset                                        ; $0189BC |/
    ADC <r_menu_current_tilemap_base_address                                    ; $0189BE |\
    TAX                                                                         ; $0189C0 | | Add the base tilemap address and transfer to the X register.
    SEP #FLAG_P_ACCUMULATOR                                                     ; $0189C1 |/
.if FF4_REGION == "JAPAN"
    LDA #TEXT_UPPERCASE_L.b                                                     ; $0189C3 |\
    STA (0 * 32 * 2) + (0 * 2).w,X                                              ; $0189C5 | | Draw "LEVEL" to the tilemap.
    STA (0 * 32 * 2) + (4 * 2).w,X                                              ; $0189C8 | |
    LDA #TEXT_UPPERCASE_E.b                                                     ; $0189CB | |
    STA (0 * 32 * 2) + (1 * 2).w,X                                              ; $0189CD | |
    STA (0 * 32 * 2) + (3 * 2).w,X                                              ; $0189D0 | |
    LDA #TEXT_UPPERCASE_V.b                                                     ; $0189D3 | |
    STA (0 * 32 * 2) + (2 * 2).w,X                                              ; $0189D5 |/
.else
    LDA #TEXT_UPPERCASE_L.b                                                     ; $0189C3 |\
    STA (0 * 32 * 2) + (0 * 2).w,X                                              ; $0189C5 | | Draw "Level" to the tilemap.
    LDA #TEXT_LOWERCASE_L.b                                                     ; $0189C8 | |
    STA (0 * 32 * 2) + (4 * 2).w,X                                              ; $0189CA | |
    LDA #TEXT_LOWERCASE_E.b                                                     ; $0189CD | |
    STA (0 * 32 * 2) + (1 * 2).w,X                                              ; $0189CF | |
    STA (0 * 32 * 2) + (3 * 2).w,X                                              ; $0189D2 | |
    LDA #TEXT_LOWERCASE_V.b                                                     ; $0189D5 | |
    STA (0 * 32 * 2) + (2 * 2).w,X                                              ; $0189D7 |/
.endif
    LDA #TEXT_UPPERCASE_H.b                                                     ; $0189DA |\
    STA (1 * 32 * 2) + (0 * 2).w,X                                              ; $0189DC | | Draw "HP" to the tilemap.
    LDA #TEXT_UPPERCASE_P.b                                                     ; $0189DF | |
    STA (1 * 32 * 2) + (1 * 2).w,X                                              ; $0189E1 |/
    STA (2 * 32 * 2) + (1 * 2).w,X                                              ; $0189E4 |\
    LDA #TEXT_UPPERCASE_M.b                                                     ; $0189E7 | | Draw "MP" to the tilemap.
    STA (2 * 32 * 2) + (0 * 2).w,X                                              ; $0189E9 |/
    LDA #TEXT_SLASH.b                                                           ; $0189EC |\
    STA (1 * 32 * 2) + (7 * 2).w,X                                              ; $0189EE | | Draw the HP and MP slashes to the tilemap.
    STA (2 * 32 * 2) + (7 * 2).w,X                                              ; $0189F1 |/
    LDY #character_field.level.w                                                ; $0189F4 |\
    LDA (<r_menu_party_tmp_character_offset),Y                                  ; $0189F7 | | Draw the character's level to the tilemap.
    JSR _menu_format_two_digit_number                                           ; $0189F9 | |
    STA (0 * 32 * 2) + (10 * 2).w,X                                             ; $0189FC | |
    XBA                                                                         ; $0189FF | |
    STA (0 * 32 * 2) + (11 * 2).w,X                                             ; $018A00 |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $018A03 |\
    LDA #(1 * 32 * 2) + (3 * 2).w                                               ; $018A05 | | Draw the character's current HP to the tilemap.
    LDY #character_field.hp.w                                                   ; $018A08 | |
    JSR _menu_party_format_numeric_stat                                         ; $018A0B |/
    LDA #(1 * 32 * 2) + (8 * 2).w                                               ; $018A0E |\
    LDY #character_field.hp_max.w                                               ; $018A11 | | Draw the character's maximum HP to the tilemap.
    JSR _menu_party_format_numeric_stat                                         ; $018A14 |/
    LDA #(2 * 32 * 2) + (3 * 2).w                                               ; $018A17 |\
    LDY #character_field.mp.w                                                   ; $018A1A | | Draw the character's current MP to the tilemap.
    JSR _menu_party_format_numeric_stat                                         ; $018A1D |/
    LDA #(2 * 32 * 2) + (8 * 2).w                                               ; $018A20 |\
    LDY #character_field.mp_max.w                                               ; $018A23 | | Draw the character's maximum MP to the tilemap.
    JSR _menu_party_format_numeric_stat                                         ; $018A26 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $018A29 |/
    RTS                                                                         ; $018A2B

; _menu_party_format_numeric_stat ($01:8A2C)
;
; Given the current tilemap offset in the X register, an offset within that
; tilemap in the accumulator, and the offset to a character stat in the Y
; register, renders that stat as a four digit number and draws it to the
; tilemap.
_menu_party_format_numeric_stat:
    REP #FLAG_P_ACCUMULATOR                                                     ; $018A2C | Switch to 16-bit accumulator mode. NOTE: This is pointless.
    PHX                                                                         ; $018A2E | Preserve the value of the X register.
    STX <r_menu_generic_tmp_word                                                ; $018A2F |\
    CLC                                                                         ; $018A31 | | Set the X register to the current value plus the value in the
    ADC <r_menu_generic_tmp_word                                                ; $018A32 | | accumulator.
    TAX                                                                         ; $018A34 |/
    LDA (<r_menu_party_tmp_character_offset),Y                                  ; $018A35 |\ Read the stat from the offset passed in the Y register and format
    JSR _menu_format_four_digit_number                                          ; $018A37 |/ it as a four digit number.
    SEP #FLAG_P_ACCUMULATOR                                                     ; $018A3A |\
    LDA <r_menu_format_four_digit_number_result + 0                             ; $018A3C | | Copy the formatted number to the tilemap.
    STA (0 * 2).w,X                                                             ; $018A3E | |
    LDA <r_menu_format_four_digit_number_result + 1                             ; $018A41 | |
    STA (1 * 2).w,X                                                             ; $018A43 | |
    LDA <r_menu_format_four_digit_number_result + 3                             ; $018A46 | |
    STA (2 * 2).w,X                                                             ; $018A48 | |
    LDA <r_menu_format_four_digit_number_result + 4                             ; $018A4B | |
    STA (3 * 2).w,X                                                             ; $018A4D | |
    REP #FLAG_P_ACCUMULATOR                                                     ; $018A50 |/
    PLX                                                                         ; $018A52 | Restore the value of the X register.
    RTS                                                                         ; $018A53

; _menu_select_character ($01:8A54)
;
; Part of the main menu, allows the player to select a character from the list
; on the left side of the screen. If a character is selected, the slot number
; will be returned in $E8. If no character is selected, $FF will be returned
; instead. Finally, if the change option is enabled (by setting $1B27 to a
; non-zero value) and the player presses left or right, $7F will be returned.
_menu_select_character:
-   LDA <r_menu_current_selected_character_position                             ; $018A54 |\
    JSR _menu_transfer_a_to_x                                                   ; $018A56 | | Get the character ID for the currently selected position, and if
    JSR _menu_get_character_id_from_position                                    ; $018A59 | | not empty, branch forward to the next section.
    BNE @loop_start                                                             ; $018A5C |/
    LDA <r_menu_current_selected_character_position                             ; $018A5E |\
    INC A                                                                       ; $018A60 | | Otherwise, loop through the character positions, wrapping around
    CMP #5.b                                                                    ; $018A61 | | if necessary, until a non-empty position is found.
    BNE +                                                                       ; $018A63 | |
    LDA #0.b                                                                    ; $018A65 | |
+   STA <r_menu_current_selected_character_position                             ; $018A67 | |
    BRA -                                                                       ; $018A69 |/
@loop_start:
    LDA <r_menu_current_selected_character_position                             ; $018A6B |\
    ASL A                                                                       ; $018A6D | | Set the cursor Y coordinate to 16 plus the selected position times
    ASL A                                                                       ; $018A6E | | 40.
    ASL A                                                                       ; $018A6F | |
    STA <r_menu_generic_tmp_count                                               ; $018A70 | |
    ASL A                                                                       ; $018A72 | |
    ASL A                                                                       ; $018A73 | |
    ADC <r_menu_generic_tmp_count                                               ; $018A74 | |
    ADC #16.b                                                                   ; $018A76 | |
    STA <r_menu_draw_cursor_arg_coordinates.y                                   ; $018A78 |/
    LDA #2.b                                                                    ; $018A7A |\ Set the cursor X coordinate to 2.
    STA <r_menu_draw_cursor_arg_coordinates.x                                   ; $018A7C |/
    JSR _menu_draw_cursor_1                                                     ; $018A7E | Draw the cursor.
    JSR _menu_wait_for_vblank_copy_oam_to_ppu                                   ; $018A81 | Wait for vblank and copy the OAM to the PPU.
    JSR _menu_update_joypad_and_play_sound_effect                               ; $018A84 | Update the joypad values and play an appropriate sound effect.
    LDA <r_menu_joypad_repeat.hi                                                ; $018A87 |\
    AND #JOYPAD_H_UP.b                                                          ; $018A89 | | If up on the d-pad is not pressed, branch to the next section.
    BEQ ++                                                                      ; $018A8B |/
-   LDA <r_menu_current_selected_character_position                             ; $018A8D |\
    DEC A                                                                       ; $018A8F | | Decrement the selected character position and if it goes negative,
    BPL +                                                                       ; $018A90 | | change it to four to wrap around.
    LDA #4.b                                                                    ; $018A92 | |
+   STA <r_menu_current_selected_character_position                             ; $018A94 |/
    JSR _menu_transfer_a_to_x                                                   ; $018A96 |\
    LDA bank14.character_position_to_slot_data.l,X                              ; $018A99 | | Get the character field offset for the selected character.
    JSR _menu_get_character_field_offset                                        ; $018A9D |/
    LDA r_menu_enable_empty_slot_selection.w                                    ; $018AA0 |\ Skip ahead if empty slot selection is enabled.
    BNE ++                                                                      ; $018AA3 |/
    LDA character_field.id.w,X                                                  ; $018AA5 |\
    AND #%00011111.b                                                            ; $018AA8 | | Otherwise, loop until a non-empty slot is found.
    BEQ -                                                                       ; $018AAA |/
++  LDA <r_menu_joypad_repeat.hi                                                ; $018AAC |\
    AND #JOYPAD_H_DOWN.b                                                        ; $018AAE | | If down is not pressed on the d-pad, branch ahead.
    BEQ ++                                                                      ; $018AB0 |/
-   LDA <r_menu_current_selected_character_position                             ; $018AB2 |\
    INC A                                                                       ; $018AB4 | | Increment the selected character position, and if it reaches 5,
    CMP #5.b                                                                    ; $018AB5 | | reset it to zero to wrap around.
    BNE +                                                                       ; $018AB7 | |
    TDC                                                                         ; $018AB9 | |
+   STA <r_menu_current_selected_character_position                             ; $018ABA |/
    JSR _menu_transfer_a_to_x                                                   ; $018ABC |\
    LDA bank14.character_position_to_slot_data.l,X                              ; $018ABF | | Ensure that either empty slot selection is enabled or that the
    JSR _menu_get_character_field_offset                                        ; $018AC3 | | newly selected slot is not empty. If neither is true, loop to
    LDA r_menu_enable_empty_slot_selection.w                                    ; $018AC6 | | repeat the down press.
    BNE ++                                                                      ; $018AC9 | |
    LDA character_field.id.w,X                                                  ; $018ACB | |
    AND #%00011111.b                                                            ; $018ACE | |
    BEQ -                                                                       ; $018AD0 |/
++  LDA r_menu_character_selection_change_enabled.w                             ; $018AD2 |\
    BEQ +                                                                       ; $018AD5 | | If the Change option is enabled, and if either left or right is
    LDA <r_menu_joypad_repeat.hi                                                ; $018AD7 | | pressed on the d-pad, set the result slot to the change slot
    AND #JOYPAD_H_LEFT.b | JOYPAD_H_RIGHT                                       ; $018AD9 | | value and return.
    BEQ +                                                                       ; $018ADB | |
    LDA #MENU_TARGET_SLOT_CHANGE.b                                              ; $018ADD | |
    STA <r_menu_current_selected_character_slot                                 ; $018ADF | |
    RTS                                                                         ; $018AE1 |/
+   LDA <r_menu_joypad_repeat.lo                                                ; $018AE2 |\
    AND #JOYPAD_L_A.b                                                           ; $018AE4 | | If the A button is pressed, set the target slot to the selected
    BEQ +                                                                       ; $018AE6 | | slot and return.
    LDA <r_menu_current_selected_character_position                             ; $018AE8 | |
    JSR _menu_transfer_a_to_x                                                   ; $018AEA | |
    LDA bank14.character_position_to_slot_data.l,X                              ; $018AED | |
    STA <r_menu_current_selected_character_slot                                 ; $018AF1 | |
    RTS                                                                         ; $018AF3 |/
+   LDA <r_menu_joypad_repeat.hi                                                ; $018AF4 |\
    AND #JOYPAD_H_B.b                                                           ; $018AF6 | | If the B button is pressed, set the target slot to none and
    BEQ +                                                                       ; $018AF8 | | return.
    LDA #MENU_TARGET_SLOT_NONE.b                                                ; $018AFA | |
    STA <r_menu_current_selected_character_slot                                 ; $018AFC | |
    RTS                                                                         ; $018AFE |/
+   JMP @loop_start                                                             ; $018AFF | Loop back to repeat the loop.

; _menu_draw_status_class ($01:8B02)
;
; Draws either the status icons or class for a single character in the party
; menu. The tilemap offset for this character's data should be in the Y
; register, and the offset to the character's record should be in the X
; register.
_menu_draw_status_class:
    STY <r_menu_party_tmp_tilemap_offset                                        ; $018B02 |\ Save the two parameters to temporary variables.
    STX <r_menu_party_tmp_character_offset                                      ; $018B04 |/
    LDA character_field.status_1.w,X                                            ; $018B06 |\
    BIT #STATUS_1_SWOON.b                                                       ; $018B09 | | If the character is swooned, branch to code for that.
    BNE @swoon                                                                  ; $018B0B |/
    ASL A                                                                       ; $018B0D |\
    STA <r_menu_generic_tmp_count                                               ; $018B0E | | Create a temporary variable that combines the seven low bits of
    LDA character_field.status_2.w,X                                            ; $018B10 | | the first status byte (as the top seven bits) and the float bit
    ROL A                                                                       ; $018B13 | | of the second status byte (as the lowest bit).
    ROL A                                                                       ; $018B14 | |
    ROL A                                                                       ; $018B15 | |
    AND #STATUS_2_FLOAT.b >> 6                                                  ; $018B16 | |
    ORA <r_menu_generic_tmp_count                                               ; $018B18 |/
    BEQ @normal                                                                 ; $018B1A | Branch to the normal code if no bits are set.
    PHA                                                                         ; $018B1C |\
    JSR _menu_party_get_status_class_tilemap_offset                             ; $018B1D | | Adjust the Y register to point to where the status icons should be
    JSR _increment_y_by_64                                                      ; $018B20 | | drawn. The subtraction accounts for the fact that the status icons
    PLA                                                                         ; $018B23 | | are one tile earlier than the actual textual class.
    DEY                                                                         ; $018B24 | |
    DEY                                                                         ; $018B25 |/
    BRA @status                                                                 ; $018B26 | Branch to the status icon drawing code.
@swoon:
    JSR _menu_party_get_status_class_tilemap_offset                             ; $018B28 |\
    TYX                                                                         ; $018B2B | | Draw the "Swoon" text and return.
    LDY #menu_text_swoon_data.w                                                 ; $018B2C | |
    JMP _menu_draw_text_direct                                                  ; $018B2F |/
@normal:
    LDA r_menu_status_active.w                                                  ; $018B32 |\
    BEQ +                                                                       ; $018B35 | | Return if the status menu is active, as the class isn't drawn.
    RTS                                                                         ; $018B37 |/
+   LDY <r_menu_party_tmp_character_offset                                      ; $018B38 |\
    LDA character_field.sprite_class.w,Y                                        ; $018B3A | | Update the Y register to point to a location seven characters
    PHA                                                                         ; $018B3D | | beyond the character's name.
    JSR _menu_party_get_status_class_tilemap_offset                             ; $018B3E | |
    PLA                                                                         ; $018B41 |/
    JMP _menu_draw_character_class                                              ; $018B42 | Draw the character class text and return.
@status:
    STA <r_menu_generic_tmp_word.lo                                             ; $018B45 | Store the status bits to a temporary variable.
    LDA #TILE_MENU_STATUS_BASE.b                                                ; $018B47 |\ Set the current tile number to the base status icon tile.
    STA <r_menu_generic_tmp_word.hi                                             ; $018B49 |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $018B4B |\
    TYA                                                                         ; $018B4D | | Add the base tilemap address to the offset.
    CLC                                                                         ; $018B4E | |
    ADC <r_menu_current_tilemap_base_address                                    ; $018B4F | |
    TAY                                                                         ; $018B51 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $018B52 |/
    LDX #8.w                                                                    ; $018B54 | Initialize the X register to eight.
-   LDA <r_menu_generic_tmp_word.lo                                             ; $018B57 |\
    BIT #%10000000.b                                                            ; $018B59 | | If the current status bit is set, set the tile number and the
    BEQ +                                                                       ; $018B5B | | flags for the icon that set the correct palette.
    LDA <r_menu_generic_tmp_word.hi                                             ; $018B5D | |
    STA 0.w,Y                                                                   ; $018B5F | |
    LDA menu_party_status_palette_data.l - 1,X                                  ; $018B62 | |
    ORA <r_menu_current_tilemap_base_tile_flags                                 ; $018B66 | |
    STA 1.w,Y                                                                   ; $018B68 | |
    BRA ++                                                                      ; $018B6B |/
+   LDA #TILE_MENU_WINDOW_BLANK.b                                               ; $018B6D |\ Otherwise, draw a blank tile.
    STA 0.w,Y                                                                   ; $018B6F |/
++  PHY                                                                         ; $018B72 |\
    REP #FLAG_P_ACCUMULATOR                                                     ; $018B73 | | Draw a blank tile to the tile above the status icon (used for
    TYA                                                                         ; $018B75 | | diacritics).
    SEC                                                                         ; $018B76 | |
    SBC #(32 * 2).w                                                             ; $018B77 | |
    TAY                                                                         ; $018B7A | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $018B7B | |
    LDA #TILE_MENU_WINDOW_BLANK.b                                               ; $018B7D | |
    STA 0.w,Y                                                                   ; $018B7F | |
    PLY                                                                         ; $018B82 |/
    INY                                                                         ; $018B83 |\ Increment the Y register twice to move to the next tile.
    INY                                                                         ; $018B84 |/
    INC <r_menu_generic_tmp_word.hi                                             ; $018B85 | Increment the current icon tile number.
    ASL <r_menu_generic_tmp_word.lo                                             ; $018B87 | Shift the bits to move to the next status bit.
    DEX                                                                         ; $018B89 |\ Decrement the X register and loop until it reaches zero.
    BNE -                                                                       ; $018B8A |/
    RTS                                                                         ; $018B8C

; menu_party_status_palette_data ($01:8B8D)
;
; For each of the eight status icons on the menu screen, provides the palette
; for that icon. The ordering is a little strange. The table is indexed by the
; number of icons remaining (including the current one), which results in them
; being in this table in the reverse order. In addition, the code actually
; points to the byte before this table, and indexes with 1 through 8.
menu_party_status_palette_data:
    .db 0 << 2                                                                  ; $018B8D | $01: Float
    .db 2 << 2                                                                  ; $018B8E | $02: Poison
    .db 3 << 2                                                                  ; $018B8F | $03: Darkness
    .db 3 << 2                                                                  ; $018B90 | $04: Mute
    .db 3 << 2                                                                  ; $018B91 | $05: Pig
    .db 3 << 2                                                                  ; $018B92 | $06: Small
    .db 2 << 2                                                                  ; $018B93 | $07: Toad
    .db 0 << 2                                                                  ; $018B94 | $08: Stone

; _menu_main_draw_game_time ($01:8B95)
;
; Draw the game time to the tilemap. This suffers from a bug that causes it to
; render game times of 999 hours and above incorrectly.
_menu_main_draw_game_time:
    LDA r_game_time.seconds_lo.w                                                ; $018B95 |\
    STA <r_menu_divide_by_60_arg_value.lo                                       ; $018B98 | | Divide the game time in seconds by 3600, which leaves the hours as
    LDX r_game_time.seconds_md.w                                                ; $018B9A | | the quotient and the minutes as the remainder.
    STX <r_menu_divide_by_60_arg_value.md                                       ; $018B9D | |
    JSR _menu_divide_by_60                                                      ; $018B9F | |
    JSR _menu_divide_by_60                                                      ; $018BA2 |/
    LDX <r_menu_divide_by_60_arg_value.lo                                       ; $018BA5 |\
    CPX #999.w                                                                  ; $018BA7 | | If the number of hours is 999 or greater, attempt to shift the
    BCC +                                                                       ; $018BAA | | time to display all four digits.
    LDY #r_menu_tilemap_bg3.w + (2 * 1)                                         ; $018BAC | |
    JSR ++                                                                      ; $018BAF | | BUG: This doesn't work right. First, it shouldn't trigger for 999.
    LDA <r_menu_format_four_digit_number_result + 1                             ; $018BB2 | |      Second, instead of copying in the first of the four digits,
    STA (22 * 2) + (21 * 32 * 2).w,Y                                            ; $018BB4 | |      it ends up duplicating the second.
    RTS                                                                         ; $018BB7 |/
+   LDY <r_menu_current_tilemap_base_address                                    ; $018BB8 |\
++  LDA <r_menu_divide_by_60_remainder                                          ; $018BBA | | Format the remainder (minutes) as a two digit number.
    JSR _menu_format_two_digit_number                                           ; $018BBC |/
    CMP #TILE_MENU_WINDOW_BLANK.b                                               ; $018BBF |\
    BNE +                                                                       ; $018BC1 | | If the first digit is blank, replace it with a zero.
    LDA #TILE_MENU_NUMBER_BASE.b                                                ; $018BC3 |/
+   STA (27 * 2) + (21 * 32 * 2).w,Y                                            ; $018BC5 |\
    XBA                                                                         ; $018BC8 | | Draw the two digits to 27, 21.
    STA (28 * 2) + (21 * 32 * 2).w,Y                                            ; $018BC9 |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $018BCC |\
    LDA <r_menu_divide_by_60_arg_value                                          ; $018BCE | | Format the hours value as a four digit number.
    SEP #FLAG_P_ACCUMULATOR                                                     ; $018BD0 | |
    JSR _menu_format_four_digit_number                                          ; $018BD2 |/
    LDA <r_menu_format_four_digit_number_result + 1                             ; $018BD5 |\
    STA (23 * 2) + (21 * 32 * 2).w,Y                                            ; $018BD7 | | Copy the last three digits to the tilemap at 23, 21.
    LDA <r_menu_format_four_digit_number_result + 3                             ; $018BDA | |
    STA (24 * 2) + (21 * 32 * 2).w,Y                                            ; $018BDC | |
    LDA <r_menu_format_four_digit_number_result + 4                             ; $018BDF | |
    STA (25 * 2) + (21 * 32 * 2).w,Y                                            ; $018BE1 |/
    LDA #TEXT_COLON.b                                                           ; $018BE4 |\ Draw a coln to 26,21.
    STA (26 * 2) + (21 * 32 * 2).w,Y                                            ; $018BE6 |/
    RTS                                                                         ; $018BE9

; _menu_divide_by_60 ($01:8BEA)
;
; Given a 24-bit value in $73, divides the value by 60 and returns the 24-bit
; result in $73. The remainder is returned in $1D.
_menu_divide_by_60:
    STZ <r_menu_divide_by_60_remainder                                          ; $018BEA | Initialize the remainder to 24.
    LDX #24.w                                                                   ; $018BEC | Initialize the loop variable to 24.
    ROL <r_menu_divide_by_60_arg_value.lo                                       ; $018BEF |\
    ROL <r_menu_divide_by_60_arg_value.md                                       ; $018BF1 | | Rotate the first bit out.
    ROL <r_menu_divide_by_60_arg_value.hi                                       ; $018BF3 |/
-   ROL <r_menu_divide_by_60_remainder                                          ; $018BF5 | Rotate the current bit into the remainder.
    LDA <r_menu_divide_by_60_remainder                                          ; $018BF7 |\
    CMP #60.b                                                                   ; $018BF9 | | If the current remainder is greater than 60, subtract 60. This
    BCC +                                                                       ; $018BFB | | will also result in the carry bit being set from the CMP
    SBC #60.b                                                                   ; $018BFD | | operation.
    STA <r_menu_divide_by_60_remainder                                          ; $018BFF |/
+   ROL <r_menu_divide_by_60_arg_value.lo                                       ; $018C01 |\
    ROL <r_menu_divide_by_60_arg_value.md                                       ; $018C03 | | Rotate the carry bit, if any, into the result value.
    ROL <r_menu_divide_by_60_arg_value.hi                                       ; $018C05 |/
    DEX                                                                         ; $018C07 |\ Repeat until all 24 bits have been rotated.
    BNE -                                                                       ; $018C08 |/
    RTS                                                                         ; $018C0A

; _menu_initialize_and_draw_main ($01:8C0B)
;
; Initializes the tilemaps and draws the main menu.
_menu_initialize_and_draw_main:
    JSR _menu_initialize_tilemaps                                               ; $018C0B | Initialize the tilemaps.
    JSR _menu_initialize_oam                                                    ; $018C0E | Initialize the OAM.
    JSR _menu_copy_oam_to_ppu                                                   ; $018C11 | Copy the OAM to the PPU.
    JMP _menu_main_draw                                                         ; $018C14 | Draw the main menu.

; _menu_party_get_status_class_tilemap_offset ($01:8C17)
;
; Assuming the current base tilemap offset for the character being examined is
; in $4B, sets the Y register to that value plus 14, to shift the cursor to the
; right by seven tiles, to skip over their name.
_menu_party_get_status_class_tilemap_offset:
    REP #FLAG_P_ACCUMULATOR                                                     ; $018C17 |\
    LDA <r_menu_party_tmp_tilemap_offset                                        ; $018C19 | | Add 7 tiles to the tilemap offset and transfer it to the Y
    CLC                                                                         ; $018C1B | | register.
    ADC #(7 * 2).w                                                              ; $018C1C | |
    TAY                                                                         ; $018C1F | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $018C20 |/
    RTS                                                                         ; $018C22

; _menu_party_set_single_tile_flags ($01:8C23)
;
; Given the tilemap base address in $29, the offset to a character record in the
; Y register and the offset within the tilemap in the Y register, initializes a
; single character's tile flags in the tilemap. (Used for the party menu that
; displays stats about the entire party.) It initializes 5 rows of tiles,
; starting from the coordinate passed.
_menu_party_set_single_tile_flags:
    PHA                                                                         ; $018C23 |\
    PHX                                                                         ; $018C24 | | Preserve the values of the accumulator and X and Y registers.
    PHY                                                                         ; $018C25 |/
    LDA character_field.status_1.w,Y                                            ; $018C26 |\
    AND #STATUS_1_SWOON.b                                                       ; $018C29 | | Set up tile flags to set the palette to zero if the character is
    CLC                                                                         ; $018C2B | | alive and 1 if they are swooned. This is done by masking out the
    ROL A                                                                       ; $018C2C | | swooned it, and then rotating left until it is in the right
    ROL A                                                                       ; $018C2D | | position to set the palette number.
    ROL A                                                                       ; $018C2E | |
    ROL A                                                                       ; $018C2F | |
    STA <r_menu_generic_tmp_word.lo                                             ; $018C30 |/
    LDA #7.b                                                                    ; $018C32 |\
    JSR _menu_set_row_tile_flags                                                ; $018C34 | | Set the palette flags on seven tiles in the first two rows.
    JSR _menu_set_row_tile_flags                                                ; $018C37 |/
    LDA #14.b                                                                   ; $018C3A |\
    JSR _menu_set_row_tile_flags                                                ; $018C3C | | Set the palette flags on fourteen tiles in the last three rows.
    JSR _menu_set_row_tile_flags                                                ; $018C3F | |
    JSR _menu_set_row_tile_flags                                                ; $018C42 |/
    PLY                                                                         ; $018C45 |\
    PLX                                                                         ; $018C46 | | Restore the saved registers.
    PLA                                                                         ; $018C47 |/
    RTS                                                                         ; $018C48

; _menu_set_row_tile_flags ($01:8C49)
;
; Given the current tilemap base address in $29, the number of tiles in the
; accumulator, and the offset within that tilemap in the X register, writes the
; tilemap flags for that number of tiles by setting it to the value passed in
; $45. As a convenience to the caller, automatically increments X by 64 at the
; end to allow the function to be repeatedly called to update subsequent lines.
_menu_set_row_tile_flags:
    PHA                                                                         ; $018C49 |\ Preserve the initial value of the accumulator and save it as the
    STA <r_menu_party_tmp_count                                                 ; $018C4A |/ count.
    PHX                                                                         ; $018C4C | Preserve the value of the X register.
    REP #FLAG_P_ACCUMULATOR                                                     ; $018C4D |\
    TXA                                                                         ; $018C4F | | Add the current value of the X register to the base tilemap
    CLC                                                                         ; $018C50 | | address.
    ADC <r_menu_current_tilemap_base_address                                    ; $018C51 | |
    TAX                                                                         ; $018C53 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $018C54 |/
    LDA <r_menu_generic_tmp_word.lo                                             ; $018C56 |\ Set the tile flags for the currently pointed to tile.
-   STA 1.w,X                                                                   ; $018C58 |/
    INX                                                                         ; $018C5B |\
    INX                                                                         ; $018C5C | | Update the variables and loop until the passed number of
    DEC <r_menu_party_tmp_count                                                 ; $018C5D | | characters has been updated.
    BNE -                                                                       ; $018C5F |/
    PLX                                                                         ; $018C61 | Restore the value of the X register.
    JSR _increment_x_by_64                                                      ; $018C62 | Increment X by 64 to move to the next row of tiles.
    PLA                                                                         ; $018C65 | Restore the original value of the accumulator.
    RTS                                                                         ; $018C66

; _menu_reset_state ($01:8C67)
;
; Assuming cursor memory is not enabled, resets the menu state by zeroing out
; memory from $1B00 to $1BEA. This largely resets menu cursor coordinates.
_menu_reset_state:
    PHA                                                                         ; $018C67 | Preserve the value of the accumulator.
    LDA r_config.memory.w                                                       ; $018C68 |\ Skip to the end if cursor memory is enabled.
    BNE +                                                                       ; $018C6B |/
    LDX #$00EB.w                                                                ; $018C6D |\
    LDY <r_menu_zero                                                            ; $018C70 | | Otherwise, reset the memory range from $1B00 to $1BEA to zero.
    TDC                                                                         ; $018C72 | | This range is largely used for menu cursor coordinates.
-   STA r_menu_namingway_character_cursor_coordinates.w,Y                       ; $018C73 | |
    INY                                                                         ; $018C76 | |
    DEX                                                                         ; $018C77 | |
    BNE -                                                                       ; $018C78 |/
    JSR _menu_init_first_non_empty_position                                     ; $018C7A | Initialize some minor things like item and magic cursors.
+   PLA                                                                         ; $018C7D | Restore the accumulator.
    RTS                                                                         ; $018C7E

; _menu_init ($01:8C7F)
;
; Handles generic initialization for the menu system, including initializing
; tilemaps and the PPU, among other things.
_menu_init:
    SEI                                                                         ; $018C7F | Disable interrupts.
    LDA #0.b                                                                    ; $018C80 |\ Set the high byte of the menu generic temporary offset to zero, as
    STA r_menu_generic_tmp_offset.hi.l & $FFFF                                  ; $018C82 |/ that value is used implicitly in several places.
    PHA                                                                         ; $018C86 |\ Set the data bank register to $00.
    PLB                                                                         ; $018C87 |/
    LDA #%10000000.b                                                            ; $018C88 |\ Set the PPU brightness to zero and set forced blanking.
    STA reg_ppu_inidisp.w                                                       ; $018C8A |/
    LDA #%00000001.b                                                            ; $018C8D |\ Disable NMI and IRQ, but enable automatic joypad reading.
    STA reg_cpu_nmitimen.w                                                      ; $018C8F |/
    LDX #$2100.w                                                                ; $018C92 |\
    PHX                                                                         ; $018C95 | | Set the direct register to $2100 for easy register access.
    PLD                                                                         ; $018C96 |/
    JSL bank1E.menu_init_ppu                                                    ; $018C97 | Initialize the PPU.
    JSR _menu_init_bg_scroll                                                    ; $018C9B | Initialize the background scroll values to zero.
    LDX #$4000.w                                                                ; $018C9E |\ Set the VRAM write address to $4000.
    STX <reg_ppu_vmadd                                                          ; $018CA1 |/
    PHB                                                                         ; $018CA3 |\
    LDA #:bank0C.battle_sprite_icon_data.b                                      ; $018CA4 | | Preserve the current value of the data bank register, and set it
    PHA                                                                         ; $018CA6 | | to $0C, as a parameter for the next function.
    PLB                                                                         ; $018CA7 |/
    LDA #32.b                                                                   ; $018CA8 |\
    LDY #bank0C.battle_sprite_icon_data.w                                       ; $018CAA | | Load the first 32 tiles of the battle sprite icons to VRAM.
    JSR _menu_copy_3bpp_to_vram                                                 ; $018CAD |/
    PLB                                                                         ; $018CB0 | Restore the data bank register to its original value.
    LDX #$0100.w                                                                ; $018CB1 |\
    PHX                                                                         ; $018CB4 | | Set the direct register to $0100.
    PLD                                                                         ; $018CB5 |/
    LDA #$7E.b                                                                  ; $018CB6 |\
    PHA                                                                         ; $018CB8 | | Set the data bank register to $7E.
    PLB                                                                         ; $018CB9 |/
    STZ <r_menu_zero.lo                                                         ; $018CBA |\ Initialize the zero variable to zero.
    STZ <r_menu_zero.hi                                                         ; $018CBC |/
    LDX #$1000.w                                                                ; $018CBE |\ Set the tilemap copy argument to transfer 4096 bytes.
    STX <r_menu_copy_tilemap_to_vram_arg_bytes                                  ; $018CC1 |/
    JSR _menu_set_bg_scroll_proxy                                               ; $018CC3 | Set the current BG scroll values to the configured values.
    LDX #$2000.w                                                                ; $018CC6 |\
    STX <r_menu_copy_to_vram_arg_target_vram_address                            ; $018CC9 | | Copy the dialog tiles from ROM to VRAM at $2000.
    LDX #bank0A.dialog_tile_data.w                                              ; $018CCB | |
    STX <r_menu_copy_to_vram_arg_source_address                                 ; $018CCE | |
    LDA #:bank0A.dialog_tile_data.b                                             ; $018CD0 | |
    STA <r_menu_copy_to_vram_arg_source_bank                                    ; $018CD2 | |
    LDX #bank0A._sizeof_dialog_tile_data.w                                      ; $018CD4 | |
    STX <r_menu_copy_to_vram_arg_bytes                                          ; $018CD7 | |
    JSR _menu_copy_to_vram                                                      ; $018CD9 |/
    JSR _menu_initialize_oam                                                    ; $018CDC | Initialize the OAM.
    JSR _menu_initialize_tilemaps                                               ; $018CDF | Initialize the menu tilemaps.
    JSR _menu_copy_tilemaps_to_vram                                             ; $018CE2 | Copy the tilemaps to VRAM.
    JSL bank1E.menu_load_dialog_palette                                         ; $018CE5 | Load the dialog palette.
    REP #FLAG_P_ACCUMULATOR                                                     ; $018CE9 | Switch to 16-bit accumulator mode.
    JSR _menu_set_palette_window_color                                          ; $018CEB | Set the custom window color on the dialog palettes.
    LDX #bank0D.menu_cursor_palette_data.w                                      ; $018CEE |\
    LDY #r_menu_cgram_data.9.w                                                  ; $018CF1 | | Copy the cursor palette data to the ninth palette..
    LDA #_sizeof_palette.w / 2 - 1                                              ; $018CF4 | |
    MVN :bank0D.menu_cursor_palette_data,:r_menu_cgram_data.9                   ; $018CF7 |/
    SEP #FLAG_P_ACCUMULATOR                                                     ; $018CFA | Switch back to 8-bit accumulator mode.
    JSR _menu_copy_palette_to_cgram                                             ; $018CFC | Copy the palettes to CG-RAM.
    JSR _menu_copy_oam_to_ppu                                                   ; $018CFF | Copy the current OAM to the PPU.
    JSR _menu_copy_tilemaps_to_vram                                             ; $018D02 | Copy the tilemaps to VRAM.
    STZ <r_unknown_0184                                                         ; $018D05 | TODO
    STZ <r_unknown_0185                                                         ; $018D07 | TODO
    STZ <r_menu_ppu_inidisp                                                     ; $018D09 | Set the PPU to no forced blanking, but brightness zero.
    LDA #%00110000.b                                                            ; $018D0B |\ Set the cursor sprite flags for priority 3, palette zero, and the
    STA <r_menu_cursor_sprite_flags                                             ; $018D0D |/ low name table.
    LDA #$4C.b                                                                  ; $018D0F |\
    STA r_menu_window_transition_custom_function_2.opcode.w                     ; $018D11 | | Configure the two window transition custom functions to jump to
    STA r_menu_window_transition_custom_function_1.opcode.w                     ; $018D14 | | an RTS instruction as a noop.
    LDX #@done.w                                                                ; $018D17 | |
    STX r_menu_window_transition_custom_function_2.address.w                    ; $018D1A | |
    STX r_menu_window_transition_custom_function_1.address.w                    ; $018D1D |/
    JSR _initialize_joypad_maps                                                 ; $018D20 | Initialize the joypad maps.
    LDA #99.b                                                                   ; $018D23 |\ Set the maximum item count for the inventory when buying from a
    STA <r_menu_shop_maximum_item_count                                         ; $018D25 |/ shop to 99.
    LDA #%10000000.b                                                            ; $018D27 |\ Set forced blanking and set the PPU brightness to zero.
    STA <r_menu_ppu_inidisp                                                     ; $018D29 |/
    STZ r_menu_items_enabled.w                                                  ; $018D2B | Initially disable items in an inventory menu.
@done:
    RTS                                                                         ; $018D2E

; _menu_initialize_tilemaps ($01:8D2F)
;
; Initializes the four menu tilemap mirrors in RAM. All four tilemaps are
; initialized to nothing but tile zero. BG1 and BG3 are set to priority 0 and
; BG2 and BG4 are set to priority 1. Additionally, there are entry points to
; initialize only one of the tilemaps as needed.
_menu_initialize_tilemaps:
    JSR _menu_initialize_tilemap_bg3                                            ; $018D2F | Recursively call this routine for BG3.
    JSR _menu_initialize_tilemap_bg1                                            ; $018D32 | Recursively call this routine for BG1.
    JSR _menu_initialize_tilemap_bg4                                            ; $018D35 | Recursively call this routine for BG4.
_menu_initialize_tilemap_bg2:
    LDX #r_menu_tilemap_bg2.w                                                   ; $018D38 |\ Finish by loading the BG2 pointer and branching to priority 1.
    BRA _menu_initialize_tilemaps_priority_1                                    ; $018D3B |/
_menu_initialize_tilemap_bg1:
    LDX #r_menu_tilemap_bg1.w                                                   ; $018D3D |\ Load the BG1 pointer and branch to priority 0.
    BRA _menu_initialize_tilemaps_priority_0                                    ; $018D40 |/
_menu_initialize_tilemap_bg4:
    LDX #r_menu_tilemap_bg4.w                                                   ; $018D42 |\ Load the BG4 pointer and branch to priority 1.
    BRA _menu_initialize_tilemaps_priority_1                                    ; $018D45 |/
_menu_initialize_tilemap_bg3:
    LDX #r_menu_tilemap_bg3.w                                                   ; $018D47 |\ Load the BG3 pointer and branch to priority 0.
    BRA _menu_initialize_tilemaps_priority_0                                    ; $018D4A |/
_menu_initialize_tilemaps_priority_1:
    STX <r_menu_initialize_tilemaps_tmp_ptr                                     ; $018D4C | Save the loaded pointer to the pointer variable.
    REP #FLAG_P_ACCUMULATOR                                                     ; $018D4E | Switch to 16-bit accumulator mode.
    LDA #$2000.w                                                                ; $018D50 | Load the value to write to the tilemap to set priority 2.
--  LDY <r_menu_zero                                                            ; $018D53 | Initialize the Y register to zero.
    LDX #_sizeof_r_menu_tilemap_bg1.w / 2                                       ; $018D55 | Initialize the X register to the number of tiles in the tilemap.
-   STA (<r_menu_initialize_tilemaps_tmp_ptr),Y                                 ; $018D58 | Save the loaded value to the tilemap.
    INY                                                                         ; $018D5A |\ Increment the Y register by two to move to the next tile.
    INY                                                                         ; $018D5B |/
    DEX                                                                         ; $018D5C |\ Decrement the count and loop until all tiles have been written.
    BNE -                                                                       ; $018D5D |/
    SEP #FLAG_P_ACCUMULATOR.b                                                   ; $018D5F | Switch back to 8-bit accumulator mode.
    STZ <r_menu_generic_tmp_offset.hi                                           ; $018D61 | Zero out the high byte of the generic menu offset variable.
    RTS                                                                         ; $018D63
_menu_initialize_tilemaps_priority_0:
    STX <r_menu_initialize_tilemaps_tmp_ptr                                     ; $018D64 | Save the loaded value as the pointer.
    REP #FLAG_P_ACCUMULATOR                                                     ; $018D66 | Switch to 16-bit accumulator mode.
    LDA <r_menu_zero                                                            ; $018D68 | Load the zero value into the accumulator.
    BRA --                                                                      ; $018D6A

; _menu_initialize_oam ($01:8D6C)
;
; Does the base initialization of the OAM for the menu system. All sprites are
; reset to coordinates of 255, 240. The first eight sprites are set to be 16x16
; and the remainder are set to be 8x8.
_menu_initialize_oam:
    REP #FLAG_P_ACCUMULATOR                                                     ; $018D6C | Switch to 16-bit accumulator mode.
    LDY #_sizeof_r_oam.w / _sizeof_oam_sprite                                   ; $018D6E | Initialize the Y register (remaining entries) to 128.
    LDX #0.w                                                                    ; $018D71 | Initialize the X register (OAM offset) to zero.
-   LDA #255.w + (240 << 8)                                                     ; $018D74 |\ Set the X and Y coordinates of this OAM entry to 255 and 240,
    STA r_oam.1.x.l & $FFFF,X                                                   ; $018D77 |/ respectively.
    LDA #$3000.w                                                                ; $018D7B |\ Set the tile number to zero and the flags to priority 3, with no
    STA r_oam.1.tile.l & $FFFF,X                                                ; $018D7E |/ other flags set.
    INX                                                                         ; $018D82 |\
    INX                                                                         ; $018D83 | | Loop until the entire OAM has been initialized.
    INX                                                                         ; $018D84 | |
    INX                                                                         ; $018D85 | |
    DEY                                                                         ; $018D86 | |
    BNE -                                                                       ; $018D87 |/
    LDY #_sizeof_r_oam_hi.w / 2                                                 ; $018D89 |\
    LDA #0.w                                                                    ; $018D8C | | Loop through the high OAM table (by not resetting the X register),
-   STA r_oam.l & $FFFF,X                                                       ; $018D8F | | setting all of the values to zero, which sets the high bit of the
    INX                                                                         ; $018D93 | | X coordinate to zero and sets the size to 8x8.
    INX                                                                         ; $018D94 | |
    DEY                                                                         ; $018D95 | |
    BNE -                                                                       ; $018D96 |/
    LDA #%1010101010101010.w                                                    ; $018D98 |\ Set the size of the first eight sprites to 16x16.
    STA r_oam_hi.l & $FFFF.l                                                    ; $018D9B |/
    SEP #FLAG_P_ACCUMULATOR                                                     ; $018D9F | Return to 8-bit accumulator mode.
    RTS                                                                         ; $018DA1

; _menu_load_character_sprites ($01:8DA2)
;
; Loops through the five character slots, loading the sprite for each.
_menu_load_character_sprites:
    STZ <r_menu_generic_tmp_index                                               ; $018DA2 | Initialize the slot number to zero.
-   LDA <r_menu_generic_tmp_index                                               ; $018DA4 |\ Set the X register to the offset to the record for the current
    JSR _menu_get_character_field_offset                                        ; $018DA6 |/ slot.
    ASL A                                                                       ; $018DA9 |\
    STA <r_menu_generic_tmp_offset.lo                                           ; $018DAA | | Set the Y register to the slot number times two.
    LDY <r_menu_generic_tmp_offset                                              ; $018DAC |/
    LDA character_field.id.w,X                                                  ; $018DAE |\
    AND #%00111111.b                                                            ; $018DB1 | | Transfer the character ID to the load character sprite argument
    STA <r_menu_load_character_sprite_arg_id                                    ; $018DB3 | | and to another location.
    STA r_menu_character_id_slot.1.id.w,Y                                       ; $018DB5 |/
    LDA <r_menu_generic_tmp_index                                               ; $018DB8 |\
    STA <r_menu_load_character_sprite_arg_slot                                  ; $018DBA | | Repeat with the slot number.
    STA r_menu_character_id_slot.1.slot.w,Y                                     ; $018DBC |/
    LDA character_field.sprite_class.w,X                                        ; $018DBF |\ Set the sprite index argument.
    STA <r_menu_load_character_sprite_arg_sprite_class                          ; $018DC2 |/
    JSR _menu_load_character_sprite                                             ; $018DC4 | Load the character sprite and palette for this slot.
    INC <r_menu_generic_tmp_index                                               ; $018DC7 |\
    LDA <r_menu_generic_tmp_index                                               ; $018DC9 | | Increment the slot and loop until all five characters have been
    CMP #5.b                                                                    ; $018DCB | | loaded.
    BNE -                                                                       ; $018DCD |/
    RTS                                                                         ; $018DCF

; _menu_load_character_sprite ($01:8DD0)
;
; Given an 8-bit character ID in $5A, an 8-bit slot index in $5B and an 8-bit
; sprite index in $5C, loads the character sprite data to VRAM and additionally
; loads the palette to the array at $FE28.
_menu_load_character_sprite:
    LDA <r_menu_load_character_sprite_arg_id                                    ; $018DD0 |\
    BNE +                                                                       ; $018DD2 | | Skip this routine if the passed character ID was zero.
    RTS                                                                         ; $018DD4 |/
+   LDA #0.b                                                                    ; $018DD5 |\ Zero out the high byte of the accumulator.
    XBA                                                                         ; $018DD7 |/
    LDA <r_menu_load_character_sprite_arg_sprite_class                          ; $018DD8 |\
    ASL A                                                                       ; $018DDA | | Set the source address to load from by multiplying the sprite
    ASL A                                                                       ; $018DDB | | index by 2048, and then adding the base address for the sprite
    ASL A                                                                       ; $018DDC | | data in ROM.
    XBA                                                                         ; $018DDD | |
    REP #FLAG_P_ACCUMULATOR                                                     ; $018DDE | |
    CLC                                                                         ; $018DE0 | |
    ADC #bank1A.battle_sprite_character_cecil_dknight_data.w                    ; $018DE1 | |
    STA <r_menu_copy_to_vram_arg_source_address                                 ; $018DE4 |/
    LDA #bank1A._sizeof_battle_sprite_character_cecil_dknight_data.w * 3 / 4    ; $018DE6 |\ Set the number of bytes to load to $600, which is 3/4 of the entire
    STA <r_menu_copy_to_vram_arg_bytes                                          ; $018DE9 |/ sprite sheet, as some tiles are not needed.
    SEP #FLAG_P_ACCUMULATOR                                                     ; $018DEB | Switch back to 8-bit accumulator mode.
    LDA #:bank1A.battle_sprite_character_cecil_dknight_data.b                   ; $018DED |\ Set the source bank to copy from.
    STA <r_menu_copy_to_vram_arg_source_bank                                    ; $018DEF |/
    LDA <r_menu_load_character_sprite_arg_slot                                  ; $018DF1 |\
    ASL A                                                                       ; $018DF3 | | Set the VRAM address to the loaded VRAM address for this slot.
    JSR _menu_transfer_a_to_x                                                   ; $018DF4 | |
    REP #FLAG_P_ACCUMULATOR                                                     ; $018DF7 | |
    LDA bank1E.menu_character_sprite_vram_address_data.l,X                      ; $018DF9 | |
    STA <r_menu_copy_to_vram_arg_target_vram_address                            ; $018DFD | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $018DFF |/
    JSR _menu_wait_for_vblank                                                   ; $018E01 | Wait for the next vblank.
    JSR _menu_copy_to_vram                                                      ; $018E04 | Copy the character sprite data to VRAM.
    TDC                                                                         ; $018E07 |\ Set the high byte of the accumulator to zero.
    XBA                                                                         ; $018E08 |/
    LDA <r_menu_load_character_sprite_arg_sprite_class                          ; $018E09 |\
    AND #%00001111.b                                                            ; $018E0B | | Set the X register to the sprite index times 32.
    REP #FLAG_P_ACCUMULATOR                                                     ; $018E0D | |
    ASL A                                                                       ; $018E0F | |
    ASL A                                                                       ; $018E10 | |
    ASL A                                                                       ; $018E11 | |
    ASL A                                                                       ; $018E12 | |
    ASL A                                                                       ; $018E13 | |
    TAX                                                                         ; $018E14 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $018E15 |/
    LDA <r_menu_load_character_sprite_arg_slot                                  ; $018E17 |\
    ASL A                                                                       ; $018E19 | | Set the Y register to the slot index times 32.
    ASL A                                                                       ; $018E1A | |
    ASL A                                                                       ; $018E1B | |
    ASL A                                                                       ; $018E1C | |
    ASL A                                                                       ; $018E1D | |
    STA <r_menu_generic_tmp_offset.lo                                           ; $018E1E | |
    LDY <r_menu_generic_tmp_offset                                              ; $018E20 |/
    LDA #_sizeof_palette.b                                                      ; $018E22 |\
    STA <r_menu_generic_tmp_count                                               ; $018E24 | | Copy the palette for this character to RAM.
-   LDA bank1C.battle_character_palette_data.l,X                                ; $018E26 | |
    STA r_menu_character_sprite_palettes.w,Y                                    ; $018E2A | |
    INX                                                                         ; $018E2D | |
    INY                                                                         ; $018E2E | |
    DEC <r_menu_generic_tmp_count                                               ; $018E2F | |
    BNE -                                                                       ; $018E31 |/
    RTS                                                                         ; $018E33

; _menu_get_diacritic_tile ($01:8E34)
;
; Given an 8-bit text value in the accumulator, determines if it is a character
; that uses a diacritic. If so, returns the new base tile number in the high
; byte of the accumulator and the diacritic tile number in the low byte.
; Otherwise, returns the original tile number in the high byte of the
; accumulator and a blank tile in the low byte.
;
; NOTE: The American release does not actually use any of the diacritic
;       features, as they were used in the Japanese version to add the voiced
;       and semi-voiced marks to various kana.
_menu_get_diacritic_tile:
    PHX                                                                         ; $018E34 | Preserve the value in the X register.
    CMP #TILE_MENU_NON_DIACRITIC_BASE.b                                         ; $018E35 |\ If the passed value is $42 or greater, branch to the end.
    BCS +                                                                       ; $018E37 |/
    SEC                                                                         ; $018E39 |\
    SBC #$0F.b                                                                  ; $018E3A | | Otherwise, set the X register to the value minus $0F, times two.
    ASL A                                                                       ; $018E3C | |
    XBA                                                                         ; $018E3D | |
    LDA #$00.b                                                                  ; $018E3E | |
    XBA                                                                         ; $018E40 | |
    TAX                                                                         ; $018E41 |/
    LDA bank1E.diacritic_tile_data.l + 1,X                                      ; $018E42 |\
    XBA                                                                         ; $018E46 | | Read the values for the two tiles from ROM, ensuring that the main
    LDA bank1E.diacritic_tile_data.l + 0,X                                      ; $018E47 | | tile is in the high byte and the diacritic in the low byte.
    XBA                                                                         ; $018E4B |/
    PLX                                                                         ; $018E4C |\ Restore the value of the X register and return.
    RTS                                                                         ; $018E4D |/
+   XBA                                                                         ; $018E4E |\
    LDA #TILE_MENU_WINDOW_BLANK.b                                               ; $018E4F | | If no diacritic, set the diacritic tile to $FF.
    PLX                                                                         ; $018E51 |/
    RTS                                                                         ; $018E52

UNUSED_CODE_018E53:
    LDX #$0004.w                                                                ; $018E53
    REP #FLAG_P_ACCUMULATOR                                                     ; $018E56
-   LDA #$0100.w                                                                ; $018E58
    STA 0.w,Y                                                                   ; $018E5B
    STA 2.w,Y                                                                   ; $018E5E
    STA 4.w,Y                                                                   ; $018E61
    STA 6.w,Y                                                                   ; $018E64
    JSR _increment_y_by_64                                                      ; $018E67
    DEX                                                                         ; $018E6A
    BNE -                                                                       ; $018E6B
    SEP #FLAG_P_ACCUMULATOR                                                     ; $018E6D
    RTS                                                                         ; $018E6F

; _menu_draw_portrait ($01:8E70)
;
; Given a set of coordinates in the Y register and the character slot number in
; the accumulator, draws that character's portrait by writing the appropriate
; data into the OAM.
_menu_draw_portrait:
    PHA                                                                         ; $018E70 |\ Preserve the values of the accumulator and Y register.
    PHY                                                                         ; $018E71 |/
    STA <r_menu_draw_portrait_tmp_slot                                          ; $018E72 | Save the slot to a temporary variable.
    STY <r_menu_draw_portrait_tmp_coordinates                                   ; $018E74 | Save the coordinates to a temporary variable.
    JSR _menu_get_character_id                                                  ; $018E76 |\ Branch ahead if the slot is not empty.
    BNE +                                                                       ; $018E79 |/
    TDC                                                                         ; $018E7B |\ Zero out the high byte of the accumulator.
    XBA                                                                         ; $018E7C |/
    LDA <r_menu_draw_portrait_tmp_slot                                          ; $018E7D |\
    REP #FLAG_P_ACCUMULATOR                                                     ; $018E7F | | Set the Y register (used to index the OAM) to the slot times 64
    ASL A                                                                       ; $018E81 | | (to give 16 sprites to each slot for a 4x4 portrait).
    ASL A                                                                       ; $018E82 | |
    ASL A                                                                       ; $018E83 | |
    ASL A                                                                       ; $018E84 | |
    ASL A                                                                       ; $018E85 | |
    ASL A                                                                       ; $018E86 | |
    TAY                                                                         ; $018E87 |/
    LDX #32.w                                                                   ; $018E88 | Initialize the X register to 32. (NOTE: Should this be 16?)
-   LDA #(255 + (240 << 8)).w                                                   ; $018E8B |\ Set the coordinates for the sprite to 255, 240.
    STA r_oam.17.x.w,Y                                                          ; $018E8E |/
    LDA #($00 + (%00110000 << 8)).w                                             ; $018E91 |\ Set the tile to $00 and the flags for priority 3.
    STA r_oam.17.tile.w,Y                                                       ; $018E94 |/
    INY                                                                         ; $018E97 |\
    INY                                                                         ; $018E98 | | Update the registers and loop until all 32 entries have been
    INY                                                                         ; $018E99 | | updated.
    INY                                                                         ; $018E9A | | NOTE: It's unknown why they are writing 32 entries instead of 16.
    DEX                                                                         ; $018E9B | |       It doesn't end up mattering, since they're written in order.
    BNE -                                                                       ; $018E9C |/
    SEP #FLAG_P_ACCUMULATOR                                                     ; $018E9E |\
    PLY                                                                         ; $018EA0 | | Restore the Y register and accumulator and return.
    PLA                                                                         ; $018EA1 | |
    RTS                                                                         ; $018EA2 |/
+   LDA #0.b                                                                    ; $018EA3 |\ Zero out the high byte of the accumulator.
    XBA                                                                         ; $018EA5 |/
    LDA <r_menu_draw_portrait_tmp_slot                                          ; $018EA6 |\
    REP #FLAG_P_ACCUMULATOR                                                     ; $018EA8 | | Set the Y register to the slot number times 64 (as each slot gets
    ASL A                                                                       ; $018EAA | | 16 OAM entries).
    ASL A                                                                       ; $018EAB | |
    ASL A                                                                       ; $018EAC | |
    ASL A                                                                       ; $018EAD | |
    ASL A                                                                       ; $018EAE | |
    ASL A                                                                       ; $018EAF | |
    TAY                                                                         ; $018EB0 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $018EB1 |/
    LDA <r_menu_draw_portrait_tmp_slot                                          ; $018EB3 |\
    ASL A                                                                       ; $018EB5 | | Set the initial tile number to the slot times 16 plus $20.
    ASL A                                                                       ; $018EB6 | |
    ASL A                                                                       ; $018EB7 | |
    ASL A                                                                       ; $018EB8 | |
    ADC #$20.b                                                                  ; $018EB9 | |
    STA <r_menu_draw_portrait_tmp_tile                                          ; $018EBB |/
    LDA <r_menu_draw_portrait_tmp_slot                                          ; $018EBD |\
    CLC                                                                         ; $018EBF | | Set the tile flags to the base character sprite tile flags, plus
    ADC #3.b                                                                    ; $018EC0 | | set the palette to palette 3 plus the slot.
    ASL A                                                                       ; $018EC2 | |
    ORA r_menu_character_sprite_base_tile_flags.w                               ; $018EC3 | |
    STA <r_menu_draw_portrait_tmp_flags                                         ; $018EC6 |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $018EC8 |\ Initialize the X register to four.
    LDX #4.w                                                                    ; $018ECA |/
-   LDA <r_menu_draw_portrait_tmp_coordinates                                   ; $018ECD |\ Copy the coordinates to the OAM entry.
    STA r_oam.17.x.w,Y                                                          ; $018ECF |/
    CLC                                                                         ; $018ED2 |\
    ADC #8.w                                                                    ; $018ED3 | | Add eight to the coordinates to shift to the right eight pixels.
    STA <r_menu_draw_portrait_tmp_coordinates                                   ; $018ED6 |/
    LDA <r_menu_draw_portrait_tmp_tile                                          ; $018ED8 |\
    STA r_oam.17.tile.w,Y                                                       ; $018EDA | | Copy the tile to the OAM entry and then increment the tile number.
    INC A                                                                       ; $018EDD | |
    STA <r_menu_draw_portrait_tmp_tile                                          ; $018EDE |/
    INY                                                                         ; $018EE0 |\
    INY                                                                         ; $018EE1 | | Increment the Y register by four to move to the next entry.
    INY                                                                         ; $018EE2 | |
    INY                                                                         ; $018EE3 |/
    DEX                                                                         ; $018EE4 |\ Loop until all four tiles have been set.
    BNE -                                                                       ; $018EE5 |/
    LDA <r_menu_draw_portrait_tmp_coordinates                                   ; $018EE7 |\
    CLC                                                                         ; $018EE9 | | Add $7E0 ($800 - $20) to the coordinates to shift down one line
    ADC #$07E0.w                                                                ; $018EEA | | and back to the start of the row.
    STA <r_menu_draw_portrait_tmp_coordinates                                   ; $018EED |/
    LDX #4.w                                                                    ; $018EEF |\
-   LDA <r_menu_draw_portrait_tmp_coordinates                                   ; $018EF2 | | Repeat the above process to draw the second row of tiles.
    STA r_oam.17.x.w,Y                                                          ; $018EF4 | |
    CLC                                                                         ; $018EF7 | |
    ADC #8.w                                                                    ; $018EF8 | |
    STA <r_menu_draw_portrait_tmp_coordinates                                   ; $018EFB | |
    LDA <r_menu_draw_portrait_tmp_tile                                          ; $018EFD | |
    STA r_oam.17.tile.w,Y                                                       ; $018EFF | |
    INC A                                                                       ; $018F02 | |
    STA <r_menu_draw_portrait_tmp_tile                                          ; $018F03 | |
    INY                                                                         ; $018F05 | |
    INY                                                                         ; $018F06 | |
    INY                                                                         ; $018F07 | |
    INY                                                                         ; $018F08 | |
    DEX                                                                         ; $018F09 | |
    BNE -                                                                       ; $018F0A | |
    LDA <r_menu_draw_portrait_tmp_coordinates                                   ; $018F0C | |
    CLC                                                                         ; $018F0E | |
    ADC #$07E0.w                                                                ; $018F0F | |
    STA <r_menu_draw_portrait_tmp_coordinates                                   ; $018F12 |/
    LDX #4.w                                                                    ; $018F14 |\
-   LDA <r_menu_draw_portrait_tmp_coordinates                                   ; $018F17 | | Repeat the process to draw the third row of tiles.
    STA r_oam.17.x.w,Y                                                          ; $018F19 | |
    CLC                                                                         ; $018F1C | | NOTE: As you may have noticed, this code is extremely wasteful,
    ADC #8.w                                                                    ; $018F1D | |       duplicating a large section of code four times.
    STA <r_menu_draw_portrait_tmp_coordinates                                   ; $018F20 | |
    LDA <r_menu_draw_portrait_tmp_tile                                          ; $018F22 | |
    STA r_oam.17.tile.w,Y                                                       ; $018F24 | |
    INC A                                                                       ; $018F27 | |
    STA <r_menu_draw_portrait_tmp_tile                                          ; $018F28 | |
    INY                                                                         ; $018F2A | |
    INY                                                                         ; $018F2B | |
    INY                                                                         ; $018F2C | |
    INY                                                                         ; $018F2D | |
    DEX                                                                         ; $018F2E | |
    BNE -                                                                       ; $018F2F | |
    LDA <r_menu_draw_portrait_tmp_coordinates                                   ; $018F31 | |
    CLC                                                                         ; $018F33 | |
    ADC #$07E0.w                                                                ; $018F34 | |
    STA <r_menu_draw_portrait_tmp_coordinates                                   ; $018F37 |/
    LDX #04.w                                                                   ; $018F39 |\
-   LDA <r_menu_draw_portrait_tmp_coordinates                                   ; $018F3C | | Repeat one last time for the last row.
    STA r_oam.17.x.w,Y                                                          ; $018F3E | |
    CLC                                                                         ; $018F41 | |
    ADC #8.w                                                                    ; $018F42 | |
    STA <r_menu_draw_portrait_tmp_coordinates                                   ; $018F45 | |
    LDA <r_menu_draw_portrait_tmp_tile                                          ; $018F47 | |
    STA r_oam.17.tile.w,Y                                                       ; $018F49 | |
    INC A                                                                       ; $018F4C | |
    STA <r_menu_draw_portrait_tmp_tile                                          ; $018F4D | |
    INY                                                                         ; $018F4F | |
    INY                                                                         ; $018F50 | |
    INY                                                                         ; $018F51 | |
    INY                                                                         ; $018F52 | |
    DEX                                                                         ; $018F53 | |
    BNE -                                                                       ; $018F54 |/
    SEP #FLAG_P_ACCUMULATOR                                                     ; $018F56 |\
    PLY                                                                         ; $018F58 | | Restore the preserved registers.
    PLA                                                                         ; $018F59 |/
    RTS                                                                         ; $018F5A

; _menu_format_number_24bit ($01:8F5B)
;
; Given a 24-bit value (passed with the low 16 bits in the X register and the
; high 8 bits in the accumulator), converts that number to decimal form and
; stores the result as tile numbers at the seven bytes starting at $0163.
; Importantly, these tiles are stored in little-endian order, with the least
; significant digit first.
_menu_format_number_24bit:
    STX <r_menu_divide_by_10_arg_value_lo                                       ; $018F5B |\ Copy the parameter into the division argument variables.
    STA <r_menu_divide_by_10_arg_value_hi                                       ; $018F5D |/
    LDA #TILE_MENU_WINDOW_BLANK.b                                               ; $018F5F |\
    LDX <r_menu_zero                                                            ; $018F61 | | Initialize the result array to blank tiles.
-   STA r_menu_format_number_result.w,X                                         ; $018F63 | |
    INX                                                                         ; $018F66 | |
    CPX #_sizeof_r_menu_format_number_result.w                                  ; $018F67 | |
    BNE -                                                                       ; $018F6A |/
    LDY <r_menu_zero                                                            ; $018F6C | Initialize the Y register to zero.
-   JSR _menu_divide_by_10                                                      ; $018F6E | Divide the current value by 10.
    LDA <r_menu_divide_by_10_remainder                                          ; $018F71 |\
    ORA #TILE_MENU_NUMBER_BASE.b                                                ; $018F73 | | Set the current tile to the remainder plus $80, the tile base and
    STA r_menu_format_number_result.w,Y                                         ; $018F75 | | increment the Y register.
    INY                                                                         ; $018F78 |/
    LDA <r_menu_divide_by_10_arg_value_lo                                       ; $018F79 |\
    ORA <r_menu_divide_by_10_arg_value_md                                       ; $018F7B | | If there are no more set bits in the value, branch to the end.
    ORA <r_menu_divide_by_10_arg_value_hi                                       ; $018F7D | |
    BEQ +                                                                       ; $018F7F |/
    CPY #_sizeof_r_menu_format_number_result.w                                  ; $018F81 |\ Otherwise, loop until 7 digits have been set.
    BNE -                                                                       ; $018F84 |/
+   RTS                                                                         ; $018F86

; _menu_divide_by_10 ($01:8F87)
;
; Given a 24-bit value in $73, divides that value by 10, leaving the quotient in
; $73 and the remainder in $1D.
_menu_divide_by_10:
    STZ <r_menu_divide_by_10_remainder                                          ; $018F87 | Initialize the remainder to zero.
    LDX #24.w                                                                   ; $018F89 | Initialize the X register to 24.
    ROL <r_menu_divide_by_10_arg_value_lo                                       ; $018F8C |\
    ROL <r_menu_divide_by_10_arg_value_md                                       ; $018F8E | | Rotate the first bit out of the parameter.
    ROL <r_menu_divide_by_10_arg_value_hi                                       ; $018F90 |/
-   ROL <r_menu_divide_by_10_remainder                                          ; $018F92 | Rotate the current bit into the temporary value.
    LDA <r_menu_divide_by_10_remainder                                          ; $018F94 |\
    CMP #10.b                                                                   ; $018F96 | | If the value is 10 or more, subtract 10. In this case, the carry
    BCC +                                                                       ; $018F98 | | bit will now be set, to indicate that we finally were able to
    SBC #10.b                                                                   ; $018F9A | | divide by 10 at this poition.
    STA <r_menu_divide_by_10_remainder                                          ; $018F9C |/
+   ROL <r_menu_divide_by_10_arg_value_lo                                       ; $018F9E |\
    ROL <r_menu_divide_by_10_arg_value_md                                       ; $018FA0 | | Rotate the result bit back into the value and fetch the next.
    ROL <r_menu_divide_by_10_arg_value_hi                                       ; $018FA2 |/
    DEX                                                                         ; $018FA4 |\ Decrement the X register and loop until all 24 bits have been
    BNE -                                                                       ; $018FA5 |/ checked.
    RTS                                                                         ; $018FA7

; _menu_draw_number_as_decimal ($01:8FA8)
;
; Given a 24-bit number (with the low 16 bits in the X register and the high 8
; bits in the accumulator), the base tilemap address in $29 and the offset
; within that tilemap in the Y register, writes the decimal form of the number
; to the tilemap, using blank tiles for any leading zeroes.
_menu_draw_number_as_decimal:
    PHY                                                                         ; $018FA8 |\ Push the value in the Y register to the stack twice.
    PHY                                                                         ; $018FA9 |/
    JSR _menu_format_number_24bit                                               ; $018FAA | Format the values in the X and A registers as a decimal number.
    REP #FLAG_P_ACCUMULATOR                                                     ; $018FAD |\
    PLA                                                                         ; $018FAF | | Set the Y register to the value originally passed in the Y
    CLC                                                                         ; $018FB0 | | register plus (two bytes for each of the seven digits).
    ADC #(7 * 2).w                                                              ; $018FB1 | |
    TAY                                                                         ; $018FB4 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $018FB5 |/
    LDX <r_menu_zero                                                            ; $018FB7 | Initialize the X register to zero.
-   LDA r_menu_format_number_result.w,X                                         ; $018FB9 |\ Copy the current tile to the current tilemap location (the order is
    STA (<r_menu_current_tilemap_base_address),Y                                ; $018FBC |/ reversed as the format number result is little endian).
    DEY                                                                         ; $018FBE |\
    DEY                                                                         ; $018FBF | | Update the index registers and loop until all seven digits have
    INX                                                                         ; $018FC0 | | been written.
    CPX #_sizeof_r_menu_format_number_result.w                                  ; $018FC1 | |
    BNE -                                                                       ; $018FC4 |/
    PLY                                                                         ; $018FC6 | Restore the original value of the Y register.
    RTS                                                                         ; $018FC7

; _menu_draw_character_class ($01:8FC8)
;
; Given a character sprite/class byte in the accumulator, the base tilemap
; address in $29, and an offset within that tilemap in the Y register, draws the
; textual name for the character's class onto the tilemap.
_menu_draw_character_class:
    AND #%00001111.b                                                            ; $018FC8 | Mask out the sprite/class portion of the variable.
    PHA                                                                         ; $018FCA |\
    REP #FLAG_P_ACCUMULATOR                                                     ; $018FCB | | Add the base tilemap address to the value in the Y register and
    TYA                                                                         ; $018FCD | | then move that new value into the Y register.
    CLC                                                                         ; $018FCE | |
    ADC <r_menu_current_tilemap_base_address                                    ; $018FCF | |
    TAY                                                                         ; $018FD1 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $018FD2 | |
    PLA                                                                         ; $018FD4 |/
.if FF4_REGION == "JAPAN"
    ASL A                                                                       ; $018FD3 |\
    STA <r_menu_generic_tmp_word.lo                                             ; $018FD4 | | Set the X register to the value in the accumulator times six.
    ASL A                                                                       ; $018FD6 | |
    ADC <r_menu_generic_tmp_word.lo                                             ; $018FD7 | |
    STA <r_menu_generic_tmp_word.lo                                             ; $018FD9 | |
    STZ <r_menu_generic_tmp_word.hi                                             ; $018FDB | |
    LDX <r_menu_generic_tmp_word                                                ; $018FDD |/
    LDA #6.b                                                                    ; $018FDF |\ Initialize the count to six.
    STA $45.b                                                                   ; $018FE1 |/
.else
    STA <r_menu_generic_tmp_word.hi                                             ; $018FD5 |\
    ASL A                                                                       ; $018FD7 | | Set the X register to the value in the accumulator times seven.
    STA <r_menu_generic_tmp_word.lo                                             ; $018FD8 | |
    ASL A                                                                       ; $018FDA | |
    ADC <r_menu_generic_tmp_word.lo                                             ; $018FDB | |
    ADC <r_menu_generic_tmp_word.hi                                             ; $018FDD | |
    STA <r_menu_generic_tmp_word.lo                                             ; $018FDF | |
    STZ <r_menu_generic_tmp_word.hi                                             ; $018FE1 | |
    LDX <r_menu_generic_tmp_word                                                ; $018FE3 |/
    LDA #7.b                                                                    ; $018FE5 |\ Initialize the count to seven.
    STA <r_menu_generic_tmp_count                                               ; $018FE7 |/
.endif
-   LDA bank0F.character_class_text_data.l,X                                    ; $018FE9 | Load the next character from ROM.
    JSR _menu_get_diacritic_tile                                                ; $018FED | Get the diacritic tiles for this character.
    STA (0 * 2 * 32).w,Y                                                        ; $018FF0 |\
    XBA                                                                         ; $018FF3 | | Store the two diacritic tiles to the tilemap.
    STA (1 * 2 * 32).w,Y                                                        ; $018FF4 | |
    INY                                                                         ; $018FF7 |/
    LDA <r_menu_current_tilemap_base_tile_flags                                 ; $018FF8 |\
    STA (0 * 2 * 32).w,Y                                                        ; $018FFA | | Store the tile flags to the tilemap.
    STA (1 * 2 * 32).w,Y                                                        ; $018FFD |/
    INY                                                                         ; $019000 |\
    INX                                                                         ; $019001 | | Update the registers and loop until all seven characters have been
    DEC <r_menu_generic_tmp_count                                               ; $019002 | | written.
    BNE -                                                                       ; $019004 |/
    RTS                                                                         ; $019006

; _menu_get_character_field_offset ($01:9007)
;
; Given a slot number in the accumulator, returns the offset to the character
; record for that slot in the X register.
_menu_get_character_field_offset:
    PHA                                                                         ; $019007 | Preserve the value in the accumulator.
    AND #%00001111.b                                                            ; $019008 |\
    ASL A                                                                       ; $01900A | | Transfer the value in the accumulator mod 16 to the X register.
    JSR _menu_transfer_a_to_x                                                   ; $01900B |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $01900E |\
    LDA bank0F.character_field_offset_data.l,X                                  ; $019010 | | Set the X register to the offset to the field character record for
    TAX                                                                         ; $019014 | | the passed slot.
    SEP #FLAG_P_ACCUMULATOR                                                     ; $019015 |/
    PLA                                                                         ; $019017 | Restore the original value in the accumulator.
    RTS                                                                         ; $019018

; _menu_draw_item_name_* ($01:9019)
;
; This set of two functions draws an item name to the current tilemap specified
; in $29. The _direct variant takes the item ID in the accumulator and the
; offset within the tilemap in the Y register. The _equipped variant expects
; the offset to a character record in $60, and the offset within that record in
; the Y register.
_menu_draw_item_name_equipped:
    PHY                                                                         ; $019019 | Preserve the value in the Y register.
    PHX                                                                         ; $01901A | Push the tilemap offset to the stack for later use.
    LDA (<r_menu_selected_character_offset),Y                                   ; $01901B | Read the equipped item ID from the character.
__menu_draw_item_name_common:
    STA <r_menu_generic_tmp_offset.lo                                           ; $01901D | Store the passed item ID into a temporary variable.
    REP #FLAG_P_ACCUMULATOR                                                     ; $01901F |\
    LDA <r_menu_current_tilemap_base_address                                    ; $019021 | | Calculate a second pointer which points to the tilemap, except one
    CLC                                                                         ; $019023 | | row lower.
    ADC #(32 * 2).w                                                             ; $019024 | |
    STA <r_menu_draw_item_name_tmp_second_row_ptr                               ; $019027 |/
    LDA <r_menu_generic_tmp_offset                                              ; $019029 |\
    ASL A                                                                       ; $01902B | | Set the X register to the item ID times nine (to index the item
    ASL A                                                                       ; $01902C | | name data).
    ASL A                                                                       ; $01902D | |
    ADC <r_menu_generic_tmp_offset                                              ; $01902E | |
    TAX                                                                         ; $019030 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $019031 |/
    PLY                                                                         ; $019033 | Load the passed tilemap offset into the Y register.
    LDA bank0F.item_name_data.l,X                                               ; $019034 |\
    STA (<r_menu_draw_item_name_tmp_second_row_ptr),Y                           ; $019038 | | Load the icon character and store it to the second row.
    INY                                                                         ; $01903A |/
    LDA <r_menu_current_tilemap_extra_tile_flags                                ; $01903B |\
    ORA <r_menu_current_tilemap_base_tile_flags                                 ; $01903D | | Set the tilemap flags on both rows.
    STA (<r_menu_current_tilemap_base_address),Y                                ; $01903F | |
    STA (<r_menu_draw_item_name_tmp_second_row_ptr),Y                           ; $019041 | |
    INY                                                                         ; $019043 | |
    INX                                                                         ; $019044 |/
    LDA #8.b                                                                    ; $019045 |\ Initialize the counter to eight.
    STA <r_menu_generic_tmp_count                                               ; $019047 |/
-   LDA bank0F.item_name_data.l,X                                               ; $019049 |\
    JSR _menu_get_diacritic_tile                                                ; $01904D | | Set the first character of the item name on the tilemap, including
    STA (<r_menu_current_tilemap_base_address),Y                                ; $019050 | | any diacritic.
    XBA                                                                         ; $019052 | |
    STA (<r_menu_draw_item_name_tmp_second_row_ptr),Y                           ; $019053 | |
    INX                                                                         ; $019055 | |
    INY                                                                         ; $019056 |/
    LDA <r_menu_current_tilemap_extra_tile_flags                                ; $019057 |\
    ORA <r_menu_current_tilemap_base_tile_flags                                 ; $019059 | | Set the tile flags on the two rows.
    STA (<r_menu_current_tilemap_base_address),Y                                ; $01905B | |
    STA (<r_menu_draw_item_name_tmp_second_row_ptr),Y                           ; $01905D | |
    INY                                                                         ; $01905F |/
    DEC <r_menu_generic_tmp_count                                               ; $019060 |\ Decrement the count and loop until all eight characters are copied.
    BNE -                                                                       ; $019062 |/
    PLY                                                                         ; $019064 | Restore the value of the Y register.
    RTS                                                                         ; $019065
_menu_draw_item_name_direct:
    PHY                                                                         ; $019066 | Preserve the value in the Y register.
    PHY                                                                         ; $019067 | Push the tilemap offset to the stack for later use.
    BRA __menu_draw_item_name_common                                            ; $019068 | Branch to the common code.

; _menu_update_character_sprite ($01:906A)
;
; Given a set of character sprite properties in $1D through $20, sets the OAM
; entries necessary to display that character sprite. The _erase variant allows
; the caller to force the erasure of a sprite.
_menu_update_character_sprite:
    PHX                                                                         ; $01906A | Preserve the value in the X register.
    LDA <r_menu_update_character_sprite_arg_properties.slot                     ; $01906B |\
    JSR _menu_get_character_field_offset                                        ; $01906D | | Load the character ID for the character whose slot was passed in
    STX <r_menu_update_character_sprite_tmp_ptr                                 ; $019070 | | the argument array.
    LDA (<r_menu_update_character_sprite_tmp_ptr)                               ; $019072 | |
    AND #%00111111.b                                                            ; $019074 |/
    BNE __menu_update_character_sprite_non_empty                                ; $019076 | If non-zero, branch ahead to the non-empty code.
    BRA __menu_update_character_sprite_empty                                    ; $019078 | Branch ahead to the common code.
_menu_update_character_sprite_erase:
    PHX                                                                         ; $01907A | Preserve the value of the X register.
__menu_update_character_sprite_empty:
    TDC                                                                         ; $01907B |\ Zero out the high byte of the accumulator.
    XBA                                                                         ; $01907C |/
    LDA <r_menu_update_character_sprite_arg_properties.slot                     ; $01907D |\
    REP #FLAG_P_ACCUMULATOR                                                     ; $01907F | | Set the Y register to the offset to the OAM entries for this slot
    ASL A                                                                       ; $019081 | | by multiplying the slot number by 64 (16 entries) and then adding
    ASL A                                                                       ; $019082 | | the base offset used for character sprites.
    ASL A                                                                       ; $019083 | |
    ASL A                                                                       ; $019084 | |
    ASL A                                                                       ; $019085 | |
    ASL A                                                                       ; $019086 | |
    ADC #r_oam.17.w                                                             ; $019087 | |
    TAY                                                                         ; $01908A | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01908B |/
    JSR _menu_shop_erase_next_10_oam_entries                                    ; $01908D | Erase any character sprites in that position.
    PLX                                                                         ; $019090 |\ Restore the original value of the X register and return.
    RTS                                                                         ; $019091 |/
__menu_update_character_sprite_non_empty:
++  LDY <r_menu_zero                                                            ; $019092 | Initialize the Y register to zero.
-   CMP r_menu_character_id_slot.1.id.w,Y                                       ; $019094 |\
    BEQ +                                                                       ; $019097 | | Loop through the ID and slot array until finding the slot with the
    INY                                                                         ; $019099 | | associated character ID.
    INY                                                                         ; $01909A | |
    BRA -                                                                       ; $01909B |/
+   LDA r_menu_character_id_slot.1.slot.w,Y                                     ; $01909D |\ Push the slot number for later use.
    PHA                                                                         ; $0190A0 |/
    STA <r_menu_generic_tmp_count                                               ; $0190A1 |\
    ASL A                                                                       ; $0190A3 | | Calculate the slot number times 48 plus 128 and save it to another
    ADC <r_menu_generic_tmp_count                                               ; $0190A4 | | variable. This is the base tile number for this slot.
    ASL A                                                                       ; $0190A6 | |
    ASL A                                                                       ; $0190A7 | | If the value is greater than 255, the carry bit will be set and
    ASL A                                                                       ; $0190A8 | | transferred into the flags variable, where it will serve as the
    ASL A                                                                       ; $0190A9 | | high name table bit.
    ADC #128.b                                                                  ; $0190AA | |
    STA <r_menu_update_character_sprite_tmp_base_tile                           ; $0190AC | |
    LDA #0.b                                                                    ; $0190AE | |
    ADC #0.b                                                                    ; $0190B0 | |
    STA <r_menu_update_character_sprite_tmp_flags                               ; $0190B2 |/
    PLA                                                                         ; $0190B4 |\
    INC A                                                                       ; $0190B5 | | For the other bits in the tile flags, OR in the base tile flags
    INC A                                                                       ; $0190B6 | | (which set priority 2 on the sprite), set the palette to the slot
    INC A                                                                       ; $0190B7 | | number plus three, and store the result back to the flags
    ASL A                                                                       ; $0190B8 | | variable.
    ORA <r_menu_character_sprite_base_tile_flags                                ; $0190B9 | |
    ADC <r_menu_update_character_sprite_tmp_flags                               ; $0190BB | |
    STA <r_menu_update_character_sprite_tmp_flags                               ; $0190BD |/
    LDA <r_menu_update_character_sprite_arg_properties.pose                     ; $0190BF |\
    CMP #MENU_POSE_SWOON.b                                                      ; $0190C1 | | If the pose is the swoon pose, load six into the X register.
    BNE +                                                                       ; $0190C3 | | Otherwise, set it to zero. This value is the current tile number.
    LDX #6.w                                                                    ; $0190C5 | |
    BRA ++                                                                      ; $0190C8 | |
+   LDX <r_menu_zero                                                            ; $0190CA |/
++  TDC                                                                         ; $0190CC |\ Zero out the high byte of the accumulator.
    XBA                                                                         ; $0190CD |/
    LDA <r_menu_update_character_sprite_arg_properties.slot                     ; $0190CE |\
    REP #FLAG_P_ACCUMULATOR                                                     ; $0190D0 | | Set the Y register to the offset to the OAM entries for this slot
    ASL A                                                                       ; $0190D2 | | by multiplying the slot number by 64 (16 entries) and adding the
    ASL A                                                                       ; $0190D3 | | base offset used for character sprites.
    ASL A                                                                       ; $0190D4 | |
    ASL A                                                                       ; $0190D5 | |
    ASL A                                                                       ; $0190D6 | |
    ASL A                                                                       ; $0190D7 | |
    ADC #r_oam.17.w                                                             ; $0190D8 | |
    TAY                                                                         ; $0190DB | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $0190DC |/
    LDA #6.b                                                                    ; $0190DE |\ Initialize the counter to six.
    STA <r_menu_generic_tmp_count                                               ; $0190E0 |/
@loop_start:
    LDA <r_menu_update_character_sprite_arg_properties.coordinates.x            ; $0190E2 |\
    CLC                                                                         ; $0190E4 | | Set the X coordinate for the tile by adding the tile offset to the
    ADC menu_character_sprite_tile_x_coordinate_data.l,X                        ; $0190E5 | | base coordinate for this slot.
    STA oam_sprite.x.w,Y                                                        ; $0190E9 |/
    LDA <r_menu_update_character_sprite_arg_properties.coordinates.y            ; $0190EC |\
    CLC                                                                         ; $0190EE | | Set the Y coordinate for the tile by adding the tile offset to the
    ADC menu_character_sprite_tile_y_coordinate_data.l,X                        ; $0190EF | | base coordinate for this slot.
    STA oam_sprite.y.w,Y                                                        ; $0190F3 |/
    STX <r_menu_update_character_sprite_tmp_offset                              ; $0190F6 |\
    LDA <r_menu_update_character_sprite_arg_properties.pose                     ; $0190F8 | | Set the X register to the pose times six plus the value in the X
    ASL A                                                                       ; $0190FA | | register (0-5 for most poses and 6-11 for swoon).
    STA <r_menu_generic_tmp_offset.lo                                           ; $0190FB | |
    ASL A                                                                       ; $0190FD | |
    ADC <r_menu_generic_tmp_offset.lo                                           ; $0190FE | |
    ADC <r_menu_update_character_sprite_tmp_offset.lo                           ; $019100 | |
    JSR _menu_transfer_a_to_x                                                   ; $019102 |/
    LDA #0.b                                                                    ; $019105 |\
    XBA                                                                         ; $019107 | | Load the tile number to use with this tile.
    LDA menu_character_sprite_pose_tile_data.l,X                                ; $019108 |/
    LDX <r_menu_update_character_sprite_tmp_offset                              ; $01910C | Restore the tile index to the X register.
    REP #FLAG_P_ACCUMULATOR                                                     ; $01910E |\
    CLC                                                                         ; $019110 | | Add the tile number to the base tile and copy both it and the
    ADC <r_menu_update_character_sprite_tmp_base_tile                           ; $019111 | | tile flags to the OAM data.
    STA oam_sprite.tile.w,Y                                                     ; $019113 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $019116 |/
    INY                                                                         ; $019118 |\
    INY                                                                         ; $019119 | | Increment the Y register by four, the X register by one,
    INY                                                                         ; $01911A | | decrement the counter and loop until it reaches zero.
    INY                                                                         ; $01911B | |
    INX                                                                         ; $01911C | |
    DEC <r_menu_generic_tmp_count                                               ; $01911D | |
    BNE @loop_start                                                             ; $01911F |/
    JSR _menu_shop_erase_next_10_oam_entries                                    ; $019121 | Erase the remaining 10 sprites in this character's range.
    PLX                                                                         ; $019124 | Restore the X register.
    RTS                                                                         ; $019125

; _menu_shop_erase_next_10_oam_entries ($01:9126)
;
; Erases a character sprite in the shop menu, given a pointer to the start of
; that character's OAM entries in the Y register. Note that this technically
; only erases 10 sprites, which allows it to be used after writing the first six
; to erase the remaining 10 in each character's group.
_menu_shop_erase_next_10_oam_entries:
    LDX #10.w                                                                   ; $019126 | Initialize the X register to 10.
    REP #FLAG_P_ACCUMULATOR                                                     ; $019129 | Switch to 16-bit accumulator mode.
-   LDA #$F0FF.w                                                                ; $01912B |\ Set the coordinates for the sprite to 255, 240.
    STA oam_sprite.x.w,Y                                                        ; $01912E |/
    LDA #$3000.w                                                                ; $019131 |\ Set the tile number to zero and the flags to only priority 3.
    STA oam_sprite.tile.w,Y                                                     ; $019134 |/
    INY                                                                         ; $019137 |\
    INY                                                                         ; $019138 | | Increment Y by four to move to the next OAM entry.
    INY                                                                         ; $019139 | |
    INY                                                                         ; $01913A |/
    DEX                                                                         ; $01913B |\ Decrement the index and loop until it reaches zero.
    BNE -                                                                       ; $01913C |/
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01913E | Switch to 8-bit accumulator mode.
    RTS                                                                         ; $019140

; menu_character_sprite_pose_tile_data ($01:9141)
;
; For each pose of a character sprite within the menu, determines the tile
; numbers within their sprite set to use to draw that pose.
;
; NOTE: For whatever reason, swoon is duplicated. The code that accesses this
;       array saves an offset used to index the following two tables and adds it
;       to the offset when accessing this table. That offset ranges from zero to
;       five except when accessing swoon, where the value is six through eleven.
;       Fixing it would have required using two separate offsets (one for the
;       current tile number and one for the swoon offset) for the other arrays,
;       however.
menu_character_sprite_pose_tile_data:
    .db $00, $01, $02, $03, $04, $05                                            ; $019141.9146 | $00: Normal
    .db $06, $07, $08, $09, $0A, $0B                                            ; $019147.914C | $01: Parrying
    .db $00, $01, $02, $03, $0C, $0D                                            ; $01914D.9152 | $02: Walking
    .db $0E, $0F, $10, $11, $12, $13                                            ; $019153.9158 | $03: Crouching
    .db $00, $01, $14, $03, $15, $0D                                            ; $019159.915E | $04: Right Arm Raised
    .db $00, $01, $16, $17, $18, $19                                            ; $01915F.9164 | $05: Striking
    .db $00, $1A, $02, $1B, $1C, $1D                                            ; $019165.916A | $06: Left Arm Raised
    .db $1E, $1F, $20, $21, $22, $23                                            ; $01916B.9170 | $07: Reeling
    .db $24, $25, $26, $27, $28, $29                                            ; $019171.9176 | $08: Cheering
    .db $2A, $2B, $2C, $2D, $2E, $2F                                            ; $019177.917C | $09: Swoon
    .db $2A, $2B, $2C, $2D, $2E, $2F                                            ; $01917D.9182 | $0A: Swoon

; menu_character_sprite_tile_x_coordinate_data ($01:9183)
;
; For each of the six tiles that make up a character sprite, determines the
; relative X coordinate for that tile. The first set of six is for 2x3 sprites
; and the second set is for 3x2 sprites (only swoon).
menu_character_sprite_tile_x_coordinate_data:
    .db  0,  8,  0,  8,  0,  8                                                  ; $019183.9188
    .db  0,  8, 16,  0,  8, 16                                                  ; $019189.918E

; menu_character_sprite_tile_y_coordinate_data ($01:918F)
;
; For each of the six tiles that make up a character sprite, determines the
; relative Y coordinate for that tile. The first set of six is for 2x3 sprites
; and the second set is for 3x2 sprites (only swoon).
menu_character_sprite_tile_y_coordinate_data:
    .db  0,  0,  8,  8, 16, 16                                                  ; $01918F.9194
    .db  0,  0,  0, 8 ,  8,  8                                                  ; $019195.919A

UNUSED_CODE_01919B:
    LDX <r_menu_zero                                                            ; $01919B
    REP #FLAG_P_ACCUMULATOR                                                     ; $01919D
    LDA #5.w                                                                    ; $01919F
    STA <r_menu_generic_tmp_count                                               ; $0191A2
    LDY <r_menu_zero                                                            ; $0191A4
-   LDA DATA_0191CA.l,X                                                         ; $0191A6
    CLC                                                                         ; $0191AA
    ADC r_menu_party_sprites_base_coordinates.w                                 ; $0191AB
    STA r_menu_character_sprite_properties_frame_1.1.coordinates.w,Y            ; $0191AE
    STA r_menu_character_sprite_properties_frame_2.1.coordinates.w,Y            ; $0191B1
    TYA                                                                         ; $0191B4
    LSR A                                                                       ; $0191B5
    LSR A                                                                       ; $0191B6
    STA r_menu_character_sprite_properties_frame_1.1.slot.w,Y                   ; $0191B7
    STA r_menu_character_sprite_properties_frame_2.1.slot.w,Y                   ; $0191BA
    INY                                                                         ; $0191BD
    INY                                                                         ; $0191BE
    INY                                                                         ; $0191BF
    INY                                                                         ; $0191C0
    INX                                                                         ; $0191C1
    INX                                                                         ; $0191C2
    DEC <r_menu_generic_tmp_count                                               ; $0191C3
    BNE -                                                                       ; $0191C5
    SEP #FLAG_P_ACCUMULATOR                                                     ; $0191C7
    RTS                                                                         ; $0191C9

DATA_0191CA:
    .db  0,  0                                                                  ; $0191CA.91CB
    .db  0, 24                                                                  ; $0191CC.91CD
    .db  0, 48                                                                  ; $0191CE.91CF
    .db  0, 72                                                                  ; $0191D0.91D1
    .db  0, 96                                                                  ; $0191D2.91D3

; _menu_init_character_sprite_properties ($01:91D4)
;
; Initializes the character sprite properties arrays at $FE00.
_menu_init_character_sprite_properties:
    LDA r_party_formation_two_front.w                                           ; $0191D4 |\
    BEQ +                                                                       ; $0191D7 | | Set the X register to either zero or ten, depending on which party
    LDA #_sizeof_coordinates.b * 5                                              ; $0191D9 | | formation is in use.
+   JSR _menu_transfer_a_to_x                                                   ; $0191DB |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $0191DE |\
    LDA #5.w                                                                    ; $0191E0 | | Initialize the count to 5.
    STA <r_menu_generic_tmp_count                                               ; $0191E3 |/
    LDY <r_menu_zero                                                            ; $0191E5 | Initialize the Y register to zero.
-   LDA menu_party_coordinate_offset_data.l,X                                   ; $0191E7 |\
    CLC                                                                         ; $0191EB | | Set the coordinates for this character's sprite by adding the
    ADC r_menu_party_sprites_base_coordinates.w                                 ; $0191EC | | offset for this slot to the base coordinates.
    STA r_menu_character_sprite_properties_frame_1.1.coordinates.w,Y            ; $0191EF | |
    STA r_menu_character_sprite_properties_frame_2.1.coordinates.w,Y            ; $0191F2 |/
    TYA                                                                         ; $0191F5 |\
    LSR A                                                                       ; $0191F6 | | Set the slot for this character by dividing the current Y register
    LSR A                                                                       ; $0191F7 | | value by four.
    STA r_menu_character_sprite_properties_frame_1.1.slot.w,Y                   ; $0191F8 | |
    STA r_menu_character_sprite_properties_frame_2.1.slot.w,Y                   ; $0191FB |/
    INY                                                                         ; $0191FE |\
    INY                                                                         ; $0191FF | | Increment the Y register by four to move to the next slot.
    INY                                                                         ; $019200 | |
    INY                                                                         ; $019201 |/
    INX                                                                         ; $019202 |\ Increment the X register by two to move to the next slot.
    INX                                                                         ; $019203 |/
    DEC <r_menu_generic_tmp_count                                               ; $019204 |\ Decrement the count and loop until all five slots have been set.
    BNE -                                                                       ; $019206 |/
    SEP #FLAG_P_ACCUMULATOR                                                     ; $019208 |\
    LDA #10.b                                                                   ; $01920A | | Initialize the sprite frame change delay to 10.
    STA r_menu_shop_character_sprites_frame_change_delay.w                      ; $01920C |/
    RTS                                                                         ; $01920F

; menu_party_coordinate_offset_data ($01:9210)
;
; Contains two 10 byte arrays, each with 5 sets of coordinate offsets used to
; place the character sprites in the shop screen. The coordinate are ordered in
; slot order, with the "three in front" formation in the first 10 bytes and the
; "two in front" formation in the second 10 bytes.
menu_party_coordinate_offset_data:
    .db  0, 28                                                                  ; $019210.9211 | $00: Three Front
    .db  0,  0                                                                  ; $019212.9213
    .db  0, 56                                                                  ; $019214.9215
    .db 24, 12                                                                  ; $019216.9217
    .db 24, 44                                                                  ; $019218.9219

    .db 24, 28                                                                  ; $01921A.921B | $0A: Two Front
    .db 24,  0                                                                  ; $01921C.921D
    .db 24, 56                                                                  ; $01921E.921F
    .db  0, 12                                                                  ; $019220.9221
    .db  0, 44                                                                  ; $019222.9223

; _menu_shop_update_character_sprites ($01:9224)
;
; Updates the character sprites on the shop screen. It has a built-in delay
; function that prevents it from doing anything more often than once every 10
; calls (presumably you'd call this once per frame). Each sprite is alternated
; between its two configured frames.
_menu_shop_update_character_sprites:
    LDA r_menu_shop_character_sprites_frame_change_delay.w                      ; $019224 |\
    BEQ +                                                                       ; $019227 | | If the frame change delay is non-zero, decrement the value and
    DEC r_menu_shop_character_sprites_frame_change_delay.w                      ; $019229 | | return.
    RTS                                                                         ; $01922C |/
+   LDA #10.b                                                                   ; $01922D |\ Reset the frame change delay to 10.
    STA r_menu_shop_character_sprites_frame_change_delay.w                      ; $01922F |/
    LDA #$FF.b                                                                  ; $019232 |\
    EOR r_menu_shop_character_sprites_frame_change_flag.w                       ; $019234 | | Flip the bits on the frame change flag to toggle which frame.
    STA r_menu_shop_character_sprites_frame_change_flag.w                       ; $019237 |/
    BEQ +                                                                       ; $01923A |\
    LDY #r_menu_character_sprite_properties_frame_1.w                           ; $01923C | | If the value is zero, load the offset for frame 2, otherwise load
    BRA ++                                                                      ; $01923F | | the offset for frame 1.
+   LDY #r_menu_character_sprite_properties_frame_2.w                           ; $019241 |/
++  LDX #5.w                                                                    ; $019244 | Initialize the X register to 5.
-   REP #FLAG_P_ACCUMULATOR                                                     ; $019247 |\
    LDA menu_character_sprite.slot.w,Y                                          ; $019249 | | Transfer the current slot, pose and coordinates to the argument
    STA <r_menu_update_character_sprite_arg_properties.slot                     ; $01924C | | array.
    LDA menu_character_sprite.coordinates.w,Y                                   ; $01924E | |
    STA <r_menu_update_character_sprite_arg_properties.coordinates              ; $019251 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $019253 |/
    PHX                                                                         ; $019255 |\
    PHY                                                                         ; $019256 | | Update the character sprite for this slot.
    JSR _menu_update_character_sprite                                           ; $019257 | |
    PLY                                                                         ; $01925A | |
    PLX                                                                         ; $01925B |/
    INY                                                                         ; $01925C |\
    INY                                                                         ; $01925D | | Increment the Y register by four to move to the next entry.
    INY                                                                         ; $01925E | |
    INY                                                                         ; $01925F |/
    DEX                                                                         ; $019260 |\ Decrement the X register and loop until it reaches zero.
    BNE -                                                                       ; $019261 |/
    RTS                                                                         ; $019263

; _menu_load_portraits ($01:9264)
;
; Loads the portraits for the characters in the party, including loading the
; associated palettes. No attempt is made to place these portraits on screen.
; The tile and palette data is merely loaded to VRAM and CG-RAM, respectively.
_menu_load_portraits:
    TDC                                                                         ; $019264 | Initialize the accumulator to zero (slot number).
-   JSR _menu_wait_for_vblank                                                   ; $019265 | Wait for vblank.
    JSR _menu_load_portrait_character                                           ; $019268 | Load the portrait for the character in the current slot.
    JSR _menu_load_portrait_palette                                             ; $01926B | Load the palette for this character.
    INC A                                                                       ; $01926E |\
    CMP #5.b                                                                    ; $01926F | | Increment the slot and loop until all five have been checked.
    BNE -                                                                       ; $019271 |/
    JSR _menu_wait_for_vblank                                                   ; $019273 | Wait for vblank.
    JMP _menu_copy_palette_to_cgram                                             ; $019276 | Copy the updated palette data to CG-RAM.

; _menu_load_portrait_character ($01:9279)
;
; Given a character slot number in the accumulator, loads the portrait for that
; character and copies it to VRAM at an appropriate address for that slot.
; Automatically handles loading the toad, small or pig portraits instead if the
; character has the associated status effect.
_menu_load_portrait_character:
    PHA                                                                         ; $019279 | Preserve the accumulator value (the current character slot).
    STA <r_menu_generic_tmp_word.lo                                             ; $01927A |\ Store the slot number in a temporary variable.
    STZ <r_menu_generic_tmp_word.hi                                             ; $01927C |/
    JSR _menu_get_character_id                                                  ; $01927E | Get the character ID and record offset for this slot.
    BNE +                                                                       ; $019281 |\
    PLA                                                                         ; $019283 | | If the slot is empty, restore the accumulator and return.
    RTS                                                                         ; $019284 |/
+   PHA                                                                         ; $019285 | Push the character ID to the stack.
    LDA character_field.sprite_class.w,X                                        ; $019286 |\
    AND #%00001111.b                                                            ; $019289 | | Load the character's class, multiply by 256 and save as an offset
    STA r_menu_load_portrait_tmp_class_offset.hi.w                              ; $01928B | | for later use.
    STZ r_menu_load_portrait_tmp_class_offset.lo.w                              ; $01928E |/
    LDA character_field.status_1.w,X                                            ; $019291 |\
    AND #(STATUS_1_TOAD | STATUS_1_SMALL | STATUS_1_PIG).b                      ; $019294 | | Branch ahead if the character is not a toad, small, or pig.
    BEQ +                                                                       ; $019296 |/
    LSR A                                                                       ; $019298 |\
    LSR A                                                                       ; $019299 | | Load the pointer for the portrait data for the character's status
    JSR _menu_transfer_a_to_x                                                   ; $01929A | | and transfer it to the Y register.
    REP #FLAG_P_ACCUMULATOR                                                     ; $01929D | |
    LDA bank1E.portrait_pig_small_toad_offset_data.l,X                          ; $01929F | |
    TAY                                                                         ; $0192A3 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $0192A4 |/
    LDA <r_menu_generic_tmp_word                                                ; $0192A6 |\
    ASL A                                                                       ; $0192A8 | | Set the X register to the slot times two.
    STA <r_menu_generic_tmp_offset.lo                                           ; $0192A9 | |
    LDX <r_menu_generic_tmp_offset                                              ; $0192AB |/
    LDA #%10000000.b                                                            ; $0192AD |\ Set the VRAM increment to 1 by 1 after two bytes.
    STA reg_ppu_vmainc.l                                                        ; $0192AF |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $0192B3 |\
    LDA portrait_vram_offset_data.l,X                                           ; $0192B5 | | Set the VRAM address to the designated address for this slot.
    STA reg_ppu_vmadd.l                                                         ; $0192B9 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $0192BD |/
    PLA                                                                         ; $0192BF | Restore the character ID from the stack (unused).
    PHD                                                                         ; $0192C0 |\
    LDX #$2100.w                                                                ; $0192C1 | | Preserve the existing direct register and then set the register to
    PHX                                                                         ; $0192C4 | | $2100.
    PLD                                                                         ; $0192C5 |/
    BRA ++                                                                      ; $0192C6 | Branch ahead to the common code.
+   PLA                                                                         ; $0192C8 | Restore the character ID to the accumulator.
    PHD                                                                         ; $0192C9 |\
    LDX #$2100.w                                                                ; $0192CA | | Preserve the existing direct register and set it to $2100.
    PHX                                                                         ; $0192CD | |
    PLD                                                                         ; $0192CE |/
    DEC A                                                                       ; $0192CF |\
    ASL A                                                                       ; $0192D0 | | Decrement the ID, multiply by two and save to temporary variable.
    STA r_menu_generic_tmp_offset.lo.w                                          ; $0192D1 |/  NOTE: This seems to be unused.
    LDA #%10000000.b                                                            ; $0192D4 |\ Set the VRAM increment to 1 by 1 after two bytes.
    STA <reg_ppu_vmainc                                                         ; $0192D6 |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $0192D8 |\
    LDA r_menu_load_portrait_tmp_class_offset.w                                 ; $0192DA | | Set the Y register to the offset within bank $1D to the potrait
    LSR A                                                                       ; $0192DD | | data for this character's class. (Uses the value multiplied by 256
    CLC                                                                         ; $0192DE | | and then adds it to half of itself, since each portrait uses 384
    ADC r_menu_load_portrait_tmp_class_offset.w                                 ; $0192DF | | bytes.)
    ADC #bank1D.portrait_character_class_data.w                                 ; $0192E2 | |
    TAY                                                                         ; $0192E5 |/
    LDA r_menu_generic_tmp_word.lo.w                                            ; $0192E6 |\
    ASL A                                                                       ; $0192E9 | | Set the X register to the slot times two.
    TAX                                                                         ; $0192EA |/
    LDA portrait_vram_offset_data.l,X                                           ; $0192EB |\
    STA <reg_ppu_vmadd                                                          ; $0192EF | | Set the VRAM address to the designated address for this slot.
    SEP #FLAG_P_ACCUMULATOR                                                     ; $0192F1 |/
++  PHB                                                                         ; $0192F3 |\
    LDA #:bank1D.portrait_character_class_data.b                                ; $0192F4 | | Preserve the existing data bank register and then set it to $1D as
    PHA                                                                         ; $0192F6 | | a parameter to the copy to VRAM.
    PLB                                                                         ; $0192F7 |/
    LDA #16.b                                                                   ; $0192F8 |\ Copy 16 tiles from the address in the Y register (in bank $1D) to
    JSR _menu_copy_3bpp_to_vram                                                 ; $0192FA |/ the configured VRAM address.
    PLB                                                                         ; $0192FD |\
    PLD                                                                         ; $0192FE | | Restore the various registers.
    PLA                                                                         ; $0192FF |/
    RTS                                                                         ; $019300

; _menu_copy_3bpp_to_vram ($01:9301)
;
; This routine is used by menu routines to copy 3bpp data to VRAM. It assumes
; the direct register is set to $2100. Any other value will result in unexpected
; results. As parameters, it takes a number of 8x8 tiles to copy in the
; accumulator and the offset to the desired data to copy from in the Y register.
; The bank to read from should be set in the data bank register.
_menu_copy_3bpp_to_vram:
    STA r_menu_copy_3bpp_to_vram_tmp_count.w                                    ; $019301 | Store the desired number of tiles in a temporary variable.
--  LDX #8.w                                                                    ; $019304 |\
-   LDA 0.w,Y                                                                   ; $019307 | | Copy the first 16 bytes directly into VRAM without modification.
    STA <reg_ppu_vmdatal_write                                                  ; $01930A | |
    LDA 1.w,Y                                                                   ; $01930C | |
    STA <reg_ppu_vmdatah_write                                                  ; $01930F | |
    INY                                                                         ; $019311 | |
    INY                                                                         ; $019312 | |
    DEX                                                                         ; $019313 | |
    BNE -                                                                       ; $019314 |/
    LDX #8.w                                                                    ; $019316 |\
-   LDA 0.w,Y                                                                   ; $019319 | | Copy the last eight bytes, adding an extra zero for the high byte
    STA <reg_ppu_vmdatal_write                                                  ; $01931C | | for each write, expanding the data from 3bpp to 4bpp.
    STZ <reg_ppu_vmdatah_write                                                  ; $01931E | |
    INY                                                                         ; $019320 | |
    DEX                                                                         ; $019321 | |
    BNE -                                                                       ; $019322 |/
    DEC r_menu_copy_3bpp_to_vram_tmp_count.w                                    ; $019324 |\ Loop until the desired number of tiles have been copied.
    BNE --                                                                      ; $019327 |/
    RTS                                                                         ; $019329

; portrait_vram_offset_data ($01:932A)
;
; For character portraits used in menus, determines the VRAM address to load the
; portrait to for the given slot number.
portrait_vram_offset_data:
    .dw VRAM_MENU_PORTRAIT_SLOT_0                                               ; $01932A.932B
    .dw VRAM_MENU_PORTRAIT_SLOT_1                                               ; $01932C.932D
    .dw VRAM_MENU_PORTRAIT_SLOT_2                                               ; $01932E.932F
    .dw VRAM_MENU_PORTRAIT_SLOT_3                                               ; $019330.9331
    .dw VRAM_MENU_PORTRAIT_SLOT_4                                               ; $019332.9333

; _menu_load_portrait_palette ($01:9334)
;
; Given a character slot number in the accumulator, loads the palette for that
; character's portrait into the CG-RAM mirror in RAM, in palettes 11 through 15
; depending on the slot number.
_menu_load_portrait_palette:
    PHA                                                                         ; $019334 | Preserve the value in the accumulator.
    STA <r_menu_generic_tmp_word.lo                                             ; $019335 |\ Save the slot number to a temporary variable.
    STZ <r_menu_generic_tmp_word.hi                                             ; $019337 |/
    JSR _menu_get_character_id                                                  ; $019339 |\
    BNE +                                                                       ; $01933C | | Return if this character slot is empty. (Also loads the record
    PLA                                                                         ; $01933E | | offset into the X register.)
    RTS                                                                         ; $01933F |/
+   LDA character_field.sprite_class.w,X                                        ; $019340 |\
    AND #%00001111.b                                                            ; $019343 | | Read the character's class and save it to a temporary variable.
    STA <r_menu_generic_tmp_offset.lo                                           ; $019345 |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $019347 |\
    LDA <r_menu_generic_tmp_offset                                              ; $019349 | | Multiply the class number by 16 and add to the base address for
    ASL A                                                                       ; $01934B | | the character portrait palettes to determine the offset for this
    ASL A                                                                       ; $01934C | | character's class. (Each palette is eight colors.) Transfer the
    ASL A                                                                       ; $01934D | | result to the X register.
    ASL A                                                                       ; $01934E | |
    ADC #bank0D.portrait_character_palette_data.w                               ; $01934F | |
    TAX                                                                         ; $019352 |/
    LDA <r_menu_generic_tmp_word                                                ; $019353 |\
    ASL A                                                                       ; $019355 | | Multiply the slot number by 32 (the size of a 16-color palette)
    ASL A                                                                       ; $019356 | | and then add that to the address for the 12th palette, to load the
    ASL A                                                                       ; $019357 | | portrait palettes to the last five palettes.
    ASL A                                                                       ; $019358 | |
    ASL A                                                                       ; $019359 | |
    ADC #r_menu_cgram_data.12.w                                                 ; $01935A | |
    TAY                                                                         ; $01935D |/
    LDA #(_sizeof_palette.w / 2) - 1                                            ; $01935E |\
    MVN :bank0D.portrait_character_palette_data,:r_menu_cgram_data              ; $019361 | | Copy the palette to the CG-RAM mirror.
    SEP #FLAG_P_ACCUMULATOR                                                     ; $019364 |/
    PLA                                                                         ; $019366 | Restore the accumulator value.
    RTS                                                                         ; $019367

; _menu_namingway_draw_character_sprites ($01:9368)
;
; Loops through the five character slots, updating the sprites for each slot,
; including changing the pose every few frames. Takes the base coordinates for
; the set of sprites in the X register.
_menu_namingway_draw_character_sprites:
    DEC r_menu_shop_character_sprites_frame_change_delay.w                      ; $019368 |\ Decrement the frame change delay and unless it's zero, branch
    BNE +                                                                       ; $01936B |/ ahead.
    LDA #10.b                                                                   ; $01936D |\
    STA r_menu_shop_character_sprites_frame_change_delay.w                      ; $01936F | | Otherwise, reset the delay to 10 and toggle the bits in the flag
    LDA r_menu_shop_character_sprites_frame_change_flag.w                       ; $019372 | | to indicate the sprites should change.
    EOR #%11111111.b                                                            ; $019375 | |
    STA r_menu_shop_character_sprites_frame_change_flag.w                       ; $019377 |/
+   REP #FLAG_P_ACCUMULATOR                                                     ; $01937A |\
    TXA                                                                         ; $01937C | | Initialize the character sprite coordinates to values that start
    STA <r_menu_namingway_character_sprite_coordinates.1                        ; $01937D | | at the coordinates passed in the X register, and increment the X
    CLC                                                                         ; $01937F | | coordinate by 24 for each character slot.
    ADC #24.w                                                                   ; $019380 | |
    STA <r_menu_namingway_character_sprite_coordinates.2                        ; $019383 | |
    ADC #24.w                                                                   ; $019385 | |
    STA <r_menu_namingway_character_sprite_coordinates.3                        ; $019388 | |
    ADC #24.w                                                                   ; $01938A | |
    STA <r_menu_namingway_character_sprite_coordinates.4                        ; $01938D | |
    ADC #24.w                                                                   ; $01938F | |
    STA <r_menu_namingway_character_sprite_coordinates.5                        ; $019392 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $019394 |/
    TDC                                                                         ; $019396 |\
    STA <r_menu_update_character_sprite_arg_properties.slot                     ; $019397 | | Update the character sprite for slot 0.
    LDA r_menu_character_sprite_pose.1.lo.w                                     ; $019399 | |
    STA <r_menu_update_character_sprite_arg_properties.pose                     ; $01939C | |
    LDA r_menu_shop_character_sprites_frame_change_flag.w                       ; $01939E | |
    BNE +                                                                       ; $0193A1 | |
    LDA r_menu_character_sprite_pose.1.hi.w                                     ; $0193A3 | |
    STA <r_menu_update_character_sprite_arg_properties.pose                     ; $0193A6 | |
+   LDX <r_menu_namingway_character_sprite_coordinates.1                        ; $0193A8 | |
    STX <r_menu_update_character_sprite_arg_properties.coordinates              ; $0193AA | |
    JSR _menu_update_character_sprite                                           ; $0193AC |/
    LDA #1.b                                                                    ; $0193AF |\
    STA <r_menu_update_character_sprite_arg_properties.slot                     ; $0193B1 | | Update the character sprite for slot 1.
    LDA r_menu_character_sprite_pose.2.lo.w                                     ; $0193B3 | |
    STA <r_menu_update_character_sprite_arg_properties.pose                     ; $0193B6 | |
    LDA r_menu_shop_character_sprites_frame_change_flag.w                       ; $0193B8 | |
    BNE +                                                                       ; $0193BB | |
    LDA r_menu_character_sprite_pose.2.hi.w                                     ; $0193BD | |
    STA <r_menu_update_character_sprite_arg_properties.pose                     ; $0193C0 | |
+   LDX <r_menu_namingway_character_sprite_coordinates.2                        ; $0193C2 | |
    STX <r_menu_update_character_sprite_arg_properties.coordinates              ; $0193C4 | |
    JSR _menu_update_character_sprite                                           ; $0193C6 |/
    LDA #2.b                                                                    ; $0193C9 |\
    STA <r_menu_update_character_sprite_arg_properties.slot                     ; $0193CB | | Update the character sprite for slot 2.
    LDA r_menu_character_sprite_pose.3.lo.w                                     ; $0193CD | |
    STA <r_menu_update_character_sprite_arg_properties.pose                     ; $0193D0 | |
    LDA r_menu_shop_character_sprites_frame_change_flag.w                       ; $0193D2 | |
    BNE +                                                                       ; $0193D5 | |
    LDA r_menu_character_sprite_pose.3.hi.w                                     ; $0193D7 | |
    STA <r_menu_update_character_sprite_arg_properties.pose                     ; $0193DA | |
+   LDX <r_menu_namingway_character_sprite_coordinates.3                        ; $0193DC | |
    STX <r_menu_update_character_sprite_arg_properties.coordinates              ; $0193DE | |
    JSR _menu_update_character_sprite                                           ; $0193E0 |/
    LDA #3.b                                                                    ; $0193E3 |\
    STA <r_menu_update_character_sprite_arg_properties.slot                     ; $0193E5 | | Update the character sprite for slot 3.
    LDA r_menu_character_sprite_pose.4.lo.w                                     ; $0193E7 | |
    STA <r_menu_update_character_sprite_arg_properties.pose                     ; $0193EA | |
    LDA r_menu_shop_character_sprites_frame_change_flag.w                       ; $0193EC | |
    BNE +                                                                       ; $0193EF | |
    LDA r_menu_character_sprite_pose.4.hi.w                                     ; $0193F1 | |
    STA <r_menu_update_character_sprite_arg_properties.pose                     ; $0193F4 | |
+   LDX <r_menu_namingway_character_sprite_coordinates.4                        ; $0193F6 | |
    STX <r_menu_update_character_sprite_arg_properties.coordinates              ; $0193F8 | |
    JSR _menu_update_character_sprite                                           ; $0193FA |/
    LDA #4.b                                                                    ; $0193FD |\
    STA <r_menu_update_character_sprite_arg_properties.slot                     ; $0193FF | | Update the character sprite for slot 4.
    LDA r_menu_character_sprite_pose.5.lo.w                                     ; $019401 | |
    STA <r_menu_update_character_sprite_arg_properties.pose                     ; $019404 | |
    LDA r_menu_shop_character_sprites_frame_change_flag.w                       ; $019406 | |
    BNE +                                                                       ; $019409 | |
    LDA r_menu_character_sprite_pose.5.hi.w                                     ; $01940B | |
    STA <r_menu_update_character_sprite_arg_properties.pose                     ; $01940E | |
+   LDX <r_menu_namingway_character_sprite_coordinates.5                        ; $019410 | |
    STX <r_menu_update_character_sprite_arg_properties.coordinates              ; $019412 | |
    JMP _menu_update_character_sprite                                           ; $019414 |/

; _menu_copy_tilemaps_to_vram ($01:9417)
;
; Copies the four tilemaps from the staging area in memory to VRAM.
_menu_copy_tilemaps_to_vram:
    JSR _menu_copy_tilemap_to_vram_bg2_no_vblank                                ; $019417 | Copy the BG2 tilemap to VRAM.
    JSR _menu_copy_tilemap_to_vram_bg1_no_vblank                                ; $01941A | Copy the BG1 tilemap to VRAM.
    JSR _menu_copy_tilemap_to_vram_bg4_no_vblank                                ; $01941D | Copy the BG4 tilemap to VRAM.
    JMP _menu_copy_tilemap_to_vram_bg3_no_vblank                                ; $019420 | Copy the BG3 tilemap to VRAM.

; _menu_initialize_tilemap_bg2_and_copy_to_vram ($01:9423)
;
; Initializes the tilemap for BG2 (by clearing it) and then falls through to the
; next routine to copy the tilemap to VRAM, including a wait for vblank.
_menu_initialize_tilemap_bg2_and_copy_to_vram:
    JSR _menu_initialize_tilemap_bg2                                            ; $019423

; _menu_copy_tilemap_to_vram_* ($01:9429)
;
; Given a number of bytes to transfer in $DE, copies the tilemap data for the
; chosen background to VRAM. The background is chosen by the entry point. In
; addition, each entry point offers a _no_vblank variant which will not wait for
; the next vblank, but instead leave it to the caller to synchronize.
_menu_copy_tilemap_to_vram_bg2:
    JSR _menu_wait_for_vblank                                                   ; $019426 | Wait for the next vblank to begin.
_menu_copy_tilemap_to_vram_bg2_no_vblank:
    PHX                                                                         ; $019429 |\ Preserve the values of the X and Y registers.
    PHY                                                                         ; $01942A |/
    LDX #VRAM_MENU_TILEMAP_BG2.w                                                ; $01942B |\ Set the source and target addresses for BG2.
    LDY #r_menu_tilemap_bg2.w                                                   ; $01942E |/
    BRA _menu_copy_tilemap_to_vram_common                                       ; $019431 | Branch to the common code.
_menu_copy_tilemap_to_vram_bg1:
    JSR _menu_wait_for_vblank                                                   ; $019433 | Wait for the next vblank to begin.
_menu_copy_tilemap_to_vram_bg1_no_vblank:
    PHX                                                                         ; $019436 |\ Preserve the values of the X and Y registers.
    PHY                                                                         ; $019437 |/
    LDX #VRAM_MENU_TILEMAP_BG1.w                                                ; $019438 |\ Set the source and target addresses for BG1.
    LDY #r_menu_tilemap_bg1.w                                                   ; $01943B |/
    BRA _menu_copy_tilemap_to_vram_common                                       ; $01943E | Branch to the common code.
_menu_copy_tilemap_to_vram_bg4:
    JSR _menu_wait_for_vblank                                                   ; $019440 | Wait for the next vblank to begin.
_menu_copy_tilemap_to_vram_bg4_no_vblank:
    PHX                                                                         ; $019443 |\ Preserve the values of the X and Y registers.
    PHY                                                                         ; $019444 |/
    LDX #VRAM_MENU_TILEMAP_BG4.w                                                ; $019445 |\ Set the source and target addresses for BG4.
    LDY #r_menu_tilemap_bg4.w                                                   ; $019448 |/
    BRA _menu_copy_tilemap_to_vram_common                                       ; $01944B | Branch to the common code.
_menu_copy_tilemap_to_vram_bg3:
    JSR _menu_wait_for_vblank                                                   ; $01944D | Wait for the next vblank to begin.
_menu_copy_tilemap_to_vram_bg3_no_vblank:
    PHX                                                                         ; $019450 |\ Preserve the values of the X and Y registers.
    PHY                                                                         ; $019451 |/
    LDX #VRAM_MENU_TILEMAP_BG3.w                                                ; $019452 |\ Set the source and target addresses for BG3 and fall through to the
    LDY #r_menu_tilemap_bg3.w                                                   ; $019455 |/ common code.
_menu_copy_tilemap_to_vram_common:
    STX <r_menu_copy_to_vram_arg_target_vram_address                            ; $019458 | Set the target VRAM address to the parameter in the X register.
    STY <r_menu_copy_to_vram_arg_source_address                                 ; $01945A | Set the source address to the parameter in the Y register.
    LDA #:r_menu_tilemap_bg1.b                                                  ; $01945C |\ Set the source bank to $7E.
    STA <r_menu_copy_to_vram_arg_source_bank                                    ; $01945E |/
    LDX <r_menu_copy_tilemap_to_vram_arg_bytes                                  ; $019460 |\ Set the number of bytes to transfer to the given parameter.
    STX <r_menu_copy_to_vram_arg_bytes                                          ; $019462 |/
    JSR _menu_copy_to_vram                                                      ; $019464 | Copy the data to VRAM via DMA.
    PLY                                                                         ; $019467 |\ Restore the original values of the X and Y registers.
    PLX                                                                         ; $019468 |/
    RTS                                                                         ; $019469

; _menu_ppu_fade_in ($01:946A)
;
; Fades the screen in, with the brightness being increased by one step per
; frame.
_menu_ppu_fade_in:
-   JSR _menu_wait_for_vblank                                                   ; $01946A | Wait for the next vblank.
    LDA <r_menu_ppu_inidisp                                                     ; $01946D |\
    AND #%01111111.b                                                            ; $01946F | | Unset any forced blanking on the PPU.
    STA reg_ppu_inidisp.l                                                       ; $019471 |/
    PHA                                                                         ; $019475 |\
    JSR _update_joypad_2                                                        ; $019476 | | Update the current joypad values.
    PLA                                                                         ; $019479 |/
    INC A                                                                       ; $01947A |\ Increase the PPU brightness by one step.
    STA <r_menu_ppu_inidisp                                                     ; $01947B |/
    CMP #16.b                                                                   ; $01947D |\ Loop until it reaches 16.
    BCC -                                                                       ; $01947F |/
    DEC <r_menu_ppu_inidisp                                                     ; $019481 | Decrement the value to keep it at the max of 15.
    RTS                                                                         ; $019483

; _menu_ppu_fade_out ($01:9484)
;
; Fades the screen out, with the brightness being decreased by one step per
; frame.
_menu_ppu_fade_out:
-   JSR _menu_wait_for_vblank                                                   ; $019484 | Wait for the next vblank.
    LDA <r_menu_ppu_inidisp                                                     ; $019487 |\ If forced blanking is currently set, branch to return.
    BMI +                                                                       ; $019489 |/
    STA reg_ppu_inidisp.l                                                       ; $01948B | Set the current PPU brightness value.
    PHA                                                                         ; $01948F |\
    JSR _update_joypad_2                                                        ; $019490 | | Update the current joypad values.
    PLA                                                                         ; $019493 |/
    DEC A                                                                       ; $019494 |\ Decrease the PPU brightness by one step.
    STA <r_menu_ppu_inidisp                                                     ; $019495 |/
    BPL -                                                                       ; $019497 | Loop until it becomes negative.
    LDA #%10000000.b                                                            ; $019499 |\
    STA reg_ppu_inidisp.l                                                       ; $01949B | | Set forced blanking on the PPU.
    STA <r_menu_ppu_inidisp                                                     ; $01949F |/
+   RTS                                                                         ; $0194A1

; _menu_init_and_set_bg_scroll ($01:94A2)
;
; Initializes the background scroll values and sets those values as the current
; scroll.
_menu_init_and_set_bg_scroll:
    JSR _menu_init_bg_scroll                                                    ; $0194A2 | Initialize the background scroll values.
    BRA _menu_set_bg_scroll_proxy                                               ; $0194A5 | Jump to set the scroll values.

; _menu_set_bg_scroll_proxy_* ($01:94AA)
;
; Proxy function to call the similarly named function in bank $14, which sets
; the current background scroll values for each of the four backgrounds. The
; _vblank entry point waits for vblank before setting the scroll values.
_menu_set_bg_scroll_proxy_vblank:
    JSR _menu_wait_for_vblank                                                   ; $0194A7
_menu_set_bg_scroll_proxy:
    JSL bank14.menu_set_bg_scroll_proxy                                         ; $0194AA
    RTS                                                                         ; $0194AE

; _menu_init_bg_scroll ($01:94AF)
;
; Initializes memory from $0189 to $01C0, which appears to primarily initialize
; the values of all the background scroll values to zero. Technically, this
; routine actually initializes 56 bytes starting from $0189 plus the 16-bit
; value at $0141. Much of the menu code implicitly treats $0141 as if it has the
; value of zero, however.
_menu_init_bg_scroll:
    PHX                                                                         ; $0194AF |\ Preserve the values of the X and direct registers.
    PHD                                                                         ; $0194B0 |/
    LDX #$0100.w                                                                ; $0194B1 |\
    PHX                                                                         ; $0194B4 | | Set the direct register to $0100.
    PLD                                                                         ; $0194B5 |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $0194B6 |\
    LDA #0.w                                                                    ; $0194B8 | | Write zeroes from $0189 to $01C0, which includes the area of RAM
    LDY #$001C.w                                                                ; $0194BB | | used for the menu background scroll register values.
    LDX <r_menu_zero                                                            ; $0194BE | |
-   STA <r_menu_scroll_bg2,X                                                    ; $0194C0 | | TODO: Is anything else in that area of interest, or did they
    INX                                                                         ; $0194C2 | |       simply allocate an area way too big?
    INX                                                                         ; $0194C3 | |
    DEY                                                                         ; $0194C4 | | NOTE: Seems to assume that $0141 is already set to zero, even
    BNE -                                                                       ; $0194C5 | |       though the caller doesn't do so until later.
    SEP #FLAG_P_ACCUMULATOR                                                     ; $0194C7 |/
    PLD                                                                         ; $0194C9 |\ Restore the direct and X registers to their original values.
    PLX                                                                         ; $0194CA |/
    RTS                                                                         ; $0194CB

; _menu_backup_cgram_1 ($01:94CC)
;
; Backs up the current CG-RAM mirror to the first backup location at $A200.
_menu_backup_cgram_1:
    REP #FLAG_P_ACCUMULATOR                                                     ; $0194CC |\
    LDA #_sizeof_r_menu_cgram_data.w / 2 - 1                                    ; $0194CE | | Copy the current palette data to the first backup location.
    LDX #r_menu_cgram_data.w                                                    ; $0194D1 | |
    LDY #r_menu_cgram_data_backup_1.w                                           ; $0194D4 | |
    MVN :r_menu_cgram_data,:r_menu_cgram_data_backup_1                          ; $0194D7 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $0194DA |/
    RTS                                                                         ; $0194DC

; _menu_backup_cgram_2 ($01:94DD)
;
; Backs up the current CG-RAM mirror to the second backup location at $A400.
_menu_backup_cgram_2:
    REP #FLAG_P_ACCUMULATOR                                                     ; $0194DD |\
    LDA #_sizeof_r_menu_cgram_data.w / 2 - 1                                    ; $0194DF | | Copy the current palette data to the second backup location.
    LDX #r_menu_cgram_data.w                                                    ; $0194E2 | |
    LDY #r_menu_cgram_data_backup_2.w                                           ; $0194E5 | |
    MVN :r_menu_cgram_data,:r_menu_cgram_data_backup_2                          ; $0194E8 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $0194EB |/
    RTS                                                                         ; $0194ED

; _menu_restore_cgram_1 ($01:94EE)
;
; Restores the CG-RAM mirror in memory from the first backup location at $A200.
_menu_restore_cgram_1:
    REP #FLAG_P_ACCUMULATOR                                                     ; $0194EE |\
    LDA #_sizeof_r_menu_cgram_data.w / 2 - 1                                    ; $0194F0 | | Restore the palette data from the first backup.
    LDX #r_menu_cgram_data_backup_1.w                                           ; $0194F3 | |
    LDY #r_menu_cgram_data.w                                                    ; $0194F6 | |
    MVN :r_menu_cgram_data_backup_1,:r_menu_cgram_data                          ; $0194F9 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $0194FC |/
    RTS                                                                         ; $0194FE

; _menu_restore_cgram_2 ($01:94FF)
;
; Restores the CG-RAM mirror in memory from the second backup location at $A400.
_menu_restore_cgram_2:
    REP #FLAG_P_ACCUMULATOR                                                     ; $0194FF |\
    LDA #_sizeof_r_menu_cgram_data.w / 2 - 1                                    ; $019501 | | Restore the palette data from the second backup.
    LDX #r_menu_cgram_data_backup_2.w                                           ; $019504 | |
    LDY #r_menu_cgram_data.w                                                    ; $019507 | |
    MVN :r_menu_cgram_data_backup_2,:r_menu_cgram_data                          ; $01950A | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01950D |/
    RTS                                                                         ; $01950F

; menu_bg_palette_offset_data ($01:9510)
;
; For each of the four backgrounds, listed in the in-memory order (BG2, BG1, BG4
; and BG3), determines the offset within the CG-RAM data for that background's
; palettes.
menu_bg_palette_offset_data:
    .db _sizeof_palette * 2                                                     ; $019510 | BG2
    .db _sizeof_palette * 0                                                     ; $019511 | BG1
    .db _sizeof_palette * 6                                                     ; $019512 | BG4
    .db _sizeof_palette * 4                                                     ; $019513 | BG3

; _menu_get_bg_palette_offset ($01:9514)
;
; Given a background number in the accumulator, returns the offset to that
; background's palette data relative to the start of CG-RAM in the X register
; and in $43. The background numbers are ordered in the in-memory order. In
; other words, 1 is BG2, 2 is BG1, 3 is BG4 and 4 is BG3. 0 would not return a
; useful value.
_menu_get_bg_palette_offset:
    DEC A                                                                       ; $019514 |\
    JSR _menu_transfer_a_to_x                                                   ; $019515 | | Set the X register to the offset for the given background.
    LDA menu_bg_palette_offset_data.l,X                                         ; $019518 | |
    STA <r_menu_generic_tmp_offset                                              ; $01951C | |
    LDX <r_menu_generic_tmp_offset                                              ; $01951E |/
    RTS                                                                         ; $019520

; _menu_erase_background_palette ($01:9521)
;
; Given a background number in the accumulator (where 1 is BG2, 2 is BG1, 3 is
; BG4 and 4 is BG3), erases that background's palette in the memory CG-RAM
; mirror.
_menu_erase_background_palette:
    PHA                                                                         ; $019521 | Preserve the accumulator value.
    JSR _menu_get_bg_palette_offset                                             ; $019522 | Set the X register to the offset to that background's palette data.
    LDA #_sizeof_palette.b                                                      ; $019525 |\
    STA <r_menu_erase_palette_tmp_count                                         ; $019527 | | Erase the palette by writing zeroes.
    TDC                                                                         ; $019529 | |
-   STA r_menu_cgram_data.w,X                                                   ; $01952A | |
    INX                                                                         ; $01952D | |
    DEC <r_menu_erase_palette_tmp_count                                         ; $01952E | |
    BNE -                                                                       ; $019530 |/
    PLA                                                                         ; $019532 | Restore the value of the accumulator.
    RTS                                                                         ; $019533

; _menu_portrait_transition_update ($01:9534)
;
; Updates the location of the character portrait in the menu, as part of a
; transition effect.
_menu_portrait_transition_update:
    LDA <r_menu_portrait_transition_frames_remaining                            ; $019534 |\
    BNE +                                                                       ; $019536 | | Return if the frames remaining is zero.
    RTS                                                                         ; $019538 |/
+   LDA <r_menu_portrait_transition_delta.x.value                               ; $019539 |\
    BPL +                                                                       ; $01953B | | If the high bit is set on the X delta value, add the X delta to
    AND #%01111111.b                                                            ; $01953D | | the X coordinate.
    STA <r_menu_portrait_transition_tmp                                         ; $01953F | |
    CLC                                                                         ; $019541 | |
    LDA <r_menu_portrait_transition_delta.x.fraction                            ; $019542 | |
    ADC <r_menu_portrait_transition_coordinates.x.fraction                      ; $019544 | |
    STA <r_menu_portrait_transition_coordinates.x.fraction                      ; $019546 | |
    LDA <r_menu_portrait_transition_coordinates.x.value                         ; $019548 | |
    ADC <r_menu_portrait_transition_tmp                                         ; $01954A | |
    STA <r_menu_portrait_transition_coordinates.x.value                         ; $01954C | |
    BRA ++                                                                      ; $01954E |/
+   LDA <r_menu_portrait_transition_coordinates.x.fraction                      ; $019550 |\
    SEC                                                                         ; $019552 | | If the high bit was not set, instead subtract the delta from the
    SBC <r_menu_portrait_transition_delta.x.fraction                            ; $019553 | | value.
    STA <r_menu_portrait_transition_coordinates.x.fraction                      ; $019555 | |
    LDA <r_menu_portrait_transition_coordinates.x.value                         ; $019557 | |
    SBC <r_menu_portrait_transition_delta.x.value                               ; $019559 | |
    STA <r_menu_portrait_transition_coordinates.x.value                         ; $01955B |/
++  LDA <r_menu_portrait_transition_delta.y.value                               ; $01955D |\
    BPL +                                                                       ; $01955F | | If the high bit is set on the Y delta value, add the Y delta to
    AND #%01111111.b                                                            ; $019561 | | the Y coordinate.
    STA <r_menu_portrait_transition_tmp                                         ; $019563 | |
    CLC                                                                         ; $019565 | |
    LDA <r_menu_portrait_transition_delta.y.fraction                            ; $019566 | |
    ADC <r_menu_portrait_transition_coordinates.y.fraction                      ; $019568 | |
    STA <r_menu_portrait_transition_coordinates.y.fraction                      ; $01956A | |
    LDA <r_menu_portrait_transition_coordinates.y.value                         ; $01956C | |
    ADC <r_menu_portrait_transition_tmp                                         ; $01956E | |
    STA <r_menu_portrait_transition_coordinates.y.value                         ; $019570 | |
    BRA ++                                                                      ; $019572 |/
+   LDA <r_menu_portrait_transition_coordinates.y.fraction                      ; $019574 |\
    SEC                                                                         ; $019576 | | Otherwise, subtract the delta from the coordinate.
    SBC <r_menu_portrait_transition_delta.y.fraction                            ; $019577 | |
    STA <r_menu_portrait_transition_coordinates.y.fraction                      ; $019579 | |
    LDA <r_menu_portrait_transition_coordinates.y.value                         ; $01957B | |
    SBC <r_menu_portrait_transition_delta.y.value                               ; $01957D | |
    STA <r_menu_portrait_transition_coordinates.y.value                         ; $01957F |/
++  LDA <r_menu_portrait_transition_coordinates.y.value                         ; $019581 |\
    XBA                                                                         ; $019583 | | Transfer the current coordinates into the Y register.
    LDA <r_menu_portrait_transition_coordinates.x.value                         ; $019584 | |
    TAY                                                                         ; $019586 |/
    LDA <r_menu_portrait_transition_character_slot                              ; $019587 |\ Draw the character portrait in its updated location.
    JSR _menu_draw_portrait                                                     ; $019589 |/
    DEC <r_menu_portrait_transition_frames_remaining                            ; $01958C | Decrement the frames remaining counter.
    RTS                                                                         ; $01958E

; _menu_get_selected_character_status_1 ($01:958F)
;
; Returns the first status byte of the currently selected character (such as in
; the magic menu).
_menu_get_selected_character_status_1:
    LDA <r_menu_current_selected_character_slot                                 ; $01958F |\
    JSR _menu_get_character_field_offset                                        ; $019591 | | Read the first status byte of the selected character.
    LDA character_field.status_1.w,X                                            ; $019594 |/
    RTS                                                                         ; $019597

; _menu_load_game ($01:9598)
;
; Does some basic initialization of the save menu system, and checks if there is
; a valid save. If so, displays the load game menu. Otherwise, simply returns.
_menu_load_game:
    PHB                                                                         ; $019598 |\ Save the current values of the direct and data bank registers.
    PHD                                                                         ; $019599 |/
    JSR _menu_backup_vram_tiles                                                 ; $01959A | Back up the area of VRAM used for text tiles.
    LDA #$7E                                                                    ; $01959D |\
    PHA                                                                         ; $01959F | | Set the data bank register to $7E.
    PLB                                                                         ; $0195A0 |/
    STZ r_menu_save_unfolding_done.w                                            ; $0195A1 | Reset the flag that indicates the save unfolding animation is done.
    LDX #SAVE_SIGNATURE.w                                                       ; $0195A4 |\
    CPX r_menu_load_signature.w                                                 ; $0195A7 | | If this load menu has not been initialized before, set the save
    BEQ +                                                                       ; $0195AA | | cursor index to zero and initialize the default controller
    STX r_menu_load_signature.w                                                 ; $0195AC | | configuration. Copy the save signature value into memory so this
    STZ r_menu_save_cursor_index.w                                              ; $0195AF | | code won't be executed again.
    JSR _set_default_custom_joypad_config                                       ; $0195B2 | | TODO: Is this right? Is this only to prevent calling this stuff
    JSR _initialize_joypad_maps                                                 ; $0195B5 |/        again if the player dies and this menu is displayed again?
+   JSR _menu_save_init                                                         ; $0195B8 | Initialize any invalid save slots.
    JSR _menu_save_check_for_valid_save_signature                               ; $0195BB |\
    BCS +                                                                       ; $0195BE | | If there is a save with a valid save signature, execute the load
    JSR _menu_load_game_menu_execute                                            ; $0195C0 | | game menu, and then call a function to initialize some variables.
    JSR _menu_init_first_non_empty_position                                     ; $0195C3 |/
+   JSR _menu_restore_vram_tiles                                                ; $0195C6 | Restore the backed up VRAM tiles.
    TDC                                                                         ; $0195C9 |\ Zero out the high byte of the accumulator.
    XBA                                                                         ; $0195CA |/
    LDA r_saved.l & $FFFF                                                       ; $0195CB | Load the saved flag into the accumulator.
    PLD                                                                         ; $0195CF |\ Restore the direct and data bank registers.
    PLB                                                                         ; $0195D0 |/
    RTS                                                                         ; $0195D1

; _menu_init_first_non_empty_position ($01:95D2)
;
; Initializes a few variables based on the the first non-empty character
; position, such as the item and magic targeting cursors.
_menu_init_first_non_empty_position:
    STZ <r_menu_save_tmp_slot.lo                                                ; $0195D2 | Initialize the current character position to zero.
-   LDA <r_menu_save_tmp_slot                                                   ; $0195D4 |\ Set the record offset for this position.
    JSR _menu_get_position_character_field_offset                               ; $0195D6 |/
    LDA character_field.id.w,X                                                  ; $0195D9 |\
    AND #%00111111.b                                                            ; $0195DC | | If this position is not empty, branch forward.
    BNE +                                                                       ; $0195DE |/
    INC <r_menu_save_tmp_slot.lo                                                ; $0195E0 |\
    LDA <r_menu_save_tmp_slot.lo                                                ; $0195E2 | | Otherwise, loop until all slots have been checked.
    CMP #5.b                                                                    ; $0195E4 | |
    BNE -                                                                       ; $0195E6 |/
+   LDA <r_menu_save_tmp_slot.lo                                                ; $0195E8 |\ Initialize the selected character position to this first filled
    STA <r_menu_current_selected_character_position                             ; $0195EA |/ position.
    STA r_menu_item_targeting_cursor_index.w                                    ; $0195EC | Initialize the item targeting cursor to that position.
    STA r_menu_magic_targeting_cursor_index.w                                   ; $0195EF | Initialize the magic targeting cursor to that position.
    LDX #-40.w                                                                  ; $0195F2 |\ Initialize the inventory scroll value to -40.
    STX r_menu_bg_scroll_vertical_bg1_backup.w                                  ; $0195F5 |/
    LDA r_config_joypad_map_index.w                                             ; $0195F8 |\ TODO
    STA <r_unknown_011c                                                         ; $0195FB |/
    RTS                                                                         ; $0195FD

; _menu_load_game_menu_execute ($01:95FE)
;
; Displays the menu to either start a new game or load an existing save. If
; loading an existing save, handles loading the data, and if starting a new
; game, handles initializing a new save.
_menu_load_game_menu_execute:
    LDA #AUDIO_TRACK_PRELUDE.b                                                  ; $0195FE |\
    STA r_play_audio_arg_track.w                                                ; $019600 | | Play the Prelude audio track.
    LDA #AUDIO_MODE_NORMAL.b                                                    ; $019603 | |
    STA r_play_audio_arg_mode.w                                                 ; $019605 | |
    JSL bank04.play_audio                                                       ; $019608 |/
    JSR _menu_init                                                              ; $01960C | Initialize the menu subsystem.
    LDA #%00110000.b                                                            ; $01960F |\ Set the sprite tile flags for priority 3.
    STA <r_menu_character_sprite_base_tile_flags                                ; $019611 |/
    JSR _menu_save_init                                                         ; $019613 | Initialize the invalid save slots.
    STZ r_menu_save_saving_enabled.w                                            ; $019616 | Configure the save menu for loading.
@loop_start:
    JSR _menu_initialize_tilemaps                                               ; $019619 | Initialize the tilemaps.
    JSR _menu_initialize_oam                                                    ; $01961C | Initialize the OAM.
    JSR _menu_copy_oam_to_ppu                                                   ; $01961F | Copy the OAM to the PPU.
    LDA r_menu_save_cursor_index.w                                              ; $019622 |\ Load the save data from the currently pointed to slot.
    JSR _menu_load_save_slot                                                    ; $019625 |/
    JSR _menu_load_character_sprites                                            ; $019628 | Load the character sprites.
    JSR _menu_save_update_character_sprites                                     ; $01962B | Update the character sprites.
    JSR _menu_save_draw_menu                                                    ; $01962E | Draw the save menu.
    JSR _menu_set_current_tilemap_bg2                                           ; $019631 |\
    LDY #menu_text_new_game_data.w                                              ; $019634 | | Draw the "New Game" text.
    JSR _menu_draw_text_indirect                                                ; $019637 |/
    JSR _menu_copy_tilemaps_to_vram                                             ; $01963A | Copy the tilemaps to VRAM.
    JSR _menu_save_fade_in                                                      ; $01963D | Fade in the save menu.
    JSR _menu_save_main_loop                                                    ; $019640 | Execute the main save menu loop.
    LDA r_menu_save_cursor_index.w                                              ; $019643 |\
    BNE +                                                                       ; $019646 | | If the cursor is on "New Game", jump to the new game code.
    JMP _menu_save_new_game                                                     ; $019648 |/
+   JSR _menu_save_load_confirm_execute                                         ; $01964B | Otherwise, display the confirmation screen to confirm the load.
    BCC +                                                                       ; $01964E |\
    JSR _menu_set_custom_joypad                                                 ; $019650 | | If the player confirmed the load, set the custom joypad values
    JSR _audio_set_stereo_mono                                                  ; $019653 | | from the save, set the audio mode, and fade out the confirm menu.
    JMP _menu_ppu_fade_out                                                      ; $019656 |/
+   JSR _menu_ppu_fade_out                                                      ; $019659 |\ Otherwise, simply fade out the confirm menu and branch back to
    JMP @loop_start                                                             ; $01965C |/ display the load menu again.

; _menu_save_main_loop ($01:965F)
;
; This is the main loop for the save/load menu. Sets the carry flag if the
; player presses the confirm button on an option, and clears the carry flag if
; the player presses the cancel button.
_menu_save_main_loop:
    LDA r_menu_save_cursor_index.w                                              ; $01965F |\
    CMP #5.b                                                                    ; $019662 | | If the save cursor index is five or greater, reset it to zero.
    BCC +                                                                       ; $019664 | |
    STZ r_menu_save_cursor_index.w                                              ; $019666 |/
+   JSR _menu_wait_for_vblank_copy_oam_to_ppu                                   ; $019669 | Wait for vblank and copy the OAM to the PPU.
    JSR _menu_copy_palette_to_cgram                                             ; $01966C | Copy the palette to CG-RAM.
    LDA #%00011111.b                                                            ; $01966F |\ Set the main screens to BG1, BG2, BG3, BG4 and sprites.
    STA reg_ppu_tm.l                                                            ; $019671 |/
    INC r_menu_save_frame_counter.w                                             ; $019675 | Increment a save menu frame counter.
    JSR _menu_update_joypad_and_play_sound_effect                               ; $019678 | Update the joypad and play a sound effect if appropriate.
    LDA <r_menu_joypad_repeat.lo                                                ; $01967B |\
    AND #JOYPAD_L_A.b                                                           ; $01967D | | If the A button is pressed, set the carry flag and return.
    BEQ +                                                                       ; $01967F | |
    SEC                                                                         ; $019681 | |
    RTS                                                                         ; $019682 |/
.if FF4_VERSION == "JAPAN_EASYTYPE"
+   LDA <r_menu_joypad_repeat.hi                                                ; $01967D |\
    AND #JOYPAD_H_B.b                                                           ; $01967F | | If the B button is pressed, clear the carry flag and return.
    BEQ +                                                                       ; $019681 | | This only applies to Easytype.
    CLC                                                                         ; $019683 | |
    RTS                                                                         ; $019684 |/
.endif
+   LDA <r_menu_joypad_repeat.hi                                                ; $019683 |\
    AND #JOYPAD_H_UP.b                                                          ; $019685 | | If the up d-pad button is not pressed, branch to check down.
    BEQ @check_down                                                             ; $019687 |/
    LDA #%00001111.b                                                            ; $019689 |\ Remove the sprites as a main screen.
    STA reg_ppu_tm.l                                                            ; $01968B |/
-   LDA r_menu_save_saving_enabled.w                                            ; $01968F |\
    BEQ +                                                                       ; $019692 | | If saving mode is enabled, decrement the cursor index, and if it
    LDA r_menu_save_cursor_index.w                                              ; $019694 | | reaches zero, branch to reset it to four. Otherwise, branch to
    DEC A                                                                       ; $019697 | | save the updated index.
    BEQ ++                                                                      ; $019698 | |
    BRA +++                                                                     ; $01969A |/
+   LDA r_menu_save_cursor_index.w                                              ; $01969C |\
    DEC A                                                                       ; $01969F | | If saving mode is not enabled, decrement the cursor index, and if
    BPL +++                                                                     ; $0196A0 | | it goes negative, reset it to four.
++  LDA #4.b                                                                    ; $0196A2 |/
+++ STA r_menu_save_cursor_index.w                                              ; $0196A4 | Save the updated index.
    JSR _menu_save_check_cursor_valid                                           ; $0196A7 |\ If the currently pointed to save is not valid, branch to decrement
    BCC -                                                                       ; $0196AA |/ again.
    BRA ++                                                                      ; $0196AC | Otherwise, branch forward past the down check.
@check_down:
    LDA <r_menu_joypad_repeat.hi                                                ; $0196AE |\
    AND #JOYPAD_H_DOWN.b                                                        ; $0196B0 | | If the down d-pad button is not pressed, branch to check cancel.
    BEQ @check_cancel                                                           ; $0196B2 |/
    LDA #%00001111.b                                                            ; $0196B4 |\ Unset sprites as being part of the main screen.
    STA reg_ppu_tm.l                                                            ; $0196B6 |/
-   LDA r_menu_save_cursor_index.w                                              ; $0196BA |\ Increment the cursor index.
    INC A                                                                       ; $0196BD |/
    CMP #5.b                                                                    ; $0196BE |\
    BNE +                                                                       ; $0196C0 | | If the cursor reaches five, set it to 0 if saving is not enabled
    LDA r_menu_save_saving_enabled.w                                            ; $0196C2 | | and 1 if it is.
+   STA r_menu_save_cursor_index.w                                              ; $0196C5 |/
    JSR _menu_save_check_cursor_valid                                           ; $0196C8 |\ If the cursor is not valid, branch to increment again.
    BCC -                                                                       ; $0196CB |/
++  LDA r_menu_save_cursor_index.w                                              ; $0196CD |\
    JSR _menu_load_save_slot                                                    ; $0196D0 | | If the cursor index changed, load the new save slot and update the
    JSR _menu_load_character_sprites                                            ; $0196D3 | | character sprites for the new slot.
    JSR _menu_save_update_character_sprites                                     ; $0196D6 |/
@check_cancel:
.if FF4_VERSION != "JAPAN_EASYTYPE"
    LDA <r_menu_joypad_repeat.hi                                                ; $0196D9 |\
    AND #JOYPAD_H_B.b                                                           ; $0196DB | | If the B button is pressed, clear the carry flag and return. The
    BEQ +                                                                       ; $0196DD | | Easytype version did this check earlier in the routine.
    CLC                                                                         ; $0196DF | |
    RTS                                                                         ; $0196E0 |/
.endif
+   JMP _menu_save_main_loop                                                    ; $0196E1 | Jump to the beginning of the loop.

; _menu_save_draw_menu ($01:96E4)
;
; Draws the save menu, including drawing the four save slots.
_menu_save_draw_menu:
    JSR _menu_set_palette_window_color                                          ; $0196E4 | Set the window color in the palette.
    REP #FLAG_P_ACCUMULATOR                                                     ; $0196E7 |\
    LDA s_save_slots.1.window_color.l                                           ; $0196E9 | | Transfer the window colors for the four save slots to the CG-RAM
    STA r_menu_cgram_data.3.color2.w                                            ; $0196ED | | mirror.
    STA r_menu_cgram_data.3.color6.w                                            ; $0196F0 | |
    LDA s_save_slots.2.window_color.l                                           ; $0196F3 | |
    STA r_menu_cgram_data.1.color2.w                                            ; $0196F7 | |
    STA r_menu_cgram_data.1.color6.w                                            ; $0196FA | |
    LDA s_save_slots.3.window_color.l                                           ; $0196FD | |
    STA r_menu_cgram_data.7.color2.w                                            ; $019701 | |
    STA r_menu_cgram_data.7.color6.w                                            ; $019704 | |
    LDA s_save_slots.4.window_color.l                                           ; $019707 | |
    STA r_menu_cgram_data.5.color2.w                                            ; $01970B | |
    STA r_menu_cgram_data.5.color6.w                                            ; $01970E | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $019711 |/
    TDC                                                                         ; $019713 |\
    JSR _menu_save_draw_slot                                                    ; $019714 | | Draw the four save slots.
    JSR _menu_save_draw_slot                                                    ; $019717 | |
    JSR _menu_save_draw_slot                                                    ; $01971A | |
    JSR _menu_save_draw_slot                                                    ; $01971D |/
    LDX #$4000.w                                                                ; $019720 |\ Copy a dark blue color to CG-RAM.
    STX r_menu_cgram_data.2.color2.w                                            ; $019723 |/ NOTE: This sets palette 4 for BG1, but nothing uses that on BG1.
    LDA <r_menu_current_tilemap_base_tile_flags                                 ; $019726 |\ Preserve the existing base tile flags.
    PHA                                                                         ; $019728 |/
    JSR _menu_set_current_tilemap_bg2                                           ; $019729 | Set the current tilemap to BG2.
    LDA #%00110000.b                                                            ; $01972C |\ Set the tile flags for priority 1 and palette 4.
    STA <r_menu_current_tilemap_base_tile_flags                                 ; $01972E |/
    LDY #menu_window_save_new_game_data.w                                       ; $019730 |\ Draw the new game window.
    JSR _menu_configure_and_draw_window                                         ; $019733 |/
    PLA                                                                         ; $019736 |\ Restore the original base tile flags.
    STA <r_menu_current_tilemap_base_tile_flags                                 ; $019737 |/
    JMP _menu_copy_palette_to_cgram                                             ; $019739 | Copy the palette to CG-RAM and return.

; _menu_format_and_draw_time ($01:973C)
;
; Given a time value in seconds, with the low byte in the accumulator and the
; high two bytes in the X register, formats and displays it as a time in the
; format HHHH:MM and draws it to the tilemap at the address passed in the Y
; register.
_menu_format_and_draw_time:
    PHY                                                                         ; $01973C | Preserve the value in the Y register.
    STA <r_menu_divide_by_60_arg_value.lo                                       ; $01973D |\ Store the argument values to the division argument variables.
    STX <r_menu_divide_by_60_arg_value.md                                       ; $01973F |/
    PHB                                                                         ; $019741 |\
    LDA #$7E.b                                                                  ; $019742 | | Set the data bank register to $7E.
    PHA                                                                         ; $019744 | |
    PLB                                                                         ; $019745 |/
    JSR _menu_divide_by_60                                                      ; $019746 |\ Divide the argument by 3600, discarding the original remainder. The
    JSR _menu_divide_by_60                                                      ; $019749 |/ remainder will be the remainder from the second division.
    LDX <r_menu_divide_by_60_arg_value.lo                                       ; $01974C | Transfer the low two bytes of the result into the X register.
    LDA <r_menu_divide_by_60_remainder                                          ; $01974E |\ Format the remainder as a number.
    JSR _menu_format_two_digit_number                                           ; $019750 |/
    CMP #TILE_MENU_WINDOW_BLANK.b                                               ; $019753 |\
    BNE +                                                                       ; $019755 | | If the tens digit is blank, replace it with a zero.
    LDA #TILE_MENU_NUMBER_BASE.b                                                ; $019757 |/
+   STA (5 * 2).w,Y                                                             ; $019759 |\
    XBA                                                                         ; $01975C | | Write the minutes value to the tilemap.
    STA (6 * 2).w,Y                                                             ; $01975D |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $019760 |\
    LDA <r_menu_divide_by_60_arg_value.lo                                       ; $019762 | | Format the hours value as a four digit number.
    SEP #FLAG_P_ACCUMULATOR                                                     ; $019764 | |
    JSR _menu_format_four_digit_number                                          ; $019766 |/
    LDA <r_menu_format_four_digit_number_result + 0                             ; $019769 |\
    STA (0 * 2).w,Y                                                             ; $01976B | | Copy the four digits of the hours to the tilemap.
    LDA <r_menu_format_four_digit_number_result + 1                             ; $01976E | |
    STA (1 * 2).w,Y                                                             ; $019770 | |
    LDA <r_menu_format_four_digit_number_result + 3                             ; $019773 | |
    STA (2 * 2).w,Y                                                             ; $019775 | |
    LDA <r_menu_format_four_digit_number_result + 4                             ; $019778 | |
    STA (3 * 2).w,Y                                                             ; $01977A |/
    LDA #TEXT_COLON.b                                                           ; $01977D |\ Copy the colon to the tilemap, in between the hours and minutes.
    STA (4 * 2).w,Y                                                             ; $01977F |/
    PLB                                                                         ; $019782 |\ Restore the data bank and Y registers.
    PLY                                                                         ; $019783 |/
    RTS                                                                         ; $019784

; _menu_load_save_slot ($01:9785)
;
; Given a number in the accumulator ranging from 0 to 4, either initializes the
; characters in a new save (if the value is zero) or copies the entire saved
; data from the associated slot (if the value is 1 to 4)..
_menu_load_save_slot:
    DEC A                                                                       ; $019785 | Decrement the argument to convert it to a true save slot number.
    BMI _init_characters                                                        ; $019786 | If the original value was zero, branch to initialize a fresh save.
    ASL A                                                                       ; $019788 |\
    ASL A                                                                       ; $019789 | | Otherwise, set the source address by multiplying the save slot by
    ASL A                                                                       ; $01978A | | $800.
    STA <r_menu_generic_tmp_word.hi                                             ; $01978B | |
    STZ <r_menu_generic_tmp_word.lo                                             ; $01978D |/
    PHB                                                                         ; $01978F |\
    REP #FLAG_P_ACCUMULATOR                                                     ; $019790 | | Copy the saved data to memory.
    LDX <r_menu_generic_tmp_word                                                ; $019792 | |
    LDY #r_character_field.w                                                    ; $019794 | |
    LDA #_sizeof_save_slot.w - 1                                                ; $019797 | |
    MVN :s_save_slots,$00                                                       ; $01979A | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01979D | |
    PLB                                                                         ; $01979F |/
    RTS                                                                         ; $0197A0

; _init_characters ($01:97A1)
;
; Copies the default character names from ROM into memory, initializes Cecil,
; sets Cecil's HP and maximum HP to zero, and ensures the remaining four slots
; are empty.
_init_characters:
    PHB                                                                         ; $0197A1 |\
    REP #FLAG_P_ACCUMULATOR                                                     ; $0197A2 | | Transfer the default character names from ROM to memory.
    LDX #bank0F.character_names_data.w                                          ; $0197A4 | |
    LDY #r_character_names.w                                                    ; $0197A7 | |
    LDA #bank0F._sizeof_character_names_data.w - 1                              ; $0197AA | |
    MVN :bank0F.character_names_data,$00                                        ; $0197AD | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $0197B0 | |
    PLB                                                                         ; $0197B2 |/
    PHB                                                                         ; $0197B3 | Preserve the value of the data bank register.
    PHD                                                                         ; $0197B4 |\
    TDC                                                                         ; $0197B5 | | Set the data bank register to $00.
    PHA                                                                         ; $0197B6 | |
    PLB                                                                         ; $0197B7 |/
    XBA                                                                         ; $0197B8 | Set the high byte of the accumulator to zero.
    LDX #$0600.w                                                                ; $0197B9 |\
    PHX                                                                         ; $0197BC | | Set the direct register to $0600.
    PLD                                                                         ; $0197BD |/
    JSL bank00.init_cecil_proxy                                                 ; $0197BE | Initialize Cecil.
    PLD                                                                         ; $0197C2 |\ Restore the original values of the direct and data bank
    PLB                                                                         ; $0197C3 |/ registers.
    LDX <r_menu_zero                                                            ; $0197C4 |\
    STX r_character_field.1.hp.w                                                ; $0197C6 | | Initialize the HP of slot zero to zero and ensure the other four
    STX r_character_field.1.hp_max.w                                            ; $0197C9 | | slots are empty.
    STZ r_character_field.2.id.w                                                ; $0197CC | |
    STZ r_character_field.3.id.w                                                ; $0197CF | | NOTE: This actually reads $0641 instead of $0141 in at least one
    STZ r_character_field.4.id.w                                                ; $0197D2 | |       case. This doesn't seem to matter, since it has the value of
    STZ r_character_field.5.id.w                                                ; $0197D5 |/        zero at the relevant time.
    RTS                                                                         ; $0197D8

; _menu_save_load_confirm_execute ($01:97D9)
;
; Handles the confirmation dialog to either load or save. (Loading or saving
; specific changes are determined by the flag at $1B47.) If the user confirms
; their selection, the carry flag is set. Otherwise, it is cleared.
_menu_save_load_confirm_execute:
    JSR _menu_ppu_fade_out                                                      ; $0197D9 | Fade out the PPU.
    JSR _menu_init_and_set_bg_scroll                                            ; $0197DC | Initialize and set the background scroll registers.
    JSR _menu_initialize_tilemaps                                               ; $0197DF | Initialize the tilemaps.
    JSR _menu_copy_tilemaps_to_vram                                             ; $0197E2 | Copy the tilemaps to VRAM.
    JSR _menu_initialize_oam                                                    ; $0197E5 | Initialize the OAM.
    JSR _menu_set_current_tilemap_bg3                                           ; $0197E8 | Set the current tilemap to BG3.
    JSR _menu_load_portraits                                                    ; $0197EB | Load the character portraits.
    LDX #SAVE_SIGNATURE.w                                                       ; $0197EE |\
    CPX r_signature.w                                                           ; $0197F1 | | If the save signature of the save is valid, draw the party details
    BNE +                                                                       ; $0197F4 | | window to show the save details.
    JSR _menu_draw_party_window                                                 ; $0197F6 | |
    BRA ++                                                                      ; $0197F9 |/
+   JSR _menu_set_current_tilemap_bg3                                           ; $0197FB |\
    LDY #menu_window_party_details_data.w                                       ; $0197FE | | Otherwise, draw the party details window and simply print "Empty"
    JSR _menu_configure_and_draw_window                                         ; $019801 | | inside it.
    LDX #(10 * 2 + 14 * 32 * 2).w                                               ; $019804 | |
    LDY #menu_text_empty_direct_data.w                                          ; $019807 | |
    JSR _menu_draw_text_direct                                                  ; $01980A |/
++  JSR _menu_copy_oam_to_ppu                                                   ; $01980D | Copy the OAM to the PPU.
    JSR _menu_set_current_tilemap_bg4                                           ; $019810 | Set the current tilemap to BG4.
    LDY #menu_window_save_time_data.w                                           ; $019813 |\ Draw the window to display the game time.
    JSR _menu_configure_and_draw_window                                         ; $019816 |/
    LDY #menu_window_save_confirm_data.w                                        ; $019819 |\ Draw the window to display the confirmation choice.
    JSR _menu_configure_and_draw_window                                         ; $01981C |/
    LDA r_menu_save_saving_enabled.w                                            ; $01981F |\
    BEQ +                                                                       ; $019822 | | Depending on if saving is enabled or not, display either the save
    LDY #menu_text_save_confirm_data.w                                          ; $019824 | | or load confirmation text.
    JSR _menu_draw_text_indirect                                                ; $019827 | |
    BRA ++                                                                      ; $01982A | |
+   LDY #menu_text_load_confirm_data.w                                          ; $01982C | |
    JSR _menu_draw_text_indirect                                                ; $01982F |/
++  LDY #menu_text_save_yes_no_data.w                                           ; $019832 |\ Either way, draw the Yes and No options.
    JSR _menu_draw_text_indirect                                                ; $019835 |/
    LDA r_game_time.seconds_lo.w                                                ; $019838 |\
    LDX r_game_time.seconds_md.w                                                ; $01983B | | Draw the game time to 23, 20.
    LDY #r_menu_tilemap_bg4.w + 23 * 2 + 20 * 32 * 2                            ; $01983E | |
    JSR _menu_format_and_draw_time                                              ; $019841 |/
    LDY #menu_text_save_time_data.w                                             ; $019844 |\ Draw the "Time" label to the time window.
    JSR _menu_draw_text_indirect                                                ; $019847 |/
    JSR _menu_set_current_tilemap_bg1                                           ; $01984A | Set the current tilemap to BG1.
    LDY #menu_window_save_gp_data.w                                             ; $01984D |\ Draw the window for displaying GP.
    JSR _menu_configure_and_draw_window                                         ; $019850 |/
    LDY #menu_text_shop_party_gp_text_only_data.w                               ; $019853 |\
    LDX #(28 * 2 + 25 * 32 * 2).w                                               ; $019856 | | Draw the "GP" text to 28, 25.
    JSR _menu_draw_text_direct                                                  ; $019859 |/
    LDY #(22 * 2 + 24 * 32 * 2).w                                               ; $01985C |\
    LDA r_party_gp.hi.w                                                         ; $01985F | | Draw the party GP value to 22, 24.
    LDX r_party_gp.lo.w                                                         ; $019862 | |
    JSR _menu_draw_number_as_decimal                                            ; $019865 |/
    JSR _menu_copy_tilemaps_to_vram                                             ; $019868 | Copy the updated tilemaps to VRAM.
    JSR _menu_set_palette_window_color                                          ; $01986B | Set the configured window color in the palettes.
    JSR _menu_copy_palette_to_cgram                                             ; $01986E | Copy the palette data to CG-RAM.
    JSR _menu_ppu_fade_in                                                       ; $019871 | Fade the PPU in.
    STZ r_menu_save_confirm_cursor_index.w                                      ; $019874 | Initialize the cursor index to zero.
@loop_start:
    LDA r_menu_save_confirm_cursor_index.w                                      ; $019877 |\
    BEQ +                                                                       ; $01987A | | Draw the cursor at either 64, 184 or 48, 184, depending on the
    LDA #64.b                                                                   ; $01987C | | current value of the cursor index.
    BRA ++                                                                      ; $01987E | |
+   LDA #48.b                                                                   ; $019880 | |
++  STA <r_menu_draw_cursor_arg_coordinates.y                                   ; $019882 | |
    LDA #184.b                                                                  ; $019884 | |
    STA <r_menu_draw_cursor_arg_coordinates.x                                   ; $019886 | |
    JSR _menu_draw_cursor_1                                                     ; $019888 |/
    JSR _menu_wait_for_vblank_copy_oam_to_ppu                                   ; $01988B | Wait for vblank and copy the OAM to the PPU.
    JSR _menu_update_joypad_and_play_sound_effect                               ; $01988E | Update the joypad values and play a sound effect if appropriate.
    LDA <r_menu_joypad_repeat.hi                                                ; $019891 |\
    AND #(JOYPAD_H_UP | JOYPAD_H_DOWN).b                                        ; $019893 | | If either up or down is pressed on the d-pad, update the cursor
    BEQ +                                                                       ; $019895 | | index by alternating between either 0 or 1.
    LDA r_menu_save_confirm_cursor_index.w                                      ; $019897 | |
    INC A                                                                       ; $01989A | |
    AND #%00000001.b                                                            ; $01989B | |
    STA r_menu_save_confirm_cursor_index.w                                      ; $01989D |/
+   LDA <r_menu_joypad_repeat.lo                                                ; $0198A0 |\
    AND #JOYPAD_L_A.b                                                           ; $0198A2 | | If the A button is pressed, set the carry flag and return if the
    BEQ ++                                                                      ; $0198A4 | | player chose "Yes" and clear the carry flag and return if "No".
    SEC                                                                         ; $0198A6 | |
    LDA r_menu_save_confirm_cursor_index.w                                      ; $0198A7 | |
    BEQ +                                                                       ; $0198AA | |
    CLC                                                                         ; $0198AC | |
+   RTS                                                                         ; $0198AD |/
++  LDA <r_menu_joypad_repeat.hi                                                ; $0198AE |\
    AND #JOYPAD_H_B.b                                                           ; $0198B0 | | If the B button is pressed, clear the carry flag and return.
    BEQ +                                                                       ; $0198B2 | |
    CLC                                                                         ; $0198B4 | |
    RTS                                                                         ; $0198B5 |/
+   JMP @loop_start                                                             ; $0198B6 | Jump to the start of the loop.

; _menu_copy_character_sprite_palettes_to_cgram ($01:98B9)
;
; Copies the character sprite palettes stored in the array at $FE28 to CG-RAM,
; starting with the 12th palette.
_menu_copy_character_sprite_palettes_to_cgram:
    REP #FLAG_P_ACCUMULATOR                                                     ; $0198B9 |\
    LDX #r_menu_character_sprite_palettes.w                                     ; $0198BB | | Copy the five character sprite palettes to the menu CG-RAM staging
    LDY #r_menu_cgram_data.12.w                                                 ; $0198BE | | area.
    LDA #_sizeof_palette.w * 5 - 1                                              ; $0198C1 | |
    MVN :r_menu_character_sprite_palettes.b,:r_menu_cgram_data.b                ; $0198C4 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $0198C7 |/
    JSR _menu_wait_for_vblank                                                   ; $0198C9 | Wait for vblank.
    JMP _menu_copy_palette_to_cgram                                             ; $0198CC | Copy the palette to CG-RAM.

; _menu_save_update_character_sprites ($01:98CF)
;
; Updates the character sprites visible on the save menu.
_menu_save_update_character_sprites:
    LDA #%00110000.b                                                            ; $0198CF |\ Set the character sprite tile flags for priority 3.
    STA <r_menu_character_sprite_base_tile_flags                                ; $0198D1 |/
    JSR _menu_copy_character_sprite_palettes_to_cgram                           ; $0198D3 | Copy the character sprite palettes to CG-RAM.
    JSR _menu_initialize_oam                                                    ; $0198D6 | Initialize the OAM.
    TDC                                                                         ; $0198D9 |\ Initialize the slot to zero.
    STA <r_menu_update_character_sprite_arg_properties.slot                     ; $0198DA |/
    TDC                                                                         ; $0198DC |\ Initialize the pose to normal.
    STA <r_menu_update_character_sprite_arg_properties.pose                     ; $0198DD |/
    LDA r_menu_save_cursor_index.w                                              ; $0198DF |\
    ASL A                                                                       ; $0198E2 | | Set the character sprite coordinates for the currently selected
    JSR _menu_transfer_a_to_x                                                   ; $0198E3 | | slot.
    REP #FLAG_P_ACCUMULATOR                                                     ; $0198E6 | |
    LDA menu_save_character_sprite_coordinates_data.l,X                         ; $0198E8 | |
    STA <r_menu_update_character_sprite_arg_properties.coordinates              ; $0198EC | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $0198EE |/
    LDA #5.b                                                                    ; $0198F0 |\ Initialize the count to five.
    STA <r_menu_save_tmp_count                                                  ; $0198F2 |/
-   JSR _menu_update_character_sprite                                           ; $0198F4 | Update the character slot in the current slot.
    REP #FLAG_P_ACCUMULATOR                                                     ; $0198F7 |\
    LDA #24.w                                                                   ; $0198F9 | | Update the coordinates to move 24 pixels to the right.
    CLC                                                                         ; $0198FC | |
    ADC <r_menu_update_character_sprite_arg_properties.coordinates.x            ; $0198FD | |
    STA <r_menu_update_character_sprite_arg_properties.coordinates.x            ; $0198FF | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $019901 |/
    INC <r_menu_update_character_sprite_arg_properties.slot                     ; $019903 | Increment the slot.
    DEC <r_menu_save_tmp_count                                                  ; $019905 |\ Loop until all five potential characters have been drawn.
    BNE -                                                                       ; $019907 |/
    RTS                                                                         ; $019909

; menu_save_character_sprite_coordinates_data ($01:990A)
;
; For each potential save slot (including the new game slot at the top) on the
; save screen, determines the coordinates to place the character sprites for
; that slot.
menu_save_character_sprite_coordinates_data:
.if FF4_REGION == "JAPAN"
    .db 78, 4                                                                   ; $019904.9905
.else
    .db 108, 4                                                                  ; $01990A.990B
.endif
    .db 120, 40                                                                 ; $01990C.990D
    .db 120, 88                                                                 ; $01990E.990F
    .db 120, 136                                                                ; $019910.9911
    .db 120, 184                                                                ; $019912.9913

; _menu_save_new_game ($01:9914)
;
; Handles selecting New Game on the save menu. Fades out the save menu,
; initializes the save data and then falls through to the next function which
; initializes the save signature and initializes the custom joypad mappings.
_menu_save_new_game:
    JSR _menu_ppu_fade_out                                                      ; $019914 | Fade out the PPU.
    JSR _initialize_save_data                                                   ; $019917 | Initialize the save data for a new game.
    JSR _audio_set_stereo_mono                                                  ; $01991A | Set the audio to either stereo or mono as configured.

; _initialize_save_signature_and_joypad ($01:991D)
;
; Initializes the save signature and save flag for the current data in memory,
; and then falls through to the next function which initializes the default
; custom joypad mappings.
_initialize_save_signature_and_joypad:
    REP #FLAG_P_ACCUMULATOR                                                     ; $01991D |\
    LDA #SAVE_SIGNATURE.w                                                       ; $01991F | | Initialize the signature to the valid save signature value.
    STA r_signature.w                                                           ; $019922 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $019925 |/
    STZ r_saved.w                                                               ; $019927 | Reset the flag that indicates this game has been saved.

; _set_default_custom_joypad_config ($01:992A)
;
; Initializes the default custom joypad mappings. While these aren't
; configurable in the U.S. version, the code remains intact. The values
; themselves reference tables at $14:FE79 and $14:FE7E.
_set_default_custom_joypad_config:
    REP #FLAG_P_ACCUMULATOR                                                     ; $01992A | Switch to 16-bit accumulator mode.
    LDA #$0100.w                                                                ; $01992C |\
    STA r_joypad_custom_confirm.w                                               ; $01992F | | Set the confirm button to A and the cancel button to B.
    STA r_config_joypad_confirm.w                                               ; $019932 |/
    LDA #$0002.w                                                                ; $019935 |\
    STA r_config_joypad_menu.w                                                  ; $019938 | | Set the menu button to X and ignore the L button.
    STA r_joypad_custom_menu.w                                                  ; $01993B |/
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01993E | Switch back to 8-bit accumulator mode.
    LDA #$00.b                                                                  ; $019940 |\
    STA r_joypad_custom_start.w                                                 ; $019942 | | Ignore the start button.
    STA r_config_joypad_start.w                                                 ; $019945 |/
    RTS                                                                         ; $019948

; _menu_save_check_cursor_valid ($01:9949)
;
; Sets the carry flag if the currently pointed to cursor index is valid. If in
; saving mode, then all accessible positions are valid, so the carry flag will
; always be set. If not in saving mode, will set the carry flag if the cursor
; is set to zero (New Game) or if the save being pointed to is valid. Otherwise,
; clears the carry flag. Falls through to the next routine to check the validity
; of the save if necessary.
_menu_save_check_cursor_valid:
    LDA r_menu_save_saving_enabled.w                                            ; $019949 |\
    BNE +                                                                       ; $01994C | | If the menu is in saving mode or if the cursor is set to zero, set
    LDA r_menu_save_cursor_index.w                                              ; $01994E | | the carry flag and return.
    BNE ++                                                                      ; $019951 | |
+   SEC                                                                         ; $019953 | |
    RTS                                                                         ; $019954 |/
++  DEC A                                                                       ; $019955 | Decrement the cursor to get the save index and then fall through.

; _menu_save_check_valid ($01:9956)
;
; Given a save slot number, ranging from 0 to 3, in the accumulator, determines
; if that save is valid by checking for the signature and validating that its
; checksum is correct. If so, sets the carry flag. Otherwise, clears the carry
; flag.
_menu_save_check_valid:
    STA <r_menu_save_check_valid_tmp_slot                                       ; $019956 | Save the passed save slot.
    ASL A                                                                       ; $019958 |\
    ASL A                                                                       ; $019959 | | Calculate the offset to the corresponding save data by multiplying
    ASL A                                                                       ; $01995A | | by $800.
    STA <r_menu_generic_tmp_word.hi                                             ; $01995B | |
    STZ <r_menu_generic_tmp_word.lo                                             ; $01995D |/
    LDX <r_menu_generic_tmp_word                                                ; $01995F |\
    REP #FLAG_P_ACCUMULATOR                                                     ; $019961 | | If the save signature bytes matches the signature value, branch to
    LDA s_save_slots.1.signature.l,X                                            ; $019963 | | the next step.
    TAY                                                                         ; $019967 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $019968 | |
    CPY #SAVE_SIGNATURE.w                                                       ; $01996A | |
    BEQ +                                                                       ; $01996D |/
-   SEP #FLAG_P_ACCUMULATOR                                                     ; $01996F |\
    CLC                                                                         ; $019971 | | Otherwise, clear the carry flag and return.
    RTS                                                                         ; $019972 |/
+   LDA <r_menu_save_check_valid_tmp_slot                                       ; $019973 |\
    INC A                                                                       ; $019975 | | Calculate the checksum for this save slot.
    JSR _menu_save_get_checksum                                                 ; $019976 |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $019979 |\
    TXA                                                                         ; $01997B | | If the stored checksum does not match the calculated checksum,
    LDX <r_menu_generic_tmp_word                                                ; $01997C | | branch to clear the carry flag and return.
    CMP s_save_slots.1.checksum.l,X                                             ; $01997E | |
    BNE -                                                                       ; $019982 |/
    SEP #FLAG_P_ACCUMULATOR                                                     ; $019984 |\ Otherwise, set the carry flag and return.
    SEC                                                                         ; $019986 |/
    RTS                                                                         ; $019987

; _menu_save_init ($01:9988)
;
; Initializes any invalid save slots with basic data and a darker blue window
; color.
_menu_save_init:
    JSR _init_characters                                                        ; $019988 | Initialize the characters.
    STZ <r_menu_save_tmp_slot.lo                                                ; $01998B |\ Initialize the save slot number to zero.
    STZ <r_menu_save_tmp_slot.hi                                                ; $01998D |/
-   LDA <r_menu_save_tmp_slot                                                   ; $01998F |\ Load the current save slot number and check if it's valid or not.
    JSR _menu_save_check_valid                                                  ; $019991 |/
    BCS +                                                                       ; $019994 | If so, branch to skip this slot.
    REP #FLAG_P_ACCUMULATOR                                                     ; $019996 |\
    PHB                                                                         ; $019998 | | Otherwise, multiply the slot number by $800 to get the offset to
    LDA <r_menu_save_tmp_slot                                                   ; $019999 | | the save data and store it in the Y register.
    XBA                                                                         ; $01999B | |
    ASL A                                                                       ; $01999C | |
    ASL A                                                                       ; $01999D | |
    ASL A                                                                       ; $01999E | |
    TAY                                                                         ; $01999F |/
    PHY                                                                         ; $0199A0 | Push the slot offset to the stack.
    LDX #r_character_field.w                                                    ; $0199A1 |\
    LDA #_sizeof_save_slot.w - 1                                                ; $0199A4 | | Copy the current data to the save slot.
    MVN :r_character_field,:s_save_slots                                        ; $0199A7 |/
    PLX                                                                         ; $0199AA |\
    LDA #((8 << 10) + (0 << 5) + 0).w                                           ; $0199AB | | Set that save slot's window color to a darker blue color.
    STA s_save_slots.1.window_color.w,X                                         ; $0199AE |/
    PLB                                                                         ; $0199B1 | Restore the data bank register.
    SEP #FLAG_P_ACCUMULATOR                                                     ; $0199B2 | Switch back to 8-bit accumulator mode.
+   LDA <r_menu_save_tmp_slot.lo                                                ; $0199B4 |\
    INC A                                                                       ; $0199B6 | | Increment the slot number and loop until all four slots have been
    STA <r_menu_save_tmp_slot.lo                                                ; $0199B7 | | checked.
    CMP #4.b                                                                    ; $0199B9 | |
    BNE -                                                                       ; $0199BB |/
    RTS                                                                         ; $0199BD

; _menu_save_fade_in ($01:99BE)
;
; Fades in the save menu (which should already be drawn to the relevant
; backgrounds). Depending on the value of $1B9A, it will either animate an
; unfolding effect (if it's zero) or simply fade in.
_menu_save_fade_in:
    LDA r_menu_save_unfolding_done.w                                            ; $0199BE |\
    BEQ +                                                                       ; $0199C1 | | If the unfolding animation is already done, set the final vertical
    JSR _menu_save_set_vertical_scroll                                          ; $0199C3 | | scroll values and fade in the display before returning.
    JSR _menu_set_bg_scroll_proxy                                               ; $0199C6 | |
    JMP _menu_ppu_fade_in                                                       ; $0199C9 |/
+   INC r_menu_save_unfolding_done.w                                            ; $0199CC | Set the flag to indicate the unfolding animation is done.
    TDC                                                                         ; $0199CF |\ Set the PPU brightness to zero.
    STA <r_menu_ppu_inidisp                                                     ; $0199D0 |/
    LDX #-24.w                                                                  ; $0199D2 |\
    STX <r_menu_scroll_bg1.vertical.value                                       ; $0199D5 | | Initialize the scroll values for BG1, BG3 and BG4 to -24.
    STX <r_menu_scroll_bg4.vertical.value                                       ; $0199D7 | |
    STX <r_menu_scroll_bg3.vertical.value                                       ; $0199D9 |/
    LDA #3.b                                                                    ; $0199DB |\ Initialize the count to 3.
    STA <r_menu_save_show_menu_tmp_count                                        ; $0199DD |/
    LDY #48.w                                                                   ; $0199DF | Initialize the Y register to 48.
-   JSR _menu_set_bg_scroll_proxy_vblank                                        ; $0199E2 | Set the currently set scroll values.
    REP #FLAG_P_ACCUMULATOR                                                     ; $0199E5 |\
    DEC <r_menu_scroll_bg1.vertical.value                                       ; $0199E7 | | Decrement the BG1 vertical scroll by one, the BG4 vertical scroll
    DEC <r_menu_scroll_bg4.vertical.value                                       ; $0199E9 | | by two, and the BG3 vertical scroll by three. (This causes the
    DEC <r_menu_scroll_bg4.vertical.value                                       ; $0199EB | | save window on each to move down at different rates.)
    DEC <r_menu_scroll_bg3.vertical.value                                       ; $0199ED | |
    DEC <r_menu_scroll_bg3.vertical.value                                       ; $0199EF | |
    DEC <r_menu_scroll_bg3.vertical.value                                       ; $0199F1 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $0199F3 |/
    DEC <r_menu_save_show_menu_tmp_count                                        ; $0199F5 |\
    BNE +                                                                       ; $0199F7 | | Decrement the count, and if it reaches zero, reset it to three and
    LDA #3.b                                                                    ; $0199F9 | | increment the PPU brightness by one step.
    STA <r_menu_save_show_menu_tmp_count                                        ; $0199FB | |
    INC <r_menu_ppu_inidisp                                                     ; $0199FD |/
+   JSR _menu_update_joypad_and_play_sound_effect                               ; $0199FF | Update the joypad values and play a sound effect if appropriate.
    LDA <r_menu_joypad_repeat.lo                                                ; $019A02 |\
    AND #JOYPAD_L_A.b                                                           ; $019A04 | | If A or either of the up or down d-pad buttons is pressed,
    BNE +                                                                       ; $019A06 | | immediately abort the unfolding by setting the vertical scroll
    LDA <r_menu_joypad_repeat.hi                                                ; $019A08 | | values to their final values, setting the count to 3, setting the
    AND #JOYPAD_H_UP.b | JOYPAD_H_DOWN                                          ; $019A0A | | PPU brightness to maximum, and setting the Y register to 2 so the
    BEQ ++                                                                      ; $019A0C | | loop will finish sooner.
+   JSR _menu_save_set_vertical_scroll                                          ; $019A0E | |
    LDA #3.b                                                                    ; $019A11 | |
    STA <r_menu_save_show_menu_tmp_count                                        ; $019A13 | |
    LDA #%00001111.b                                                            ; $019A15 | |
    STA <r_menu_ppu_inidisp                                                     ; $019A17 | |
    LDY #2.w                                                                    ; $019A19 |/
++  DEY                                                                         ; $019A1C |\ Decrement the Y register and loop until it reaches zero.
    BNE -                                                                       ; $019A1D |/
    LDA #%00001111.b                                                            ; $019A1F |\ Set the PPU brightness to maximum.
    STA <r_menu_ppu_inidisp                                                     ; $019A21 |/
    RTS                                                                         ; $019A23

; _menu_save_set_vertical_scroll ($01:9A24)
;
; Sets the vertical scroll values for BG1, BG3 and BG4 to ensure each save slot
; is drawn to a separate location on the screen.
_menu_save_set_vertical_scroll:
    LDA #-72.b                                                                  ; $019A24 |\
    STA <r_menu_scroll_bg1.vertical.value.lo                                    ; $019A26 | | Set the vertical scroll values for the four backgrounds to place
    LDA #-120.b                                                                 ; $019A28 | | each save slot at a different location.
    STA <r_menu_scroll_bg4.vertical.value.lo                                    ; $019A2A | |
    LDA #-168.b & $FF                                                           ; $019A2C | |
    STA <r_menu_scroll_bg3.vertical.value.lo                                    ; $019A2E | |
    LDA #$FF.b                                                                  ; $019A30 | |
    STA <r_menu_scroll_bg1.vertical.value.hi                                    ; $019A32 | |
    STA <r_menu_scroll_bg4.vertical.value.hi                                    ; $019A34 | |
    STA <r_menu_scroll_bg3.vertical.value.hi                                    ; $019A36 |/
    RTS                                                                         ; $019A38

; _menu_save_draw_slot ($01:9A39)
;
; Given a save slot number in the accumulator, draws that slot to the tilemap
; designated for that slot. Returns the next slot number in the accumulator,
; allowing this function to be called four times in succession to draw all
; slots.
_menu_save_draw_slot:
    PHA                                                                         ; $019A39 | Preserve the accumulator value.
    STA <r_menu_save_draw_slot_tmp_slot                                         ; $019A3A | Save the value (the current slot) to a temporary variable.
    ASL A                                                                       ; $019A3C |\
    STA <r_menu_save_draw_slot_tmp_offset.lo                                    ; $019A3D | | Set the current tilemap to the tilemap for this save slot. Each
    STZ <r_menu_save_draw_slot_tmp_offset.hi                                    ; $019A3F | | slot is drawn to a separate tilemap.
    LDX #menu_save_slot_set_tilemap_offset_data.w                               ; $019A41 | |
    LDA <r_menu_save_draw_slot_tmp_slot                                         ; $019A44 | |
    JSR _menu_execute_jump                                                      ; $019A46 |/
    LDA <r_menu_save_draw_slot_tmp_slot                                         ; $019A49 |\
    BNE +                                                                       ; $019A4B | | If this is slot 0, adjust the base tilemap address to move three
    LDY #r_menu_tilemap_bg2.w + (32 * 2 * 3)                                    ; $019A4D | | rows down.
    STY <r_menu_current_tilemap_base_address                                    ; $019A50 |/
+   LDY #menu_window_save_slot_data.w                                           ; $019A52 |\ Draw the current save slot window.
    JSR _menu_configure_and_draw_window                                         ; $019A55 |/
    LDY #menu_text_save_data.w                                                  ; $019A58 |\
    LDX #(1 * 2 + 32 * 2 * 2).w                                                 ; $019A5B | | Draw "Save" to 1, 2.
    JSR _menu_draw_text_direct                                                  ; $019A5E |/
    LDA <r_menu_save_draw_slot_tmp_slot                                         ; $019A61 |\
    CLC                                                                         ; $019A63 | | Draw the save slot number plus one to the tilemap at 5, 3. The
    ADC #TILE_MENU_NUMBER_BASE.b + 1                                            ; $019A64 | | Japanese version instead draws at 4, 3.
    LDY <r_menu_current_tilemap_base_address                                    ; $019A66 | |
.if FF4_REGION == "JAPAN"                                                       ;         | |
    STA (4 * 2 + 3 * 32 * 2).w,Y                                                ; $019A62 | |
.else                                                                           ;         | |
    STA (5 * 2 + 3 * 32 * 2).w,Y                                                ; $019A68 |/
.endif
    PHB                                                                         ; $019A6B |\
    LDA #:s_save_slots.b                                                        ; $019A6C | | Preserve the data bank register and set it to $70.
    PHA                                                                         ; $019A6E | |
    PLB                                                                         ; $019A6F |/
    LDA <r_menu_save_draw_slot_tmp_slot                                         ; $019A70 |\
    JSR _menu_save_check_valid                                                  ; $019A72 | | Branch to the empty code if the save is not valid.
    BCC @empty                                                                  ; $019A75 |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $019A77 |\
    LDA <r_menu_save_draw_slot_tmp_offset                                       ; $019A79 | | Set the X register to the offset to the save's data by multiplying
    ASL A                                                                       ; $019A7B | | by $800.
    ASL A                                                                       ; $019A7C | |
    XBA                                                                         ; $019A7D | |
    TAX                                                                         ; $019A7E |/
    PHX                                                                         ; $019A7F |\ Push the offset to the stack twice.
    PHX                                                                         ; $019A80 |/
-   LDA character_field.id.w,X                                                  ; $019A81 |\
    AND #$003F.w                                                                ; $019A84 | | Loop through the five character slots, searching for either form
    CMP #CHARACTER_CECIL_1.w                                                    ; $019A87 | | of Cecil. Once found, branch ahead to the next section. Otherwise,
    BEQ +                                                                       ; $019A8A | | keep looping.
    CMP #CHARACTER_CECIL_2.w                                                    ; $019A8C | |
    BEQ +                                                                       ; $019A8F | | NOTE: If Cecil is not in the party, this will keep scanning
    TXA                                                                         ; $019A91 | |       indefinitely until it finds either a $01 or a $0B in the
    CLC                                                                         ; $019A92 | |       checked byte.
    ADC #_sizeof_character_field.w                                              ; $019A93 | |
    TAX                                                                         ; $019A96 | |
    BRA -                                                                       ; $019A97 |/
+   LDA character_field.hp.w,X                                                  ; $019A99 |\
    LDY #(5 * 2 + 5 * 32 * 2).w                                                 ; $019A9C | | Draw Cecil's HP to the tilemap at 5, 5.
    JSR _menu_save_draw_number_four_digit                                       ; $019A9F |/
    LDA character_field.hp_max.w,X                                              ; $019AA2 |\
    LDY #(10 * 2 + 5 * 32 * 2).w                                                ; $019AA5 | | Draw Cecil's maximum HP to the tilemap at 10, 5.
    JSR _menu_save_draw_number_four_digit                                       ; $019AA8 |/
    PLX                                                                         ; $019AAB | Set the X register to the save slot offset.
    LDA <r_menu_current_tilemap_base_address                                    ; $019AAC |\
    CLC                                                                         ; $019AAE | | Set the Y register to the tilemap address for 6, 3 within the
    ADC #(6 * 2 + 3 * 32 * 2).w                                                 ; $019AAF | | tilemap.
    TAY                                                                         ; $019AB2 |/
    PLX                                                                         ; $019AB3 | Set the X register to the save slot offset.
    LDA save_slot.game_time.seconds.md.w,X                                      ; $019AB4 |\
    PHA                                                                         ; $019AB7 | | Draw the save's time value to the tilemap.
    SEP #FLAG_P_ACCUMULATOR                                                     ; $019AB8 | |
    LDA save_slot.game_time.seconds.lo.w,X                                      ; $019ABA | |
    PLX                                                                         ; $019ABD | |
    JSR _menu_format_and_draw_time                                              ; $019ABE |/
    PLB                                                                         ; $019AC1 | Restore the original data bank register.
    LDY <r_menu_current_tilemap_base_address                                    ; $019AC2 |\
    LDA #TEXT_SLASH.b                                                           ; $019AC4 | | Draw a slash in between the current HP and maximum HP values.
    STA $0152.w,Y                                                               ; $019AC6 |/
    BRA +                                                                       ; $019AC9 | Branch past the empty code.
@empty:
    LDY #menu_text_empty_data.w                                                 ; $019ACB |\ Draw the "Empty" text to the save slot.
    JSR _menu_draw_text_indirect                                                ; $019ACE |/
    PLB                                                                         ; $019AD1 | Restore the data bank register.
+   PLA                                                                         ; $019AD2 | Restore the accumulator.
    INC A                                                                       ; $019AD3 | Increment the save slot in the accumulator.
    RTS                                                                         ; $019AD4

; _menu_save_draw_number_four_digit ($01:9AD5)
;
; Given a 16-bit number in the accumulator and a tilemap address (relative to
; the current tilemap) in the Y register, draws the number as a four digit
; decimal number to the tilemap. This is a wrapper function for
; _menu_draw_number_four_digit that sets the data bank register to $7E first.
_menu_save_draw_number_four_digit:
    PHB                                                                         ; $019AD5 | Preserve the value of the data bank register.
    STA <r_menu_generic_tmp_word                                                ; $019AD6 |\
    SEP #FLAG_P_ACCUMULATOR                                                     ; $019AD8 | |
    LDA #$7E.b                                                                  ; $019ADA | | Set the data bank register to $7E.
    PHA                                                                         ; $019ADC | |
    PLB                                                                         ; $019ADD | |
    REP #FLAG_P_ACCUMULATOR                                                     ; $019ADE | |
    LDA <r_menu_generic_tmp_word                                                ; $019AE0 |/
    JSR _menu_draw_four_digit_number                                            ; $019AE2 | Draw the number to the tilemap.
    PLB                                                                         ; $019AE5 | Restore the data bank register.
    RTS                                                                         ; $019AE6

; menu_save_slot_set_tilemap_offset_data ($01:9AE7)
;
; For each save slot, provides the offset to the function that will set the
; current tilemap to the one for that save slot.
menu_save_slot_set_tilemap_offset_data:
    .addr _menu_set_current_tilemap_bg2                                         ; $019AE7.9AE8
    .addr _menu_set_current_tilemap_bg1                                         ; $019AE9.9AEA
    .addr _menu_set_current_tilemap_bg4                                         ; $019AEB.9AEC
    .addr _menu_set_current_tilemap_bg3                                         ; $019AED.9AEE

; _menu_save_check_for_valid_save_signature ($01:9AEF)
;
; Loops through the four save slots, searching for one that has a signature that
; matches the known value. If one is found, it clears the carry flag. Otherwise,
; it sets the carry flag.
_menu_save_check_for_valid_save_signature:
    REP #FLAG_P_ACCUMULATOR                                                     ; $019AEF |\
    LDA #SAVE_SIGNATURE.w                                                       ; $019AF1 | | Search for a save slot with a valid signature. If one is found,
    CMP s_save_slots.1.signature.l                                              ; $019AF4 | | branch ahead to clear the carry flag.
    BEQ +                                                                       ; $019AF8 | |
    CMP s_save_slots.2.signature.l                                              ; $019AFA | |
    BEQ +                                                                       ; $019AFE | |
    CMP s_save_slots.3.signature.l                                              ; $019B00 | |
    BEQ +                                                                       ; $019B04 | |
    CMP s_save_slots.4.signature.l                                              ; $019B06 | |
    BEQ +                                                                       ; $019B0A | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $019B0C |/
    JSR _initialize_save_data                                                   ; $019B0E | Initialize the save data in memory.
    JSR _initialize_save_signature_and_joypad                                   ; $019B11 | Initialize the save signature and joypad settings.
    JSR _menu_init_first_non_empty_position                                     ; $019B14 | Initialize some minor menu things relating to the characters.
    SEC                                                                         ; $019B17 |\ Set the carry flag and return.
    RTS                                                                         ; $019B18 |/
+   SEP #FLAG_P_ACCUMULATOR                                                     ; $019B19 |\ Clear the carry flag.
    CLC                                                                         ; $019B1B |/
    RTS                                                                         ; $019B1C

; _initialize_save_data ($01:9B1D)
;
; Initializes certain areas of RAM used for the save data. In particular, erases
; memory from $1040 to $17FF, sets the window color to the default blue, copies
; the default character names into the character names array, copies any set
; name for the first character into the first character name slot, sets the
; default battle speed and battle message speed, and sets the default button
; mappings (the values used there refer to tables at $14:FE79 and $14:FE7E).
;
; NOTE: While this does seem to indicate that there was potentially planned to
;       be the option to name Cecil when the game starts, the code to display
;       the naming screen is never executed, so no name can be set.
_initialize_save_data:
    LDX #r_character_field.2.w                                                  ; $019B1D |\
-   LDA #0.b                                                                    ; $019B20 | | Except for the first 64 bytes, which contains the character record
    STA 0.w,X                                                                   ; $019B22 | | for the character in slot zero, write zeroes to the entire portion
    INX                                                                         ; $019B25 | | of memory from $1000 to $17FF, which corresponds to the save game
    CPX #r_battle_formation.w                                                   ; $019B26 | | data.
    BNE -                                                                       ; $019B29 |/
    LDX #((12 << 10) + (0 << 5) + 0).w                                          ; $019B2B |\
    STX r_window_color.w                                                        ; $019B2E | | Set the window color to a blue color.
    JSR _menu_set_palette_window_color                                          ; $019B31 |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $019B34 |\
    LDA #bank0F._sizeof_character_names_data.w - 1                              ; $019B36 | | Copy the default character names to the character names array in
    LDX #bank0F.character_names_data.w                                          ; $019B39 | | memory.
    LDY #r_character_names.w                                                    ; $019B3C | |
    MVN :bank0F.character_names_data,:r_character_names                         ; $019B3F |/
    LDA #6.w - 1                                                                ; $019B42 |\
    LDX #r_character_names.w                                                    ; $019B45 | | Copy name data from the naming screen result array to the first
    LDY #r_menu_namingway_name_new.w                                            ; $019B48 | | name slot. NOTE: The game never shows this menu, so this isn't
    MVN :r_menu_namingway_name_new,:r_character_names                           ; $019B4B | | actually used.
    SEP #FLAG_P_ACCUMULATOR                                                     ; $019B4E |/
    LDA #0.b                                                                    ; $019B50 |\ Set the default confirm button to the A button.
    STA r_config_joypad_confirm.w                                               ; $019B52 |/
    INC A                                                                       ; $019B55 |\ Set the default cancel button to the B button.
    STA r_config_joypad_cancel.w                                                ; $019B56 |/
    STA r_config_joypad_l_button.w                                              ; $019B59 | Set the L button to ignore by default.
    INC A                                                                       ; $019B5C |\
    STA r_battle_message_speed.w                                                ; $019B5D | | Set the battle speed and battle message speed to 2.
    STA r_battle_speed.w                                                        ; $019B60 |/
    STA r_config_joypad_menu.w                                                  ; $019B63 | Set the defualt menu button to the X button.
    RTS                                                                         ; $019B66

; _menu_namingway_name_change_menu_run ($01:9B67)
;
; Runs the name change menu. If $1B49 is non-zero, is assumed to be run as part
; of the Namingway system. Otherwise, draws a standalone naming screen that
; includes the character's portrait. In that case, the slot number of the
; character being modified should be passed in $1B18. The character's current
; name, if any, should be in the six bytes starting at $1B0A.
_menu_namingway_name_change_menu_run:
    LDA r_menu_namingway_use_namingway_layout.l & $FFFF                         ; $019B67 |\ If using the Namingway layout, branch ahead to that code.
    BNE +                                                                       ; $019B6B |/
    JSR _menu_init                                                              ; $019B6D | Initialize the menu system.
    JSR _menu_load_portraits                                                    ; $019B70 | Load the character portraits.
    JSR _menu_set_current_tilemap_bg4                                           ; $019B73 | Set the current tilemap to BG4.
    LDY #menu_window_namingway_character_portrait_data.w                        ; $019B76 |\ Draw the window for the character portrait.
    JSR _menu_configure_and_draw_window                                         ; $019B79 |/
    LDY #menu_window_namingway_character_name_data.w                            ; $019B7C |\ Draw the window for the character name.
    JSR _menu_configure_and_draw_window                                         ; $019B7F |/
    LDY #(64 + (16 << 8)).w                                                     ; $019B82 | Set the portrait coordinates argument to 64, 16.
    LDA #%00110000.b                                                            ; $019B85 |\ Set the character sprite base tile flags to priority 3.
    STA r_menu_character_sprite_base_tile_flags.w                               ; $019B87 |/
    LDA r_menu_namingway_portrait_slot.w                                        ; $019B8A |\ Draw the selected character's portrait.
    JSR _menu_draw_portrait                                                     ; $019B8D |/
    BRA ++                                                                      ; $019B90 | Branch ahead to the common code.
+   LDY #menu_window_namingway_name_data.w                                      ; $019B92 |\ Draw the window for the name of the character.
    JSR _menu_configure_and_draw_window                                         ; $019B95 |/
++  LDY #menu_window_namingway_characters_data.w                                ; $019B98 |\ Draw the window to hold the various characters available for
    JSR _menu_configure_and_draw_window                                         ; $019B9B |/ selection.
    JSR _menu_set_current_tilemap_bg3                                           ; $019B9E | Change the current tilemap to BG3.
    LDY #menu_window_namingway_character_sets_data.w                            ; $019BA1 |\ Draw the window to hold the character set selections.
    JSR _menu_configure_and_draw_window                                         ; $019BA4 |/
    JSR _menu_namingway_draw_character_sets_text                                ; $019BA7 | Draw the character set choices.
    REP #FLAG_P_ACCUMULATOR                                                     ; $019BAA |\
    LDA #_sizeof_r_menu_tilemap_bg3.w / 2                                       ; $019BAC | | Copy the top half of the BG3 tilemap to BG1.
    LDX #r_menu_tilemap_bg3.w                                                   ; $019BAF | |
    LDY #r_menu_tilemap_bg1.w                                                   ; $019BB2 | |
    MVN :r_menu_tilemap_bg3.b,:r_menu_tilemap_bg1.b                             ; $019BB5 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $019BB8 |/
    JSR _menu_set_current_tilemap_bg4                                           ; $019BBA | Set the current tilemap back to BG4.
    LDA r_menu_namingway_use_namingway_layout.w                                 ; $019BBD |\
    BEQ +                                                                       ; $019BC0 | | If using the Namingway menu layout, draw the name window again.
    LDY #menu_window_namingway_name_data.w                                      ; $019BC2 | | NOTE: This was just done a few lines ago. Is it really necessary?
    JSR _menu_configure_and_draw_window                                         ; $019BC5 |/
+   LDA #$7E.b                                                                  ; $019BC8 |\
    PHA                                                                         ; $019BCA | | Set the data bank register to $7E.
    PLB                                                                         ; $019BCB |/
    LDX #r_menu_namingway_character_cursor_coordinates.w                        ; $019BCC |\
    LDA #10.b                                                                   ; $019BCF | | Zero out ten bytes in the Namingway area of memory. This largely
-   STZ 0.w,X                                                                   ; $019BD1 | | zeroes out several coordinates and pointers used in the Namingway
    DEC A                                                                       ; $019BD4 | | menu.
    BNE -                                                                       ; $019BD5 |/
    STZ r_menu_namingway_name_new_end_index.w                                   ; $019BD7 | Initialize the new end pointer to zero
    LDX #r_menu_namingway_name_new.w                                            ; $019BDA |\
    LDY #6.w                                                                    ; $019BDD | | Loop through the passed name, copying it to the old location.
-   LDA 0.w,X                                                                   ; $019BE0 | | While copying, count the characters, to determine where the end of
    STA 7.w,X                                                                   ; $019BE3 | | the name is.
    INX                                                                         ; $019BE6 | |
    CMP #$FF.b                                                                  ; $019BE7 | |
    BEQ +                                                                       ; $019BE9 | |
    INC r_menu_namingway_name_new_end_index.w                                   ; $019BEB | |
+   DEY                                                                         ; $019BEE | |
    BNE -                                                                       ; $019BEF |/
    DEC r_menu_namingway_name_new_end_index.w                                   ; $019BF1 | Decrement the index so it points to the first unused character.
    LDA r_menu_namingway_name_new_end_index.w                                   ; $019BF4 |\ Copy the end index to the old end index location.
    STA r_menu_namingway_name_old_end_index.w                                   ; $019BF7 |/
    JSR _menu_namingway_load_character_set                                      ; $019BFA | Load the "ABC" character set.
    JSR _menu_namingway_draw_new_character_name                                 ; $019BFD | Draw the new character name to BG4.
    LDA #NAMINGWAY_CHARACTER_SET_END.b                                          ; $019C00 |\ Set the character set index to default to the "END" option.
    STA r_menu_namingway_character_set_index.w                                  ; $019C02 |/
    JSR _menu_copy_tilemap_to_vram_bg4                                          ; $019C05 | Copy the BG4 tilemap to VRAM.
    JSR _menu_copy_tilemap_to_vram_bg1                                          ; $019C08 | Copy the BG1 tilemap to VRAM.
    JSR _menu_copy_tilemap_to_vram_bg3                                          ; $019C0B | Copy the BG3 tilemap to VRAM.
    LDA #%00011001.b                                                            ; $019C0E |\ Set BG1, BG4 and sprites as the main screen.
    STA reg_ppu_tm.l                                                            ; $019C10 |/
    LDX #-4.w                                                                   ; $019C14 |\
    STX <r_menu_scroll_bg1.horizontal.value                                     ; $019C17 | | Set the BG1 and BG3 horizontal scroll values to -4.
    STX <r_menu_scroll_bg3.horizontal.value                                     ; $019C19 |/
    JSR _menu_set_bg_scroll_proxy                                               ; $019C1B | Set the configured background scroll values.
    JSR _menu_copy_oam_to_ppu                                                   ; $019C1E | Copy the OAM to the PPU.
    JSR _menu_ppu_fade_in                                                       ; $019C21 | Fade the PPU in.
    STZ r_menu_namingway_name_cleared.w                                         ; $019C24 | Initially reset the flag that says the name has been cleared.
    JMP _menu_namingway_character_set_window_run                                ; $019C27 | Jump to the character set selection window.

; _menu_namingway_character_window_run ($01:9C2A)
;
; Handles input and other behavior for the character selection window during
; the Namingway menu, where the player selects characters for the character's
; new name. The Japanese has a _no_animation variant that skips the animation
; effect. This is used when pressing the X button to switch among character
; sets.
;
; NOTE: This routine makes assumptions about the layouts of the character sets
;       that assume there are no unselectable blank spaces in between valid
;       characters.
;
; NOTE: This routine does not return. When it completes, it jumps directly back
;       to the character set selection routine.
_menu_namingway_character_window_run:
    JSR _menu_namingway_animate_character_set_window_slide_under                ; $019C2A | Animate the switch to the character selection window as active.
.if FF4_REGION == "JAPAN"
_menu_namingway_character_window_run_no_animation:
.endif
    JSR _menu_namingway_load_character_set_and_update_joypad                    ; $019C2D | Load the character set an update the joypad.
    LDA r_menu_namingway_character_set_index.w                                  ; $019C30 |\
    ASL A                                                                       ; $019C33 | | Set the X register to the character set index times two.
    STA <r_menu_generic_tmp_word.lo                                             ; $019C34 | |
    STZ <r_menu_generic_tmp_word.hi                                             ; $019C36 | |
    LDX <r_menu_generic_tmp_word                                                ; $019C38 |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $019C3A |\
    LDA menu_namingway_character_sets_offset_data.l,X                           ; $019C3C | | Determine the offset to the selected character set data, and save
    CLC                                                                         ; $019C40 | | the pointer to a variable.
    ADC #menu_namingway_character_sets_data.w                                   ; $019C41 | |
    STA <r_menu_namingway_character_set_ptr.address                             ; $019C44 | | NOTE: This technically overwrites an extra byte as well, but it's
    LDA #:menu_namingway_character_sets_data.w                                  ; $019C46 | |       going to be rewritten in a few lines anyway, so it doesn't
    STA <r_menu_namingway_character_set_ptr.bank                                ; $019C49 | |       matter.
    SEP #FLAG_P_ACCUMULATOR                                                     ; $019C4B |/
    LDA r_menu_namingway_character_set_index.w                                  ; $019C4D |\
    STA <r_menu_generic_tmp_word.lo                                             ; $019C50 | | Calculate and save pointers to both the X coordinate and the Y
    ASL A                                                                       ; $019C52 | | coordinate for the cursor in this character set. (Each character
    STA <r_menu_generic_tmp_word.lo                                             ; $019C53 | | set has its own set of independent coordinates.)
    STZ <r_menu_generic_tmp_word.hi                                             ; $019C55 | |
    REP #FLAG_P_ACCUMULATOR                                                     ; $019C57 | |
    LDA <r_menu_generic_tmp_word                                                ; $019C59 | |
    CLC                                                                         ; $019C5B | |
    ADC #r_menu_namingway_character_cursor_coordinates.w                        ; $019C5C | |
    STA <r_menu_namingway_character_x_coordinate_ptr                            ; $019C5F | |
    INC A                                                                       ; $019C61 | |
    STA <r_menu_namingway_character_y_coordinate_ptr                            ; $019C62 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $019C64 |/
@loop_start:
    JSR _menu_namingway_draw_new_character_name                                 ; $019C66 | Draw the new character name.
    LDA (<r_menu_namingway_character_x_coordinate_ptr)                          ; $019C69 |\
    STA <r_menu_generic_tmp_word.lo                                             ; $019C6B | | Calculate the X coordinate for the character selection cursor.
    STZ <r_menu_generic_tmp_word.hi                                             ; $019C6D | |
    LDX <r_menu_generic_tmp_word                                                ; $019C6F | |
    LDA bank14.menu_namingway_character_window_cursor_x_coordinate_data.l,X     ; $019C71 | |
    STA <r_menu_namingway_tmp_character_cursor_coordinates.x                    ; $019C75 |/
    LDA (<r_menu_namingway_character_y_coordinate_ptr)                          ; $019C77 |\
    ASL A                                                                       ; $019C79 | | Calculate the Y coordinate for the character selection cursor.
    ASL A                                                                       ; $019C7A | |
    ASL A                                                                       ; $019C7B | |
    ASL A                                                                       ; $019C7C | |
    CLC                                                                         ; $019C7D | |
    ADC #80.b                                                                   ; $019C7E | |
    STA <r_menu_namingway_tmp_character_cursor_coordinates.y                    ; $019C80 |/
    LDX <r_menu_namingway_tmp_character_cursor_coordinates                      ; $019C82 |\
    LDY #r_oam.1.w                                                              ; $019C84 | | Draw the cursor to the first OAM entry.
    JSR _menu_draw_cursor_direct                                                ; $019C87 |/
    JSR _menu_namingway_update_character_sprites_if_namingway_layout            ; $019C8A | Update character sprites if appropriate.
    JSR _menu_wait_for_vblank_copy_oam_to_ppu                                   ; $019C8D | Wait for vblank and copy the OAM to the PPU.
    JSR _menu_copy_tilemap_to_vram_bg4_no_vblank                                ; $019C90 | Copy the BG4 tilemap to VRAM.
    JSR _menu_update_joypad_and_play_sound_effect                               ; $019C93 | Update the joypad values and play a sound effect if appropriate.
.if FF4_REGION == "JAPAN"
    LDA <r_menu_joypad_repeat.lo                                                ; $019C90 |\
    AND #JOYPAD_L_X.b                                                           ; $019C92 | | For the Japanese version, if the X button is pressed, cycle to the
    BEQ ++                                                                      ; $019C94 | | next character set, and then jump back to the start of the
    LDA r_menu_namingway_character_set_index.w                                  ; $019C96 | | routine, being careful to cycle back to zero once the value
    CMP #NAMINGWAY_CHARACTER_SET_ABC.b                                          ; $019C99 | | reaches the maximum.
    BNE +                                                                       ; $019C9B | |
    LDA #-1.b                                                                   ; $019C9D | |
    STA r_menu_namingway_character_set_index.w                                  ; $019C9F | |
+   JSR _menu_namingway_increment_character_set_index                           ; $019CA2 | |
    JMP _menu_namingway_character_window_run_no_animation                       ; $019CA5 |/
.endif
++  LDA <r_menu_joypad_repeat.hi                                                ; $019C96 |\
    BIT #JOYPAD_H_UP.b                                                          ; $019C98 | | If the up d-pad button is currently being pressed, decrement the
    BEQ ++                                                                      ; $019C9A | | Y coordinate of the cursor. Repeat the decrement until the result
-   LDA (<r_menu_namingway_character_y_coordinate_ptr)                          ; $019C9C | | is a valid selection. If at any time the result is less than zero,
    DEC A                                                                       ; $019C9E | | reset the value to 7 to wrap around to the bottom.
    BPL +                                                                       ; $019C9F | |
    LDA #7.b                                                                    ; $019CA1 | |
+   STA (<r_menu_namingway_character_y_coordinate_ptr)                          ; $019CA3 | |
    JSR _menu_namingway_get_current_character                                   ; $019CA5 | |
    BEQ -                                                                       ; $019CA8 |/
++  LDA <r_menu_joypad_repeat.hi                                                ; $019CAA |\
    BIT #JOYPAD_H_DOWN.b                                                        ; $019CAC | | If the down d-pad button is currently being pressed, increment the
    BEQ ++                                                                      ; $019CAE | | Y coordinate of the cursor. If the result is 8 or greater, set the
-   LDA (<r_menu_namingway_character_y_coordinate_ptr)                          ; $019CB0 | | coordinate explicitly to zero to wrap around to the top. If the
    INC A                                                                       ; $019CB2 | | resulting character selection is not valid, repeat the process
    CMP #8.b                                                                    ; $019CB3 | | until it is.
    BCC +                                                                       ; $019CB5 | |
    TDC                                                                         ; $019CB7 | |
+   STA (<r_menu_namingway_character_y_coordinate_ptr)                          ; $019CB8 | |
    JSR _menu_namingway_get_current_character                                   ; $019CBA | |
    BEQ -                                                                       ; $019CBD |/
++  LDA <r_menu_joypad_repeat.hi                                                ; $019CBF |\
    BIT #JOYPAD_H_LEFT.b                                                        ; $019CC1 | | If the left d-pad button is pressed, decrement the cursor X
    BEQ ++                                                                      ; $019CC3 | | coordinate. If the result is negative or if a valid character was
    LDA (<r_menu_namingway_character_x_coordinate_ptr)                          ; $019CC5 | | not found, jump to return to the character set selection window
    DEC A                                                                       ; $019CC7 | | (and leave the character selection window).
    BPL +                                                                       ; $019CC8 | |
-   STZ r_menu_namingway_character_window_active.w                              ; $019CCA | | NOTE: This assumes that there are no empty spaces for spacing.
    JMP _menu_namingway_return_to_character_set_selection                       ; $019CCD | |
+   STA (<r_menu_namingway_character_x_coordinate_ptr)                          ; $019CD0 | |
    JSR _menu_namingway_get_current_character                                   ; $019CD2 | |
    BEQ -                                                                       ; $019CD5 |/
++  LDA <r_menu_joypad_repeat.hi                                                ; $019CD7 |\
    BIT #JOYPAD_H_RIGHT.b                                                       ; $019CD9 | | If the right d-pad button is pressed, increment the X coordinate.
    BEQ ++                                                                      ; $019CDB | | If the result is 10, return to the character set selection window.
    LDA (<r_menu_namingway_character_x_coordinate_ptr)                          ; $019CDD | | Otherwise, save the updated coordinate and check if it points to
    INC A                                                                       ; $019CDF | | a valid character. If so, continue to the next section. If not,
    CMP #10.b                                                                   ; $019CE0 | | decrement the X coordinate again, and then return to the character
    BCC +                                                                       ; $019CE2 | | set selection window.
-   STZ r_menu_namingway_character_window_active.w                              ; $019CE4 | |
    JMP _menu_namingway_return_to_character_set_selection                       ; $019CE7 | | NOTE: This also assumes that there are no empty spaces.
+   STA (<r_menu_namingway_character_x_coordinate_ptr)                          ; $019CEA | |
    JSR _menu_namingway_get_current_character                                   ; $019CEC | |
    BNE ++                                                                      ; $019CEF | |
    LDA (<r_menu_namingway_character_x_coordinate_ptr)                          ; $019CF1 | |
    DEC A                                                                       ; $019CF3 | |
    STA (<r_menu_namingway_character_x_coordinate_ptr)                          ; $019CF4 | |
    BRA -                                                                       ; $019CF6 |/
++  LDA <r_menu_joypad_repeat.lo                                                ; $019CF8 |\
    BIT #JOYPAD_L_A.b                                                           ; $019CFA | | Skip to the next section if the A button is not pressed.
    BEQ +                                                                       ; $019CFC |/
    LDA r_menu_namingway_name_new_end_index.w                                   ; $019CFE |\
    INC A                                                                       ; $019D01 | | If the new end index would be 6 or greater, branch ahead to skip
    CMP #6.b                                                                    ; $019D02 | | actually placing the new character (name is full).
    BCS +                                                                       ; $019D04 |/
    STA r_menu_namingway_name_new_end_index.w                                   ; $019D06 | Otherwise, save the updated index.
    JSR _menu_namingway_get_current_character                                   ; $019D09 | Get the currently selected character.
    PHA                                                                         ; $019D0C |\
    LDA r_menu_namingway_name_new_end_index.w                                   ; $019D0D | | Save the character to the end index of the new name, which will
    STA <r_menu_generic_tmp_word.lo                                             ; $019D10 | | append it to the end.
    STZ <r_menu_generic_tmp_word.hi                                             ; $019D12 | |
    LDY <r_menu_generic_tmp_word                                                ; $019D14 | |
    PLA                                                                         ; $019D16 | |
    STA r_menu_namingway_name_new.w,Y                                           ; $019D17 |/
+   LDA <r_menu_joypad_repeat.hi                                                ; $019D1A |\
    BIT #JOYPAD_H_B.b                                                           ; $019D1C | | If the B button is not pressed, branch to loop again.
    BEQ +                                                                       ; $019D1E |/
    LDA r_menu_namingway_name_new_end_index.w                                   ; $019D20 |\ If the name is currently empty, branch to revert back to the
    BMI ++                                                                      ; $019D23 |/ original name and then loop again.
    DEC A                                                                       ; $019D25 |\ Otherwise, decrement the new end index.
    STA r_menu_namingway_name_new_end_index.w                                   ; $019D26 |/
    INC A                                                                       ; $019D29 |\
    STA <r_menu_generic_tmp_word.lo                                             ; $019D2A | | Replace the deleted character with a blank tile.
    STZ <r_menu_generic_tmp_word.hi                                             ; $019D2C | |
    LDY <r_menu_generic_tmp_word                                                ; $019D2E | |
    LDA #TILE_MENU_WINDOW_BLANK.b                                               ; $019D30 | |
    STA r_menu_namingway_name_new.w,Y                                           ; $019D32 |/
+   JMP @loop_start                                                             ; $019D35 | Repeat the loop.
++  JSR _menu_namingway_revert_name_changes                                     ; $019D38 |\ Revert the name changes and then repeat the loop.
    JMP @loop_start                                                             ; $019D3B |/

; _menu_namingway_return_to_character_set_selection ($01:9D3E)
;
; Animates the character set window coming back to the front, and then falls
; through to the next routine, which is the character set selection handler.
; Yes, this is incredible spaghetti code.
_menu_namingway_return_to_character_set_selection:
    JSR _menu_namingway_animate_character_set_window_slide_over                 ; $019D3E | Animate the character set window coming to the front.

; _menu_namingway_character_set_window_run ($01:9D41)
;
; Handles the input and behavior for the character set selection window in the
; Namingway menu.
_menu_namingway_character_set_window_run:
    JSR _menu_namingway_load_character_set_and_update_joypad                    ; $019D41 | Load the character set and update the joypad.
@loop_start:
    LDA r_menu_namingway_character_set_index.w                                  ; $019D44 |\
    JSR _menu_transfer_a_to_x                                                   ; $019D47 | | Draw the character set index cursor.
    LDA menu_namingway_character_set_index_cursor_y_coordinate_data.l,X         ; $019D4A | |
    STA <r_menu_draw_cursor_arg_coordinates.y                                   ; $019D4E | |
    LDA #12.b                                                                   ; $019D50 | |
    STA <r_menu_draw_cursor_arg_coordinates.x                                   ; $019D52 | |
    JSR _menu_draw_cursor_1                                                     ; $019D54 |/
    JSR _menu_namingway_update_character_sprites_if_namingway_layout            ; $019D57 | Update the character sprites if using the Namingway layout.
    JSR _menu_wait_for_vblank_copy_oam_to_ppu                                   ; $019D5A | Wait for vblank and copy the OAM to the PPU.
    JSR _menu_update_joypad_and_play_sound_effect                               ; $019D5D | Update the joypad values and play a sound effect if appropriate.
    LDA <r_menu_joypad_repeat.lo                                                ; $019D60 |\
    AND #JOYPAD_L_A.b                                                           ; $019D62 | | If the A button is not pressed, branch ahead past the A code.
    BEQ +++                                                                     ; $019D64 |/
    LDA r_menu_namingway_character_set_index.w                                  ; $019D66 |\
    CMP #NAMINGWAY_CHARACTER_SET_END.b                                          ; $019D69 | | Skip this next block if the END option isn't selected.
    BNE ++                                                                      ; $019D6B |/
    LDA r_menu_namingway_name_new_end_index.w                                   ; $019D6D |\
    BMI +                                                                       ; $019D70 | | If a new name has been entered, fade out and return.
    JMP _menu_ppu_fade_out                                                      ; $019D72 |/
+   JSR _menu_namingway_revert_name_changes                                     ; $019D75 |\
    JSR _menu_namingway_draw_new_character_name                                 ; $019D78 | | If the new name is empty, revert the name to the original name,
    JSR _menu_copy_tilemap_to_vram_bg4                                          ; $019D7B | | redraw the name so the user is aware, and wait for input before
    JSR _menu_wait_for_input                                                    ; $019D7E | | fading out and returning.
    JMP _menu_ppu_fade_out                                                      ; $019D81 |/
++  LDA r_menu_namingway_name_cleared.w                                         ; $019D84 |\
    BNE +                                                                       ; $019D87 | | If pressing A on a character set, clear the new name if it hasn't
    JSR _menu_namingway_clear_new_name                                          ; $019D89 |/  already been cleared.
+   LDA #1.b                                                                    ; $019D8C |\ Set the flag that indicates the character selection menu is active.
    STA r_menu_namingway_character_window_active.w                              ; $019D8E |/
    JMP _menu_namingway_character_window_run                                    ; $019D91 | Run the character selection. (Jumps to this routine when done.)
+++ LDA <r_menu_joypad_repeat.hi                                                ; $019D94 |\
    BIT #JOYPAD_H_UP.b                                                          ; $019D96 | | If the up d-pad button is pressed, decrement the character set
    BEQ ++                                                                      ; $019D98 | | index. If the result is negative, set it explicitly to 1 to loop
    LDA r_menu_namingway_character_set_index.w                                  ; $019D9A | | back to the bottom option. Afterward, load the character set and
    DEC A                                                                       ; $019D9D | | update the joypad.
    STA r_menu_namingway_character_set_index.w                                  ; $019D9E | |
    BPL +                                                                       ; $019DA1 | |
    LDA #NAMINGWAY_CHARACTER_SET_END.b                                          ; $019DA3 | |
+   STA r_menu_namingway_character_set_index.w                                  ; $019DA5 | |
    JSR _menu_namingway_load_character_set_and_update_joypad                    ; $019DA8 |/
++  LDA <r_menu_joypad_repeat.hi                                                ; $019DAB |\
    BIT #JOYPAD_H_DOWN.b                                                        ; $019DAD | | If the down d-pad button is pressed, increment the character set
    BEQ +                                                                       ; $019DAF | | index, make sure it's in range, and load the character set.
    JSR _menu_namingway_increment_character_set_index                           ; $019DB1 |/
+   LDA <r_menu_joypad_repeat.hi                                                ; $019DB4 |\
    BIT #(JOYPAD_H_LEFT | JOYPAD_H_RIGHT).b                                     ; $019DB6 | | If neither left nor right is pressed, branch to the next loop.
    BEQ @loop_start                                                             ; $019DB8 |/
    LDA r_menu_namingway_name_cleared.w                                         ; $019DBA |\
    BNE +                                                                       ; $019DBD | | If the new name hasn't been cleared, clear it.
    JSR _menu_namingway_clear_new_name                                          ; $019DBF |/
+   LDA r_menu_namingway_character_set_index.w                                  ; $019DC2 |\
    CMP #NAMINGWAY_CHARACTER_SET_END.b                                          ; $019DC5 | | If the END character set is chosen, loop back to the next loop.
    BCC ++                                                                      ; $019DC7 | |
    JMP @loop_start                                                             ; $019DC9 |/
++  LDA #1.b                                                                    ; $019DCC |\ Set the character selection window active flag.
    STA r_menu_namingway_character_window_active.w                              ; $019DCE |/
    JMP _menu_namingway_character_window_run                                    ; $019DD1 | Jump to run the character selection window.

; _menu_namingway_load_character_set_and_update_joypad ($01:9DD4)
;
; In the Namingway menu, loads the "ABC" character set, copies the updated
; BG4 tilemap to VRAM, and updates the joypad.
_menu_namingway_load_character_set_and_update_joypad:
.if FF4_REGION == "JAPAN"
    JSR _menu_namingway_load_character_set_current                              ; $019DE6 | Load the character set and draw it to the tilemap.
.else
    JSR _menu_namingway_load_character_set                                      ; $019DD4 | Load the character set and draw it to the tilemap.
.endif
    JSR _menu_copy_tilemap_to_vram_bg4                                          ; $019DD7 | Copy the BG4 tilemap to VRAM.
    JMP _menu_update_joypad_and_play_sound_effect                               ; $019DDA | Update the joypad and play a sound effect, then return.

; _menu_namingway_revert_name_changes ($01:9DDD)
;
; Reverts any name changes by copying the original name back to the new name
; location.
_menu_namingway_revert_name_changes:
    LDA r_menu_namingway_name_old_end_index.w                                   ; $019DDD |\ Copy the old end index to the new end index location.
    STA r_menu_namingway_name_new_end_index.w                                   ; $019DE0 |/
    LDX #r_menu_namingway_name_new.w                                            ; $019DE3 |\
    LDY #6.w                                                                    ; $019DE6 | | Copy the old name to the new name location.
-   LDA 7.w,X                                                                   ; $019DE9 | |
    STA 0.w,X                                                                   ; $019DEC | |
    INX                                                                         ; $019DEF | |
    DEY                                                                         ; $019DF0 | |
    BNE -                                                                       ; $019DF1 |/
    RTS                                                                         ; $019DF3

; _menu_namingway_load_character_set ($01:9DF4)
;
; Loads a character set and draws it to the tilemap. The USA version only has
; one variant, which loads the first character set. The Japanese version
; additionally has a variant that loads the currently selected character set,
; aptly suffixed with _current.
.if FF4_REGION == "JAPAN"
_menu_namingway_load_character_set_current:
    LDA r_menu_namingway_character_set_index.w                                  ; $019E06 |\
    BEQ +                                                                       ; $019E09 | | Initialize the X register to the offset for the currently selected
    DEC A                                                                       ; $019E0B | | character set. If the value is not 0, 1 or 2, return.
    BEQ ++                                                                      ; $019E0C | |
    DEC A                                                                       ; $019E0E | |
    BEQ +++                                                                     ; $019E0F | |
    RTS                                                                         ; $019E11 |/
_menu_namingway_load_character_set:
+   LDX <r_menu_zero                                                            ; $019E12 |\ Load the offset for the first character set.
    BRA +                                                                       ; $019E14 |/
++  LDX #80.w                                                                   ; $019E16 |\ Load the offset for the second character set.
    BRA +                                                                       ; $019E19 |/
+++ LDX #160.w                                                                  ; $019E1B | Load the offset for the third character set.
.else
_menu_namingway_load_character_set:
    LDX <r_menu_zero                                                            ; $019DF4 | Initialize the X register to zero.
.endif
+   LDY #r_menu_tilemap_bg4.w + (9 * 2 + 9 * 32 * 2)                            ; $019DF6 | Initialize the Y register to the offset for 9, 9 on BG4.
    LDA #8.b                                                                    ; $019DF9 |\ Initialize the remaining number of rows to eight.
    STA <r_menu_generic_tmp_count                                               ; $019DFB |/
@row_start:
    LDA #2.b                                                                    ; $019DFD |\ Initialize the remaining number of groups in this row to two.
    STA <r_menu_namingway_tmp_group_count                                       ; $019DFF |/
@group_start:
    LDA #5.b                                                                    ; $019E01 |\ Initialize the number of remaining characters in this group to
    STA <r_menu_namingway_tmp_character_count                                   ; $019E03 |/ five.
@character_start:
    LDA bank01.menu_namingway_character_sets_data.l,X                           ; $019E05 | Read the next character.
    INX                                                                         ; $019E09 | Increment the X register.
    CMP #0.b                                                                    ; $019E0A |\
    BEQ +                                                                       ; $019E0C | | If the read value is not zero, get the full diacritic for that
    JSR _menu_get_diacritic_tile                                                ; $019E0E | | tile and branch ahead.
    BRA ++                                                                      ; $019E11 |/
+   DEC A                                                                       ; $019E13 |\
    STA 0.w,Y                                                                   ; $019E14 | | If the read value was zero, write $FF to both rows.
    STA (32 * 2).w,Y                                                            ; $019E17 | |
    BRA +                                                                       ; $019E1A |/
++  STA 0.w,Y                                                                   ; $019E1C |\
    XBA                                                                         ; $019E1F | | Otherwise, write the read diacritic tile values.
    STA (32 * 2).w,Y                                                            ; $019E20 |/
+   INY                                                                         ; $019E23 |\
    INY                                                                         ; $019E24 | | Increment the Y register by four to move to the next location.
    INY                                                                         ; $019E25 | |
    INY                                                                         ; $019E26 |/
    DEC <r_menu_namingway_tmp_character_count                                   ; $019E27 |\ Decrement the character count and loop until it reaches zero.
    BNE @character_start                                                        ; $019E29 |/
    INY                                                                         ; $019E2B |\ Since we're at the end of a group, increment the Y register by two
    INY                                                                         ; $019E2C |/ to insert a gap.
    DEC <r_menu_namingway_tmp_group_count                                       ; $019E2D |\ Decrement the group count and loop until it reaches zero.
    BNE @group_start                                                            ; $019E2F |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $019E31 |\
    TYA                                                                         ; $019E33 | | Add two full rows to the Y register, and then subtract 22
    CLC                                                                         ; $019E34 | | characters to move back to the start of the line.
    ADC #(32 * 2 * 2 - 22 * 2).w                                                ; $019E35 | |
    TAY                                                                         ; $019E38 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $019E39 |/
    DEC <r_menu_generic_tmp_count                                               ; $019E3B |\ Decrement the row count and loop until it reaches zero.
    BNE @row_start                                                              ; $019E3D |/
    RTS                                                                         ; $019E3F

; _menu_namingway_draw_character_sets_text ($01:9E40)
;
; Draws the available character sets and the "END" option to the current
; tilemap.
_menu_namingway_draw_character_sets_text:
    LDY #menu_text_namingway_character_sets_data.w                              ; $019E40
    JMP _menu_draw_text_indirect                                                ; $019E43

; _menu_namingway_get_current_character ($01:9E46)
;
; Within the Namingway menu, fetches the currently selected character in the
; character selection window. Returns the result in the accumulator.
; Additionally compares the result to zero, so one can use the flags to check
; if the character is a valid character or not.
_menu_namingway_get_current_character:
    PHY                                                                         ; $019E46 | Preserve the value in the Y register.
    LDY <r_menu_zero                                                            ; $019E47 | Initialize the Y register to zero.
    LDA (<r_menu_namingway_character_y_coordinate_ptr)                          ; $019E49 |\
    ASL A                                                                       ; $019E4B | | Multiply the Y coordinate by 10 (as there are 10 characters per
    STA <r_menu_generic_tmp_word.lo                                             ; $019E4C | | row).
    ASL A                                                                       ; $019E4E | |
    ASL A                                                                       ; $019E4F | |
    CLC                                                                         ; $019E50 | |
    ADC <r_menu_generic_tmp_word.lo                                             ; $019E51 |/
    ADC (<r_menu_namingway_character_x_coordinate_ptr)                          ; $019E53 |\
    STA <r_menu_generic_tmp_word.lo                                             ; $019E55 | | Add in the X coordinate to determine the offset.
    STZ <r_menu_generic_tmp_word.hi                                             ; $019E57 |/
    LDY <r_menu_generic_tmp_word                                                ; $019E59 |\ Read the character at that location in the character set.
    LDA [<r_menu_namingway_character_set_ptr],Y                                 ; $019E5B |/
    PLY                                                                         ; $019E5D | Restore the original value of the Y register.
    CMP #$00.b                                                                  ; $019E5E | Compare the result to zero and return.
    RTS                                                                         ; $019E60

; _menu_namingway_draw_new_character_name ($01:9E61)
;
; During the renaming portion of the Namingway menu, displays the character name
; at the appropriate location, depending on if configured to use the Namingway
; layout or not (by setting $1B49 to a non-zero value). Displays the currently
; being edited name.
_menu_namingway_draw_new_character_name:
    PHX                                                                         ; $019E61 |\ Preserve the values of the X and Y register.
    PHY                                                                         ; $019E62 |/
    LDA r_menu_namingway_use_namingway_layout.w                                 ; $019E63 |\
    BEQ +                                                                       ; $019E66 | | Set the Y register to the offset for 9, 5 if using the Namingway
    LDY #(9 * 2 + 5 * 32 * 2).w                                                 ; $019E68 | | layout, and 16, 3 otherwise.
    BRA ++                                                                      ; $019E6B | |
+   LDY #(16 * 2 + 3 * 32 * 2).w                                                ; $019E6D |/
++  LDX #r_menu_namingway_name_new.w                                            ; $019E70 | Set the X register to the offset for the new name.
    LDA #6.b                                                                    ; $019E73 |\ Initialize the count to six.
    STA <r_menu_generic_tmp_count                                               ; $019E75 |/
-   LDA 0.w,X                                                                   ; $019E77 |\
    INX                                                                         ; $019E7A | | Read the next character, get its diacritic layout, and write it to
    JSR _menu_get_diacritic_tile                                                ; $019E7B | | the tilemap.
    STA r_menu_tilemap_bg4.w,Y                                                  ; $019E7E | |
    XBA                                                                         ; $019E81 | |
    STA r_menu_tilemap_bg4 + (32 * 2).w,Y                                       ; $019E82 |/
    INY                                                                         ; $019E85 |\ Increment the Y register twice to move to the next character.
    INY                                                                         ; $019E86 |/
    DEC <r_menu_generic_tmp_count                                               ; $019E87 |\ Decrement the count and loop until it reaches zero.
    BNE -                                                                       ; $019E89 |/
    PLY                                                                         ; $019E8B |\ Restore the values of the X and Y registers.
    PLX                                                                         ; $019E8C |/
    RTS                                                                         ; $019E8D

; _menu_namingway_update_character_sprites_if_namingway_layout ($01:9E8E)
;
; Call the routine to update the character sprites, but only if the flag to use
; the Namingway layout is set ($1B49).
_menu_namingway_update_character_sprites_if_namingway_layout:
    LDA r_menu_namingway_use_namingway_layout.w                                 ; $019E8E |\
    BNE +                                                                       ; $019E91 | | Update the character sprites if using the Namingway layout.
    RTS                                                                         ; $019E93 | |
+   JMP _menu_namingway_update_character_sprites                                ; $019E94 |/

; _menu_namingway_animate_character_set_window_slide_over ($01:9E97)
;
; Animates the process of the character set selection window sliding to the left
; and then sliding back to the right over the character selection window in the
; Namingway menu.
_menu_namingway_animate_character_set_window_slide_over:
    LDX #4.w                                                                    ; $019E97 |\
-   INC <r_menu_scroll_bg3.horizontal.value.lo                                  ; $019E9A | | For four frames, increment the BG3 horizontal scroll by one to
    JSR _menu_set_bg_scroll_proxy_vblank                                        ; $019E9C | | move the character set selection window left.
    DEX                                                                         ; $019E9F | |
    BNE -                                                                       ; $019EA0 |/
    LDX <r_menu_scroll_bg3.horizontal.value                                     ; $019EA2 |\
    STX <r_menu_scroll_bg1.horizontal.value                                     ; $019EA4 | | Transfer the BG3 horizontal scroll to BG1, and then change the
    LDA #%00011001.b                                                            ; $019EA6 | | visible screens to BG1, BG4 and sprites.
    STA reg_ppu_tm.l                                                            ; $019EA8 |/
    LDX #4.w                                                                    ; $019EAC |\
-   DEC <r_menu_scroll_bg1.horizontal.value.lo                                  ; $019EAF | | For four frames, decrement the BG1 horizontal scroll by one to
    JSR _menu_set_bg_scroll_proxy_vblank                                        ; $019EB1 | | move the character set selection window back to the right, except
    DEX                                                                         ; $019EB4 | | in front of the character selection window.
    BNE -                                                                       ; $019EB5 |/
    RTS                                                                         ; $019EB7

; _menu_namingway_animate_character_set_window_slide_under ($01:9EB8)
;
; Animates the process of the character set selection window sliding to the left
; and then sliding back to the right under the character selection window in the
; Namingway menu.
_menu_namingway_animate_character_set_window_slide_under:
    LDX #4.w                                                                    ; $019EB8 |\
-   INC <r_menu_scroll_bg1.horizontal.value.lo                                  ; $019EBB | | For four frames, increment the BG1 horizontal scroll by one to
    JSR _menu_set_bg_scroll_proxy_vblank                                        ; $019EBD | | move the character set selection window left.
    DEX                                                                         ; $019EC0 | |
    BNE -                                                                       ; $019EC1 |/
    LDX <r_menu_scroll_bg1.horizontal.value                                     ; $019EC3 |\
    STX <r_menu_scroll_bg3.horizontal.value                                     ; $019EC5 | | Transfer the BG1 horizontal scroll to BG3, and then change the
    LDA #%00011100.b                                                            ; $019EC7 | | visible screens to BG3, BG4 and sprites.
    STA reg_ppu_tm.l                                                            ; $019EC9 |/
    LDX #4.w                                                                    ; $019ECD |\
-   DEC <r_menu_scroll_bg3.horizontal.value.lo                                  ; $019ED0 | | For four frames, decrement the BG3 horizontal scroll by one to
    JSR _menu_set_bg_scroll_proxy_vblank                                        ; $019ED2 | | move the character set selection window back to the right, except
    DEX                                                                         ; $019ED5 | | behind the character selection window.
    BNE -                                                                       ; $019ED6 |/
    RTS                                                                         ; $019ED8

; _menu_namingway_increment_character_set_index ($01:9ED9)
;
; Increments the current character set index, loads the new character set, and
; updates the joypad values. Ensures that the character set index remains in the
; valid range.
_menu_namingway_increment_character_set_index:
    LDA r_menu_namingway_character_set_index.w                                  ; $019ED9 |\
    INC A                                                                       ; $019EDC | | Increment the character set index.
    STA r_menu_namingway_character_set_index.w                                  ; $019EDD |/
    CMP #NAMINGWAY_CHARACTER_SET_END.b + 1                                      ; $019EE0 |\
    BCC +                                                                       ; $019EE2 | | If the result goes past the maximum, reset it to zero.
    TDC                                                                         ; $019EE4 | |
+   STA r_menu_namingway_character_set_index.w                                  ; $019EE5 |/
    JMP _menu_namingway_load_character_set_and_update_joypad                    ; $019EE8 | Update the character set and the joypad values.

; _menu_namingway_clear_new_name ($01:9EEB)
;
; Clears the new name in the Namingway menu.
_menu_namingway_clear_new_name:
    LDA #$FF.b                                                                  ; $019EEB |\ Set the new name end index to $FF to reset the pointer for an empty
    STA r_menu_namingway_name_new_end_index.w                                   ; $019EED |/ name.
    STA r_menu_namingway_name_cleared.w                                         ; $019EF0 | Set the flag that indicates the name has been cleared.
    LDX <r_menu_zero                                                            ; $019EF3 |\
-   STA r_menu_namingway_name_new.w,X                                           ; $019EF5 | | Loop through the name, replacing it with spaces.
    INX                                                                         ; $019EF8 | |
    CPX #6.w                                                                    ; $019EF9 | |
    BNE -                                                                       ; $019EFC |/
    RTS                                                                         ; $019EFE

; _menu_command_item ($01:9EFF)
;
; Handler for the Item menu command in the main menu.
_menu_command_item:
    STZ r_menu_equip_active.w                                                   ; $019EFF | Reset the flag that says the equip screen is active.
    JSR _menu_backup_cgram_1                                                    ; $019F02 | Back up the current palette data.
    JSR _menu_init_bg_scroll                                                    ; $019F05 | Initialize the background scroll values.
    JSR _menu_initialize_tilemap_bg2                                            ; $019F08 | Clear BG2.
    JSR _menu_set_current_tilemap_bg4                                           ; $019F0B | Set the current tilemap to BG4.
    LDA #28.b                                                                   ; $019F0E |\
    STA <r_menu_transition_scroll_frames                                        ; $019F10 | | Set the window transition effect to scroll BG4 to the right by
    LDA #6.b                                                                    ; $019F12 | | 6 pixels 28 times (a total of 168 pixels).
    STA <r_menu_scroll_delta_bg4.horizontal.value.lo                            ; $019F14 |/
    JSR _menu_initialize_oam                                                    ; $019F16 | Initialize the menu OAM.
    JSR _menu_wait_for_vblank_copy_oam_to_ppu                                   ; $019F19 | Wait for vblank and copy the OAM to the PPU.
    LDA #%00011011.b                                                            ; $019F1C |\ Set the current screens to BG1, BG2, BG4 and sprites.
    STA reg_ppu_tm.l                                                            ; $019F1E |/
    LDY #menu_window_main_command_data.w                                        ; $019F22 |\
    LDX #menu_window_item_title_right_data.w                                    ; $019F25 | | Transition the command window to the item title window.
    JSR _menu_window_transition                                                 ; $019F28 |/
    JSR _menu_set_current_tilemap_bg2                                           ; $019F2B | Switch the current tilemap to BG2.
    LDY #menu_window_item_title_data.w                                          ; $019F2E |\ Draw the item title window to BG2.
    JSR _menu_draw_text_indirect_plus_window                                    ; $019F31 |/
    LDA #MENU_PALETTE_INDEX_BG4.b                                               ; $019F34 |\ Erase the palette for BG4 to make it disappear.
    JSR _menu_erase_background_palette                                          ; $019F36 |/
    JSR _menu_copy_tilemap_to_vram_bg2                                          ; $019F39 | Copy the BG2 tilemap to VRAM.
    JSR _menu_copy_palette_to_cgram                                             ; $019F3C | Copy the updated palette data to CG-RAM
    LDX r_menu_bg_scroll_vertical_bg1_backup.w                                  ; $019F3F |\ Set the BG1 scroll value to the backed up value, if any.
    STX <r_menu_scroll_bg1.vertical.value                                       ; $019F42 |/
    JSR _menu_set_bg_scroll_proxy                                               ; $019F44 | Set the background scroll values.
    INC r_menu_items_enabled.w                                                  ; $019F47 | Show items as being available for use.
    LDX #ITEM_FIRST_FIELD_ITEM + (ITEM_LAST_FIELD_ITEM << 8).w                  ; $019F4A |\ Set the enabled items to those usable in the field.
    STX r_menu_inventory_enabled_item_range.w                                   ; $019F4D |/
    JSR _menu_set_current_tilemap_bg1_and_initialize                            ; $019F50 | Set the current tilemap to BG1 and erase it.
    JSR _menu_inventory_draw_window                                             ; $019F53 | Draw the inventory window.
    JSR _menu_set_bg_scroll_proxy                                               ; $019F56 | Set the current background scroll values.
    JSR _menu_animate_current_tilemap_50_rows_to_vram                           ; $019F59 | Animate the inventory window opening.
    JSR _menu_item_handle_input                                                 ; $019F5C | Execute the item menu input handler to run the menu.
    JSR _menu_initialize_oam                                                    ; $019F5F | Initialize the OAM.
    JSR _menu_wait_for_vblank_copy_oam_to_ppu                                   ; $019F62 | Copy the OAM to the PPU.
    LDX <r_menu_scroll_bg1.vertical.value                                       ; $019F65 |\ Back up the current BG1 vertical scroll value.
    STX r_menu_bg_scroll_vertical_bg1_backup.w                                  ; $019F67 |/
    JSR _menu_set_current_tilemap_bg1_and_initialize                            ; $019F6A | Set the current tilemap to BG1 and erase it.
    JSR _menu_animate_current_tilemap_50_rows_to_vram_reversed                  ; $019F6D | Animate the inventory window closing.
    JSR _menu_initialize_tilemap_bg2                                            ; $019F70 | Erase BG2.
    JSR _menu_restore_cgram_1                                                   ; $019F73 | Restore the backed up palette data.
    JSR _menu_copy_tilemap_to_vram_bg2                                          ; $019F76 | Copy the BG2 tilemap to VRAM.
    JSR _menu_copy_palette_to_cgram                                             ; $019F79 | Copy the palette data to CG-RAM.
    JSR _menu_set_current_tilemap_bg4                                           ; $019F7C | Set the current tilemap to BG4.
    LDA #$1C.b                                                                  ; $019F7F |\
    STA <r_menu_transition_scroll_frames                                        ; $019F81 | | Animate the item title window changing into the command window and
    LDA #6.b | %10000000                                                        ; $019F83 | | sliding right by 168 pixels.
    STA <r_menu_scroll_delta_bg4.horizontal.value.lo                            ; $019F85 | |
    LDX #menu_window_main_command_data.w                                        ; $019F87 | |
    LDY #menu_window_item_title_right_data.w                                    ; $019F8A | |
    JSR _menu_window_transition                                                 ; $019F8D |/
    JSR _menu_main_draw                                                         ; $019F90 | Draw the main menu.
    JSR _menu_party_draw_character_portraits                                    ; $019F93 | Draw the character portraits.
    JSR _menu_wait_for_vblank_copy_oam_to_ppu                                   ; $019F96 | Copy the OAM to the PPU.
    LDA #%00011111.b                                                            ; $019F99 |\ Set all screens as the main screen.
    STA reg_ppu_tm.l                                                            ; $019F9B |/
    STZ r_menu_items_enabled.w                                                  ; $019F9F | Reset the items enabled flag.
    JMP _menu_animate_current_tilemap_50_rows_to_vram                           ; $019FA2 | Animate the command list opening from the top.

; _menu_item_handle_input ($01:9FA5)
;
; Handles input in the item menu.
_menu_item_handle_input:
    JSR _menu_item_draw_item_description_window                                 ; $019FA5 | Draw the item description window.
    LDX #VRAM_MENU_TILEMAP_BG2.w                                                ; $019FA8 |\
    STX <r_menu_copy_to_vram_arg_target_vram_address                            ; $019FAB | | Wait for vblank and copy the first five rows of BG2 to VRAM, to
    LDX #r_menu_tilemap_bg2.w                                                   ; $019FAD | | copy the updated item description window.
    STX <r_menu_copy_to_vram_arg_source_address                                 ; $019FB0 | |
    LDA #:r_menu_tilemap_bg2.b                                                  ; $019FB2 | |
    STA <r_menu_copy_to_vram_arg_source_bank                                    ; $019FB4 | |
    LDX #(5 * 32 * 2).w                                                         ; $019FB6 | |
    STX <r_menu_copy_to_vram_arg_bytes                                          ; $019FB9 | |
    JSR _menu_wait_for_vblank                                                   ; $019FBB | |
    JSR _menu_copy_to_vram                                                      ; $019FBE |/
    JSR _menu_copy_oam_to_ppu                                                   ; $019FC1 | Copy the OAM to the PPU.
    JSR _menu_copy_tilemap_to_vram_bg1_no_vblank                                ; $019FC4 | Copy the BG1 tilemap to VRAM.
    JSR _menu_update_joypad_and_play_sound_effect                               ; $019FC7 | Update the joypad values and play an associated sound effect.
@loop_start:
    LDA <r_menu_joypad_repeat.hi                                                ; $019FCA |\
    AND #JOYPAD_H_LEFT.b                                                        ; $019FCC | | If the left button is pressed on the d-pad, toggle the X
    BEQ +                                                                       ; $019FCE | | coordinate between 0 and 1. If the result is 1, branch to the up
    LDA r_menu_item_cursor_coordinates.x.w                                      ; $019FD0 | | code to move up a row.
    INC A                                                                       ; $019FD3 | |
    AND #%00000001.b                                                            ; $019FD4 | |
    STA r_menu_item_cursor_coordinates.x.w                                      ; $019FD6 | |
    BNE @up                                                                     ; $019FD9 |/
+   LDA <r_menu_joypad_repeat.hi                                                ; $019FDB |\
    AND #JOYPAD_H_RIGHT.b                                                       ; $019FDD | | If the right d-pad button is pressed, toggle the X coordinate
    BEQ +                                                                       ; $019FDF | | between 0 and 1, and if the result is zero, branch to the down
    LDA r_menu_item_cursor_coordinates.x.w                                      ; $019FE1 | | code to handle moving down a row.
    INC A                                                                       ; $019FE4 | |
    AND #%00000001.b                                                            ; $019FE5 | |
    STA r_menu_item_cursor_coordinates.x.w                                      ; $019FE7 | |
    BEQ @down                                                                   ; $019FEA |/
+   LDA <r_menu_joypad_repeat.hi                                                ; $019FEC |\
    AND #JOYPAD_H_UP.b                                                          ; $019FEE | | If the up d-pad button is not pressed, branch to check down.
    BEQ @check_down                                                             ; $019FF0 |/
@up:
    LDA r_menu_item_cursor_coordinates.y.w                                      ; $019FF2 |\ If the Y coordinate of the cursor is greater than zero, branch to
    BNE @cursor_up_only                                                         ; $019FF5 |/ only decrement the cursor.
    LDA r_menu_item_first_row.w                                                 ; $019FF7 |\ If the first row is already zero, branch to check down, as there is
    BEQ @check_down                                                             ; $019FFA |/ no further to go up.
    DEC A                                                                       ; $019FFC |\ Otherwise, decrement the first row.
    STA r_menu_item_first_row.w                                                 ; $019FFD |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $01A000 |\ Initialize the Y register to eight.
    LDY #8.w                                                                    ; $01A002 |/
-   LDA <r_menu_scroll_bg1.vertical.value.lo                                    ; $01A005 |\
    SEC                                                                         ; $01A007 | | Decrement the BG1 vertical scroll value by 2.
    SBC #2.w                                                                    ; $01A008 | |
    STA <r_menu_scroll_bg1.vertical.value.lo                                    ; $01A00B | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01A00D |/
    LDA r_menu_item_selected.w                                                  ; $01A00F |\
    BEQ +                                                                       ; $01A012 | | If an item is selected, adjust the Y coordinate of the selected
    INC r_oam.5.y.w                                                             ; $01A014 | | cursor to cause it to move as well.
    INC r_oam.5.y.w                                                             ; $01A017 |/
+   PHY                                                                         ; $01A01A | Preserve the value of the Y register.
    JSR _menu_item_draw_item_description_window                                 ; $01A01B | Draw the updated item description window.
    JSR _menu_wait_for_vblank_copy_oam_to_ppu                                   ; $01A01E | Wait for vblank and copy the updated OAM to the PPU.
    JSR _menu_copy_tilemap_to_vram_bg2_no_vblank                                ; $01A021 | Copy the BG2 tilemap to VRAM.
    JSR _menu_set_bg_scroll_proxy                                               ; $01A024 | Set the updated background scroll values.
    PLY                                                                         ; $01A027 |\ Restore the Y register and switch back to 16-bit accumulator mode.
    REP #FLAG_P_ACCUMULATOR                                                     ; $01A028 |/
    DEY                                                                         ; $01A02A |\ Decrement the Y register and loop until a total of 8 pixels have
    BNE -                                                                       ; $01A02B |/ been scrolled.
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01A02D | Switch to 8-bit accumulator mode.
    JSR _menu_item_update_cursors                                               ; $01A02F | Update the item menu cursors.
    JSR _menu_input_check_left_right                                            ; $01A032 |\ If left or right is either not pressed or pressed but not repeating
    BCS @check_down                                                             ; $01A035 |/ on this frame, branch to check down.
    JMP @loop_start                                                             ; $01A037 | Otherwise, jump back to check left/right input immediately.
@cursor_up_only:
    DEC A                                                                       ; $01A03A |\ If only the cursor is going up, decrement the cursor's Y
    STA r_menu_item_cursor_coordinates.y.w                                      ; $01A03B |/ coordinate.
@check_down:
    LDA <r_menu_joypad_repeat.hi                                                ; $01A03E |\
    AND #JOYPAD_H_DOWN.b                                                        ; $01A040 | | If the down d-pad button is not pressed, branch to check confirm.
    BEQ @check_confirm                                                          ; $01A042 |/
@down:
    LDA r_menu_item_cursor_coordinates.y.w                                      ; $01A044 |\
    CMP #9.b                                                                    ; $01A047 | | If the cursor Y coordinate is less than 9, branch to only update
    BCC @cursor_down_only                                                       ; $01A049 |/  the cursor.
    LDA r_menu_item_first_row.w                                                 ; $01A04B |\
    CMP #14.b                                                                   ; $01A04E | | If the first row is already set to 14, branch to check confirm.
    BEQ @check_confirm                                                          ; $01A050 |/
    INC A                                                                       ; $01A052 |\ Otherwise, increment the first row.
    STA r_menu_item_first_row.w                                                 ; $01A053 |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $01A056 |\ Initialize the loop variable to eight.
    LDY #8.w                                                                    ; $01A058 |/
-   LDA <r_menu_scroll_bg1.vertical.value.lo                                    ; $01A05B |\
    CLC                                                                         ; $01A05D | | Increment the BG1 vertical scroll by two.
    ADC #2.w                                                                    ; $01A05E | |
    STA <r_menu_scroll_bg1.vertical.value.lo                                    ; $01A061 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01A063 |/
    LDA r_menu_item_selected.w                                                  ; $01A065 |\
    BEQ +                                                                       ; $01A068 | | If an item is selected, decrement that cursor's Y coordinate so it
    DEC r_oam.5.y.w                                                             ; $01A06A | | will move up.
    DEC r_oam.5.y.w                                                             ; $01A06D |/
+   PHY                                                                         ; $01A070 |\
    JSR _menu_item_draw_item_description_window                                 ; $01A071 | | Draw the item description window, copy it and the OAM to VRAM, and
    JSR _menu_wait_for_vblank_copy_oam_to_ppu                                   ; $01A074 | | update the background scroll values.
    JSR _menu_copy_tilemap_to_vram_bg2_no_vblank                                ; $01A077 | |
    JSR _menu_set_bg_scroll_proxy                                               ; $01A07A | |
    PLY                                                                         ; $01A07D |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $01A07E |\
    DEY                                                                         ; $01A080 | | Decrement the Y register and loop until all 8 pixels are done.
    BNE -                                                                       ; $01A081 |/
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01A083 | Switch back to 8-bit accumulator mode.
    JSR _menu_item_update_cursors                                               ; $01A085 | Update the item menu cursors.
    JSR _menu_input_check_left_right                                            ; $01A088 |\ If left or right is not pressed or if pressed but not repeating on
    BCS @check_confirm                                                          ; $01A08B |/ this frame, branch to check confirm.
    JMP @loop_start                                                             ; $01A08D | Otherwise, branch to immediately check input again.
@cursor_down_only:
    INC A                                                                       ; $01A090 |\ Increment the cursor Y coordinate.
    STA r_menu_item_cursor_coordinates.y.w                                      ; $01A091 |/
@check_confirm:
    LDA <r_menu_joypad_repeat.lo                                                ; $01A094 |\
    AND #JOYPAD_L_A.b                                                           ; $01A096 | | If the A button is pressed and an item is not currently selected,
    BEQ ++                                                                      ; $01A098 | | select the current item before branching to the end.
    LDA r_menu_item_selected.w                                                  ; $01A09A | |
    BNE +                                                                       ; $01A09D | |
    JSR _menu_item_select_current_item                                          ; $01A09F | |
    BRA @next                                                                   ; $01A0A2 |/
+   JSR _menu_item_attempt_use                                                  ; $01A0A4 | Otherwise, attempt to use the selected item.
    JSR _menu_set_current_tilemap_bg1                                           ; $01A0A7 |\ Draw the updated inventory window.
    JSR _menu_inventory_draw_window                                             ; $01A0AA |/
    STZ r_menu_item_selected.w                                                  ; $01A0AD |\ Unset the currently selected item.
    JSR _menu_item_unselect_item                                                ; $01A0B0 |/
    JSR _menu_copy_tilemap_to_vram_bg1                                          ; $01A0B3 |\
    JSR _menu_copy_oam_to_ppu                                                   ; $01A0B6 | | Copy the updated tilemap and OAM to the PPU and branch to next.
    BRA @next                                                                   ; $01A0B9 |/
++  LDA <r_menu_joypad_repeat.hi                                                ; $01A0BB |\
    AND #JOYPAD_H_B.b                                                           ; $01A0BD | | If the B button is not pressed, branch to the next iteration.
    BEQ @next                                                                   ; $01A0BF |/
    LDA r_menu_item_selected.w                                                  ; $01A0C1 |\
    BEQ +                                                                       ; $01A0C4 | | If the B button is pressed and an item is selected, unselect the
    STZ r_menu_item_selected.w                                                  ; $01A0C6 | | item and then branch to the next iteration.
    JSR _menu_item_unselect_item                                                ; $01A0C9 | |
    BRA @next                                                                   ; $01A0CC |/
+   JSR _menu_item_unselect_item                                                ; $01A0CE |\
    JSR _menu_load_portraits                                                    ; $01A0D1 | | If the B button is pressed and no item is selected, reload the
    STZ <r_unknown_0186                                                         ; $01A0D4 | | character portraits, zero a TODO variable and return.
    RTS                                                                         ; $01A0D6 |/
@next:
    JSR _menu_item_update_cursors                                               ; $01A0D7 | Update the cursors.
    JMP _menu_item_handle_input                                                 ; $01A0DA | Jump to the beginning to keep handling input.

; _menu_item_update_cursors ($01:A0DD)
;
; Updates the coordinates for the main cursor and the selected cursor in the
; item menu.
_menu_item_update_cursors:
    PHY                                                                         ; $01A0DD | Preserve the value in the Y register.
    LDA #%00100000                                                              ; $01A0DE |\ Set the cursor sprite flags for priority 2.
    STA <r_menu_cursor_sprite_flags                                             ; $01A0E0 |/
    LDA r_menu_item_cursor_coordinates.y.w                                      ; $01A0E2 |\
    ASL A                                                                       ; $01A0E5 | | Set the high byte of the accumulator to the cursor Y coordinate
    ASL A                                                                       ; $01A0E6 | | times 16 plus 54.
    ASL A                                                                       ; $01A0E7 | |
    ASL A                                                                       ; $01A0E8 | |
    ADC #54.b                                                                   ; $01A0E9 | |
    XBA                                                                         ; $01A0EB |/
    LDA r_menu_item_cursor_coordinates.x.w                                      ; $01A0EC |\
    BEQ +                                                                       ; $01A0EF | | Set the low byte of the accumulator to either 4 or 108 depending
    LDA #108.b                                                                  ; $01A0F1 | | on the current cursor X coordinate.
+   CLC                                                                         ; $01A0F3 | |
    ADC #4.b                                                                    ; $01A0F4 |/
    TAX                                                                         ; $01A0F6 | Transfer the accumulator value to the X register.
    LDY #r_oam.1.w                                                              ; $01A0F7 |\ Draw the cursor to those coordinates in the first OAM entry.
    JSR _menu_draw_cursor_direct                                                ; $01A0FA |/
    LDA r_menu_item_selected.w                                                  ; $01A0FD |\ Branch to the end unless an item is selected.
    BEQ @done                                                                   ; $01A100 |/
    LDA r_menu_item_selected_coordinates.y.w                                    ; $01A102 |\
    SEC                                                                         ; $01A105 | | Subtract the first row from the selected Y coordinate to determine
    SBC r_menu_item_first_row.w                                                 ; $01A106 | | its on-screen coordinate. If the result is less than -4 or greater
    CMP #-4.b                                                                   ; $01A109 | | than 10, branch ahead to erase the selected cursor. Otherwise,
    BCS +                                                                       ; $01A10B | | continue.
    CMP #0.b                                                                    ; $01A10D | |
    BMI ++                                                                      ; $01A10F | |
    CMP #11.b                                                                   ; $01A111 | |
    BCS ++                                                                      ; $01A113 |/
+   ASL A                                                                       ; $01A115 |\
    ASL A                                                                       ; $01A116 | | Draw the selected cursor in much the same way as the first. The
    ASL A                                                                       ; $01A117 | | only differences are that the 5th OAM entry is used and that the
    ASL A                                                                       ; $01A118 | | cursor is drawn to the right by four pixels.
    ADC #54.b                                                                   ; $01A119 | |
    XBA                                                                         ; $01A11B | |
    LDA r_menu_item_selected_coordinates.x.w                                    ; $01A11C | |
    BEQ +                                                                       ; $01A11F | |
    LDA #112.b                                                                  ; $01A121 | |
+   CLC                                                                         ; $01A123 | |
    ADC #8.b                                                                    ; $01A124 | |
    TAX                                                                         ; $01A126 | |
    LDY #r_oam.5.w                                                              ; $01A127 | |
    JSR _menu_draw_cursor_direct                                                ; $01A12A | |
    BRA @done                                                                   ; $01A12D |/
++  JSR _menu_erase_cursor_2                                                    ; $01A12F | Erase the cursor if not visible.
@done:
    PLY                                                                         ; $01A132 | Restore the Y register.
    RTS                                                                         ; $01A133

; _menu_spoils_draw_inventory ($01:A134)
;
; Draws the spoils inventory to the current tilemap.
_menu_spoils_draw_inventory:
    LDX #r_menu_spoils_inventory.w                                              ; $01A134 |\ Set the inventory pointer to the spoils inventory.
    STX <r_menu_load_inventory_tmp_inventory_ptr                                ; $01A137 |/
    LDA #8.b                                                                    ; $01A139 |\ Set the item index limit to the size of the spoils inventory.
    STA <r_menu_load_inventory_tmp_item_index_limit                             ; $01A13B |/
    BRA _menu_inventory_draw_inventory                                          ; $01A13D | Branch to the code to draw the inventory entries.

; _menu_big_chocobo_draw_inventory ($01:A13F)
;
; Draws the Big Chocobo inventory to the current tilemap. Since the Big Chocobo
; inventory is big enough to cover two backgrounds, this will actually overwrite
; both the current tilemap and the one following it. The code itself uses BG2,
; which is followed by BG1 in RAM. These tilemaps are never copied to VRAM, and
; are instead used as a staging area in RAM before being copied piecemeal as
; needed to BG4.
_menu_big_chocobo_draw_inventory:
    LDX #r_big_chocobo_inventory.w                                              ; $01A13F |\ Set the inventory pointer to the Big Chocobo inventory.
    STX <r_menu_load_inventory_tmp_inventory_ptr                                ; $01A142 |/
    LDA #126.b                                                                  ; $01A144 |\ Set the item index limit to the size of the Big Chocobo inventory.
    STA <r_menu_load_inventory_tmp_item_index_limit                             ; $01A146 |/
    BRA _menu_inventory_draw_inventory                                          ; $01A148 | Branch to the code to actually draw the entries.

; _menu_inventory_draw_window ($01:A14A)
;
; Draws the inventory window used for various menu screens. Falls through to the
; next function to draw the actual inventory.
_menu_inventory_draw_window:
    LDY #menu_window_sell_inventory_data.w                                      ; $01A14A |\ Draw the main window for displaying the player's inventory.
    JSR _menu_configure_and_draw_window                                         ; $01A14D |/
    LDX #r_inventory.w                                                          ; $01A150 |\ Initialize the inventory pointer to the base address for the
    STX <r_menu_load_inventory_tmp_inventory_ptr                                ; $01A153 |/ inventory.
    LDA #48.b                                                                   ; $01A155 |\ Initialize the item index limit to 48, as the inventory has 48
    STA <r_menu_load_inventory_tmp_item_index_limit                             ; $01A157 |/ entries.

; _menu_inventory_draw_inventory ($01:A159)
;
; Given the 16-bit offset to an inventory in $5A, draws that inventory to the
; currently active tilemap. The item index limit should also be configured in
; $E1.
_menu_inventory_draw_inventory:
    STZ <r_menu_load_inventory_tmp_item_index.lo                                ; $01A159 |\ Initialize the item index to zero.
    STZ <r_menu_load_inventory_tmp_item_index.hi                                ; $01A15B |/
@start:
    LDA (<r_menu_load_inventory_tmp_inventory_ptr)                              ; $01A15D |\ Skip to the next iteration if this inventory slot is empty.
    BEQ @next                                                                   ; $01A15F |/
    CMP #ITEM_TRASHCAN.b                                                        ; $01A161 |\
    BNE +                                                                       ; $01A163 | | If the item is the TrashCan, draw the associated icon and then
    JSR _menu_inventory_draw_trashcan                                           ; $01A165 | | branch to the next iteration.
    BRA @next                                                                   ; $01A168 |/
+   LDY #inventory_entry.count.w                                                ; $01A16A |\
    LDA (<r_menu_load_inventory_tmp_inventory_ptr),Y                            ; $01A16D | | Otherwise, if the item count is zero, branch to the next loop.
    BEQ @next                                                                   ; $01A16F |/
    STA <r_menu_load_inventory_tmp_item_count                                   ; $01A171 | Save the item count to a temporary variable.
    LDA #0.b                                                                    ; $01A173 |\ Zero out the high byte of the accumulator.
    XBA                                                                         ; $01A175 |/
    LDA (<r_menu_load_inventory_tmp_inventory_ptr)                              ; $01A176 |\
    CMP #ITEM_WHISTLE.b                                                         ; $01A178 | | If the current item is either the Whistle or Sort and if items are
    BEQ +                                                                       ; $01A17A | | enabled in the inventory menu, copy the base tile flags to the
    CMP #ITEM_SORT.b                                                            ; $01A17C | | extra tile flags variable.
    BNE ++                                                                      ; $01A17E | |
+   LDA r_menu_items_enabled.w                                                  ; $01A180 | |
    BEQ ++                                                                      ; $01A183 | |
    LDA <r_menu_current_tilemap_base_tile_flags                                 ; $01A185 | |
    STA <r_menu_current_tilemap_extra_tile_flags                                ; $01A187 | |
    BRA +                                                                       ; $01A189 |/
++  LDA (<r_menu_load_inventory_tmp_inventory_ptr)                              ; $01A18B |\ Set the tile flags for the current item.
    JSR _menu_inventory_set_tile_flags                                          ; $01A18D |/
+   REP #FLAG_P_ACCUMULATOR                                                     ; $01A190 |\
    LDA <r_menu_load_inventory_tmp_item_index                                   ; $01A192 | | Set the Y register to the item index divided by two, multiplied by
    LSR A                                                                       ; $01A194 | | 128, and then add four to account for the black tile and the
    ASL A                                                                       ; $01A195 | | window border tile on the left side of the screen.
    ASL A                                                                       ; $01A196 | |
    ASL A                                                                       ; $01A197 | |
    ASL A                                                                       ; $01A198 | |
    ASL A                                                                       ; $01A199 | |
    ASL A                                                                       ; $01A19A | |
    ASL A                                                                       ; $01A19B | |
    ADC #(2 * 2).w                                                              ; $01A19C | |
    TAY                                                                         ; $01A19F | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01A1A0 |/
    JSR _menu_inventory_draw_item_and_count                                     ; $01A1A2 | Draw the item name and count to the tilemap.
@next:
    REP #FLAG_P_ACCUMULATOR                                                     ; $01A1A5 |\
    INC <r_menu_load_inventory_tmp_inventory_ptr                                ; $01A1A7 | | Increment the inventory pointer by two to move to the next item.
    INC <r_menu_load_inventory_tmp_inventory_ptr                                ; $01A1A9 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01A1AB |/
    INC <r_menu_load_inventory_tmp_item_index                                   ; $01A1AD |\ Increment the current item index.
    LDA <r_menu_load_inventory_tmp_item_index                                   ; $01A1AF |/
    CMP <r_menu_load_inventory_tmp_item_index_limit                             ; $01A1B1 |\ Loop until it reaches the limit.
    BNE @start                                                                  ; $01A1B3 |/
    RTS                                                                         ; $01A1B5

; _menu_inventory_draw_item_and_count ($01:A1B6)
;
; Draws the current item to the current tilemap, when drawing the inventory for
; the menu. This code does not handle the TrashCan icon.
_menu_inventory_draw_item_and_count:
    LDA r_menu_inventory_shift_one_row.w                                        ; $01A1B6 |\
    BNE +                                                                       ; $01A1B9 | | If configured to shift one row, add 64 to the tilemap offset.
    REP #FLAG_P_ACCUMULATOR                                                     ; $01A1BB | |
    TYA                                                                         ; $01A1BD | |
    CLC                                                                         ; $01A1BE | |
    ADC #64.w                                                                   ; $01A1BF | |
    TAY                                                                         ; $01A1C2 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01A1C3 |/
+   LDA <r_menu_load_inventory_tmp_item_index                                   ; $01A1C5 |\
    AND #%00000001.b                                                            ; $01A1C7 | | If the item index is odd, branch to the right side code.
    BNE @right                                                                  ; $01A1C9 |/
    LDA (<r_menu_load_inventory_tmp_inventory_ptr)                              ; $01A1CB |\ Draw the item name to the tilemap.
    JSR _menu_draw_item_name_direct                                             ; $01A1CD |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $01A1D0 |\
    TYA                                                                         ; $01A1D2 | | Add to the tilemap offset in the Y register to move the current
    CLC                                                                         ; $01A1D3 | | location to the lower row and nine characters to the right.
    ADC #((32 + 9) * 2).w                                                       ; $01A1D4 | |
    TAY                                                                         ; $01A1D7 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01A1D8 |/
    LDA (<r_menu_load_inventory_tmp_inventory_ptr)                              ; $01A1DA |\
    CMP #ITEM_SORT.b                                                            ; $01A1DC | | If the item is Sort, branch to return.
    BEQ +                                                                       ; $01A1DE |/
    LDA #TEXT_COLON.b                                                           ; $01A1E0 |\
    STA (<r_menu_current_tilemap_base_address),Y                                ; $01A1E2 | | Set the character at this location to a colon.
    INY                                                                         ; $01A1E4 | |
    LDA <r_menu_current_tilemap_extra_tile_flags.b                              ; $01A1E5 | |
    STA (<r_menu_current_tilemap_base_address),Y                                ; $01A1E7 | |
    INY                                                                         ; $01A1E9 |/
    PHY                                                                         ; $01A1EA |\
    LDA <r_menu_load_inventory_tmp_item_count                                   ; $01A1EB | | Draw the two digit item count at the current location (after the
    JSR _menu_draw_two_digit_number                                             ; $01A1ED | | colon).
    PLY                                                                         ; $01A1F0 |/
    INY                                                                         ; $01A1F1 |\
    LDA <r_menu_current_tilemap_extra_tile_flags.b                              ; $01A1F2 | | Set the tile flags for the number to the extra tile flags value.
    STA (<r_menu_current_tilemap_base_address),Y                                ; $01A1F4 | |
    INY                                                                         ; $01A1F6 | |
    INY                                                                         ; $01A1F7 | |
    STA (<r_menu_current_tilemap_base_address),Y                                ; $01A1F8 |/
+   RTS                                                                         ; $01A1FA
@right:
    REP #FLAG_P_ACCUMULATOR                                                     ; $01A1FB |\
    TYA                                                                         ; $01A1FD | | Move the cursor 14 tiles to the right, in order to draw the item
    CLC                                                                         ; $01A1FE | | name to the right half of the tilemap.
    ADC #(14 * 2).w                                                             ; $01A1FF | |
    TAY                                                                         ; $01A202 | |
    SEP #FLAG_P_ACCUMULATOR.b                                                   ; $01A203 |/
    LDA (<r_menu_load_inventory_tmp_inventory_ptr)                              ; $01A205 |\ Draw the item name to the current location.
    JSR _menu_draw_item_name_direct                                             ; $01A207 |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $01A20A |\
    TYA                                                                         ; $01A20C | | Add to the tilemap offset in the Y register to move the cursor to
    CLC                                                                         ; $01A20D | | the lower row and move nine characters to the right.
    ADC #((32 + 9) * 2).w                                                       ; $01A20E | |
    TAY                                                                         ; $01A211 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01A212 |/
    LDA (<r_menu_load_inventory_tmp_inventory_ptr)                              ; $01A214 |\
    CMP #ITEM_SORT.b                                                            ; $01A216 | | If the item is Sort, branch to return.
    BEQ +                                                                       ; $01A218 |/
    LDA #TEXT_COLON.b                                                           ; $01A21A |\
    STA (<r_menu_current_tilemap_base_address),Y                                ; $01A21C | | Set the current character in the tilemap to the colon, using the
    INY                                                                         ; $01A21E | | extra tile flags.
    LDA <r_menu_current_tilemap_extra_tile_flags                                ; $01A21F | |
    STA (<r_menu_current_tilemap_base_address),Y                                ; $01A221 | |
    INY                                                                         ; $01A223 |/
    LDA <r_menu_load_inventory_tmp_item_count                                   ; $01A224 |\
    PHY                                                                         ; $01A226 | | Draw the two digit item count to the next two locations.
    JSR _menu_draw_two_digit_number                                             ; $01A227 | |
    PLY                                                                         ; $01A22A |/
    INY                                                                         ; $01A22B |\
    LDA <r_menu_current_tilemap_extra_tile_flags                                ; $01A22C | | Set the flags for the number tiles to the extra tile flags.
    STA (<r_menu_current_tilemap_base_address),Y                                ; $01A22E | |
    INY                                                                         ; $01A230 | |
    INY                                                                         ; $01A231 | |
    STA (<r_menu_current_tilemap_base_address),Y                                ; $01A232 |/
+   RTS                                                                         ; $01A234

; _menu_inventory_set_tile_flags ($01:A235)
;
; Given an item ID in the accumulator, determines the color the item should be
; drawn with and sets the extra tile flags in $DB appropiately. Note that this
; routine is shared by many code paths, and is configured with various
; variables. In addition, some of the code paths do their own handling of some
; items, so this routine is not necessarily the only factor. Some of the
; variables that control its behavior are listed shortly, but note that
; attempting to describe their interaction is not attempted. $1BC9 generally
; controls if items are intended to be used from this screen, but it primarily
; enables the Tent and Cabin if appropriate. The two values in $1B1D and $1B1E
; determine the low and high end of the range of items that should be enabled.
; (This is unrelated to the previous value.) $1BC6 controls the highlighting of
; key items in a yellow color.
_menu_inventory_set_tile_flags:
    PHA                                                                         ; $01A235 |\ Push the item ID to the stack twice.
    PHA                                                                         ; $01A236 |/
    LDA r_menu_equip_active.w                                                   ; $01A237 |\
    BEQ +                                                                       ; $01A23A | | If the equip screen is active, determine if the item in question
    PLA                                                                         ; $01A23C | | can be equipped to the chosen location. If not, branch to the
    JSR _menu_equip_check_equipment_compatibility                               ; $01A23D | | incompatible code. Otherwise, branch to enable the item.
    BCC @incompatible                                                           ; $01A240 | |
    BRA @enabled                                                                ; $01A242 | |
+   PLA                                                                         ; $01A244 |/
    CMP #ITEM_TENT.b                                                            ; $01A245 |\
    BEQ +                                                                       ; $01A247 | | If the item is either the Tent or the Cabin, if items are flagged
    CMP #ITEM_CABIN.b                                                           ; $01A249 | | as enabled and if saving is enabled, branch to enable the item. If
    BNE ++                                                                      ; $01A24B | | saving is diabled, branch to disable the item. If the item is not
+   PHA                                                                         ; $01A24D | | a Tent or Cabin or if items are disabled, branch to the next
    LDA r_menu_items_enabled.w                                                  ; $01A24E | | check.
    BEQ +                                                                       ; $01A251 | |
    PLA                                                                         ; $01A253 | |
    LDA r_saving_enabled.w                                                      ; $01A254 | |
    BEQ @disabled                                                               ; $01A257 | |
    BRA @enabled                                                                ; $01A259 | |
+   PLA                                                                         ; $01A25B |/
++  CMP #ITEM_LEGEND.b                                                          ; $01A25C |\
    BEQ @incompatible                                                           ; $01A25E | | If the item is Legend or the Crystal, branch to the incompatible
    CMP #ITEM_CRYSTAL.b                                                         ; $01A260 | | code.
    BEQ @incompatible                                                           ; $01A262 |/
    CMP r_menu_inventory_enabled_item_range.lo.w                                ; $01A264 |\
    BCC @incompatible                                                           ; $01A267 | | If the item is in the enabled item range, branch or fall through
    CMP r_menu_inventory_enabled_item_range.hi.w                                ; $01A269 | | to enable the item. Otherwise, branch to the incompatible code.
    BEQ @enabled                                                                ; $01A26C | |
    BCS @incompatible                                                           ; $01A26E |/
@enabled:
    LDA <r_menu_current_tilemap_base_tile_flags                                 ; $01A270 |\
    STA <r_menu_current_tilemap_extra_tile_flags                                ; $01A272 | | Copy the base tile flags to the extra tile flags, restore the
    PLA                                                                         ; $01A274 | | accumulator and return.
    RTS                                                                         ; $01A275 |/
@incompatible:
    CMP #ITEM_LEGEND.b                                                          ; $01A276 |\
    BEQ +                                                                       ; $01A278 | | If the item is the Legend, Crystal or is in the key item range,
    CMP #ITEM_CRYSTAL.b                                                         ; $01A27A | | branch ahead past the disabled code.
    BEQ +                                                                       ; $01A27C | |
    CMP #ITEM_FIRST_KEY_ITEM.b                                                  ; $01A27E | |
    BCS +                                                                       ; $01A280 |/
@disabled:
    LDA #%00000100.b                                                            ; $01A282 |\
    ORA <r_menu_current_tilemap_base_tile_flags                                 ; $01A284 | | Set another bit in the flags to increment the palette number to
    STA <r_menu_current_tilemap_extra_tile_flags                                ; $01A286 | | draw the item in grey.
    PLA                                                                         ; $01A288 | |
    RTS                                                                         ; $01A289 |/
+   CMP #ITEM_SORT.b                                                            ; $01A28A |\ If the item is Sort, branch to the disabled code.
    BEQ @disabled                                                               ; $01A28C |/
    LDA r_menu_inventory_highlight_key_items.w                                  ; $01A28E |\
    BEQ @disabled                                                               ; $01A291 | | If key item highlighting is enabled, update the tile flags to use
    LDA #%00001000.b                                                            ; $01A293 | | the yellow text color. Otherwise, branch to the disabled code.
    ORA <r_menu_current_tilemap_base_tile_flags                                 ; $01A295 | |
    STA <r_menu_current_tilemap_extra_tile_flags                                ; $01A297 | |
    PLA                                                                         ; $01A299 |/
    RTS                                                                         ; $01A29A

; _menu_item_select_current_item ($01:A29B)
;
; Selects the current item by setting the selected item coordinates and setting
; the selected item flag.
_menu_item_select_current_item:
    LDA r_menu_item_first_row.w                                                 ; $01A29B |\
    CLC                                                                         ; $01A29E | | Set the selected Y coordinate to the first row plus the cursor Y
    ADC r_menu_item_cursor_coordinates.y.w                                      ; $01A29F | | coordinate.
    STA r_menu_item_selected_coordinates.y.w                                    ; $01A2A2 |/
    LDA r_menu_item_cursor_coordinates.x.w                                      ; $01A2A5 |\ Transfer the cursor X coordinate directly as the selected X
    STA r_menu_item_selected_coordinates.x.w                                    ; $01A2A8 |/ coordinate.
    LDA #1.b                                                                    ; $01A2AB |\ Set the item selected flag.
    STA r_menu_item_selected.w                                                  ; $01A2AD |/
    RTS                                                                         ; $01A2B0

; _menu_item_unselect_item ($01:A2B1)
;
; Unselects the selected item in the item menu. Falls through to the next
; function to erase the associated cursor.
_menu_item_unselect_item:
    STZ r_menu_item_selected.w                                                  ; $01A2B1 | Reset the selected item flag.

; _menu_erase_cursor_* ($01:A2B4)
;
; Depending on the entry point, either erases the first or the second cursor. A
; third entry point, _direct, allows the caller to directly specify the entries
; to erase by loading the offset within the OAM into the Y register. Two OAM
; entries starting at that offset will be erased.
;
; NOTE: This seems like it wants to reset the values of four OAM entries, but
;       the Y register is not incremented, so it actually only resets the first
;       two entries (including setting the tile and flags to odd vlaues). This
;       doesn't seem to matter much, since cursors use only a single sprite.
_menu_erase_cursor_2:
    LDY #r_oam.5.w                                                              ; $01A2B4 | Load the offset for the second cursor and fall through.
_menu_erase_cursor_direct:
    LDX #4.w                                                                    ; $01A2B7 | Initialize the X register to four.
-   LDA #$FF.b                                                                  ; $01A2BA |\
    STA 0.w,Y                                                                   ; $01A2BC | | Set either the X coordinate or the tile to $FF.
    INY                                                                         ; $01A2BF |/
    LDA #$F0.b                                                                  ; $01A2C0 |\
    STA 0.w,Y                                                                   ; $01A2C2 | | Set either the Y coordinate or the flags to $F0.
    INY                                                                         ; $01A2C5 |/
    DEX                                                                         ; $01A2C6 |\ Decrement the X register and loop until it reaches zero.
    BNE -                                                                       ; $01A2C7 |/
    RTS                                                                         ; $01A2C9
_menu_erase_cursor_1:
    LDY #r_oam.1.w                                                              ; $01A2CA | Load the offset for the first cursor.
    BRA _menu_erase_cursor_direct                                               ; $01A2CD | Branch to erase the cursor.

; _menu_item_handler_empty_space ($01:A2CF)
;
; Handles a player selecting an empty space in the item menu.
_menu_item_handle_empty_space:
    JSR _menu_set_current_tilemap_bg2                                           ; $01A2CF | Set the current tilemap to BG2.
    LDY #menu_window_item_description_data.w                                    ; $01A2D2 |\
    JSR _menu_configure_and_draw_window                                         ; $01A2D5 | | Draw the item description window and draw the "Nothing here" text
    LDY #menu_text_nothing_here_data.w                                          ; $01A2D8 | | within it.
    JSR _menu_draw_text_indirect                                                ; $01A2DB |/
    JMP _menu_item_finalize_error                                               ; $01A2DE | Jump to finalize the error and wait for input.

; _menu_item_attempt_use ($01:A2E1)
;
; Given the current cursor coordinates for the item menu, determines if the
; current item can be used, and if so, calls the handler.
_menu_item_attempt_use:
    LDA r_menu_item_cursor_coordinates.y.w                                      ; $01A2E1 |\
    CLC                                                                         ; $01A2E4 | | If the cursor coordinates and selected item coordinates don't
    ADC r_menu_item_first_row.w                                                 ; $01A2E5 | | match, branch to the code to handle different locations.
    CMP r_menu_item_selected_coordinates.y.w                                    ; $01A2E8 | |
    BNE _menu_item_trashcan_combine_swap                                        ; $01A2EB | |
    LDA r_menu_item_cursor_coordinates.x.w                                      ; $01A2ED | |
    CMP r_menu_item_selected_coordinates.x.w                                    ; $01A2F0 | |
    BNE _menu_item_trashcan_combine_swap                                        ; $01A2F3 |/
    LDA r_menu_item_selected_coordinates.y.w                                    ; $01A2F5 |\
    ASL A                                                                       ; $01A2F8 | | Set the X register to the offset to the selected inventory item.
    ADC r_menu_item_selected_coordinates.x.w                                    ; $01A2F9 | |
    ASL A                                                                       ; $01A2FC | |
    STA <r_menu_generic_tmp_word.lo                                             ; $01A2FD | |
    STZ <r_menu_generic_tmp_word.hi                                             ; $01A2FF | |
    LDX <r_menu_generic_tmp_word                                                ; $01A301 |/
    LDA r_inventory.1.count.w,X                                                 ; $01A303 |\ If the item count is zero, handle the item as an empty space.
    BEQ _menu_item_handle_empty_space                                           ; $01A306 |/
    LDA r_inventory.1.id.w,X                                                    ; $01A308 |\
    CMP #ITEM_SORT.b                                                            ; $01A30B | | If the item is the Sort item, jump to sort the inventory.
    BNE +                                                                       ; $01A30D | |
    JMP _menu_item_sort_inventory                                               ; $01A30F |/
+   JSR _menu_inventory_set_tile_flags                                          ; $01A312 | Set the tile flags for the item.
    LDA <r_menu_generic_tmp_offset_2.lo                                         ; $01A315 |\  TODO: If some flag is set, skip the next block. This code may not
    AND #%00001000.b                                                            ; $01A317 | |       ever actually be valid. Nothing seems to set $60, unless
    BNE +++                                                                     ; $01A319 |/        it's buried in the $A235 call.
    LDA r_inventory.1.id.w,X                                                    ; $01A31B |\ Save the selected item ID to a variable.
    STA r_menu_item_selected_item_id.w                                          ; $01A31E |/
    STX r_menu_item_inventory_offset.w                                          ; $01A321 | Save the inventory offset to another variable.
    CMP #ITEM_WHISTLE.b                                                         ; $01A324 |\
    BNE ++                                                                      ; $01A326 | | If the item is the Whistle, decrement its count, and if the count
    DEC r_inventory.1.count.w,X                                                 ; $01A328 | | reaches zero, remove the item from the inventory. Afterward, jump
    BNE +                                                                       ; $01A32B | | to the Whistle handler.
    STZ r_inventory.1.id.w,X                                                    ; $01A32D | |
+   JMP _menu_item_whistle                                                      ; $01A330 |/
++  CMP #ITEM_FIRST_FIELD_ITEM.b                                                ; $01A333 |\
    BCC +++                                                                     ; $01A335 | | If the item is in the range of usable items ($CE through $EA),
    CMP #ITEM_FIRST_KEY_ITEM.b - 1                                              ; $01A337 | | call the routine to use the item.
    BCS +++                                                                     ; $01A339 | |
    JMP _menu_item_use_item                                                     ; $01A33B |/
+++ JSR _menu_set_current_tilemap_bg2                                           ; $01A33E |\
    LDY #menu_window_item_description_data.w                                    ; $01A341 | | Otherwise, draw text at the top of the window saying that the item
    JSR _menu_configure_and_draw_window                                         ; $01A344 | | cannot be used here.
    LDY #menu_text_cannot_use_here_data.w                                       ; $01A347 | |
    JSR _menu_draw_text_indirect                                                ; $01A34A |/

; _menu_item_finalize_error ($01:A34D)
;
; Copies the BG2 tilemap to VRAM, waits for input, unselects the current item,
; does some unused drawing of a window, and returns.
_menu_item_finalize_error:
    JSR _menu_copy_tilemap_to_vram_bg2                                          ; $01A34D | Copy the BG2 tilemap to VRAM.
    JSR _menu_wait_for_input                                                    ; $01A350 | Wait for input.
    JSR _menu_item_unselect_item                                                ; $01A353 | Unselect the selected item.
    JSR _menu_set_current_tilemap_bg2                                           ; $01A356 | Set the current tilemap to BG2.
    LDY #menu_window_item_title_right_data.w                                    ; $01A359 |\
    JSR _menu_configure_and_draw_window                                         ; $01A35C | | NOTE: This odd code draws a small window to the right side of the
    LDY #menu_text_item_data.w                                                  ; $01A35F | |       BG2 tilemap and draws some text. However, the BG2 tilemap is
    JSR _menu_draw_text_indirect                                                ; $01A362 |/        never actually copied to VRAM.
    RTS                                                                         ; $01A365

; _menu_item_trashcan_combine_swap ($01:A366)
;
; This routine, part of the item menu, handles the TrashCan as well as combining
; or swapping items in the inventory.
_menu_item_trashcan_combine_swap:
    JSR _menu_item_unselect_item                                                ; $01A366 | Unselect the selected item.
    LDA r_menu_item_cursor_coordinates.y.w                                      ; $01A369 |\
    CLC                                                                         ; $01A36C | | Set the Y register to the offset to the item pointed to by the
    ADC r_menu_item_first_row.w                                                 ; $01A36D | | cursor.
    ASL A                                                                       ; $01A370 | |
    ADC r_menu_item_cursor_coordinates.x.w                                      ; $01A371 | |
    ASL A                                                                       ; $01A374 | |
    STA <r_menu_generic_tmp_word.lo                                             ; $01A375 | |
    STZ <r_menu_generic_tmp_word.hi                                             ; $01A377 | |
    LDY <r_menu_generic_tmp_word                                                ; $01A379 |/
    LDA r_menu_item_selected_coordinates.y.w                                    ; $01A37B |\
    ASL A                                                                       ; $01A37E | | Set the X register to the offset to the selected item.
    ADC r_menu_item_selected_coordinates.x.w                                    ; $01A37F | |
    ASL A                                                                       ; $01A382 | |
    STA <r_menu_generic_tmp_word.lo                                             ; $01A383 | |
    LDX <r_menu_generic_tmp_word                                                ; $01A385 |/
    LDA r_inventory.1.id.w,Y                                                    ; $01A387 |\
    CMP #ITEM_TRASHCAN.b                                                        ; $01A38A | | If the item is not the TrashCan or if the originally selected item
    BNE @check_combine                                                          ; $01A38C | | was empty, branch to check if they can be combined, and if not,
    LDA r_inventory.1.id.w,X                                                    ; $01A38E | | swap them.
    BEQ @check_combine                                                          ; $01A391 |/
    CMP #ITEM_WHISTLE.b                                                         ; $01A393 |\
    BEQ ++                                                                      ; $01A395 | | If the originally selected item was the Whistle, Legend, Crystal
    CMP #ITEM_LEGEND.b                                                          ; $01A397 | | or any item of $EC or above (key items), play the error sound
    BEQ +                                                                       ; $01A399 | | effect and branch to the done code.
    CMP #ITEM_CRYSTAL.b                                                         ; $01A39B | |
    BEQ +                                                                       ; $01A39D | |
    CMP #ITEM_FIRST_KEY_ITEM.b                                                  ; $01A39F | |
    BCC ++                                                                      ; $01A3A1 | |
+   JSR _play_sound_effect_error                                                ; $01A3A3 | |
    BRA @done                                                                   ; $01A3A6 |/
++  LDA #0.b                                                                    ; $01A3A8 |\
    STA r_inventory.1.id.w,X                                                    ; $01A3AA | | Otherwise, set the selected item's count to zero and unset the
    STA r_inventory.1.count.w,X                                                 ; $01A3AD | | item, and then branch to done.
    BRA @done                                                                   ; $01A3B0 |/
@check_combine:
    LDA r_inventory.1.id.w,X                                                    ; $01A3B2 |\
    CMP r_inventory.1.id.w,Y                                                    ; $01A3B5 | | If the two items are the same, branch to the combine code.
    BEQ @combine                                                                ; $01A3B8 |/
@swap:
    LDA r_inventory.1.id.w,X                                                    ; $01A3BA |\
    PHA                                                                         ; $01A3BD | | Swap the two items and their counts.
    LDA r_inventory.1.count.w,X                                                 ; $01A3BE | |
    PHA                                                                         ; $01A3C1 | |
    LDA r_inventory.1.id.w,Y                                                    ; $01A3C2 | |
    STA r_inventory.1.id.w,X                                                    ; $01A3C5 | |
    LDA r_inventory.1.count.w,Y                                                 ; $01A3C8 | |
    STA r_inventory.1.count.w,X                                                 ; $01A3CB | |
    PLA                                                                         ; $01A3CE | |
    STA r_inventory.1.count.w,Y                                                 ; $01A3CF | |
    PLA                                                                         ; $01A3D2 | |
    STA r_inventory.1.id.w,Y                                                    ; $01A3D3 |/
@done:
    JSR _menu_set_current_tilemap_bg1                                           ; $01A3D6 |\
    JSR _menu_inventory_draw_window                                             ; $01A3D9 | | Draw the updated inventory window and return.
    JSR _menu_item_unselect_item                                                ; $01A3DC | |
    JSR _menu_set_current_tilemap_bg2                                           ; $01A3DF | |
    RTS                                                                         ; $01A3E2 |/
@combine:
    LDA r_inventory.1.count.w,Y                                                 ; $01A3E3 |\
    CLC                                                                         ; $01A3E6 | | If the total count of the two items is 100 or greater, branch to
    ADC r_inventory.1.count.w,X                                                 ; $01A3E7 | | simply swap them instead.
    CMP #100.b                                                                  ; $01A3EA | |
    BCS @swap                                                                   ; $01A3EC |/
    STA r_inventory.1.count.w,Y                                                 ; $01A3EE |\
    LDA #0.b                                                                    ; $01A3F1 | | Otherwise, combine the counts into the second slot, and clear out
    STA r_inventory.1.id.w,X                                                    ; $01A3F3 | | the originally selected slot.
    STA r_inventory.1.count.w,X                                                 ; $01A3F6 | |
    BRA @done                                                                   ; $01A3F9 |/

; _menu_item_draw_targeting_window ($01:A3FB)
;
; Draws the item targeting window to the tilemap.
_menu_item_draw_targeting_window:
    LDA #%00110000.b                                                            ; $01A3FB |\ Set the cursor sprite flags for priority 3 and palette zero.
    STA <r_menu_cursor_sprite_flags                                             ; $01A3FD |/
    JSR _menu_backup_cgram_2                                                    ; $01A3FF | Back up the current palette data.
    JSR _menu_wait_for_vblank                                                   ; $01A402 | Wait for vblank.
    JSR _menu_copy_palette_to_cgram                                             ; $01A405 | Copy the palette data to CG-RAM.
    JSR _menu_set_current_tilemap_bg2                                           ; $01A408 | Set the current tilemap to BG2.
    LDY #menu_window_item_description_data.w                                    ; $01A40B |\ Draw the item description window.
    JSR _menu_configure_and_draw_window                                         ; $01A40E |/
    LDY #menu_text_item_whom_data.w                                             ; $01A411 |\ Draw the "Whom?" text to the item description window.
    JSR _menu_draw_text_indirect                                                ; $01A414 |/
    LDA r_menu_item_cursor_coordinates.x.w                                      ; $01A417 |\
    BEQ +                                                                       ; $01A41A | | If the cursor X coordinate is zero, prepare for putting the target
    LDA #5.b                                                                    ; $01A41C | | selection window on the right side. Otherwise, prepare for putting
    LDY #menu_window_item_target_left_data.w                                    ; $01A41E | | it on the left side.
    BRA ++                                                                      ; $01A421 | |
+   LDA #0.b                                                                    ; $01A423 | |
    LDY #menu_window_item_target_right_data.w                                   ; $01A425 | |
++  STA r_menu_item_target_current_coordinate_index.w                           ; $01A428 |/
    JSR _menu_configure_and_draw_window                                         ; $01A42B | Draw the targeting window.
    STZ r_menu_item_target_current_slot.w                                       ; $01A42E | Initialize the current slot to zero.
-   LDA r_menu_item_target_current_slot.w                                       ; $01A431 |\
    JSR _menu_get_character_field_offset                                        ; $01A434 | | Set the Y register to the record offset for the current slot.
    TXY                                                                         ; $01A437 |/
    LDA r_menu_item_target_current_coordinate_index.w                           ; $01A438 |\
    ASL A                                                                       ; $01A43B | | Depending on if we're drawing to the left or right side, load the
    JSR _menu_transfer_a_to_x                                                   ; $01A43C | | correct coordinates to place the stats about this character in the
    REP #FLAG_P_ACCUMULATOR                                                     ; $01A43F | | window.
    LDA bank1E.menu_item_target_character_coordinates_data.l,X                  ; $01A441 | |
    TAX                                                                         ; $01A445 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01A446 |/
    JSR _menu_item_target_draw_character_stats                                  ; $01A448 | Draw the stats for this character.
    INC r_menu_item_target_current_coordinate_index.w                           ; $01A44B |\
    INC r_menu_item_target_current_slot.w                                       ; $01A44E | | Increment the index and slot number and loop until all five
    LDA r_menu_item_target_current_slot.w                                       ; $01A451 | | characters have been drawn.
    CMP #5.b                                                                    ; $01A454 | |
    BNE -                                                                       ; $01A456 |/
    RTS                                                                         ; $01A458

; _menu_item_target_execute ($01:A459)
;
; Executes the item targeting window. The slot of the chosen character is
; returned in $E8. If no character was selected, $FF is returned instead.
_menu_item_target_execute:
    JSR _menu_item_draw_targeting_window                                        ; $01A459 |\ Draw the item targeting window and animate it opening.
    JSR _menu_animate_current_tilemap_50_rows_to_vram                           ; $01A45C |/
    LDA #%00110000.b                                                            ; $01A45F |\ Set the cursor sprite flags for priority 3 and palette zero.
    STA <r_menu_cursor_sprite_flags                                             ; $01A461 |/
    JSR _menu_item_target_select_target                                         ; $01A463 | Allow the player to select a target.
    LDA #%00100000.b                                                            ; $01A466 |\ Set the cursor sprite flags for priority 2.
    STA <r_menu_cursor_sprite_flags                                             ; $01A468 |/
    JSR _menu_item_unselect_item                                                ; $01A46A | Unselect the selected item.
    JSR _menu_restore_cgram_2                                                   ; $01A46D | Restore the backed up palettes.
    JSR _menu_copy_tilemap_to_vram_bg2                                          ; $01A470 | Copy the BG2 tilemap to VRAM.
    JMP _menu_copy_palette_to_cgram                                             ; $01A473 | Copy the palette data to CG-RAM.

; _menu_item_target_draw_character_stats ($01:A477)
;
; Given the offset to a character record in the Y register, draws that
; character's stats to the tilemap offset passed in the X register, relative to
; the base address in $29.
__menu_item_target_draw_character_stats_return:
    RTS                                                                         ; $01A476
_menu_item_target_draw_character_stats:
    LDA character_field.id.w,Y                                                  ; $01A477 |\
    AND #%00111111.b                                                            ; $01A47A | | If this slot is empty, branch to return.
    BEQ __menu_item_target_draw_character_stats_return                          ; $01A47C |/
    STY <r_menu_party_tmp_character_offset                                      ; $01A47E |\ Save the passed character and tilemap offsets.
    STX <r_menu_party_tmp_tilemap_offset                                        ; $01A480 |/
    PHY                                                                         ; $01A482 |\
    TXY                                                                         ; $01A483 | | Draw the character's name to the tilemap.
    PHX                                                                         ; $01A484 | |
    JSR _menu_draw_character_name                                               ; $01A485 | |
    PLX                                                                         ; $01A488 | |
    PLY                                                                         ; $01A489 |/
    PHA                                                                         ; $01A48A | Preserve the high byte of the accumulator.
    LDA character_field.status_1.w,Y                                            ; $01A48B |\
    ROL A                                                                       ; $01A48E | | If the character has the swoon status, update the tile flags to
    ROL A                                                                       ; $01A48F | | set the palette to 1. Otherwise, set the palette to zero.
    ROL A                                                                       ; $01A490 | |
    ROL A                                                                       ; $01A491 | |
    AND #STATUS_1_SWOON.b >> 5                                                  ; $01A492 | |
    ORA <r_menu_current_tilemap_base_tile_flags                                 ; $01A494 | |
    STA <r_menu_generic_tmp_word.lo                                             ; $01A496 |/
    LDA #14.b                                                                   ; $01A498 |\
    JSR _menu_set_row_tile_flags                                                ; $01A49A | | Set those flags on 14 tiles on each of four rows.
    JSR _menu_set_row_tile_flags                                                ; $01A49D | |
    JSR _menu_set_row_tile_flags                                                ; $01A4A0 | |
    JSR _menu_set_row_tile_flags                                                ; $01A4A3 |/
    PLA                                                                         ; $01A4A6 | Restore the high byte of the accumulator.
    REP #FLAG_P_ACCUMULATOR                                                     ; $01A4A7 |\
    LDA <r_menu_party_tmp_tilemap_offset                                        ; $01A4A9 | | Set one temporary variable to the base tilemap address plus the
    CLC                                                                         ; $01A4AB | | tilemap offset.
    ADC <r_menu_current_tilemap_base_address                                    ; $01A4AC | |
    STA <r_menu_party_tmp_tilemap_address                                       ; $01A4AE |/
    CLC                                                                         ; $01A4B0 |\
    ADC #(32 * 2).w                                                             ; $01A4B1 | | Add one line to the address and store that in a second temporary
    STA <r_menu_party_tmp_tilemap_address_2                                     ; $01A4B4 | | variable.
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01A4B6 |/
    LDX <r_menu_party_tmp_character_offset                                      ; $01A4B8 |\
    LDY <r_menu_party_tmp_tilemap_offset                                        ; $01A4BA | | Draw the status icons or the class of the current character.
    PHX                                                                         ; $01A4BC | |
    PHY                                                                         ; $01A4BD | |
    JSR _menu_draw_status_class                                                 ; $01A4BE | |
    PLY                                                                         ; $01A4C1 | |
    PLX                                                                         ; $01A4C2 | |
    STX <r_menu_party_tmp_character_offset                                      ; $01A4C3 | |
    STY <r_menu_party_tmp_tilemap_offset                                        ; $01A4C5 |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $01A4C7 |\
    LDA <r_menu_party_tmp_tilemap_address_2                                     ; $01A4C9 | | Set the Y register to the tilemap address of the second line (the
    CLC                                                                         ; $01A4CB | | first non-diacritic line) plus another line and one tile.
    ADC #(32 * 2 + 1 * 2).w                                                     ; $01A4CC | |
    TAY                                                                         ; $01A4CF | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01A4D0 |/
    LDA #TEXT_UPPERCASE_H.b                                                     ; $01A4D2 |\
    STA (0 * 2) + (0 * 32 * 2).w,Y                                              ; $01A4D4 | | Draw "HP" and "MP" to the tilemap.
    LDA #TEXT_UPPERCASE_P.b                                                     ; $01A4D7 | |
    STA (1 * 2) + (0 * 32 * 2).w,Y                                              ; $01A4D9 | |
    STA (1 * 2) + (1 * 32 * 2).w,Y                                              ; $01A4DC | |
    LDA #TEXT_UPPERCASE_M.b                                                     ; $01A4DF | |
    STA (0 * 2) + (1 * 32 * 2).w,Y                                              ; $01A4E1 |/
    LDA #TEXT_SLASH.b                                                           ; $01A4E4 |\
    STA (7 * 2) + (0 * 32 * 2).w,Y                                              ; $01A4E6 | | Draw the slashes to separate current from maximum HP or MP.
    STA (7 * 2) + (1 * 32 * 2).w,Y                                              ; $01A4E9 |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $01A4EC |/
    LDX <r_menu_party_tmp_tilemap_address_2                                     ; $01A4EE |\
    INX                                                                         ; $01A4F0 | | Set the X register to the second tilemap address plus one tile.
    INX                                                                         ; $01A4F1 |/
    LDA #(3 * 2) + (1 * 32 * 2).w                                               ; $01A4F2 |\
    LDY #character_field.hp.w                                                   ; $01A4F5 | | Draw the current HP to 3, 1 relative to the above.
    JSR _menu_party_format_numeric_stat                                         ; $01A4F8 |/
    LDA #(8 * 2) + (1 * 32 * 2).w                                               ; $01A4FB |\
    LDY #character_field.hp_max.w                                               ; $01A4FE | | Draw the maximum HP to 8, 1 relative to the above.
    JSR _menu_party_format_numeric_stat                                         ; $01A501 |/
    LDA #(3 * 2) + (2 * 32 * 2).w                                               ; $01A504 |\
    LDY #character_field.mp.w                                                   ; $01A507 | | Draw the current MP to 3, 2 relative to the above.
    JSR _menu_party_format_numeric_stat                                         ; $01A50A |/
    LDA #(8 * 2) + (2 * 32 * 2).w                                               ; $01A50D |\
    LDY #character_field.mp_max.w                                               ; $01A510 | | Draw the maximum MP to 8, 2 relative to the above.
    JSR _menu_party_format_numeric_stat                                         ; $01A513 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01A516 |/
    RTS                                                                         ; $01A518

; _menu_item_target_select_target ($01:A519)
;
; Handles the input during the item targeting menu. If a character is selected,
; returns the slot number in $E8. Otherwise, returns $FF in E8. The result is
; also returned in the accumulator.
_menu_item_target_select_target:
-   JSR _menu_item_targeting_get_character_id                                   ; $01A519 | Get the currently targeted character ID.
    BNE ++                                                                      ; $01A51C |\
    LDA r_menu_item_targeting_cursor_index.w                                    ; $01A51E | | If the currently selected character slot is empty, increment the
    INC A                                                                       ; $01A521 | | cursor index and if it reaches 5, reset it to zero to wrap around.
    CMP #5.b                                                                    ; $01A522 | |
    BNE +                                                                       ; $01A524 | | This code forces a valid character to be selected immediately upon
    LDA #0.b                                                                    ; $01A526 | | opening the window.
+   STA r_menu_item_targeting_cursor_index.w                                    ; $01A528 | |
    BRA -                                                                       ; $01A52B |/
++  LDA r_menu_item_cursor_coordinates.x.w                                      ; $01A52D |\
    BNE +                                                                       ; $01A530 | | Determine the cursor X coordinate based on whether this is being
    LDA #112.b                                                                  ; $01A532 | | drawn on the left or right side of the screen.
    BRA ++                                                                      ; $01A534 | |
+   LDA #8.b                                                                    ; $01A536 | |
++  STA <r_menu_item_targeting_tmp_coordinates.x.b                              ; $01A538 |/
@loop_start:
    JSR _menu_wait_for_vblank_copy_oam_to_ppu                                   ; $01A53A | Wait for vblank and copy the OAM to the PPU.
    JSR _menu_update_joypad_and_play_sound_effect                               ; $01A53D | Update the joypad values and play a sound effect if appropriate.
    LDA <r_menu_joypad_repeat.hi                                                ; $01A540 |\
    AND #JOYPAD_H_UP.b                                                          ; $01A542 | | If up is pressed on the d-pad, decrement the cursor index. If it
    BEQ ++                                                                      ; $01A544 | | goes negative, wrap back around to 4. If the selected slot has no
-   LDA r_menu_item_targeting_cursor_index.w                                    ; $01A546 | | character, loop to repeat the decrement until it does.
    DEC A                                                                       ; $01A549 | |
    BPL +                                                                       ; $01A54A | |
    LDA #4.b                                                                    ; $01A54C | |
+   STA r_menu_item_targeting_cursor_index.w                                    ; $01A54E | |
    JSR _menu_item_targeting_get_character_id                                   ; $01A551 | |
    BEQ -                                                                       ; $01A554 |/
++  LDA <r_menu_joypad_repeat.hi                                                ; $01A556 |\
    AND #JOYPAD_H_DOWN.b                                                        ; $01A558 | | If down is pressed on the d-pad, increment the cursor index. If it
    BEQ ++                                                                      ; $01A55A | | reaches 5, reset it to 0 to wrap around. If the newly selected
-   LDA r_menu_item_targeting_cursor_index.w                                    ; $01A55C | | slot is empty, loop to repeat the increment until it's not.
    INC A                                                                       ; $01A55F | |
    CMP #5.b                                                                    ; $01A560 | |
    BCC +                                                                       ; $01A562 | |
    LDA #0.b                                                                    ; $01A564 | |
+   STA r_menu_item_targeting_cursor_index.w                                    ; $01A566 | |
    JSR _menu_item_targeting_get_character_id                                   ; $01A569 | |
    BEQ -                                                                       ; $01A56C |/
++  LDA <r_menu_joypad_repeat.lo                                                ; $01A56E |\
    AND #JOYPAD_L_A.b                                                           ; $01A570 | | If the A button is pressed, set the result variable to the
    BEQ +                                                                       ; $01A572 | | selected slot number and return.
    LDA r_menu_item_targeting_cursor_index.w                                    ; $01A574 | |
    JSR _menu_transfer_a_to_x                                                   ; $01A577 | |
    LDA bank14.character_position_to_slot_data.l,X                              ; $01A57A | |
    STA <r_menu_current_selected_character_slot                                 ; $01A57E | |
    RTS                                                                         ; $01A580 |/
+   LDA <r_menu_joypad_repeat.hi                                                ; $01A581 |\
    AND #JOYPAD_H_B.b                                                           ; $01A583 | | If the B button is pressed, set the result variable to $FF and
    BEQ +                                                                       ; $01A585 | | return.
    LDA #$FF.b                                                                  ; $01A587 | |
    STA <r_menu_current_selected_character_slot                                 ; $01A589 | |
    RTS                                                                         ; $01A58B |/
+   LDA r_menu_item_targeting_cursor_index.w                                    ; $01A58C |\
    ASL A                                                                       ; $01A58F | | Set the cursor Y coordinate to 64 plus the index times 32.
    ASL A                                                                       ; $01A590 | |
    ASL A                                                                       ; $01A591 | |
    ASL A                                                                       ; $01A592 | |
    ASL A                                                                       ; $01A593 | |
    ADC #64.b                                                                   ; $01A594 | |
    STA <r_menu_item_targeting_tmp_coordinates.y                                ; $01A596 |/
    LDA #0.b                                                                    ; $01A598 | Reset the accumulator to zero.
    LDX <r_menu_item_targeting_tmp_coordinates                                  ; $01A59A |\
    LDY #r_oam.1.w                                                              ; $01A59C | | Draw the cursor to the calculated coordinates.
    JSR _menu_draw_cursor_direct                                                ; $01A59F |/
    JMP @loop_start                                                             ; $01A5A2

; _menu_item_check_living_target_and_get_item_power ($01:A5A5)
;
; Given the currently selected item and character slot, validates that the
; target is alive. If not, it falls through to the next routine to display an
; error message. Afterward, it will return to the caller's caller, so the
; immediate caller does not need to handle failure. If the target is alive, it
; instead calls another routine to return the 16-bit item power in $45.
_menu_item_check_living_target_and_get_item_power:
    LDY #character_field.status_1.w                                             ; $01A5A5 |\
    LDA (<r_menu_selected_character_offset),Y                                   ; $01A5A8 | | If the character has neither of the swoon or stone statuses,
    AND #(STATUS_1_SWOON | STATUS_1_STONE).b                                    ; $01A5AA | | branch to the alive code.
    BEQ _menu_item_calculate_item_power                                         ; $01A5AC |/
    LDY #menu_text_item_message_failed_data.w                                   ; $01A5AE | Set the Y register to the offset to the "Failed" message data.

; _menu_item_fail_and_return_* ($01:A5B1)
;
; Handles the failure of an item use in the item menu. Increments the item count
; to undo the use of the item, plays an error sound effect, and returns to the
; caller's caller (through stack pointer manipulation).
;
; The _with_message variant takes the offset for a message description and
; draws that message to the screen.
_menu_item_fail_and_return_with_message:
    INC r_menu_item_suppress_final_target_window.w                              ; $01A5B1 | Suppress the display of the final targeting window.
    PHY                                                                         ; $01A5B4 |\
    JSR _menu_set_current_tilemap_bg2                                           ; $01A5B5 | | Draw the message window to BG2.
    LDY #menu_window_item_message_data.w                                        ; $01A5B8 | |
    JSR _menu_configure_and_draw_window                                         ; $01A5BB | |
    PLY                                                                         ; $01A5BE |/
    JSR _menu_draw_text_indirect                                                ; $01A5BF | Draw the "Failed" message.
    JSR _menu_copy_tilemap_to_vram_bg2                                          ; $01A5C2 | Copy the BG2 tilemap to VRAM.
_menu_item_fail_and_return:
    LDX r_menu_item_inventory_offset.w                                          ; $01A5C5 |\
    LDA r_menu_item_selected_item_id.w                                          ; $01A5C8 | | Replace the deducted item, since the operation is canceled.
    STA r_inventory.1.id.w,X                                                    ; $01A5CB | |
    INC r_inventory.1.count.w,X                                                 ; $01A5CE |/
    PLX                                                                         ; $01A5D1 | Adjust the stack pointer so the return will return two levels out.
    LDA <r_menu_current_selected_character_slot                                 ; $01A5D2 |\
    CMP #3.b                                                                    ; $01A5D4 | | If the selected character was in slot 3 and the target window is
    BNE +                                                                       ; $01A5D6 | | being drawn on the right, erase the cursor (as it would be behind
    LDA r_menu_item_cursor_coordinates.x.w                                      ; $01A5D8 | | the failed message).
    BNE +                                                                       ; $01A5DB | |
    JSR _menu_erase_cursor_1                                                    ; $01A5DD | |
    JSR _menu_wait_for_vblank_copy_oam_to_ppu                                   ; $01A5E0 |/
+   JSR _play_sound_effect_error                                                ; $01A5E3 | Play the sound effect.
    JMP _menu_wait_for_input                                                    ; $01A5E6 | Wait for input and return (to the caller's caller).

; _menu_item_calculate_item_power ($01:A5E9)
;
; Calculates the power of the currently selected item in the item menu and
; returns the 16-bit result in $45.
_menu_item_calculate_item_power:
    TDC                                                                         ; $01A5E9 |\
    XBA                                                                         ; $01A5EA | | Load the item's power.
    LDA r_menu_item_selected_item_id.w                                          ; $01A5EB | |
    SEC                                                                         ; $01A5EE | |
    SBC #ITEM_FIRST_BATTLE_ITEM.b                                               ; $01A5EF | |
    REP #FLAG_P_ACCUMULATOR                                                     ; $01A5F1 | |
    ASL A                                                                       ; $01A5F3 | |
    STA <r_menu_generic_tmp_word                                                ; $01A5F4 | |
    ASL A                                                                       ; $01A5F6 | |
    ADC <r_menu_generic_tmp_word                                                ; $01A5F7 | |
    TAX                                                                         ; $01A5F9 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01A5FA | |
    TDC                                                                         ; $01A5FC | |
    XBA                                                                         ; $01A5FD | |
    LDA bank0F.battle_item_property_data.l + spell.power,X                      ; $01A5FE |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $01A602 |\
    ASL A                                                                       ; $01A604 | | Multiply the power by 48, and store the result in the result
    ASL A                                                                       ; $01A605 | | variable.
    ASL A                                                                       ; $01A606 | |
    ASL A                                                                       ; $01A607 | | TODO: This uses $1A84 as a temporary variable. Is it truly just a
    STA r_unknown_1a84.w                                                        ; $01A608 | |       one time temporary, or does it serve another purpose?
    ASL A                                                                       ; $01A60B | |
    ADC r_unknown_1a84.w                                                        ; $01A60C | |
    STA <r_menu_generic_tmp_word                                                ; $01A60F | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01A611 |/
    JMP _play_sound_effect_menu_chime                                           ; $01A613 | Play the menu chime sound effect.

; _menu_item_handler_cure ($01:A616)
;
; Item handler for items that cure HP.
_menu_item_handler_cure:
    JSR _menu_item_check_living_target_and_get_item_power                       ; $01A616 | Ensure the selected target is alive and calculate the item power.
    LDY #character_field.hp.w                                                   ; $01A619 | Set the Y register to the offset for the character's HP.
__menu_item_handler_cure_ether_common:
    REP #FLAG_P_ACCUMULATOR                                                     ; $01A61C |\
    LDA (<r_menu_selected_character_offset),Y                                   ; $01A61E | | Add the calculated power to the chosen stat..
    CLC                                                                         ; $01A620 | |
    ADC <r_menu_generic_tmp_word                                                ; $01A621 | |
    INY                                                                         ; $01A623 | |
    INY                                                                         ; $01A624 |/
    CMP (<r_menu_selected_character_offset),Y                                   ; $01A625 |\
    BCC +                                                                       ; $01A627 | | If the result is greater than their maximum, change the value
    LDA (<r_menu_selected_character_offset),Y                                   ; $01A629 | | to the maximum. Either way, store the new result in the
+   DEY                                                                         ; $01A62B | | character's stat variable.
    DEY                                                                         ; $01A62C | |
    STA (<r_menu_selected_character_offset),Y                                   ; $01A62D | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01A62F | |
    RTS                                                                         ; $01A631 |/

; _menu_item_handler_ether ($01:A632)
;
; Item handler for items that cure MP. This and the previous routine share some
; code. This routine jumps to the previous to do much of its work.
_menu_item_handler_ether:
    JSR _menu_item_check_living_target_and_get_item_power                       ; $01A632 | Ensure the selected target is alive and calculate the item power.
    LDY #character_field.mp.w                                                   ; $01A635 | Set the Y register to the offset for the character's MP.
    BRA __menu_item_handler_cure_ether_common                                   ; $01A638 | Jump to update the character's MP.

; _menu_item_handler_elixir ($01:A63A)
;
; Item handler for the Elixir.
_menu_item_handler_elixir:
    JSR _menu_item_check_living_target_and_get_item_power                       ; $01A63A | Ensure the selected target is alive.
    REP #FLAG_P_ACCUMULATOR.b                                                   ; $01A63D |\
    LDY #character_field.hp_max.w                                               ; $01A63F | | Set the character's HP to their maximum HP.
    LDA (<r_menu_selected_character_offset),Y                                   ; $01A642 | |
    DEY                                                                         ; $01A644 | |
    DEY                                                                         ; $01A645 | |
    STA (<r_menu_selected_character_offset),Y                                   ; $01A646 |/
    LDY #character_field.mp_max.w                                               ; $01A648 |\
    LDA (<r_menu_selected_character_offset),Y                                   ; $01A64B | | Set the character's MP to their maximum MP.
    DEY                                                                         ; $01A64D | |
    DEY                                                                         ; $01A64E | |
    STA (<r_menu_selected_character_offset),Y                                   ; $01A64F | |
    SEP #FLAG_P_ACCUMULATOR.b                                                   ; $01A651 |/
    RTS                                                                         ; $01A653

; menu_item_handler_offset_data ($01:A654)
;
; For each of the items usable in the item menu, ranging from $CE to $EA,
; provides the offset to the handler for that item.
menu_item_handler_offset_data:
    .addr _menu_item_handler_cure                                               ; $01A654.A655 | $CE: Cure1
    .addr _menu_item_handler_cure                                               ; $01A656.A657 | $CF: Cure2
    .addr _menu_item_handler_cure                                               ; $01A658.A659 | $D0: Cure3
    .addr _menu_item_handler_ether                                              ; $01A65A.A65B | $D1: Ether1
    .addr _menu_item_handler_ether                                              ; $01A65C.A65D | $D2: Ether2
    .addr _menu_item_handler_elixir                                             ; $01A65E.A65F | $D3: Elixir
    .addr _menu_item_handler_life                                               ; $01A660.A661 | $D4: Life
    .addr _menu_item_handler_status                                             ; $01A662.A663 | $D5: Dummy (GoldPin)
    .addr _menu_item_handler_status                                             ; $01A664.A665 | $D6: Dummy (MaidKiss)
    .addr _menu_item_handler_status                                             ; $01A666.A667 | $D7: Dummy (Mallet)
    .addr _menu_item_handler_status                                             ; $01A668.A669 | $D8: Dummy (DietFood)
    .addr _menu_item_handler_status                                             ; $01A66A.A66B | $D9: Dummy (EchoHerb)
    .addr _menu_item_handler_status                                             ; $01A66C.A66D | $DA: Dummy (Eyedrops)
    .addr _menu_item_handler_status                                             ; $01A66E.A66F | $DB: Dummy (Antidote)
    .addr _menu_item_handler_status                                             ; $01A670.A671 | $DC: Dummy (Cross)
    .addr _menu_item_handler_heal                                               ; $01A672.A673 | $DD: Heal
    .addr _menu_item_handler_siren                                              ; $01A674.A675 | $DE: Dummy (Siren)
    .addr _menu_item_handler_auapple                                            ; $01A676.A677 | $DF: Dummy (AuApple)
    .addr _menu_item_handler_agapple                                            ; $01A678.A679 | $E0: Dummy (AgApple)
    .addr _menu_item_handler_somadrop                                           ; $01A67A.A67B | $E1: Dummy (SomaDrop)
    .addr _menu_item_handler_tent_cabin                                         ; $01A67C.A67D | $E2: Tent
    .addr _menu_item_handler_tent_cabin                                         ; $01A67E.A67F | $E3: Cabin
    .addr _menu_item_handler_magazine                                           ; $01A680.A681 | $E4: Dummy (Magazine)
    .addr _menu_item_handler_exit                                               ; $01A682.A683 | $E5: Dummy (Exit)
    .addr _menu_item_handler_eagleeye                                           ; $01A684.A685 | $E6: Dummy (EagleEye)
    .addr _menu_item_handler_call                                               ; $01A686.A687 | $E7: Imp
    .addr _menu_item_handler_call                                               ; $01A688.A689 | $E8: Bomb
    .addr _menu_item_handler_call                                               ; $01A68A.A68B | $E9: Dummy (Cocktric)
    .addr _menu_item_handler_call                                               ; $01A68C.A68D | $EA: Dummy (Mage)

; _menu_item_handler_life ($01:A68E)
;
; Item handler for the Life item.
_menu_item_handler_life:
    LDY #character_field.status_1.w                                             ; $01A68E |\
    LDA (<r_menu_selected_character_offset),Y                                   ; $01A691 | | If the selected character does not have the swoon status, jump to
    AND #STATUS_1_SWOON.b                                                       ; $01A693 | | display the "No need!" message.
    BNE +                                                                       ; $01A695 | |
    LDY #menu_text_item_message_no_need_data.w                                  ; $01A697 | |
    JSR _menu_item_fail_and_return_with_message                                 ; $01A69A |/
+   LDY #character_field.vitality.w                                             ; $01A69D |\
    LDA (<r_menu_selected_character_offset),Y                                   ; $01A6A0 | | Multiply the character's vitality by 5.
    STA <r_menu_generic_tmp_offset.lo                                           ; $01A6A2 | |
    REP #FLAG_P_ACCUMULATOR                                                     ; $01A6A4 | |
    LDA <r_menu_generic_tmp_offset                                              ; $01A6A6 | |
    ASL A                                                                       ; $01A6A8 | |
    ASL A                                                                       ; $01A6A9 | |
    ADC <r_menu_generic_tmp_offset                                              ; $01A6AA |/
    LDY #character_field.hp.w                                                   ; $01A6AC |\
    CMP (<r_menu_selected_character_offset),Y                                   ; $01A6AF | | If the result is greater than or equal to the character's HP, set
    BCC +                                                                       ; $01A6B1 | | their HP to the calculated value.
    STA (<r_menu_selected_character_offset),Y                                   ; $01A6B3 | | NOTE: Isn't this vacuously true? Their HP should always be zero.
+   SEP #FLAG_P_ACCUMULATOR                                                     ; $01A6B5 |/
    LDY #character_field.status_1.w                                             ; $01A6B7 |\
    LDA (<r_menu_selected_character_offset),Y                                   ; $01A6BA | | Remove the swoon status from the character.
    AND #~STATUS_1_SWOON.b                                                      ; $01A6BC | |
    STA (<r_menu_selected_character_offset),Y                                   ; $01A6BE |/
    JMP _play_sound_effect_menu_chime                                           ; $01A6C0 | Play the menu chime sound effect.

; _menu_item_handler_heal ($01:A6C3)
;
; Item handler for the Heal item.
_menu_item_handler_heal:
    LDY #character_field.status_1.w                                             ; $01A6C3 |\
    LDA (<r_menu_selected_character_offset),Y                                   ; $01A6C6 | | If the character has the swoon bit set, display the Failed message
    BPL +                                                                       ; $01A6C8 | | and return.
    LDY #menu_text_item_message_failed_data.w                                   ; $01A6CA | | NOTE: The JSR returns because that routine manipulates the stack
    JSR _menu_item_fail_and_return_with_message                                 ; $01A6CD |/        to return to the caller's caller.
+   LDA #0.b                                                                    ; $01A6D0 |\
    STA (<r_menu_selected_character_offset),Y                                   ; $01A6D2 | | Remove all statuses from the first status byte.
    INY                                                                         ; $01A6D4 |/
    LDA (<r_menu_selected_character_offset),Y                                   ; $01A6D5 |\
    AND #~STATUS_2_CURSE.b                                                      ; $01A6D7 | | Remove Curse from the second byte.
    STA (<r_menu_selected_character_offset),Y                                   ; $01A6D9 |/
    JMP _play_sound_effect_menu_chime                                           ; $01A6DB | Play the menu chime sound effect and return.

; _menu_item_use_item ($01:A6DE)
;
; Given an item ID in the accumulator, handles the use of that item, including
; subtracting it from the inventory and dispatching to the correct handler for
; that item.
_menu_item_use_item:
    CMP #ITEM_SIREN.b                                                           ; $01A6DE |\
    BEQ +                                                                       ; $01A6E0 | | If the item ID is in the range $CE to $E1, except for Siren ($DE),
    CMP #ITEM_TENT.b                                                            ; $01A6E2 | | display the target menu for the player to choose the target of the
    BCS +                                                                       ; $01A6E4 | | item. If none is chosen, branch to the done code. Otherwise, get
    JSR _menu_item_target_execute                                               ; $01A6E6 | | the character's record offset and save it for later use.
    LDA <r_menu_current_selected_character_slot                                 ; $01A6E9 | |
    BMI @done                                                                   ; $01A6EB | |
    JSR _menu_get_character_field_offset                                        ; $01A6ED | |
    STX <r_menu_selected_character_offset                                       ; $01A6F0 |/
+   LDX r_menu_item_inventory_offset.w                                          ; $01A6F2 |\
    DEC r_inventory.1.count.w,X                                                 ; $01A6F5 | | Decrement the item count by one, and if it reaches zero, remove
    BNE +                                                                       ; $01A6F8 | | the item itself from the inventory.
    STZ r_inventory.1.id.w,X                                                    ; $01A6FA |/
+   LDA r_menu_item_selected_item_id.w                                          ; $01A6FD |\
    SEC                                                                         ; $01A700 | | Execute the handler for this item.
    SBC #ITEM_FIRST_FIELD_ITEM.b                                                ; $01A701 | |
    LDX #menu_item_handler_offset_data.w                                        ; $01A703 | |
    JSR _menu_execute_jump                                                      ; $01A706 |/
    LDA r_menu_item_selected_item_id.w                                          ; $01A709 |\
    CMP #ITEM_SIREN.b                                                           ; $01A70C | | If the item is one of those for which a target was selected, and
    BEQ @done                                                                   ; $01A70E | | if the display of the final updated target window hasn't been
    CMP #ITEM_TENT.b                                                            ; $01A710 | | suppressed (by a failure of the item in some way), display the
    BCS @done                                                                   ; $01A712 | | updated target window, so the player can see the result of their
    LDA r_menu_item_suppress_final_target_window.w                              ; $01A714 | | action.
    BNE @done                                                                   ; $01A717 | |
    JSR _menu_item_draw_targeting_window                                        ; $01A719 | |
    JSR _menu_copy_tilemap_to_vram_bg2                                          ; $01A71C | |
    JSR _menu_wait_for_input                                                    ; $01A71F |/
@done:
    STZ r_menu_item_suppress_final_target_window.w                              ; $01A722 | Reset the target window suppression flag.
    JSR _menu_set_current_tilemap_bg2_and_initialize                            ; $01A725 |\
    LDY #menu_window_item_title_data.w                                          ; $01A728 | | Draw the item title window to BG2 and copy it to VRAM.
    JSR _menu_draw_text_indirect_plus_window                                    ; $01A72B | |
    JMP _menu_copy_tilemap_to_vram_bg2                                          ; $01A72E |/

; _menu_item_handler_auapple ($01:A731)
;
; Item handler for the AuApple item. Falls through to the next routine.
_menu_item_handler_auapple:
    REP #FLAG_P_ACCUMULATOR                                                     ; $01A731 |\
    LDY #character_field.hp_max.w                                               ; $01A733 | | Add 100 to the character's maximum HP.
    LDA (<r_menu_selected_character_offset),Y                                   ; $01A736 | |
    CLC                                                                         ; $01A738 | |
    ADC #100.w                                                                  ; $01A739 |/

; _menu_item_handler_apple ($01:A73C)
;
; Given a new value in the accumulator and the offset to a character stat in the
; Y register, writes the minimum of the passed value and 9999 to the stat.
_menu_item_handler_apple:
    CMP #9999.w                                                                 ; $01A73C |\
    BCC +                                                                       ; $01A73F | | If the result was greater than 9999, replace it with 9999.
    LDA #9999.w                                                                 ; $01A741 |/
+   STA (<r_menu_selected_character_offset),Y                                   ; $01A744 |\ Save the updated maximum HP.
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01A746 |/
    JMP _play_sound_effect_menu_chime                                           ; $01A748 | Play the menu chime sound effect and return.

; _menu_item_handler_agapple ($01:A74B)
;
; Item handler for the AgApple item.
_menu_item_handler_agapple:
    REP #FLAG_P_ACCUMULATOR                                                     ; $01A74B |\
    LDY #character_field.hp_max.w                                               ; $01A74D | | Add 50 to the character's maximum HP.
    LDA (<r_menu_selected_character_offset),Y                                   ; $01A750 | |
    CLC                                                                         ; $01A752 | |
    ADC #50.w                                                                   ; $01A753 |/
    BRA _menu_item_handler_apple                                                ; $01A756 | Branch to update the maximum HP with the new value.

; _menu_item_handler_somadrop ($01:A758)
;
; Item handler for the SomaDrop item.
_menu_item_handler_somadrop:
    REP #FLAG_P_ACCUMULATOR                                                     ; $01A758 |\
    LDY #character_field.mp_max.w                                               ; $01A75A | | Add 10 to the character's maximum MP.
    LDA (<r_menu_selected_character_offset),Y                                   ; $01A75D | |
    CLC                                                                         ; $01A75F | |
    ADC #10.w                                                                   ; $01A760 |/
    CMP #999.w                                                                  ; $01A763 |\
    BCC +                                                                       ; $01A766 | | Set the character's maximum MP to the lesser of the calculated
    LDA #999.w                                                                  ; $01A768 | | value and 999.
+   STA (<r_menu_selected_character_offset),Y                                   ; $01A76B | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01A76D |/
    JMP _play_sound_effect_menu_chime                                           ; $01A76F | Play the menu chime sound effect and return.

; _menu_item_handler_status ($01:A772)
;
; Item handler for items that remove a restricted set of statuses.
_menu_item_handler_status:
    LDA r_menu_item_selected_item_id.w                                          ; $01A772 |\
    SEC                                                                         ; $01A775 | | Set the X register to the item ID within the status removal items
    SBC #ITEM_FIRST_STATUS_REMOVAL_ITEM.b                                       ; $01A776 | | times two.
    ASL A                                                                       ; $01A778 | |
    STA <r_menu_generic_tmp_offset.lo                                           ; $01A779 | |
    LDX <r_menu_generic_tmp_offset                                              ; $01A77B |/
    LDY #character_field.status_1.w                                             ; $01A77D | Set the Y register to the character's first status byte offset.
    REP #FLAG_P_ACCUMULATOR                                                     ; $01A780 |\
    LDA (<r_menu_selected_character_offset),Y                                   ; $01A782 | | Mask out the correct bits for the item in use.
    STA <r_menu_generic_tmp_word                                                ; $01A784 | |
    AND bank1E.item_status_mask_data.l,X                                        ; $01A786 | |
    STA (<r_menu_selected_character_offset),Y                                   ; $01A78A |/
    CMP <r_menu_generic_tmp_word                                                ; $01A78C |\
    BEQ +                                                                       ; $01A78E | | If something was removed, play the menu chime sound effect and
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01A790 | | return.
    JMP _play_sound_effect_menu_chime                                           ; $01A792 |/
+   SEP #FLAG_P_ACCUMULATOR                                                     ; $01A795 |\
    LDY #menu_text_item_message_no_need_data.w                                  ; $01A797 | | Otherwise, display the failure message and return.
    JSR _menu_item_fail_and_return_with_message                                 ; $01A79A |/  NOTE: This returns because the call returns two levels.

; _menu_item_draw_item_description_window ($01:A79D)
;
; If the currently selected item in the item menu is in the range $CE to $E7,
; draws the item description window and the item description.
_menu_item_draw_item_description_window:
    JSR _menu_set_current_tilemap_bg2                                           ; $01A79D | Set the current tilemap to BG2.
    LDA r_menu_item_cursor_coordinates.y.w                                      ; $01A7A0 |\
    CLC                                                                         ; $01A7A3 | | Set the X register to the offset for the selected item by adding
    ADC r_menu_item_first_row.w                                                 ; $01A7A4 | | the cursor Y coordinate and the first row, multiplying by 2,
    ASL A                                                                       ; $01A7A7 | | adding the X coordinate, and multiplying by two again.
    ADC r_menu_item_cursor_coordinates.x.w                                      ; $01A7A8 | |
    ASL A                                                                       ; $01A7AB | |
    JSR _menu_transfer_a_to_x                                                   ; $01A7AC |/
    LDA r_inventory.1.id.w,X                                                    ; $01A7AF | Load the selected item ID.
    PHA                                                                         ; $01A7B2 |\
    LDY #menu_window_item_description_data.w                                    ; $01A7B3 | | Draw the window for displaying the item description.
    JSR _menu_configure_and_draw_window                                         ; $01A7B6 | |
    PLA                                                                         ; $01A7B9 |/
    CMP #ITEM_FIRST_FIELD_ITEM.b                                                ; $01A7BA |\
    BCC @no_description                                                         ; $01A7BC | | If the item is not in the range $CE to $E6 (field-usable items),
    CMP #ITEM_FIRST_SUMMON.b                                                    ; $01A7BE | | branch to erase the description window.
    BCS @no_description                                                         ; $01A7C0 |/
    SEC                                                                         ; $01A7C2 |\
    SBC #ITEM_FIRST_FIELD_ITEM.b                                                ; $01A7C3 | | Fetch the item description index for this item and save it to a
    JSR _menu_transfer_a_to_x                                                   ; $01A7C5 | | temporary variable.
    LDA bank0F.item_description_index_data.l,X                                  ; $01A7C8 | |
    STA <r_menu_generic_tmp_count                                               ; $01A7CC |/
    LDX #bank0F.item_description_data.w - 1                                     ; $01A7CE | Initialize the X register to the table address minus one.
-   BEQ +                                                                       ; $01A7D1 | NOTE: This line seems completely pointless. It will never be true.
    INX                                                                         ; $01A7D3 |\
    LDA $0F0000.l,X                                                             ; $01A7D4 | | Loop through the data until a number of zero bytes equal to the
    BNE -                                                                       ; $01A7D8 | | loaded index is found. Increment the X register one final time,
    DEC <r_menu_generic_tmp_count                                               ; $01A7DA | | and the desired data will be what's currently pointed to.
    BNE -                                                                       ; $01A7DC | |
    INX                                                                         ; $01A7DE |/
+   TXY                                                                         ; $01A7DF |\
    LDA #:bank0F.item_description_data.b                                        ; $01A7E0 | | Draw the item description to the tilemap at 10, 1 and return.
    LDX #(10 * 2) + (1 * 32 * 2).w                                              ; $01A7E2 | |
    JSR _menu_draw_text_direct_other_bank                                       ; $01A7E5 | |
    RTS                                                                         ; $01A7E8 |/
@no_description:
    JSR _menu_initialize_tilemap_bg2                                            ; $01A7E9 | Re-initialize BG2.
    LDY #menu_window_item_title_data.w                                          ; $01A7EC |\ Draw the item title window to BG2.
    JMP _menu_draw_text_indirect_plus_window                                    ; $01A7EF |/

; _menu_inventory_draw_trashcan ($01:A7F2)
;
; Given the current inventory item index in $5D and the current base tilemap in
; $29, draws the TrashCan icon to that inventory location within the tilemap.
_menu_inventory_draw_trashcan:
    REP #FLAG_P_ACCUMULATOR                                                     ; $01A7F2 |\
    LDA <r_menu_load_inventory_tmp_item_index                                   ; $01A7F4 | | Initialize the Y register to the desired location in the tilemap.
    LSR A                                                                       ; $01A7F6 | | To the base tilemap address, add the current item index divided by
    ASL A                                                                       ; $01A7F7 | | two, multiplied by 128, as each full row is actually two rows of
    ASL A                                                                       ; $01A7F8 | | tiles, each of which is 64 bytes. Afterward, add 32 to move to the
    ASL A                                                                       ; $01A7F9 | | middle of the row if the item index is odd. Finally, add 74 to
    ASL A                                                                       ; $01A7FA | | account for the very top row (the window border, 64 bytes) and the
    ASL A                                                                       ; $01A7FB | | other 10 to move to the center of the entry.
    ASL A                                                                       ; $01A7FC | |
    ASL A                                                                       ; $01A7FD | |
    STA <r_menu_generic_tmp_word                                                ; $01A7FE | |
    LDA <r_menu_load_inventory_tmp_item_index                                   ; $01A800 | |
    AND #$0001.w                                                                ; $01A802 | |
    BEQ +                                                                       ; $01A805 | |
    LDA #32.w                                                                   ; $01A807 | |
+   ADC <r_menu_generic_tmp_word                                                ; $01A80A | |
    CLC                                                                         ; $01A80C | |
    ADC <r_menu_current_tilemap_base_address                                    ; $01A80D | |
    ADC #(32 * 2 + 5 * 2).w                                                     ; $01A80F | |
    TAY                                                                         ; $01A812 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01A813 |/
    LDA #TILE_MENU_TRASHCAN_BASE.b                                              ; $01A815 |\
    STA 0.w,Y                                                                   ; $01A817 | | Write the four trashcan tiles to the tilemap.
    INC A                                                                       ; $01A81A | |
    STA 2.w,Y                                                                   ; $01A81B | |
    INC A                                                                       ; $01A81E | |
    STA (32 * 2).w,Y                                                            ; $01A81F | |
    INC A                                                                       ; $01A822 | |
    STA (32 * 2 + 2).w,Y                                                        ; $01A823 |/
    RTS                                                                         ; $01A826

; _menu_item_event_fail ($01:A827)
;
; Fail handler for the item event code.
_menu_item_event_fail:
    STZ r_menu_event.w                                                          ; $01A827 | Reset the item event.
    JMP _menu_item_fail_and_return                                              ; $01A82A | Jump to fail and return.

; _menu_item_handler_tent_cabin ($01:A82D)
;
; Item handler for the Tent and Cabin items, which close the menu and execute an
; event.
_menu_item_handler_tent_cabin:
    LDA r_saving_enabled.w                                                      ; $01A82D |\ If saving is enabled, branch to execute the event.
    BNE _menu_item_event_generic                                                ; $01A830 |/
    JMP _menu_item_fail_and_return                                              ; $01A832 | Otherwise, branch to failure.

; _menu_item_handler_magazine ($01:A835)
;
; Handler for the Magazine item, which closes the menu and immediately calls an
; event.
_menu_item_handler_magazine:
    LDA r_menu_event_flags.w                                                    ; $01A835 |\
    AND #MENU_EVENT_FLAGS_MAGAZINE.b                                            ; $01A838 | | If the Magazine flag is not set, branch to fail.
    BEQ _menu_item_event_fail                                                   ; $01A83A |/
    LDA #MENU_EVENT_MAGAZINE.b                                                  ; $01A83C |\ Otherwise, execute the Magazine event.
    BRA _menu_execute_item_event                                                ; $01A83E |/

; _menu_item_handler_exit ($01:A840)
;
; Handler for the Exit item, which closes the menu and activates the Exit event.
_menu_item_handler_exit:
    LDA r_menu_event_flags.w                                                    ; $01A840 |\
    AND #MENU_EVENT_FLAGS_EXIT.b                                                ; $01A843 | | If Exit is not enabled, branch to failure.
    BEQ _menu_item_event_fail                                                   ; $01A845 |/
    BRA _menu_item_event_generic                                                ; $01A847 | Otherwise, branch to execute the event.

; _menu_item_handler_eagleeye ($01:A849)
;
; Handler for the EagleEye item, which closes the menu and casts a Sight spell.
_menu_item_handler_eagleeye:
    LDA r_menu_event_flags.w                                                    ; $01A849 |\
    AND #MENU_EVENT_FLAGS_SIGHT.b                                               ; $01A84C | | If Sight isn't enabled, branch to failure. Otherwise, continue.
    BEQ _menu_item_event_fail                                                   ; $01A84E |/

; _menu_item_event_generic ($01:A850)
;
; Handles executing a generic item event where the menu event ID can be
; calculated simply by subtracting the base ID.
_menu_item_event_generic:
    LDA r_menu_item_selected_item_id.w                                          ; $01A850 |\
    SEC                                                                         ; $01A853 | | Subtract the base item ID and fall through to execute the event.
    SBC #ITEM_TENT.b - 1                                                        ; $01A854 |/

; _menu_execute_item_event ($01:A856)
;
; Executes an item event by setting the appropriate value in $1A03 and then
; returning from the entire menu system.
_menu_execute_item_event:
    STA r_menu_event.w                                                          ; $01A856 | Set the item event to the passed value.
    STZ r_menu_item_selected.w                                                  ; $01A859 | Reset the selected flag.
    LDX <r_menu_scroll_bg1.vertical.value                                       ; $01A85C |\ Store the current scroll value.
    STX r_menu_bg_scroll_vertical_bg1_backup.w                                  ; $01A85E |/
    LDX r_menu_return_stack_pointer.w                                           ; $01A861 |\
    TXS                                                                         ; $01A864 | | Return entirely out of the menu.
    RTS                                                                         ; $01A865 |/

; _menu_item_handler_siren ($01:A866)
;
; Handles the use of the Siren item, which immediately closes the menu and
; starts a battle.
_menu_item_handler_siren:
    LDA #AUDIO_EFFECT_ALERT.b                                                   ; $01A866 |\ Play the alert sound effect.
    JSR _play_sound_effect                                                      ; $01A868 |/
    LDA #MENU_EVENT_SIREN.b                                                     ; $01A86B |\ Execute the Siren event.
    BRA _menu_execute_item_event                                                ; $01A86D |/

; _menu_item_handler_call ($01:A86F)
;
; Handles the use of one of the Call items, which teach a Call spell to Rydia.
_menu_item_handler_call:
    STZ <r_menu_generic_tmp_count                                               ; $01A86F |\
-   LDA <r_menu_generic_tmp_count                                               ; $01A871 | | Search through the five character slots, searching for an instance
    JSR _menu_get_character_id                                                  ; $01A873 | | of Rydia.
    CMP #CHARACTER_RYDIA_1.b                                                    ; $01A876 | |
    BEQ +                                                                       ; $01A878 | |
    CMP #CHARACTER_RYDIA_2.b                                                    ; $01A87A | |
    BEQ +                                                                       ; $01A87C | |
    INC <r_menu_generic_tmp_count                                               ; $01A87E | |
    LDA <r_menu_generic_tmp_count                                               ; $01A880 | |
    CMP #5.b                                                                    ; $01A882 | |
    BNE -                                                                       ; $01A884 |/
@fail:
    REP #FLAG_P_INDEX                                                           ; $01A886 |\ If none was found, display the error message and return to the
    JMP _menu_item_fail_and_return                                              ; $01A888 |/ caller's caller.
+   STA <r_menu_item_call_character_id                                          ; $01A88B | Save the character ID for later use.
    LDA r_menu_item_selected_item_id.w                                          ; $01A88D |\
    SEC                                                                         ; $01A890 | | Determine the spell ID to teach by subtracting the difference
    SBC #ITEM_FIRST_SUMMON - SPELL_IMP.b                                        ; $01A891 | | between the corresponding item and spell IDs.
    STA <r_menu_generic_tmp_count                                               ; $01A893 |/
    SEP #FLAG_P_INDEX                                                           ; $01A895 | Switch to 8-bit index register mode.
    LDY <r_menu_zero.lo                                                         ; $01A897 |\
-   LDA r_spell_lists.5.w,Y                                                     ; $01A899 | | Search through the fifth spell list, searching for the spell in
    CMP <r_menu_generic_tmp_count                                               ; $01A89C | | question. If found, branch to the failure code.
    BEQ @fail                                                                   ; $01A89E | |
    INY                                                                         ; $01A8A0 | |
    CPY #24.b                                                                   ; $01A8A1 | |
    BNE -                                                                       ; $01A8A3 |/
    LDY <r_menu_zero.lo                                                         ; $01A8A5 |\
-   LDA r_spell_lists.5.w,Y                                                     ; $01A8A7 | | Search through the fifth spell list, searching for an empty space.
    BEQ +                                                                       ; $01A8AA | |
    INY                                                                         ; $01A8AC | |
    CPY #24.b                                                                   ; $01A8AD | |
    BNE -                                                                       ; $01A8AF |/
+   LDA <r_menu_generic_tmp_count                                               ; $01A8B1 |\ Save the newly learned spell to the empty space.
    STA r_spell_lists.5.w,Y                                                     ; $01A8B3 |/
    PHA                                                                         ; $01A8B6 | Preserve the spell ID.
    REP #FLAG_P_INDEX                                                           ; $01A8B7 | Switch back to 16-bit index register mode.
    JSR _menu_set_current_tilemap_bg2                                           ; $01A8B9 |\
    LDY #menu_window_item_learned_data.w                                        ; $01A8BC | | Draw a window for displaying a message about the learned spell.
    JSR _menu_draw_text_indirect_plus_window                                    ; $01A8BF |/
    LDY #(13 * 2) + (10 * 32 * 2).w                                             ; $01A8C2 |\
    LDA <r_menu_item_call_character_id                                          ; $01A8C5 | | Draw the character name to 13, 10.
    JSR _menu_draw_character_name                                               ; $01A8C7 |/
    INC r_menu_magic_draw_spell_name_arg_disable_dim.w                          ; $01A8CA |\
    PLA                                                                         ; $01A8CD | | Draw the spell name to 13, 14, disabling the dimming of the spell
.if FF4_REGION == "JAPAN"                                                       ;         | | name. The Japanese version instead draws to 13, 12.
    LDX #(13 * 2) + (12 * 32 * 2).w                                             ; $01A8F6 | |
.else                                                                           ;         | |
    LDX #(13 * 2) + (14 * 32 * 2).w                                             ; $01A8CE | |
.endif                                                                          ;         | |
    JSR _menu_draw_spell_name_short                                             ; $01A8D1 | |
    STZ r_menu_magic_draw_spell_name_arg_disable_dim.w                          ; $01A8D4 |/
    JSR _menu_animate_current_tilemap_50_rows_to_vram                           ; $01A8D7 | Animate the updated tilemap drawing.
    JSL bank0F.menu_play_good_fanfare                                           ; $01A8DA | Play the fanfare audio and wait 330 frames.
    JSR _menu_initialize_tilemap_bg2                                            ; $01A8DE |\
    JSR _menu_copy_tilemap_to_vram_bg2                                          ; $01A8E1 | | Clear the tilemap to erase the window.
    REP #FLAG_P_INDEX                                                           ; $01A8E4 |/
    RTS                                                                         ; $01A8E6

; _menu_item_targeting_get_character_id ($01:A8E7)
;
; Returns the character ID for the currently selected character in the
; accumulator, and returns the offset to that character's stat record in the X
; register. Falls through to the next routine to finish its work.
_menu_item_targeting_get_character_id:
    LDA r_menu_item_targeting_cursor_index.w                                    ; $01A8E7 | Load the selected position into the accumulator

; _menu_get_character_id_from_position ($01:A8EA)
;
; Given a character position number in the accumulator, returns the character
; ID for that character in the accumulator and the offset to that character's
; record in the X register. Again, this is for position, where 0 is the top
; position and 4 is the bottom position, in order.
_menu_get_character_id_from_position:
    JSR _menu_transfer_a_to_x                                                   ; $01A8EA |\ Load the slot number for the current cursor position.
    LDA bank14.character_position_to_slot_data.l,X                              ; $01A8ED |/

; _menu_get_character_id ($01:A8F1)
;
; Given a slot in the accumulator, returns the character ID of that character in
; the accumulator. Additionally returns the offset to that character's record in
; the X register.
_menu_get_character_id:
    JSR _menu_get_character_field_offset                                        ; $01A8F1 | Set the X register to the offset to the character record.
    LDA character_field.id.w,X                                                  ; $01A8F4 |\ Load the character ID into the accumulator.
    AND #%00111111.b                                                            ; $01A8F7 |/
    RTS                                                                         ; $01A8F9

; _menu_item_sort_inventory ($01:A8FA)
;
; Sorts the main inventory and plays a sound effect afterward.
_menu_item_sort_inventory:
    LDA #99.b                                                                   ; $01A8FA |\
    STA <r_menu_shop_maximum_item_count                                         ; $01A8FC | | Sort the main inventory.
    LDX #r_inventory.w                                                          ; $01A8FE | |
    JSR _menu_sort_inventory                                                    ; $01A901 |/
    JMP _play_sound_effect_menu_chime                                           ; $01A904 | Play the menu chime sound effect.

; _menu_command_status ($01:A907)
;
; Handler for the status menu in the main menu.
_menu_command_status:
    INC r_menu_status_active.w                                                  ; $01A907 | Set the status menu active flag.
    JSR _menu_status_core                                                       ; $01A90A | Execute the status menu.
    STZ r_menu_status_active.w                                                  ; $01A90D | Reset the status menu active flag.
    RTS                                                                         ; $01A910

; _menu_status_core ($01:A911)
;
; Core routine for the status menu.
_menu_status_core:
    STZ r_menu_character_selection_change_enabled.w                             ; $01A911 | Disable the ability to change rows in the character selection.
    JSR _menu_select_character                                                  ; $01A914 | Allow the player to select a character.
    LDA <r_menu_current_selected_character_slot                                 ; $01A917 |\
    BPL +                                                                       ; $01A919 | | Return if no character was selected.
    RTS                                                                         ; $01A91B |/
+   LDA <r_menu_current_selected_character_slot                                 ; $01A91C |\
    JSR _menu_get_character_field_offset                                        ; $01A91E | | Save the offset to the selected character's stat record.
    STX <r_menu_selected_character_offset                                       ; $01A921 |/
    LDA (<r_menu_selected_character_offset)                                     ; $01A923 |\
    AND #%00111111.b                                                            ; $01A925 | | Return if the character slot is empty, not that this should
    BNE +                                                                       ; $01A927 | | happen.
    RTS                                                                         ; $01A929 |/
+   JSR _menu_init_bg_scroll                                                    ; $01A92A | Initialize the background scroll values.
    JSR _menu_backup_cgram_1                                                    ; $01A92D | Backup the palette data to the first backup area.
    JSR _menu_initialize_oam                                                    ; $01A930 | Initialize the OAM.
    JSR _menu_initialize_tilemap_bg2                                            ; $01A933 | Initialize the BG2 tilemap.
    JSR _menu_initialize_tilemap_bg1                                            ; $01A936 | Initialize the BG1 tilemap.
    JSR _menu_wait_for_vblank_copy_oam_to_ppu                                   ; $01A939 | Wait for vblank and copy the OAM to the PPU.
    JSR _menu_copy_palette_to_cgram                                             ; $01A93C | Copy the palette data to CG-RAM.
    LDA #12.b                                                                   ; $01A93F |\ Configure the window transition to take 12 frames.
    STA <r_menu_transition_scroll_frames                                        ; $01A941 |/
    LDA #4.b                                                                    ; $01A943 |\
    STA <r_menu_scroll_delta_bg4.vertical.value.lo                              ; $01A945 | | Configure BG2 and BG4 to scroll upward by 4 pixels per frame.
    STA <r_menu_scroll_delta_bg2.vertical.value.lo                              ; $01A947 |/
    JSR _menu_set_current_tilemap_bg4                                           ; $01A949 | Set the current tilemap to BG4.
    LDY #(24 * 2) + (9 * 32 * 2).w                                              ; $01A94C |\
    LDA #5.b                                                                    ; $01A94F | | Erase the "Form" text below "Status" in the command menu.
    CLC                                                                         ; $01A951 | |
    JSR _menu_erase_tiles                                                       ; $01A952 |/
    LDY #menu_window_main_command_data.w                                        ; $01A955 |\
    LDX #menu_window_status_portrait_title_data.w                               ; $01A958 | | Animate the transition from the command menu to the title window.
    JSR _menu_window_transition                                                 ; $01A95B |/
    JSR _menu_copy_tilemap_to_vram_bg1                                          ; $01A95E | Copy the BG1 tilemap to VRAM.
    LDA #%00110000.b                                                            ; $01A961 |\ Set the character sprite base tile flags to priority 3.
    STA <r_menu_character_sprite_base_tile_flags                                ; $01A963 |/
    LDA <r_menu_current_selected_character_slot                                 ; $01A965 |\
    LDY #152 + (8 << 8).w                                                       ; $01A967 | | Draw the character portrait to 152, 8.
    JSR _menu_draw_portrait                                                     ; $01A96A |/
    JSR _menu_set_current_tilemap_bg2                                           ; $01A96D | Set the current tilemap to BG2.
    LDY #menu_window_status_portrait_title_data.w                               ; $01A970 |\ Draw the portrait and status title window.
    JSR _menu_configure_and_draw_window                                         ; $01A973 |/
    LDY #menu_text_status_title_data.w                                          ; $01A976 |\ Draw the "Status" title text.
    JSR _menu_draw_text_indirect                                                ; $01A979 |/
    JSR _menu_copy_tilemap_to_vram_bg2                                          ; $01A97C | Copy the BG2 tilemap to VRAM.
    JSR _menu_copy_palette_to_cgram                                             ; $01A97F | Copy the palette data to CG-RAM.
    JSR _menu_copy_oam_to_ppu                                                   ; $01A982 | Copy the OAM to the PPU.
    JSR _menu_set_current_tilemap_bg1                                           ; $01A985 | Set the current tilemap to BG1.
    JSR _menu_status_draw_static_text                                           ; $01A988 | Draw the static text associated with the status menu.
    LDA (<r_menu_selected_character_offset)                                     ; $01A98B |\
    AND #%00111111.b                                                            ; $01A98D | | Draw the character's name to 2, 2.
    LDY #(2 * 2) + (2 * 32 * 2).w                                               ; $01A98F | |
    JSR _menu_draw_character_name                                               ; $01A992 |/
    LDY #(4 * 2) + (2 * 32 * 2).w                                               ; $01A995 |\
    LDX <r_menu_selected_character_offset                                       ; $01A998 | | Draw the status icons for the character.
    JSR _menu_draw_status_class                                                 ; $01A99A |/
    LDY #character_field.level.w                                                ; $01A99D |\
    LDA (<r_menu_selected_character_offset),Y                                   ; $01A9A0 | | Draw the character's level to 14, 5.
    LDY #(14 * 2) + (5 * 32 * 2).w                                              ; $01A9A2 | |
    JSR _menu_draw_two_digit_number                                             ; $01A9A5 |/
    LDY #character_field.strength.w                                             ; $01A9A8 |\
    LDA (<r_menu_selected_character_offset),Y                                   ; $01A9AB | | Draw the character's strength to 9, 16.
    LDY #(9 * 2) + (16 * 32 * 2).w                                              ; $01A9AD | |
    JSR _menu_draw_two_digit_number                                             ; $01A9B0 |/
    LDY #character_field.agility.w                                              ; $01A9B3 |\
    LDA (<r_menu_selected_character_offset),Y                                   ; $01A9B6 | | Draw the character's agility to 9, 18.
    LDY #(9 * 2) + (18 * 32 * 2).w                                              ; $01A9B8 | |
    JSR _menu_draw_two_digit_number                                             ; $01A9BB |/
    LDY #character_field.vitality.w                                             ; $01A9BE |\
    LDA (<r_menu_selected_character_offset),Y                                   ; $01A9C1 | | Draw the character's vitality to 9, 20.
    LDY #(9 * 2) + (20 * 32 * 2).w                                              ; $01A9C3 | |
    JSR _menu_draw_two_digit_number                                             ; $01A9C6 |/
    LDY #character_field.wisdom.w                                               ; $01A9C9 |\
    LDA (<r_menu_selected_character_offset),Y                                   ; $01A9CC | | Draw the character's wisdom to 9, 22.
    LDY #(9 * 2) + (22 * 32 * 2).w                                              ; $01A9CE | |
    JSR _menu_draw_two_digit_number                                             ; $01A9D1 |/
    LDY #character_field.will.w                                                 ; $01A9D4 |\
    LDA (<r_menu_selected_character_offset),Y                                   ; $01A9D7 | | Draw the character's will to 9, 24.
    LDY #(9 * 2) + (24 * 32 * 2).w                                              ; $01A9D9 | |
    JSR _menu_draw_two_digit_number                                             ; $01A9DC |/
    LDY #character_field.physical_attack_multiplier.w                           ; $01A9DF |\
    LDA (<r_menu_selected_character_offset),Y                                   ; $01A9E2 | | Draw the character's physical attack multiplier to 21, 14.
    LDY #(21 * 2) + (14 * 32 * 2).w                                             ; $01A9E4 | |
    JSR _menu_draw_two_digit_number                                             ; $01A9E7 |/
    LDY #character_field.physical_defense_multiplier.w                          ; $01A9EA |\
    LDA (<r_menu_selected_character_offset),Y                                   ; $01A9ED | | Draw the character's physical defense multiplier to 21, 18.
    LDY #(21 * 2) + (18 * 32 * 2).w                                             ; $01A9EF | |
    JSR _menu_draw_two_digit_number                                             ; $01A9F2 |/
    LDY #character_field.magic_defense_multiplier.w                             ; $01A9F5 |\
    LDA (<r_menu_selected_character_offset),Y                                   ; $01A9F8 | | Draw the character's magic defense multiplier to 21, 22.
    LDY #(21 * 2) + (22 * 32 * 2).w                                             ; $01A9FA | |
    JSR _menu_draw_two_digit_number                                             ; $01A9FD |/
    LDY #character_field.physical_attack_accuracy.w                             ; $01AA00 |\
    LDA (<r_menu_selected_character_offset),Y                                   ; $01AA03 | | Draw the character's physical attack accuracy to 26, 16.
    LDY #(26 * 2) + (16 * 32 * 2).w                                             ; $01AA05 | |
    JSR _menu_draw_two_digit_number                                             ; $01AA08 |/
    LDY #character_field.physical_defense_evade.w                               ; $01AA0B |\
    LDA (<r_menu_selected_character_offset),Y                                   ; $01AA0E | | Draw the character's physical evade to 26, 20.
    LDY #(26 * 2) + (20 * 32 * 2).w                                             ; $01AA10 | |
    JSR _menu_draw_two_digit_number                                             ; $01AA13 |/
    LDY #character_field.magic_defense_evade.w                                  ; $01AA16 |\
    LDA (<r_menu_selected_character_offset),Y                                   ; $01AA19 | | Draw the character's magic evade to 26, 24.
    LDY #(26 * 2) + (24 * 32 * 2).w                                             ; $01AA1B | |
    JSR _menu_draw_two_digit_number                                             ; $01AA1E |/
    LDY #character_field.experience.w                                           ; $01AA21 |\
    LDA (<r_menu_selected_character_offset),Y                                   ; $01AA24 | | Draw the character's experience to 19, 8.
    STA <r_menu_generic_tmp_word.lo                                             ; $01AA26 | |
    INY                                                                         ; $01AA28 | |
    LDA (<r_menu_selected_character_offset),Y                                   ; $01AA29 | |
    STA <r_menu_generic_tmp_word.hi                                             ; $01AA2B | |
    INY                                                                         ; $01AA2D | |
    LDA (<r_menu_selected_character_offset),Y                                   ; $01AA2E | |
    LDX <r_menu_generic_tmp_word                                                ; $01AA30 | |
    LDY #(19 * 2) + (8 * 32 * 2).w                                              ; $01AA32 | |
    JSR _menu_draw_number_as_decimal                                            ; $01AA35 |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $01AA38 |\
    LDY #character_field.hp.w                                                   ; $01AA3A | | Draw the character's current HP to 4, 10.
    LDA (<r_menu_selected_character_offset),Y                                   ; $01AA3D | |
    LDY #(4 * 2) + (10 * 32 * 2).w                                              ; $01AA3F | |
    JSR _menu_draw_four_digit_number                                            ; $01AA42 |/
    LDY #character_field.hp_max.w                                               ; $01AA45 |\
    LDA (<r_menu_selected_character_offset),Y                                   ; $01AA48 | | Draw the character's maximum HP to 9, 10.
    LDY #(9 * 2) + (10 * 32 * 2).w                                              ; $01AA4A | |
    JSR _menu_draw_four_digit_number                                            ; $01AA4D |/
    LDY #character_field.mp.w                                                   ; $01AA50 |\
    LDA (<r_menu_selected_character_offset),Y                                   ; $01AA53 | | Draw the character's current MP to 4, 12.
    LDY #(4 * 2) + (12 * 32 * 2).w                                              ; $01AA55 | |
    JSR _menu_draw_four_digit_number                                            ; $01AA58 |/
    LDY #character_field.mp_max.w                                               ; $01AA5B |\
    LDA (<r_menu_selected_character_offset),Y                                   ; $01AA5E | | Draw the character's maximum MP to 9, 12.
    LDY #(9 * 2) + (12 * 32 * 2).w                                              ; $01AA60 | |
    JSR _menu_draw_four_digit_number                                            ; $01AA63 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01AA66 |/
    TDC                                                                         ; $01AA68 |\ Zero out the high byte of the accumulator.
    XBA                                                                         ; $01AA69 |/
    LDY #character_field.physical_attack_base.w                                 ; $01AA6A |\
    LDA (<r_menu_selected_character_offset),Y                                   ; $01AA6D | | Draw the character's physical attack base to 25, 14.
    LDY #(25 * 2) + (14 * 32 * 2).w                                             ; $01AA6F | |
    JSR _menu_draw_four_digit_number_8bit                                       ; $01AA72 |/
    LDY #character_field.physical_defense_base.w                                ; $01AA75 |\
    LDA (<r_menu_selected_character_offset),Y                                   ; $01AA78 | | Draw the character's physical defense base to 25, 18.
    LDY #(25 * 2) + (18 * 32 * 2).w                                             ; $01AA7A | |
    JSR _menu_draw_four_digit_number_8bit                                       ; $01AA7D |/
    LDY #character_field.magic_defense_base.w                                   ; $01AA80 |\
    LDA (<r_menu_selected_character_offset),Y                                   ; $01AA83 | | Draw the character's magic defense base to 25, 22.
    LDY #(25 * 2) + (22 * 32 * 2).w                                             ; $01AA85 | |
    JSR _menu_draw_four_digit_number_8bit                                       ; $01AA88 |/
    LDA (<r_menu_selected_character_offset)                                     ; $01AA8B |\
    AND #%11000000.b                                                            ; $01AA8D | | Draw the character's handedness to 3, 6.
    LSR A                                                                       ; $01AA8F | |
    LSR A                                                                       ; $01AA90 | |
    LSR A                                                                       ; $01AA91 | |
    STA <r_menu_generic_tmp_word.lo                                             ; $01AA92 | |
    STZ <r_menu_generic_tmp_word.hi                                             ; $01AA94 | |
    REP #FLAG_P_ACCUMULATOR                                                     ; $01AA96 | |
    LDA #menu_text_equip_handedness_data.w                                      ; $01AA98 | |
    CLC                                                                         ; $01AA9B | |
    ADC <r_menu_generic_tmp_word                                                ; $01AA9C | |
    TAY                                                                         ; $01AA9E | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01AA9F | |
    LDX #(3 * 2) + (6 * 32 * 2).w                                               ; $01AAA1 | |
    JSR _menu_draw_text_direct                                                  ; $01AAA4 |/
    LDY #character_field.sprite_class.w                                         ; $01AAA7 |\
    LDA (<r_menu_selected_character_offset),Y                                   ; $01AAAA | | Draw the character's class to 3, 4.
    LDY #(3 * 2) + (4 * 32 * 2).w                                               ; $01AAAC | |
    JSR _menu_draw_character_class                                              ; $01AAAF |/
    JSR _menu_status_draw_punctuation                                           ; $01AAB2 | Draw the punctuation on the status menu.
    LDY #character_field.level.w                                                ; $01AAB5 |\
    LDA (<r_menu_selected_character_offset),Y                                   ; $01AAB8 | | If the character is at level 99, skip drawing the needed
    CMP #99.b                                                                   ; $01AABA | | experience.
    BNE +                                                                       ; $01AABC | |
    JMP @no_needed_exp                                                          ; $01AABE |/
+   LDY #menu_text_status_for_level_up_data.w                                   ; $01AAC1 |\ Draw the "For level up" text.
    JSR _menu_draw_text_indirect                                                ; $01AAC4 |/
    LDY #character_field.experience_needed.w                                    ; $01AAC7 |\
    LDA (<r_menu_selected_character_offset),Y                                   ; $01AACA | | Copy the character's needed experience value to a temporary
    STA <r_menu_generic_tmp_long.lo                                             ; $01AACC | | variable.
    INY                                                                         ; $01AACE | |
    LDA (<r_menu_selected_character_offset),Y                                   ; $01AACF | |
    STA <r_menu_generic_tmp_long.md                                             ; $01AAD1 | |
    INY                                                                         ; $01AAD3 | |
    LDA (<r_menu_selected_character_offset),Y                                   ; $01AAD4 | |
    STA <r_menu_generic_tmp_long.hi                                             ; $01AAD6 |/
    LDA (<r_menu_selected_character_offset)                                     ; $01AAD8 |\
    AND #%00111111.b                                                            ; $01AADA | | Store the offset to this character's level up data.
    DEC A                                                                       ; $01AADC | |
    ASL A                                                                       ; $01AADD | |
    JSR _menu_transfer_a_to_x                                                   ; $01AADE | |
    REP #FLAG_P_ACCUMULATOR                                                     ; $01AAE1 | |
    LDA bank0F.level_up_pointer_data.l,X                                        ; $01AAE3 | |
    STA <r_menu_status_tmp_level_up_offset                                      ; $01AAE7 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01AAE9 |/
    LDY #character_field.level.w                                                ; $01AAEB |\
    LDA (<r_menu_selected_character_offset),Y                                   ; $01AAEE | | Set the X register to the offset to the first byte of the
    CMP #69.b                                                                   ; $01AAF0 | | character's current experience value in the level up data.
    BCC +                                                                       ; $01AAF2 | |
    LDA #69.b                                                                   ; $01AAF4 | |
+   DEC A                                                                       ; $01AAF6 | |
    STA <r_menu_generic_tmp_offset.lo                                           ; $01AAF7 | |
    REP #FLAG_P_ACCUMULATOR                                                     ; $01AAF9 | |
    LDA <r_menu_generic_tmp_offset                                              ; $01AAFB | |
    ASL A                                                                       ; $01AAFD | |
    ASL A                                                                       ; $01AAFE | |
    ADC <r_menu_generic_tmp_offset                                              ; $01AAFF | |
    ADC <r_menu_status_tmp_level_up_offset                                      ; $01AB01 | |
    ADC #level_up.mp_exp_hi.w                                                   ; $01AB03 | |
    TAX                                                                         ; $01AB06 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01AB07 |/
    LDA $0F0000.l,X                                                             ; $01AB09 |\
    LSR A                                                                       ; $01AB0D | | Extract the three high bits of the needed experience value for
    LSR A                                                                       ; $01AB0E | | this level and store them in a temporary byte.
    LSR A                                                                       ; $01AB0F | |
    LSR A                                                                       ; $01AB10 | |
    LSR A                                                                       ; $01AB11 | |
    STA <r_menu_status_tmp_exp                                                  ; $01AB12 | |
    INX                                                                         ; $01AB14 | |
    REP #FLAG_P_ACCUMULATOR                                                     ; $01AB15 |/
    LDA $0F0000.l,X                                                             ; $01AB17 |\
    CLC                                                                         ; $01AB1B | | Add the needed experience for the next level to the experience
    ADC <r_menu_generic_tmp_long.lo                                             ; $01AB1C | | needed for the current level (from the character record) and save
    STA <r_menu_generic_tmp_long.lo                                             ; $01AB1E | | that to memory (which is the total needed experience for the next
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01AB20 | | level).
    LDA <r_menu_generic_tmp_long.hi                                             ; $01AB22 | |
    ADC <r_menu_status_tmp_exp                                                  ; $01AB24 | |
    STA <r_menu_generic_tmp_long.hi                                             ; $01AB26 |/
    LDY #character_field.experience.w                                           ; $01AB28 |\
    REP #FLAG_P_ACCUMULATOR                                                     ; $01AB2B | | Subtract the current experience from the total needed experience.
    LDA <r_menu_generic_tmp_long.lo                                             ; $01AB2D | |
    SEC                                                                         ; $01AB2F | |
    SBC (<r_menu_selected_character_offset),Y                                   ; $01AB30 | |
    STA <r_menu_generic_tmp_long.lo                                             ; $01AB32 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01AB34 | |
    INY                                                                         ; $01AB36 | |
    INY                                                                         ; $01AB37 | |
    LDA <r_menu_generic_tmp_long.hi                                             ; $01AB38 | |
    SBC (<r_menu_selected_character_offset),Y                                   ; $01AB3A | |
    STA <r_menu_generic_tmp_long.hi                                             ; $01AB3C |/
    LDY #(19 * 2) + (11 * 32 * 2).w                                             ; $01AB3E |\
    LDA <r_menu_generic_tmp_long.hi                                             ; $01AB41 | | Draw the needed experience to the tilemap at 19, 11.
    LDX <r_menu_generic_tmp_long.lo                                             ; $01AB43 | |
    JSR _menu_draw_number_as_decimal                                            ; $01AB45 |/
@no_needed_exp:
    JSR _menu_animate_current_tilemap_50_rows_to_vram                           ; $01AB48 | Animate the status menu opening from the top.
    JSR _menu_restore_cgram_1                                                   ; $01AB4B | Restore the backed up palette data.
    JSR _menu_initialize_tilemap_bg1                                            ; $01AB4E |\ Clear the BG1 and BG2 tilemaps.
    JSR _menu_initialize_tilemap_bg2                                            ; $01AB51 |/
    JSR _menu_wait_for_input                                                    ; $01AB54 | Wait for input.
    JSR _menu_animate_current_tilemap_50_rows_to_vram_reversed                  ; $01AB57 | Animate the status menu closing to the top.
    JSR _menu_copy_tilemap_to_vram_bg2                                          ; $01AB5A | Copy the BG2 tilemap to VRAM.
    JSR _menu_copy_palette_to_cgram                                             ; $01AB5D | Copy the restored palette data to CG-RAM.
    JSR _menu_initialize_oam                                                    ; $01AB60 | Initialize the OAM.
    JSR _menu_wait_for_vblank_copy_oam_to_ppu                                   ; $01AB63 | Wait for vblank and copy the OAM to the PPU.
    LDA #12.b                                                                   ; $01AB66 |\ Configure the window transition to take 12 frames.
    STA <r_menu_transition_scroll_frames                                        ; $01AB68 |/
    LDA #4.b | %10000000                                                        ; $01AB6A |\
    STA <r_menu_scroll_delta_bg4.vertical.value.lo                              ; $01AB6C | | Configure BG2 and BG4 to scroll downward at 4 pixels per frame.
    STA <r_menu_scroll_delta_bg2.vertical.value.lo                              ; $01AB6E |/
    JSR _menu_set_current_tilemap_bg4                                           ; $01AB70 | Set the current tilemap to BG4.
    LDX #menu_window_main_command_data.w                                        ; $01AB73 |\
    LDY #menu_window_status_portrait_title_data.w                               ; $01AB76 | | Animate the transition to the command menu.
    JSR _menu_window_transition                                                 ; $01AB79 |/
    STZ r_menu_status_active.w                                                  ; $01AB7C | Reset the status active flag.
    JSR _menu_main_draw                                                         ; $01AB7F | Draw the main menu.
    JSR _menu_party_draw_character_portraits                                    ; $01AB82 | Draw the party character portraits.
    JSR _menu_wait_for_vblank_copy_oam_to_ppu                                   ; $01AB85 | Wait for vblank and copy the OAM to the PPU.
    JSR _menu_animate_current_tilemap_50_rows_to_vram_reversed                  ; $01AB88 | Animate the main menu opening.
    JMP _menu_init_bg_scroll                                                    ; $01AB8B | Initialize the background scroll values to default.

; _menu_status_draw_static_text ($01:AB8E)
;
; Draws the static text on the status menu, which is consistent and is always
; displayed. Falls through to the next routine to draw the punctuation on the
; screen.
_menu_status_draw_static_text:
    LDY #menu_window_status_data.w                                              ; $01AB8E |\ Draw the overall status window.
    JSR _menu_configure_and_draw_window                                         ; $01AB91 |/
    LDY #menu_text_status_text_data.w                                           ; $01AB94 |\ Draw most of the static text that appears in the window.
    JSR _menu_draw_text_indirect                                                ; $01AB97 |/

; _menu_status_draw_punctuation ($01:AB9A)
;
; Draws the ellipses, slashes and percent signs on the status screen.
_menu_status_draw_punctuation:
    LDA #TEXT_ELLIPSIS.b                                                        ; $01AB9A |\
    STA r_menu_tilemap_bg1.w + (8 * 2) + (16 * 32 * 2)                          ; $01AB9C | | Draw ellipses at various places on the screen to separate numbers
    STA r_menu_tilemap_bg1.w + (8 * 2) + (18 * 32 * 2)                          ; $01AB9F | | from their labels.
    STA r_menu_tilemap_bg1.w + (8 * 2) + (20 * 32 * 2)                          ; $01ABA2 | |
    STA r_menu_tilemap_bg1.w + (8 * 2) + (22 * 32 * 2)                          ; $01ABA5 | |
    STA r_menu_tilemap_bg1.w + (8 * 2) + (24 * 32 * 2)                          ; $01ABA8 | |
    STA r_menu_tilemap_bg1.w + (25 * 2) + (14 * 32 * 2)                         ; $01ABAB | |
    STA r_menu_tilemap_bg1.w + (25 * 2) + (16 * 32 * 2)                         ; $01ABAE | |
    STA r_menu_tilemap_bg1.w + (25 * 2) + (18 * 32 * 2)                         ; $01ABB1 | |
    STA r_menu_tilemap_bg1.w + (25 * 2) + (20 * 32 * 2)                         ; $01ABB4 | |
    STA r_menu_tilemap_bg1.w + (25 * 2) + (22 * 32 * 2)                         ; $01ABB7 | |
    STA r_menu_tilemap_bg1.w + (25 * 2) + (24 * 32 * 2)                         ; $01ABBA |/
    LDA #TEXT_PERCENT.b                                                         ; $01ABBD |\
    STA r_menu_tilemap_bg1.w + (28 * 2) + (16 * 32 * 2)                         ; $01ABBF | | Draw percent signs for the three numbers that require it.
    STA r_menu_tilemap_bg1.w + (28 * 2) + (20 * 32 * 2)                         ; $01ABC2 | |
    STA r_menu_tilemap_bg1.w + (28 * 2) + (24 * 32 * 2)                         ; $01ABC5 |/
    LDA #TEXT_SLASH.b                                                           ; $01ABC8 |\
    STA r_menu_tilemap_bg1.w + (8 * 2) + (10 * 32 * 2)                          ; $01ABCA | | Draw slashes to separate current HP and MP from maximum HP and MP.
    STA r_menu_tilemap_bg1.w + (8 * 2) + (12 * 32 * 2)                          ; $01ABCD |/
    RTS                                                                         ; $01ABD0

; _menu_command_form ($01:ABD1)
;
; Handler for the Form command in the menu.
_menu_command_form:
    JSR _menu_form_core                                                         ; $01ABD1 | Execute the Form menu.
    STZ r_menu_enable_empty_slot_selection.w                                    ; $01ABD4 | Disable the ability to select empty slots.
    RTS                                                                         ; $01ABD7

; _menu_form_core ($01:ABD8)
;
; Core routine to handle the Form command in the menu.
_menu_form_core:
    INC r_menu_character_selection_change_enabled.w                             ; $01ABD8 | Set the flag to enable row change in the character selection.
    INC r_menu_enable_empty_slot_selection.w                                    ; $01ABDB | Set the flag to allow selection of empty slots.
    INC <r_unknown_0184                                                         ; $01ABDE | TODO
-   JSR _menu_select_character                                                  ; $01ABE0 | Allow the player to select a character.
    LDA <r_menu_current_selected_character_slot                                 ; $01ABE3 |\
    CMP #MENU_TARGET_SLOT_CHANGE.b                                              ; $01ABE5 | | If the player pressed left or right to change rows, do the row
    BNE +                                                                       ; $01ABE7 | | change and then redraw the menu. Afterward, branch back to again
    LDA #%00000001.b                                                            ; $01ABE9 | | ask the player to select a character.
    EOR r_party_formation_two_front.w                                           ; $01ABEB | |
    STA r_party_formation_two_front.w                                           ; $01ABEE | |
    JSR _menu_main_draw                                                         ; $01ABF1 | |
    JSR _menu_main_draw_time_and_gp                                             ; $01ABF4 | |
    JSR _menu_copy_tilemap_to_vram_bg3                                          ; $01ABF7 | |
    JSR _menu_copy_palette_to_cgram                                             ; $01ABFA | |
    BRA -                                                                       ; $01ABFD |/
+   LDA <r_menu_current_selected_character_slot                                 ; $01ABFF |\
    BPL @select_slot_2                                                          ; $01AC01 | | If no character was selected, zero out the selected character slot
    STZ <r_menu_current_selected_character_slot                                 ; $01AC03 | | and return.
    RTS                                                                         ; $01AC05 |/
@select_slot_2:
    LDA <r_menu_current_selected_character_position                             ; $01AC06 |\
    ASL A                                                                       ; $01AC08 | | Draw the second cursor to indicate the selected character. Set the
    ASL A                                                                       ; $01AC09 | | Y coordinate to the selected position times 40 plus 20. Set the X
    ASL A                                                                       ; $01AC0A | | coordinate to 4.
    STA <r_menu_draw_cursor_arg_coordinates.x                                   ; $01AC0B | |
    ASL A                                                                       ; $01AC0D | |
    ASL A                                                                       ; $01AC0E | |
    ADC <r_menu_draw_cursor_arg_coordinates.x                                   ; $01AC0F | |
    ADC #20.b                                                                   ; $01AC11 | |
    STA <r_menu_draw_cursor_arg_coordinates.y                                   ; $01AC13 | |
    LDA #4.b                                                                    ; $01AC15 | |
    STA <r_menu_draw_cursor_arg_coordinates.x                                   ; $01AC17 | |
    JSR _menu_draw_cursor_2                                                     ; $01AC19 |/
    LDA <r_menu_current_selected_character_slot                                 ; $01AC1C |\ Save the selected character slot.
    STA <r_menu_form_selected_character_slot_1                                  ; $01AC1E |/
    STZ r_menu_character_selection_change_enabled.w                             ; $01AC20 |\ Disable the ability to change rows and allow the player to select
    JSR _menu_select_character                                                  ; $01AC23 |/ the second character.
    LDA <r_menu_current_selected_character_slot                                 ; $01AC26 |\
    BPL +                                                                       ; $01AC28 | | If no character was selected, erase the two cursors and return.
    STZ <r_menu_current_selected_character_slot                                 ; $01AC2A | |
    JSR _menu_erase_cursor_2                                                    ; $01AC2C | |
    JMP _menu_erase_cursor_1                                                    ; $01AC2F |/
+   STA <r_menu_form_selected_character_slot_2                                  ; $01AC32 | Save the value of the second selected slot.
    CMP <r_menu_form_selected_character_slot_1                                  ; $01AC34 |\
    BNE +                                                                       ; $01AC36 | | If the same slot was selected, branch to select again.
    BRA @select_slot_2                                                          ; $01AC38 |/
+   LDA <r_menu_form_selected_character_slot_1                                  ; $01AC3A |\
    JSR _menu_get_character_id                                                  ; $01AC3C | | If two empty slots are chosen, erase the second cursor and return.
    STA <r_menu_generic_tmp_count                                               ; $01AC3F | |
    LDA <r_menu_form_selected_character_slot_2                                  ; $01AC41 | |
    JSR _menu_get_character_id                                                  ; $01AC43 | |
    ORA <r_menu_generic_tmp_count                                               ; $01AC46 | |
    BNE +                                                                       ; $01AC48 | |
    JMP _menu_erase_cursor_2                                                    ; $01AC4A |/
+   JSR _menu_load_character_sprites                                            ; $01AC4D | Load the character sprites.
    JSR _menu_form_animate_character_sprite_swap                                ; $01AC50 | Animate the character sprite swap.
    REP #FLAG_P_ACCUMULATOR                                                     ; $01AC53 |\
    LDA <r_menu_form_selected_character_slot_2                                  ; $01AC55 | | Copy the second character's stat record to a temporary location in
    AND #$00FF.w                                                                ; $01AC57 | | memory. The source address is pushed to the stack for later use.
    ASL A                                                                       ; $01AC5A | |
    ASL A                                                                       ; $01AC5B | |
    ASL A                                                                       ; $01AC5C | |
    ASL A                                                                       ; $01AC5D | |
    ASL A                                                                       ; $01AC5E | |
    ASL A                                                                       ; $01AC5F | |
    ADC #r_character_field.w                                                    ; $01AC60 | |
    TAX                                                                         ; $01AC63 | |
    PHX                                                                         ; $01AC64 | |
    LDY #r_menu_form_backup.w                                                   ; $01AC65 | |
    LDA #_sizeof_character_field.w - 1                                          ; $01AC68 | |
    MVN $00.b,:r_menu_form_backup                                               ; $01AC6B |/
    PLY                                                                         ; $01AC6E |\
    LDA <r_menu_form_selected_character_slot_1                                  ; $01AC6F | | Copy the first character's record to the original location of the
    AND #$00FF.w                                                                ; $01AC71 | | second character's record.
    ASL A                                                                       ; $01AC74 | |
    ASL A                                                                       ; $01AC75 | |
    ASL A                                                                       ; $01AC76 | |
    ASL A                                                                       ; $01AC77 | |
    ASL A                                                                       ; $01AC78 | |
    ASL A                                                                       ; $01AC79 | |
    ADC #r_character_field.w                                                    ; $01AC7A | |
    TAX                                                                         ; $01AC7D | |
    PHX                                                                         ; $01AC7E | |
    LDA #_sizeof_character_field.w - 1                                          ; $01AC7F | |
    MVN :r_character_field,:r_character_field                                   ; $01AC82 |/
    PLY                                                                         ; $01AC85 |\
    LDX #r_menu_form_backup.w                                                   ; $01AC86 | | Copy the previously backed up second character's record to the
    LDA #_sizeof_character_field.w - 1                                          ; $01AC89 | | original location of the first character's record.
    MVN :r_menu_form_backup,:r_character_field                                  ; $01AC8C | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01AC8F |/
    LDA <r_menu_form_selected_character_slot_1                                  ; $01AC91 |\
    JSR _menu_transfer_a_to_x                                                   ; $01AC93 | | Swap the multiple controller settings for the two characters.
    LDA r_config.multi.w,X                                                      ; $01AC96 | |
    PHA                                                                         ; $01AC99 | |
    TXY                                                                         ; $01AC9A | |
    LDA <r_menu_form_selected_character_slot_2                                  ; $01AC9B | |
    JSR _menu_transfer_a_to_x                                                   ; $01AC9D | |
    LDA r_config.multi.w,X                                                      ; $01ACA0 | |
    STA r_config.multi.w,Y                                                      ; $01ACA3 | |
    PLA                                                                         ; $01ACA6 | |
    STA r_config.multi.w,X                                                      ; $01ACA7 |/
    JSL bank1E.menu_form_swap_saved_cursor_coordinates                          ; $01ACAA | Swap the saved magic menu coordinates for the two characters.
    JSR _menu_load_portraits                                                    ; $01ACAE | Load the character portraits.
    JSR _menu_erase_cursor_2                                                    ; $01ACB1 | Erase the second cursor.
    BRA _menu_command_form_change_redraw_menu                                   ; $01ACB4 | Redraw the main menu and return.

; _menu_command_change ($01:ACB6)
;
; Handler for the Change command in the main menu. Falls through to the next
; routine.
_menu_command_change:
    LDA #%00000001.b                                                            ; $01ACB6 |\
    EOR r_party_formation_two_front.w                                           ; $01ACB8 | | Change the party formation.
    STA r_party_formation_two_front.w                                           ; $01ACBB |/
    INC <r_unknown_0184                                                         ; $01ACBE | TODO

; _menu_command_form_change_redraw_menu ($01:ACC0)
;
; Common routine used by the Form and Change menu handlers to redraw the main
; menu after finishing.
_menu_command_form_change_redraw_menu:
    JSR _menu_main_draw                                                         ; $01ACC0 |\
    JSR _menu_main_draw_time_and_gp                                             ; $01ACC3 | | Redraw the main menu.
    JSR _menu_copy_tilemap_to_vram_bg3                                          ; $01ACC6 | |
    JMP _menu_copy_palette_to_cgram                                             ; $01ACC9 |/

; _menu_form_get_character_sprite_coordinates ($01:ACCC)
;
; Given a character slot in the accumulator, returns the coordinates for the
; character sprite for that slot in the form menu.
_menu_form_get_character_sprite_coordinates:
    ASL A                                                                       ; $01ACCC |\
    JSR _menu_transfer_a_to_x                                                   ; $01ACCD | | Set the Y register to the desired coordinates for the passed
    REP #FLAG_P_ACCUMULATOR                                                     ; $01ACD0 | | character slot.
    LDA menu_form_character_sprite_coordinates_data.l,X                         ; $01ACD2 | |
    TAY                                                                         ; $01ACD6 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01ACD7 |/
    RTS                                                                         ; $01ACD9

; menu_form_character_sprite_coordinates_data ($01:ACDA)
;
; For each character slot, determines the coordinates to draw the character
; sprite at in the form menu, when moving characters.
menu_form_character_sprite_coordinates_data:
    .db 28, 96                                                                  ; $01ACDA.ACDB
    .db 28, 16                                                                  ; $01ACDC.ACDD
    .db 28, 176                                                                 ; $01ACDE.ACDF
    .db 28, 56                                                                  ; $01ACE0.ACE1
    .db 28, 136                                                                 ; $01ACE2.ACE3

; _menu_form_draw_character_sprites ($01:ACE4)
;
; In the form menu, draws the character sprites for the two selected characters.
_menu_form_draw_character_sprites:
    JSR _menu_erase_cursor_2                                                    ; $01ACE4 | Erase the second cursor.
    JSR _menu_backup_cgram_1                                                    ; $01ACE7 | Backup the palette data to the first backup area.
    LDA #%00110000.b                                                            ; $01ACEA |\ Set the character sprite base tile flags
    STA <r_menu_character_sprite_base_tile_flags                                ; $01ACEC |/
    LDA <r_menu_form_selected_character_slot_1                                  ; $01ACEE |\
    STA <r_menu_update_character_sprite_arg_properties.slot                     ; $01ACF0 | | Draw the first character sprite.
    JSR _menu_form_get_character_sprite_coordinates                             ; $01ACF2 | |
    STY <r_menu_update_character_sprite_arg_properties.coordinates              ; $01ACF5 | |
    STY <r_menu_form_character_sprite_1_coordinates                             ; $01ACF7 | |
    STZ <r_menu_update_character_sprite_arg_properties.pose                     ; $01ACF9 | |
    JSR _menu_update_character_sprite                                           ; $01ACFB |/
    LDA <r_menu_form_selected_character_slot_2                                  ; $01ACFE |\
    STA <r_menu_update_character_sprite_arg_properties.slot                     ; $01AD00 | | Draw the second character sprite.
    JSR _menu_form_get_character_sprite_coordinates                             ; $01AD02 | |
    STY <r_menu_update_character_sprite_arg_properties.coordinates              ; $01AD05 | |
    STY <r_menu_form_character_sprite_2_coordinates                             ; $01AD07 | |
    STZ <r_menu_update_character_sprite_arg_properties.pose                     ; $01AD09 | |
    JSR _menu_update_character_sprite                                           ; $01AD0B |/
    LDA <r_menu_form_selected_character_slot_1                                  ; $01AD0E |\
    JSR _menu_load_character_sprite_palette                                     ; $01AD10 | | Load the palettes for the two character sprites.
    LDA <r_menu_form_selected_character_slot_2                                  ; $01AD13 | |
    JSR _menu_load_character_sprite_palette                                     ; $01AD15 |/
    JSR _menu_wait_for_vblank_copy_oam_to_ppu                                   ; $01AD18 |\ Wait for vblank and copy the OAM to the PPU and palette data to
    JMP _menu_copy_palette_to_cgram                                             ; $01AD1B |/ CG-RAM.

; _menu_form_set_character_sprite_deltas ($01:AD1E)
;
; Part of the form menu, calculates and sets the deltas and number of frames for
; the character sprite animation.
_menu_form_set_character_sprite_deltas:
    LDA <r_menu_form_selected_character_slot_1                                  ; $01AD1E |\
    ASL A                                                                       ; $01AD20 | | Set the X register to the first character slot times two.
    STA <r_menu_generic_tmp_offset.lo                                           ; $01AD21 | |
    LDX <r_menu_generic_tmp_offset                                              ; $01AD23 |/
    LDA <r_menu_form_selected_character_slot_2                                  ; $01AD25 |\
    ASL A                                                                       ; $01AD27 | | Set the Y register to the second character slot times two.
    STA <r_menu_generic_tmp_offset.lo                                           ; $01AD28 | |
    LDY <r_menu_generic_tmp_offset                                              ; $01AD2A |/
    PHB                                                                         ; $01AD2C |\
    PHK                                                                         ; $01AD2D | | Preserve the data bank register and set it to the value of the
    PLB                                                                         ; $01AD2E |/  program bank register.
    REP #FLAG_P_ACCUMULATOR                                                     ; $01AD2F |\
    LDA menu_form_character_sprite_coordinates_data.w,X                         ; $01AD31 | | If the first character slot is below the second character slot,
    SEC                                                                         ; $01AD34 | | branch to the code to handle that situation.
    SBC menu_form_character_sprite_coordinates_data.w,Y                         ; $01AD35 | |
    BCS +                                                                       ; $01AD38 |/
    LDA menu_form_character_sprite_coordinates_data.w,Y                         ; $01AD3A |\
    SEC                                                                         ; $01AD3D | | Reverse the subtraction to get the absolute difference.
    SBC menu_form_character_sprite_coordinates_data.w,X                         ; $01AD3E |/
    PLB                                                                         ; $01AD41 | Restore the original data bank register.
    XBA                                                                         ; $01AD42 | Move the Y coordinate difference to the low byte of the accumulator.
    LSR A                                                                       ; $01AD43 |\
    LSR A                                                                       ; $01AD44 | | Set the number of frames to the difference divided by four.
    STA r_menu_form_character_sprite_transition_frames.w                        ; $01AD45 |/
    LDA #-4 << 8.w                                                              ; $01AD48 |\ Configure the second character sprite to move up by four pixels
    STA r_menu_form_character_sprite_2_delta.w                                  ; $01AD4B |/ per frame.
    LDA #4 << 8.w                                                               ; $01AD4E |\ Configure the first character sprite to move down by four pixels
    STA r_menu_form_character_sprite_1_delta.w                                  ; $01AD51 |/ per frame.
    BRA ++                                                                      ; $01AD54 | Branch forward to the end.
+   PLB                                                                         ; $01AD56 |\
    XBA                                                                         ; $01AD57 | | Set up the parameters similar to above, except reversed to swap
    LSR A                                                                       ; $01AD58 | | the direction the respective sprites move.
    LSR A                                                                       ; $01AD59 | |
    STA r_menu_form_character_sprite_transition_frames.w                        ; $01AD5A | |
    LDA #-4 << 8.w                                                              ; $01AD5D | |
    STA r_menu_form_character_sprite_1_delta.w                                  ; $01AD60 | |
    LDA #4 << 8.w                                                               ; $01AD63 | |
    STA r_menu_form_character_sprite_2_delta.w                                  ; $01AD66 |/
++  SEP #FLAG_P_ACCUMULATOR                                                     ; $01AD69 | Switch back to 8-bit accumulator mode.
    RTS                                                                         ; $01AD6B

; _menu_form_animate_character_sprite_swap ($01:AD6C)
;
; Animates the swap of the two character sprites in the form menu.
_menu_form_animate_character_sprite_swap:
    JSR _menu_form_draw_character_sprites                                       ; $01AD6C | Draw the character sprites at their initial locations.
    LDX #8.w                                                                    ; $01AD6F |\
-   DEC <r_menu_form_character_sprite_1_coordinates.x                           ; $01AD72 | | Animate the character sprites moving horizontally by 24 pixels,
    DEC <r_menu_form_character_sprite_1_coordinates.x                           ; $01AD74 | | moving 3 pixels per frame. The first sprite moves left and the
    DEC <r_menu_form_character_sprite_1_coordinates.x                           ; $01AD76 | | second sprite moves right.
    INC <r_menu_form_character_sprite_2_coordinates.x                           ; $01AD78 | |
    INC <r_menu_form_character_sprite_2_coordinates.x                           ; $01AD7A | |
    INC <r_menu_form_character_sprite_2_coordinates.x                           ; $01AD7C | |
    JSR _menu_form_update_character_sprites                                     ; $01AD7E | |
    JSR _menu_wait_for_vblank_copy_oam_to_ppu                                   ; $01AD81 | |
    DEX                                                                         ; $01AD84 | |
    BNE -                                                                       ; $01AD85 |/
    JSR _menu_form_set_character_sprite_deltas                                  ; $01AD87 | Configure the sprite animation (frames and deltas).
-   REP #FLAG_P_ACCUMULATOR                                                     ; $01AD8A |\
    LDA <r_menu_form_character_sprite_1_coordinates                             ; $01AD8C | | Update the character sprite coordinates for this frame.
    CLC                                                                         ; $01AD8E | |
    ADC r_menu_form_character_sprite_1_delta.w                                  ; $01AD8F | |
    STA <r_menu_form_character_sprite_1_coordinates                             ; $01AD92 | |
    LDA <r_menu_form_character_sprite_2_coordinates                             ; $01AD94 | |
    CLC                                                                         ; $01AD96 | |
    ADC r_menu_form_character_sprite_2_delta.w                                  ; $01AD97 | |
    STA <r_menu_form_character_sprite_2_coordinates                             ; $01AD9A | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01AD9C |/
    JSR _menu_form_update_character_sprites                                     ; $01AD9E | Update the character sprites to reflect the updated coordinates.
    JSR _menu_wait_for_vblank_copy_oam_to_ppu                                   ; $01ADA1 | Wait for vblank and copy the OAM to the PPU.
    DEC r_menu_form_character_sprite_transition_frames.w                        ; $01ADA4 |\ Loop until the number of required frames is done.
    BNE -                                                                       ; $01ADA7 |/
    JSR _menu_form_animate_character_sprite_finish                              ; $01ADA9 | Animate the sprites moving to the final location.
    LDA <r_menu_form_selected_character_slot_1                                  ; $01ADAC |\
    STA <r_menu_update_character_sprite_arg_properties.slot                     ; $01ADAE | | Erase the two character sprites.
    JSR _menu_update_character_sprite_erase                                     ; $01ADB0 | |
    LDA <r_menu_form_selected_character_slot_2                                  ; $01ADB3 | |
    STA <r_menu_update_character_sprite_arg_properties.slot                     ; $01ADB5 | |
    JSR _menu_update_character_sprite_erase                                     ; $01ADB7 |/
    JSR _menu_wait_for_vblank_copy_oam_to_ppu                                   ; $01ADBA | Wait for vblank and copy the OAM to the PPU.
    JMP _menu_restore_cgram_1                                                   ; $01ADBD | Restore the backed up palette data and return.

; _menu_form_animate_character_sprite_finish ($01:ADC0)
;
; Animates the final portion of the character sprite transition, wherein the
; two character sprites move horizontally to their final position.
_menu_form_animate_character_sprite_finish:
    LDX #24.w                                                                   ; $01ADC0 |\
-   DEC <r_menu_form_character_sprite_2_coordinates.x                           ; $01ADC3 | | Animate the two character sprites moving back to their base
    INC <r_menu_form_character_sprite_1_coordinates.x                           ; $01ADC5 | | location at a rate of 1 pixel per frame.
    JSR _menu_form_update_character_sprites                                     ; $01ADC7 | |
    JSR _menu_wait_for_vblank_copy_oam_to_ppu                                   ; $01ADCA | |
    DEX                                                                         ; $01ADCD | |
    BNE -                                                                       ; $01ADCE |/
    RTS                                                                         ; $01ADD0

; _menu_load_character_sprite_palette ($01:ADD1)
;
; Given a character slot in the accumulator, copies that slot's palette from the
; base palette area in RAM to the CG-RAM mirror, starting at palette 11,
; increased by the slot number.
_menu_load_character_sprite_palette:
    ASL A                                                                       ; $01ADD1 |\
    ASL A                                                                       ; $01ADD2 | | Determine the target palette offset by multiplying the slot by 32.
    ASL A                                                                       ; $01ADD3 | |
    ASL A                                                                       ; $01ADD4 | |
    ASL A                                                                       ; $01ADD5 | |
    STA <r_menu_generic_tmp_offset.lo                                           ; $01ADD6 | |
    LDY <r_menu_generic_tmp_offset                                              ; $01ADD8 |/
    LDX #_sizeof_palette.w                                                      ; $01ADDA |\
-   LDA r_menu_character_sprite_palettes.w,Y                                    ; $01ADDD | | Copy the character sprite to the appropriate location in the
    STA r_menu_cgram_data.12.w,Y                                                ; $01ADE0 | | palette data.
    INY                                                                         ; $01ADE3 | |
    DEX                                                                         ; $01ADE4 | |
    BNE -                                                                       ; $01ADE5 |/
    RTS                                                                         ; $01ADE7

; _menu_form_update_character_sprites ($01:ADE8)
;
; In the form menu, updates the character sprites to reflect their current
; coordinates.
_menu_form_update_character_sprites:
    LDA <r_menu_form_selected_character_slot_1                                  ; $01ADE8 |\
    STA <r_menu_update_character_sprite_arg_properties.slot                     ; $01ADEA | | Update the first character sprite.
    LDY <r_menu_form_character_sprite_1_coordinates                             ; $01ADEC | |
    STY <r_menu_update_character_sprite_arg_properties.coordinates              ; $01ADEE | |
    STZ <r_menu_update_character_sprite_arg_properties.pose                     ; $01ADF0 | |
    JSR _menu_update_character_sprite                                           ; $01ADF2 |/
    LDA <r_menu_form_selected_character_slot_2                                  ; $01ADF5 |\
    STA <r_menu_update_character_sprite_arg_properties.slot                     ; $01ADF7 | | Update the second character sprite.
    LDY <r_menu_form_character_sprite_2_coordinates                             ; $01ADF9 | |
    STY <r_menu_update_character_sprite_arg_properties.coordinates              ; $01ADFB | |
    STZ <r_menu_update_character_sprite_arg_properties.pose                     ; $01ADFD | |
    JMP _menu_update_character_sprite                                           ; $01ADFF |/

; _menu_sort_inventory ($01:AE02)
;
; Given the address to either the main inventory or the Big Chocobo inventory in
; the X register, sorts that inventory. The algorithm is fairly simple, and
; proceeds in two phases:
;
; 1) During the first phase, the inventory is scanned from start to finish, and
;    for each item, any items of the same type later in the inventory are added
;    so long as the total doesn't exceeed 99. If it does, whichever pair would
;    exceed the total is left alone.
;
; 2) Again, the inventory is scanned, and for each blank space, the first non-
;    empty item (except for Sort and TrashCan) is moved to that location. This
;    phase runs twice, though it's not clear if that's actually necessary.
_menu_sort_inventory:
    STX <r_sort_inventory_tmp_start_ptr                                         ; $01AE02 |\ Set both the start and current pointers to the value passed in the
    STX <r_sort_inventory_tmp_current_ptr                                       ; $01AE04 |/ X register.
    REP #FLAG_P_ACCUMULATOR                                                     ; $01AE06 |\
    TXA                                                                         ; $01AE08 | | Set the end pointer to point to the start pointer plus an offset.
    CMP #r_big_chocobo_inventory.w                                              ; $01AE09 | | If the passed pointer is specifically the Big Chocobo inventory,
    BNE +                                                                       ; $01AE0C | | the size of the Big Chocobo inventory is added. Otherwise, the
    CLC                                                                         ; $01AE0E | | size of the inventory is added. (Technically, the size minus two
    ADC #_sizeof_r_big_chocobo_inventory.w - 2                                  ; $01AE0F | | is added in either case, so that it points to the last entry and
    BRA ++                                                                      ; $01AE12 | | not beyond the data.)
+   CLC                                                                         ; $01AE14 | |
    ADC #_sizeof_r_inventory.w - 2                                              ; $01AE15 | |
++  STA <r_sort_inventory_tmp_end_ptr                                           ; $01AE18 |/
    INC A                                                                       ; $01AE1A |\
    INC A                                                                       ; $01AE1B | | Set the max pointer to the first address beyond the inventory.
    STA <r_sort_inventory_tmp_max_ptr                                           ; $01AE1C | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01AE1E |/
    INX                                                                         ; $01AE20 | Pointlessly increment the X register, as it will be overwritten.
--  LDY #2.w                                                                    ; $01AE21 | Initialize the Y reigster to 2 to point to the next entry.
    LDX <r_sort_inventory_tmp_current_ptr                                       ; $01AE24 |\
    INX                                                                         ; $01AE26 | | Set the count pointer for the current entry.
    STX <r_sort_inventory_tmp_current_count_ptr                                 ; $01AE27 |/
-   LDA (<r_sort_inventory_tmp_current_ptr)                                     ; $01AE29 |\ Skip if the current empty.
    BEQ +                                                                       ; $01AE2B |/
    CMP (<r_sort_inventory_tmp_current_ptr),Y                                   ; $01AE2D |\ Skip if the other entry is not the same item.
    BNE +                                                                       ; $01AE2F |/
    INY                                                                         ; $01AE31 |\
    LDA (<r_sort_inventory_tmp_current_ptr),Y                                   ; $01AE32 | | Add the count of the current entry and the count of the other
    CLC                                                                         ; $01AE34 | | entry.
    ADC (<r_sort_inventory_tmp_current_count_ptr)                               ; $01AE35 |/
    CMP #100.b                                                                  ; $01AE37 |\
    BCS ++                                                                      ; $01AE39 | | If the result is less than 100, update the current count to the
    STA (<r_sort_inventory_tmp_current_count_ptr)                               ; $01AE3B | | summed value. Zero out the count of the other entry and remove the
    LDA #0.b                                                                    ; $01AE3D | | item.
    STA (<r_sort_inventory_tmp_current_ptr),Y                                   ; $01AE3F | |
    DEY                                                                         ; $01AE41 | |
    STA (<r_sort_inventory_tmp_current_ptr),Y                                   ; $01AE42 |/
+   INY                                                                         ; $01AE44 |\ Regardless of path, increment the Y register to now point to the
++  INY                                                                         ; $01AE45 |/ next entry.
    REP #FLAG_P_ACCUMULATOR                                                     ; $01AE46 |\
    TYA                                                                         ; $01AE48 | | Repeat until the other entry reaches the end of the inventory.
    CLC                                                                         ; $01AE49 | |
    ADC <r_sort_inventory_tmp_current_ptr                                       ; $01AE4A | |
    CMP <r_sort_inventory_tmp_max_ptr                                           ; $01AE4C | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01AE4E | |
    BNE -                                                                       ; $01AE50 |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $01AE52 |\
    INC <r_sort_inventory_tmp_current_ptr                                       ; $01AE54 | | Increment the current entry pointer to the next entry.
    INC <r_sort_inventory_tmp_current_ptr                                       ; $01AE56 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01AE58 |/
    LDX <r_sort_inventory_tmp_current_ptr                                       ; $01AE5A |\
    CPX <r_sort_inventory_tmp_end_ptr                                           ; $01AE5C | | Loop until the everything but the last entry has been processed.
    BNE --                                                                      ; $01AE5E |/
    LDX <r_sort_inventory_tmp_start_ptr                                         ; $01AE60 |\
    PHX                                                                         ; $01AE62 | | Recursively call the following section once before falling through
    JSR @consolidate_start                                                      ; $01AE63 | | to it again.
    PLX                                                                         ; $01AE66 | | NOTE: This may not actually be necessary.
    STX <r_sort_inventory_tmp_start_ptr                                         ; $01AE67 |/
@consolidate_start:
    LDX <r_sort_inventory_tmp_start_ptr                                         ; $01AE69 |\
    INX                                                                         ; $01AE6B | | Set the current count pointer for the current entry.
    STX <r_sort_inventory_tmp_current_count_ptr                                 ; $01AE6C |/
    LDA (<r_sort_inventory_tmp_start_ptr)                                       ; $01AE6E |\ Skip the current entry if an item is already here.
    BNE ++                                                                      ; $01AE70 |/
    LDY <r_sort_inventory_tmp_start_ptr                                         ; $01AE72 |\
    INY                                                                         ; $01AE74 | | Set the Y register to the next entry.
    INY                                                                         ; $01AE75 |/
-   LDA inventory_entry.id.w,Y                                                  ; $01AE76 |\
    BEQ +                                                                       ; $01AE79 | | If the other entry is not empty and if it's not the Sort or
    CMP #ITEM_SORT.b                                                            ; $01AE7B | | TrashCan items, transfer the item and count to the current
    BCS +                                                                       ; $01AE7D | | location. Afterward, zero out the item and count at the old
    STA (<r_sort_inventory_tmp_start_ptr)                                       ; $01AE7F | | location.
    LDA inventory_entry.count.w,Y                                               ; $01AE81 | |
    STA (<r_sort_inventory_tmp_current_count_ptr)                               ; $01AE84 | |
    LDA #0.b                                                                    ; $01AE86 | |
    STA inventory_entry.id.w,Y                                                  ; $01AE88 | |
    STA inventory_entry.count.w,Y                                               ; $01AE8B | |
    BRA ++                                                                      ; $01AE8E |/
+   INY                                                                         ; $01AE90 |\
    INY                                                                         ; $01AE91 | | Increment the Y register and loop until all other locations have
    CPY <r_sort_inventory_tmp_max_ptr                                           ; $01AE92 | | been checked.
    BNE -                                                                       ; $01AE94 |/
++  LDX <r_sort_inventory_tmp_start_ptr                                         ; $01AE96 |\
    INX                                                                         ; $01AE98 | | Increment the start location by two to the move to the next entry.
    INX                                                                         ; $01AE99 | |
    STX <r_sort_inventory_tmp_start_ptr                                         ; $01AE9A |/
    CPX <r_sort_inventory_tmp_end_ptr                                           ; $01AE9C |\ Loop until all but the last entry have been checked.
    BNE @consolidate_start                                                      ; $01AE9E |/
    RTS                                                                         ; $01AEA0

; menu_window_magic_character_details_offset_data ($01:AEA1)
;
; For each character position, provides the offset to the window for that
; position for displaying the character details in the magic menu.
menu_window_magic_character_details_offset_data:
    .addr menu_window_magic_character_details_position_0_data                   ; $01AEA1.AEA2
    .addr menu_window_magic_character_details_position_1_data                   ; $01AEA3.AEA4
    .addr menu_window_magic_character_details_position_2_data                   ; $01AEA5.AEA6
    .addr menu_window_magic_character_details_position_3_data                   ; $01AEA7.AEA8
    .addr menu_window_magic_character_details_position_4_data                   ; $01AEA9.AEAA

; _menu_magic_cannot_use ($01:AEAB)
;
; Displays the "Cannot Use" window displayed when attempting to access the magic
; menu for a character who cannot use magic, waits for input and returns.
_menu_magic_cannot_use:
    JSR _menu_set_current_tilemap_bg2                                           ; $01AEAB |\
    LDY #menu_window_magic_cannot_use_data.w                                    ; $01AEAE | | Draw the "Cannot Use" window to BG2 and copy it to VRAM.
    JSR _menu_draw_text_indirect_plus_window                                    ; $01AEB1 | |
    JSR _menu_copy_tilemap_to_vram_bg2                                          ; $01AEB4 |/
    JSR _menu_wait_for_input                                                    ; $01AEB7 | Wait for input.
    JMP _menu_initialize_tilemap_bg2_and_copy_to_vram                           ; $01AEBA | Clear BG2 and return.

; _menu_command_magic ($01:AEBD)
;
; Handler for the magic menu in the menu.
_menu_command_magic:
    STZ r_menu_character_selection_change_enabled.w                             ; $01AEBD |\
    JSR _menu_select_character                                                  ; $01AEC0 | | Allow the player to choose a character, and if no character is
    LDA <r_menu_current_selected_character_slot                                 ; $01AEC3 | | selected, simply return.
    BPL +                                                                       ; $01AEC5 | |
    RTS                                                                         ; $01AEC7 |/
+   LDA <r_menu_current_selected_character_slot                                 ; $01AEC8 |\
    JSR _menu_get_character_id                                                  ; $01AECA | | If the selected slot is empty, return.
    BNE +                                                                       ; $01AECD | |
    RTS                                                                         ; $01AECF |/
+   PHX                                                                         ; $01AED0 |\
    JSL bank1E.menu_magic_load_cursor_coordinates                               ; $01AED1 | | Load the saved cursor coordinates for the selected character.
    PLX                                                                         ; $01AED5 |/
    LDA character_field.status_1.w,X                                            ; $01AED6 |\ Set the character's first status byte in the menu variable for
    STA r_menu_magic_character_status_1.w                                       ; $01AED9 |/ magic name formatting.
    AND #(STATUS_1_SWOON | STATUS_1_STONE | STATUS_1_MUTE).b                    ; $01AEDC |\ If the character has any of the swoon, stone or mute statuses,
    BNE _menu_magic_cannot_use                                                  ; $01AEDE |/ display the "Cannot Use" window and return.
    LDA character_field.sprite_class.w,X                                        ; $01AEE0 |\
    AND #%00001111.b                                                            ; $01AEE3 | | Set the X register to the character's class times three.
    STA <r_menu_generic_tmp_count                                               ; $01AEE5 | |
    ASL A                                                                       ; $01AEE7 | |
    ADC <r_menu_generic_tmp_count                                               ; $01AEE8 | |
    JSR _menu_transfer_a_to_x                                                   ; $01AEEA |/
    LDA bank14.class_spell_list_data.l + 0,X                                    ; $01AEED |\
    AND bank14.class_spell_list_data.l + 1,X                                    ; $01AEF1 | | If the character has no spell lists, display the "Cannot Use"
    AND bank14.class_spell_list_data.l + 2,X                                    ; $01AEF5 | | window and return.
    CMP #$FF.b                                                                  ; $01AEF9 | |
    BEQ _menu_magic_cannot_use                                                  ; $01AEFB |/
    PHX                                                                         ; $01AEFD | Preserve the character offset currently in the X register.
    JSR _menu_initialize_oam                                                    ; $01AEFE |\
    LDA <r_menu_current_selected_character_slot                                 ; $01AF01 | | Erase all existing sprites, draw the selected character's
    JSR _menu_party_draw_character_portrait                                     ; $01AF03 | | portrait, and transfer the updated OAM to the PPU.
    JSR _menu_wait_for_vblank_copy_oam_to_ppu                                   ; $01AF06 |/
    JSR _menu_initialize_tilemap_bg3                                            ; $01AF09 |\
    JSR _menu_draw_party_details_window                                         ; $01AF0C | | Draw the party details window to BG3.
    JSR _menu_copy_tilemap_to_vram_bg3                                          ; $01AF0F |/
    LDA #%00100000.b                                                            ; $01AF12 |\ Set the cursor sprite flags for priority 2.
    STA <r_menu_cursor_sprite_flags                                             ; $01AF14 |/
    JSR _menu_set_current_tilemap_bg4                                           ; $01AF16 |\
    LDY #menu_window_main_command_data.w                                        ; $01AF19 | | Draw the command window to BG4.
    JSR _menu_configure_and_draw_window                                         ; $01AF1C |/
    LDY #menu_text_magic_title_data.w                                           ; $01AF1F | NOTE: This line is immediately rendered useless by the next.
    LDY #menu_window_main_command_data.w                                        ; $01AF22 |\
    LDX #menu_window_magic_spell_list_selection_data.w                          ; $01AF25 | | Animate a transition from the command menu to the spell list menu.
    JSR _menu_window_transition                                                 ; $01AF28 |/
    LDX #_menu_portrait_transition_update                                       ; $01AF2B |\ Set the first custom window transition function to update the
    STX <r_menu_window_transition_custom_function_1.address                     ; $01AF2E |/ character portrait.
    LDX #_menu_copy_oam_to_ppu.w                                                ; $01AF30 |\ Set the second custom window transition function to copy the OAM
    STX <r_menu_window_transition_custom_function_2.address                     ; $01AF33 |/ to the PPU.
    LDA <r_menu_current_selected_character_slot                                 ; $01AF35 |\
    JSR _menu_party_get_portrait_coordinates                                    ; $01AF37 | | Set the initial portrait coordinates to the correct location for
    REP #FLAG_P_ACCUMULATOR                                                     ; $01AF3A | | the selected character.
    TYA                                                                         ; $01AF3C | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01AF3D | |
    STA <r_menu_portrait_transition_coordinates.x.value                         ; $01AF3F | |
    XBA                                                                         ; $01AF41 | |
    STA <r_menu_portrait_transition_coordinates.y.value                         ; $01AF42 | |
    STZ <r_menu_portrait_transition_coordinates.x.fraction                      ; $01AF44 | |
    STZ <r_menu_portrait_transition_coordinates.y.fraction                      ; $01AF46 |/
    LDA #40.b                                                                   ; $01AF48 |\
    STA <r_menu_transition_scroll_frames                                        ; $01AF4A | | Set the window transition to take 40 frames.
    STA <r_menu_portrait_transition_frames_remaining                            ; $01AF4C |/
    LDA #200.b                                                                  ; $01AF4E |\
    STA <r_menu_scroll_delta_bg3.horizontal.fraction                            ; $01AF50 | | Set BG3 and the portrait to move rightward by 1.78125 pixels per
    STA <r_menu_portrait_transition_delta.x.fraction                            ; $01AF52 | | frame.
    LDA #1.b | %10000000                                                        ; $01AF54 | |
    STA <r_menu_scroll_delta_bg3.horizontal.value.lo                            ; $01AF56 | |
    STA <r_menu_portrait_transition_delta.x.value                               ; $01AF58 |/
    LDA <r_menu_current_selected_character_position                             ; $01AF5A |\
    STA <r_menu_scroll_delta_bg3.vertical.value.lo                              ; $01AF5C | | Set BG3 and the portrait to move upward at 1 pixel per frame for
    STA <r_menu_portrait_transition_delta.y.value                               ; $01AF5E |/  each position. (e.g. 0, 1, 2, 3 or 4 pixels per frame)
    LDA #104.b                                                                  ; $01AF60 |\ Set BG4 to move upward at 0.40625 pixels per frame.
    STA <r_menu_scroll_delta_bg4.vertical.fraction                              ; $01AF62 |/
    LDA #4.b                                                                    ; $01AF64 |\
    STA <r_menu_scroll_delta_bg4.horizontal.value.lo                            ; $01AF66 | | Set BG4 to move leftward at 4.203125 pixels per frame.
    LDA #52.b                                                                   ; $01AF68 | |
    STA <r_menu_scroll_delta_bg4.horizontal.fraction                            ; $01AF6A |/
    LDA <r_menu_current_selected_character_slot                                 ; $01AF6C |\ Set the portrait transition character slot.
    STA <r_menu_portrait_transition_character_slot                              ; $01AF6E |/
    PLX                                                                         ; $01AF70 | Restore the character offset to the X register.
    LDA bank14.class_spell_list_data.l + 0,X                                    ; $01AF71 |\
    STA r_menu_magic_spell_list_ids.1.w                                         ; $01AF75 | | If the character has a first spell list, draw the "White" spell
    BMI +                                                                       ; $01AF78 | | list selection. Otherwise, draw a blank entry.
    LDY #menu_text_spell_list_white_data.w                                      ; $01AF7A | |
    BRA ++                                                                      ; $01AF7D | |
+   LDY #menu_text_spell_list_white_blank_data.w                                ; $01AF7F | |
++  JSR _menu_draw_text_indirect                                                ; $01AF82 |/
    LDA bank14.class_spell_list_data.l + 1,X                                    ; $01AF85 |\
    STA r_menu_magic_spell_list_ids.2.w                                         ; $01AF89 | | If the character has a second spell list, draw the "Black" spell
    BMI +                                                                       ; $01AF8C | | list selection. Otherwise, draw a blank entry.
    LDY #menu_text_spell_list_black_data.w                                      ; $01AF8E | |
    BRA ++                                                                      ; $01AF91 | |
+   LDY #menu_text_spell_list_black_blank_data.w                                ; $01AF93 | |
++  JSR _menu_draw_text_indirect                                                ; $01AF96 |/
    LDA bank14.class_spell_list_data.l + 2,X                                    ; $01AF99 |\
    STA r_menu_magic_spell_list_ids.3.w                                         ; $01AF9D | | If the character has a third spell list, draw the "Call" spell
    BMI +                                                                       ; $01AFA0 | | list selection. Otherwise, draw a blank entry.
    LDY #menu_text_spell_list_call_data.w                                       ; $01AFA2 | |
    BRA ++                                                                      ; $01AFA5 | |
+   LDY #menu_text_spell_list_call_blank_data.w                                 ; $01AFA7 | |
++  JSR _menu_draw_text_indirect                                                ; $01AFAA |/
    LDA <r_menu_current_selected_character_slot                                 ; $01AFAD |\
    JSR _menu_get_character_id                                                  ; $01AFAF | | If the character is Edge, draw the "Ninja" selection to replace
    CMP #CHARACTER_EDGE.b                                                       ; $01AFB2 | | the "Black" selection.
    BNE +                                                                       ; $01AFB4 | |
    LDY #menu_text_spell_list_ninja_data.w                                      ; $01AFB6 | |
    JSR _menu_draw_text_indirect                                                ; $01AFB9 |/
+   JSR _menu_set_current_tilemap_bg1                                           ; $01AFBC |\
    LDY #menu_window_magic_list_data.w                                          ; $01AFBF | | Draw the magic list window to BG1.
    JSR _menu_configure_and_draw_window                                         ; $01AFC2 |/
-   LDA r_menu_magic_cursor_coordinates.spell_list.y.w                          ; $01AFC5 |\
    JSR _menu_transfer_a_to_x                                                   ; $01AFC8 | | Load the currently selected spell list index, and if the current
    LDA r_menu_magic_spell_list_ids.w,X                                         ; $01AFCB | | character does not have a spell list in that spot, increment the
    BPL ++                                                                      ; $01AFCE | | index until finding one they do have, wrapping around to zero if
    LDA r_menu_magic_cursor_coordinates.spell_list.y.w                          ; $01AFD0 | | the value reaches three.
    INC A                                                                       ; $01AFD3 | |
    CMP #3.b                                                                    ; $01AFD4 | |
    BNE +                                                                       ; $01AFD6 | |
    LDA #0.b                                                                    ; $01AFD8 | |
+   STA r_menu_magic_cursor_coordinates.spell_list.y.w                          ; $01AFDA | |
    BRA -                                                                       ; $01AFDD |/
++  INC r_menu_magic_spell_selection_active.w                                   ; $01AFDF |\
    JSR _menu_magic_draw_spells                                                 ; $01AFE2 | | Draw the selected spell list to BG1.
    STZ r_menu_magic_spell_selection_active.w                                   ; $01AFE5 |/
    LDX #-232.w                                                                 ; $01AFE8 |\
    STX <r_menu_scroll_bg1.vertical.value                                       ; $01AFEB | | Set the BG1 vertical scroll to -232.
    JSR _menu_set_bg_scroll_proxy                                               ; $01AFED |/
    LDA #5.b                                                                    ; $01AFF0 |\
    STA <r_menu_scroll_delta_bg1.vertical.value.lo                              ; $01AFF2 | | Set the BG1 scroll delta to 5 and the fractional component to
    LDA #154.b                                                                  ; $01AFF4 | | 154/256.
    STA <r_menu_scroll_delta_bg1.vertical.fraction                              ; $01AFF6 |/
    JSR _menu_copy_tilemap_to_vram_bg1                                          ; $01AFF8 | Copy the BG1 tilemap to VRAM.
    JSR _menu_set_current_tilemap_bg3                                           ; $01AFFB | Change the active tilemap to BG3.
    JSR _menu_party_draw_selected_character_stats                               ; $01AFFE | Draw the selected character's stats to the party window.
    LDA <r_menu_current_selected_character_position                             ; $01B001 |\
    ASL A                                                                       ; $01B003 | | Set the X register to the offset for the character details window
    JSR _menu_transfer_a_to_x                                                   ; $01B004 | | for the currently selected character position.
    REP #FLAG_P_ACCUMULATOR                                                     ; $01B007 | |
    LDA menu_window_magic_character_details_offset_data.l,X                     ; $01B009 | |
    TAX                                                                         ; $01B00D | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01B00E |/
    LDY #menu_window_party_details_data.w                                       ; $01B010 | Set the source window to the party details window.
    JSR _menu_window_transition                                                 ; $01B013 | Animate the window transition.
    JSR _menu_magic_core                                                        ; $01B016 | Execute the magic menu input handler.
    LDA #%00110000.b                                                            ; $01B019 |\ Set the cursor sprite flags for priority 3.
    STA <r_menu_cursor_sprite_flags                                             ; $01B01B |/
    JSR _menu_initialize_oam                                                    ; $01B01D | Initialize the OAM.
    JSR _menu_set_current_tilemap_bg4                                           ; $01B020 | Set the current tilemap to BG4.
    LDY #(5 * 2) + (8 * 32 * 2).w                                               ; $01B023 |\
    LDA #13.b                                                                   ; $01B026 | | Erase 13 tiles at 5, 8 to erase the "Need MP" message.
    SEC                                                                         ; $01B028 | |
    JSR _menu_erase_tiles                                                       ; $01B029 |/
    JSR _menu_copy_tilemap_to_vram_bg4                                          ; $01B02C | Copy the BG4 tilemap to VRAM.
    JSR _menu_copy_oam_to_ppu                                                   ; $01B02F | Copy the OAM to the PPU.
    LDA #40.b                                                                   ; $01B032 |\ Set the transition to take 40 frames.
    STA <r_menu_transition_scroll_frames                                        ; $01B034 |/
    LDA #1.b                                                                    ; $01B036 |\ Toggle the BG3 transition horizontal direction.
    STA <r_menu_scroll_delta_bg3.horizontal.value.lo                            ; $01B038 |/
    LDA <r_menu_current_selected_character_position                             ; $01B03A |\
    ORA #%10000000.b                                                            ; $01B03C | | Toggle the BG3 transition vertical direction.
    STA <r_menu_scroll_delta_bg3.vertical.value.lo                              ; $01B03E | |
    STA <r_menu_portrait_transition_delta.y.value                               ; $01B040 |/
    LDA #104.b                                                                  ; $01B042 |\ Set BG4 to move downward at 0.40625 pixels per frame.
    STA <r_menu_scroll_delta_bg4.vertical.fraction                              ; $01B044 |/
    LDA #4.b | %10000000                                                        ; $01B046 |\
    STA <r_menu_scroll_delta_bg4.horizontal.value.lo                            ; $01B048 | | Set BG4 to move rightward at 4.203125 pixels per frame.
    LDA #52.b                                                                   ; $01B04A | |
    STA <r_menu_scroll_delta_bg4.horizontal.fraction                            ; $01B04C |/
    LDA #6.b                                                                    ; $01B04E |\ Set BG1 to move upward at 6 pixels per frame.
    STA <r_menu_scroll_delta_bg1.vertical.value.lo                              ; $01B050 |/
    JSR _menu_set_current_tilemap_bg3                                           ; $01B052 | Set the current tilemap to BG3.
    LDA <r_menu_current_selected_character_position                             ; $01B055 |\
    ASL A                                                                       ; $01B057 | | Configure the transition from the character details window to the
    JSR _menu_transfer_a_to_x                                                   ; $01B058 | | party window.
    REP #FLAG_P_ACCUMULATOR                                                     ; $01B05B | |
    LDA menu_window_magic_character_details_offset_data.l,X                     ; $01B05D | |
    TAY                                                                         ; $01B061 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01B062 | |
    LDX #menu_window_party_details_data.w                                       ; $01B064 |/
    JSR _menu_window_transition                                                 ; $01B067 | Execute the window transition.
    JSR _menu_initialize_tilemap_bg1                                            ; $01B06A | Clear BG1.
    JSR _menu_init_bg_scroll                                                    ; $01B06D | Initialize the background scroll values.
    JSR _menu_copy_tilemap_to_vram_bg1                                          ; $01B070 | Copy the BG1 tilemap to VRAM.
    JSR _menu_set_bg_scroll_proxy                                               ; $01B073 | Set the background scroll values.
    JSR _menu_set_current_tilemap_bg4                                           ; $01B076 | Set the current tilemap to BG4.
    LDY #menu_window_magic_spell_list_selection_data.w                          ; $01B079 |\
    LDX #menu_window_main_command_data.w                                        ; $01B07C | | Animate a window transition to the command window.
    JSR _menu_window_transition                                                 ; $01B07F |/
    JSR _menu_main_draw                                                         ; $01B082 | Draw the main menu.
    JSR _menu_copy_tilemap_to_vram_bg3                                          ; $01B085 | Copy the BG3 tilemap to VRAM.
    JSR _menu_set_current_tilemap_bg4                                           ; $01B088 | Set the current tilemap to BG4.
    JSR _menu_animate_current_tilemap_50_rows_to_vram                           ; $01B08B | Animate the commands appearing.
    JSL bank1E.menu_magic_save_cursor_coordinates                               ; $01B08E | Save the cursor coordinates for this character.
    RTS                                                                         ; $01B092

; _menu_magic_core ($01:B093)
;
; Core event loop for the magic menu.
_menu_magic_core:
    LDA r_menu_magic_spell_selection_active.w                                   ; $01B093 |\
    BNE +                                                                       ; $01B096 | | If spell selection is not active (selecting from a spell list),
    STZ r_menu_magic_spell_mp_cost.w                                            ; $01B098 | | draw the first cursor to 8, Y where Y is the spell list index
    LDA r_menu_magic_cursor_coordinates.spell_list.y.w                          ; $01B09B | | times 16 plus 16. Otherwise, draw the cursor to the location
    ASL A                                                                       ; $01B09E | | corresponding to the current spell coordinates.
    ASL A                                                                       ; $01B09F | |
    ASL A                                                                       ; $01B0A0 | |
    ASL A                                                                       ; $01B0A1 | |
    ADC #16.b                                                                   ; $01B0A2 | |
    STA <r_menu_draw_cursor_arg_coordinates.y                                   ; $01B0A4 | |
    LDA #8.b                                                                    ; $01B0A6 | |
    STA <r_menu_draw_cursor_arg_coordinates.x                                   ; $01B0A8 | |
    BRA ++                                                                      ; $01B0AA | |
+   JSR _menu_magic_get_current_cursor_sprite_coordinates                       ; $01B0AC | |
++  JSR _menu_draw_cursor_1                                                     ; $01B0AF |/
    JSR _menu_set_current_tilemap_bg4                                           ; $01B0B2 | Set the current tilemap to BG4.
    JSR _menu_magic_update_spell_list_tile_flags                                ; $01B0B5 | Update the spell list tile flags.
    JSR _menu_magic_get_selected_spell_mp_cost                                  ; $01B0B8 |\ Determine and save the cost of the currently selected spell.
    STA r_menu_magic_spell_mp_cost.w                                            ; $01B0BB |/
    LDY #(13 * 2) + (8 * 32 * 2).w                                              ; $01B0BE |\ Draw the needed MP for that spell to 13, 8.
    JSR _menu_draw_two_digit_number                                             ; $01B0C1 |/
    LDX #(5 * 2) + (8 * 32 * 2).w                                               ; $01B0C4 |\
    LDY #menu_text_need_mp_direct_data.w                                        ; $01B0C7 | | Draw the "Need MP" text to 5, 8.
    JSR _menu_expand_tiles_to_tilemap                                           ; $01B0CA |/
    LDA #TEXT_ELLIPSIS.b                                                        ; $01B0CD |\
.if FF4_REGION == "JAPAN"                                                       ;         | | Draw an ellipsis to 12, 8 (or 11, 8 in the Japanese version).
    STA r_menu_tilemap_bg4.w + (11 * 2) + (8 * 32 * 2).w                        ; $01B0F7 | |
.else                                                                           ;         | |
    STA r_menu_tilemap_bg4.w + (12 * 2) + (8 * 32 * 2).w                        ; $01B0CF | |
.endif                                                                          ;         |/
    JSR _menu_wait_for_vblank_copy_oam_to_ppu                                   ; $01B0D2 | Wait for vblank and copy the OAM to the PPU.
    JSR _menu_copy_tilemap_to_vram_bg4_no_vblank                                ; $01B0D5 | Copy the BG4 tilemap to VRAM.
    JSR _menu_update_joypad_and_play_sound_effect                               ; $01B0D8 | Update the joypad values.
    LDA r_menu_magic_spell_selection_active.w                                   ; $01B0DB |\ If spell selection is active, branch to the input handling code for
    BNE @spell_selection                                                        ; $01B0DE |/ that case.
    LDA <r_menu_joypad_repeat.hi                                                ; $01B0E0 |\
    AND #JOYPAD_H_UP.b                                                          ; $01B0E2 | | If up is pressed on the d-pad, decrement the current spell list
    BEQ ++                                                                      ; $01B0E4 | | index. If the value goes negative, set it to two. Repeat until the
    LDA r_menu_magic_cursor_coordinates.spell_list.y.w                          ; $01B0E6 | | spell list is one that the character has. Afterward, update the
    STA <r_menu_generic_tmp_offset.lo                                           ; $01B0E9 | | spell window.
-   LDA <r_menu_generic_tmp_offset.lo                                           ; $01B0EB | |
    DEC A                                                                       ; $01B0ED | |
    BPL +                                                                       ; $01B0EE | |
    LDA #2.b                                                                    ; $01B0F0 | |
+   JSR _menu_transfer_a_to_x                                                   ; $01B0F2 | |
    LDA r_menu_magic_spell_list_ids.w,X                                         ; $01B0F5 | |
    BMI -                                                                       ; $01B0F8 | |
    PHA                                                                         ; $01B0FA | |
    LDA <r_menu_generic_tmp_offset.lo                                           ; $01B0FB | |
    STA r_menu_magic_cursor_coordinates.spell_list.y.w                          ; $01B0FD | |
    PLA                                                                         ; $01B100 | |
    JSR _menu_update_spell_window                                               ; $01B101 |/
++  LDA <r_menu_joypad_repeat.hi                                                ; $01B104 |\
    AND #JOYPAD_H_DOWN.b                                                        ; $01B106 | | If down is pressed on the d-pad, increment the spell list index.
    BEQ ++                                                                      ; $01B108 | | If the new value is 3, reset it to zero. Repeat until the spell
    LDA r_menu_magic_cursor_coordinates.spell_list.y.w                          ; $01B10A | | list is one that the character has. Afterward, update the spell
    STA <r_menu_generic_tmp_offset.lo                                           ; $01B10D | | window.
-   LDA <r_menu_generic_tmp_offset.lo                                           ; $01B10F | |
    INC A                                                                       ; $01B111 | |
    CMP #3.b                                                                    ; $01B112 | |
    BNE +                                                                       ; $01B114 | |
    TDC                                                                         ; $01B116 | |
+   JSR _menu_transfer_a_to_x                                                   ; $01B117 | |
    LDA r_menu_magic_spell_list_ids.w,X                                         ; $01B11A | |
    BMI -                                                                       ; $01B11D | |
    PHA                                                                         ; $01B11F | |
    LDA <r_menu_generic_tmp_offset.lo                                           ; $01B120 | |
    STA r_menu_magic_cursor_coordinates.spell_list.y.w                          ; $01B122 | |
    PLA                                                                         ; $01B125 | |
    JSR _menu_update_spell_window                                               ; $01B126 |/
++  LDA <r_menu_joypad_repeat.lo                                                ; $01B129 |\
    AND #JOYPAD_L_A.b                                                           ; $01B12B | | If A is pressed, set the spell selection active flag.
    BEQ +                                                                       ; $01B12D | |
    INC r_menu_magic_spell_selection_active.w                                   ; $01B12F |/
+   LDA <r_menu_joypad_repeat.hi                                                ; $01B132 |\
    AND #JOYPAD_H_B.b                                                           ; $01B134 | | If B is pressed, return.
    BEQ +                                                                       ; $01B136 | |
    RTS                                                                         ; $01B138 |/
+   JMP _menu_magic_core                                                        ; $01B139 | Otherwise, jump back to repeat the function.
@spell_selection:
    LDA <r_menu_joypad_repeat.hi                                                ; $01B13C |\
    AND #JOYPAD_H_UP.b                                                          ; $01B13E | | If up is pressed on the d-pad, decrement the cursor Y coordinate,
    BEQ ++                                                                      ; $01B140 | | looping it back to 7 if it goes negative.
    LDA r_menu_magic_cursor_coordinates.spell_current.y.w                       ; $01B142 | |
    DEC A                                                                       ; $01B145 | |
    BPL +                                                                       ; $01B146 | |
    LDA #7.b                                                                    ; $01B148 | |
+   STA r_menu_magic_cursor_coordinates.spell_current.y.w                       ; $01B14A |/
++  LDA <r_menu_joypad_repeat.hi                                                ; $01B14D |\
    AND #JOYPAD_H_DOWN.b                                                        ; $01B14F | | If down is pressed on the d-pad, increment the cursor Y
    BEQ ++                                                                      ; $01B151 | | coordinate, wrapping it around to zero if it reaches eight.
    LDA r_menu_magic_cursor_coordinates.spell_current.y.w                       ; $01B153 | |
    INC A                                                                       ; $01B156 | |
    CMP #8.b                                                                    ; $01B157 | |
    BNE +                                                                       ; $01B159 | |
    TDC                                                                         ; $01B15B | |
+   STA r_menu_magic_cursor_coordinates.spell_current.y.w                       ; $01B15C |/
++  LDA <r_menu_joypad_repeat.hi                                                ; $01B15F |\
    AND #JOYPAD_H_LEFT.b                                                        ; $01B161 | | If left is pressed on the d-pad, decrement the cursor X coordinate
    BEQ ++                                                                      ; $01B163 | | and loop it back to 2 if it goes negative.
    LDA r_menu_magic_cursor_coordinates.spell_current.x.w                       ; $01B165 | |
    DEC A                                                                       ; $01B168 | |
    BPL +                                                                       ; $01B169 | |
    LDA #2.b                                                                    ; $01B16B | |
+   STA r_menu_magic_cursor_coordinates.spell_current.x.w                       ; $01B16D |/
++  LDA <r_menu_joypad_repeat.hi                                                ; $01B170 |\
    AND #JOYPAD_H_RIGHT.b                                                       ; $01B172 | | If right is pressed on the d-pad, increment the cursor X
    BEQ ++                                                                      ; $01B174 | | coordinate and loop it back to 0 if it reaches 3.
    LDA r_menu_magic_cursor_coordinates.spell_current.x.w                       ; $01B176 | |
    INC A                                                                       ; $01B179 | |
    CMP #3.b                                                                    ; $01B17A | |
    BNE +                                                                       ; $01B17C | |
    TDC                                                                         ; $01B17E | |
+   STA r_menu_magic_cursor_coordinates.spell_current.x.w                       ; $01B17F |/
++  LDA <r_menu_joypad_repeat.lo                                                ; $01B182 |\
    AND #JOYPAD_L_A.b                                                           ; $01B184 | | Skip this next block unless A is pressed.
    BEQ ++                                                                      ; $01B186 |/
    LDA r_menu_magic_spell_selected.w                                           ; $01B188 |\ If a spell is already selected, branch ahead.
    BNE +                                                                       ; $01B18B |/
    INC r_menu_magic_spell_selected.w                                           ; $01B18D | Set the spell selected flag.
    LDX r_menu_magic_cursor_coordinates.spell_current.w                         ; $01B190 |\ Store the current coordinates as the selected coordinates.
    STX r_menu_magic_cursor_coordinates.spell_selected.w                        ; $01B193 |/
    JSR _menu_magic_get_current_cursor_sprite_coordinates                       ; $01B196 |\
    REP #FLAG_P_ACCUMULATOR                                                     ; $01B199 | | Draw the second cursor down and to the right by 4 pixels relative
    LDA <r_menu_draw_cursor_arg_coordinates                                     ; $01B19B | | to the main cursor.
    CLC                                                                         ; $01B19D | |
    ADC #$0404.w                                                                ; $01B19E | |
    STA <r_menu_draw_cursor_arg_coordinates                                     ; $01B1A1 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01B1A3 | |
    JSR _menu_draw_cursor_2.w                                                   ; $01B1A5 |/
    BRA +++                                                                     ; $01B1A8 | Branch to handle the next buttion, other than B.
+   STZ r_menu_magic_spell_selected.w                                           ; $01B1AA |\
    JSR _menu_magic_cast_or_swap                                                ; $01B1AD | | If a spell was selected, reset the spell selected flag and call
    BRA +++                                                                     ; $01B1B0 |/  the cast or swap handler.
++  LDA <r_menu_joypad_repeat.hi                                                ; $01B1B2 |\
    AND #JOYPAD_H_B.b                                                           ; $01B1B4 | | If B is pressed, reset the spell selection flag and the selected
    BEQ +++                                                                     ; $01B1B6 | | spell and erase the cursors.
    STZ r_menu_magic_spell_selection_active.w                                   ; $01B1B8 | |
    STZ r_menu_magic_spell_selected.w                                           ; $01B1BB | |
    JSR _menu_erase_cursors                                                     ; $01B1BE |/
+++ LDA <r_menu_joypad_repeat.lo                                                ; $01B1C1 |\
    AND #JOYPAD_L_X.b                                                           ; $01B1C3 | | If X is pressed, treat it the same as pressing down on the spell
    BEQ ++                                                                      ; $01B1C5 | | list choice.
    LDA r_menu_magic_cursor_coordinates.spell_list.y.w                          ; $01B1C7 | |
    STA <r_menu_generic_tmp_offset.lo                                           ; $01B1CA | |
-   LDA <r_menu_generic_tmp_offset.lo                                           ; $01B1CC | |
    INC A                                                                       ; $01B1CE | |
    CMP #3.b                                                                    ; $01B1CF | |
    BNE +                                                                       ; $01B1D1 | |
    TDC                                                                         ; $01B1D3 | |
+   JSR _menu_transfer_a_to_x                                                   ; $01B1D4 | |
    LDA r_menu_magic_spell_list_ids.w,X                                         ; $01B1D7 | |
    BMI -                                                                       ; $01B1DA | |
    PHA                                                                         ; $01B1DC | |
    LDA <r_menu_generic_tmp_offset.lo                                           ; $01B1DD | |
    STA r_menu_magic_cursor_coordinates.spell_list.y.w                          ; $01B1DF | |
    PLA                                                                         ; $01B1E2 | |
    JSR _menu_update_spell_window                                               ; $01B1E3 |/
++  JMP _menu_magic_core                                                        ; $01B1E6

; menu_magic_cursor_column_coordinates_data ($01:B1E9)
;
; For each column of the magic menu, determines the coordinates of the cursor
; for each column.
menu_magic_cursor_column_coordinates_data:
    .db  16                                                                     ; $01B1E9
    .db  88                                                                     ; $01B1EA
    .db 160                                                                     ; $01B1EB

; menu_text_spell_list_white_data ($01:B1EC)
;
; Coordinates and text for the White spell list selection.
menu_text_spell_list_white_data:
    MENU_COORDINATES 24, 3                                                      ; $01B1EC.B1ED
.if FF4_REGION == "JAPAN"
    .db $95, $B4, $A8, $A7, $8C, 0                                              ; $01B216.B21A | 
.else
    .asc "White", 0                                                             ; $01B1EE.B1F3
.endif

; menu_text_spell_list_black_data ($01:B1F4)
;
; Coordinates and text for the Black spell list selection.
menu_text_spell_list_black_data
    MENU_COORDINATES 24, 5                                                      ; $01B1F4.B1F5
.if FF4_REGION == "JAPAN"
    .db $91, $B4, $A8, $A7, $8C, 0                                              ; $01B21E.B222 | 
.else
    .asc "Black", 0                                                             ; $01B1F6.B1FB
.endif

; menu_text_spell_list_call_data ($01:B1FC)
;
; Coordinates and text for the Call spell list selection.
menu_text_spell_list_call_data:
    MENU_COORDINATES 24, 7                                                      ; $01B1FC.B1FD
.if FF4_REGION == "JAPAN"
    .db $95, $7F, $8C, $8F, $B6, 0                                              ; $01B226.B22B | 
.else
    .asc "Call", 0                                                              ; $01B1FE.B202
.endif

; menu_text_spell_list_ninja_data ($01:B203)
;
; Coordinates and text for the Ninja spell list selection, which replaces Black
; for the Ninja class.
menu_text_spell_list_ninja_data:
    MENU_COORDINATES 24, 5                                                      ; $01B203.B204
.if FF4_REGION == "JAPAN"
    .db $9F, $B6, $16, $7E, $9B, 0                                              ; $01B22E.B233 | 
.else
    .asc "Ninja", 0                                                             ; $01B205.B20A
.endif

; menu_text_spell_list_white_blank_data ($01:B20B)
;
; Coordinates and text to display a blank spell list selection in place of White
; in case the character has no White magic.
menu_text_spell_list_white_blank_data:
    MENU_COORDINATES 24, 3                                                      ; $01B20B.B20C
    .asc "     ", 0                                                             ; $01B20D.B212

; menu_text_spell_list_black_blank_data ($01:B213)
;
; Coordinates and text to display a blank spell list selection entry instead of
; Black, if the character does not have a Black spell list.
menu_text_spell_list_black_blank_data:
    MENU_COORDINATES 24, 5                                                      ; $01B213.B214
    .asc "     ", 0                                                             ; $01B215.B21A

; menu_text_spell_list_call_blank_data ($01:B21B)
;
; Coordinates and text to display a blank spell list selection entry instead of
; Call, if hte character does not have a Call spell list.
menu_text_spell_list_call_blank_data:
    MENU_COORDINATES 24, 7                                                      ; $01B21B.B21C
    .asc "     ", 0                                                             ; $01B21D.B222

; _menu_update_spell_window ($01:B223)
;
; Draws the current listing of spells to the window on BG1.
_menu_update_spell_window:
    JSR _menu_set_current_tilemap_bg1                                           ; $01B223 | Switch to BG1.
    JSR _menu_magic_draw_spells                                                 ; $01B226 | Draw the spells.
    JMP _menu_copy_tilemap_to_vram_bg1                                          ; $01B229 | Copy the updated tilemap to VRAM.

; _menu_magic_draw_spells ($01:B22C)
;
; Given the spell list index in the accumulator, draws the names of the spells
; to three columns on BG1.
_menu_magic_draw_spells:
    STA <r_menu_generic_tmp_offset.lo                                           ; $01B22C | Save the passed spell list number to a temporary variable.
    JSR _menu_set_current_tilemap_bg1                                           ; $01B22E | Set the current tilemap to BG1.
    REP #FLAG_P_ACCUMULATOR                                                     ; $01B231 |\
    LDA <r_menu_generic_tmp_offset                                              ; $01B233 | | Set the spell list pointer to the spell list index times 24 plus
    ASL A                                                                       ; $01B235 | | the base address for the spell lists.
    ASL A                                                                       ; $01B236 | |
    ASL A                                                                       ; $01B237 | |
    STA <r_menu_magic_tmp_offset                                                ; $01B238 | |
    ASL A                                                                       ; $01B23A | |
    ADC <r_menu_magic_tmp_offset                                                ; $01B23B | |
    ADC #r_spell_lists.w                                                        ; $01B23D | |
    STA <r_menu_magic_tmp_spell_list_ptr                                        ; $01B240 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01B242 |/
    STZ <r_menu_magic_tmp_columns_remaining.hi                                  ; $01B244 | Initialize the high byte of the remaining columns to zero.
    STZ <r_menu_magic_tmp_rows_remaining.hi                                     ; $01B246 |\
    LDA #8.b                                                                    ; $01B248 | | Initialize the remaining rows to 8.
    STA <r_menu_magic_tmp_rows_remaining.lo                                     ; $01B24A |/
    LDY <r_menu_zero                                                            ; $01B24C | Initialize the Y register to zero.
--  LDA #3.b                                                                    ; $01B24E |\ Initialize the remaining columns to 3.
    STA <r_menu_magic_tmp_columns_remaining.lo                                  ; $01B250 |/
-   REP #FLAG_P_ACCUMULATOR                                                     ; $01B252 |\
    LDA <r_menu_magic_tmp_columns_remaining                                     ; $01B254 | | Set the X register to the number of remaining columns, minus one,
    DEC A                                                                       ; $01B256 | | times two, to index the coordinates table.
    ASL A                                                                       ; $01B257 | |
    TAX                                                                         ; $01B258 |/
    LDA #8.w                                                                    ; $01B259 |\
    SEC                                                                         ; $01B25C | | Multiply the current row number by 128 (two tile rows of 64 bytes
    SBC <r_menu_magic_tmp_rows_remaining                                        ; $01B25D | | each) to determine the row offset in the tilemap.
    XBA                                                                         ; $01B25F | |
    AND #$FF00.w                                                                ; $01B260 | |
    LSR A                                                                       ; $01B263 |/
    CLC                                                                         ; $01B264 |\
    ADC bank1E.menu_magic_spell_column_coordinates_data.l,X                     ; $01B265 | | Add the base offset for this column and transfer the result to the
    TAX                                                                         ; $01B269 | | X register.
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01B26A |/
    LDA (<r_menu_magic_tmp_spell_list_ptr),Y                                    ; $01B26C |\ Draw the name of the spell at the current index at the calculated
    JSR _menu_draw_spell_name_short                                             ; $01B26E |/ coordinates.
    INY                                                                         ; $01B271 |\
    DEC <r_menu_magic_tmp_columns_remaining                                     ; $01B272 | | Loop until all rows and columns have been drawn.
    BNE -                                                                       ; $01B274 | |
    DEC <r_menu_magic_tmp_rows_remaining                                        ; $01B276 | |
    BNE --                                                                      ; $01B278 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01B27A |/
    RTS                                                                         ; $01B27C

; _menu_draw_spell_name_short ($01:B27D)
;
; Given a spell ID in the accumulator, a tilemap offset in the X register, and
; the base tilemap address in $29, draws the name of that spell to the tilemap.
; This routine assumes that the spell is one of those with 6 characters in its
; name. It also has full diacritic support, which means the bulk of the name
; will actually be written one row lower than the passed address. If the value
; of $1A86 is set to the character's first status byte, special adjustments to
; the spell name palettes will be used based on the Pig or Toad status.
_menu_draw_spell_name_short:
    PHA                                                                         ; $01B27D | Preserve the spell ID from the accumulator.
    PHX                                                                         ; $01B27E | Preserve the value in the X register.
    CMP #SPELL_FIRST_FIELD_CASTABLE.b                                           ; $01B27F |\
    BCC +                                                                       ; $01B281 | | Skip this next block unless the spell is castable in the field.
    CMP #SPELL_LAST_FIELD_CASTABLE.b + 1                                        ; $01B283 | |
    BCS +                                                                       ; $01B285 |/
    STA r_menu_magic_spell_id.w                                                 ; $01B287 | Save the spell ID to a temporary variable.
    PHY                                                                         ; $01B28A |\
    JSR _menu_magic_get_spell_mp_cost                                           ; $01B28B | | Determine the spell's MP cost and save it to a temporary variable.
    PLY                                                                         ; $01B28E | |
    STA r_menu_magic_draw_spell_name_mp_cost.lo.w                               ; $01B28F | |
    STZ r_menu_magic_draw_spell_name_mp_cost.hi.w                               ; $01B292 |/
    LDA <r_menu_current_selected_character_slot                                 ; $01B295 |\
    JSR _menu_get_character_field_offset                                        ; $01B297 | | If the cost of the spell is greater than the character's current
    REP #FLAG_P_ACCUMULATOR                                                     ; $01B29A | | MP, skip directly to the next section.
    LDA character_field.mp.w,X                                                  ; $01B29C | |
    CMP r_menu_magic_draw_spell_name_mp_cost.w                                  ; $01B29F | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01B2A2 | |
    BCS ++                                                                      ; $01B2A4 |/
+   LDA r_menu_magic_draw_spell_name_arg_disable_dim.w                          ; $01B2A6 |\ If dimming of the spell name is disabled, skip ahead.
    BNE ++                                                                      ; $01B2A9 |/
-   LDA <r_menu_current_tilemap_base_tile_flags                                 ; $01B2AB |\
    ORA #%00000100.b                                                            ; $01B2AD | | Set the palette to four (to dim the spell) and branch way ahead.
    BRA +++                                                                     ; $01B2AF |/
++  LDA r_menu_magic_spell_id.w                                                 ; $01B2B1 |\
    CMP #SPELL_HEAL.b                                                           ; $01B2B4 | | If the spell in question is Heal, branch to set its tile flags to
    BEQ ++                                                                      ; $01B2B6 | | normal. If the character has neither the Pig or Toad status, also
    LDA r_menu_magic_character_status_1.w                                       ; $01B2B8 | | branch to use normal tile flags. If the character is a toad and
    AND #STATUS_1_TOAD.b | STATUS_1_PIG                                         ; $01B2BB | | the spell is Toad, branch to use normal tile flags. If the
    BEQ ++                                                                      ; $01B2BD | | character is a pig and the spell is Piggy, branch to use normal
    AND #STATUS_1_TOAD.b                                                        ; $01B2BF | | tile flags. Otherwise, branch to dim the spell.
    BEQ +                                                                       ; $01B2C1 | |
    LDA r_menu_magic_spell_id.w                                                 ; $01B2C3 | | NOTE: This does not read the character's status directly. Rather,
    CMP #SPELL_TOAD.b                                                           ; $01B2C6 | |       it reads a parameter byte that can optionally not be set by
    BEQ ++                                                                      ; $01B2C8 | |       the caller to disable this functionality.
+   LDA r_menu_magic_character_status_1.w                                       ; $01B2CA | |
    AND #STATUS_1_PIG.b                                                         ; $01B2CD | |
    BEQ -                                                                       ; $01B2CF | |
    LDA r_menu_magic_spell_id.w                                                 ; $01B2D1 | |
    CMP #SPELL_PIGGY.b                                                          ; $01B2D4 | |
    BNE -                                                                       ; $01B2D6 |/
++  LDA <r_menu_current_tilemap_base_tile_flags                                 ; $01B2D8 | If we reach here, simply load the default tile flags.
+++ STA <r_menu_current_tilemap_extra_tile_flags                                ; $01B2DA | Save whatever is loaded as the extra tile flags.
    PLX                                                                         ; $01B2DC | Restore the original value of the X register.
    PLA                                                                         ; $01B2DD | Restore the spell ID to the accumulator.
    PHA                                                                         ; $01B2DE |\
    REP #FLAG_P_ACCUMULATOR                                                     ; $01B2DF | |
    TXA                                                                         ; $01B2E1 | | Set the X register to the original value in the X register plus
    CLC                                                                         ; $01B2E2 | | the current base tilemap address.
    ADC <r_menu_current_tilemap_base_address                                    ; $01B2E3 | |
    TAX                                                                         ; $01B2E5 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01B2E6 | |
    PLA                                                                         ; $01B2E8 |/
    PHB                                                                         ; $01B2E9 |\
    PHX                                                                         ; $01B2EA | | Preserve the data bank, X and Y registers.
    PHY                                                                         ; $01B2EB |/
    XBA                                                                         ; $01B2EC |\
    LDA #0.b                                                                    ; $01B2ED | | Set the high byte of the accumulator to zero.
    XBA                                                                         ; $01B2EF |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $01B2F0 |\
    ASL A                                                                       ; $01B2F2 | | Set the Y register to the spell ID times 6 plus the base address
    STA <r_menu_generic_tmp_word                                                ; $01B2F3 | | for the short spell name data.
    ASL A                                                                       ; $01B2F5 | |
    ADC <r_menu_generic_tmp_word                                                ; $01B2F6 | |
    ADC #bank0F.spell_name_short_data.w                                         ; $01B2F8 | |
    TAY                                                                         ; $01B2FB | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01B2FC |/
    LDA #:bank0F.spell_name_short_data                                          ; $01B2FE |\
    PHA                                                                         ; $01B300 | | Set the data bank register to $0F, for the spell name data.
    PLB                                                                         ; $01B301 |/
    LDA 0.w,Y                                                                   ; $01B302 |\
    INY                                                                         ; $01B305 | | Load the first byte of the name and write it to the tilemap,
    STA $7E0040.l,X                                                             ; $01B306 | | writing a blank tile to the tile above.
    LDA #TILE_MENU_WINDOW_BLANK.b                                               ; $01B30A | |
    STA $7E0000.l,X                                                             ; $01B30C | |
    INX                                                                         ; $01B310 |/
    LDA <r_menu_current_tilemap_extra_tile_flags                                ; $01B311 |\
    STA $7E0000.l,X                                                             ; $01B313 | | Set the tile flags for the two tiles.
    STA $7E0040.l,X                                                             ; $01B317 | |
    INX                                                                         ; $01B31B |/
    LDA #5.b                                                                    ; $01B31C |\ Initialize the counter to five.
    STA <r_menu_generic_tmp_count                                               ; $01B31E |/
-   LDA 0.w,Y                                                                   ; $01B320 | Read the next byte of the name.
    JSR _menu_get_diacritic_tile                                                ; $01B323 |\
    STA $7E0000.l,X                                                             ; $01B326 | | Get the appropriate diacritic tiles for the specified character
    XBA                                                                         ; $01B32A | | and write them to the tilemap.
    STA $7E0040.l,X                                                             ; $01B32B | |
    INX                                                                         ; $01B32F |/
    LDA <r_menu_current_tilemap_extra_tile_flags                                ; $01B330 |\
    STA $7E0000.l,X                                                             ; $01B332 | | Write the tile flags as well.
    STA $7E0040.l,X                                                             ; $01B336 | |
    INX                                                                         ; $01B33A | |
    INY                                                                         ; $01B33B |/
    DEC <r_menu_generic_tmp_count                                               ; $01B33C |\ Decrement the count and loop until all five characters are done.
    BNE -                                                                       ; $01B33E |/
    PLY                                                                         ; $01B340 |\
    PLX                                                                         ; $01B341 | | Restore the preserved registers.
    PLB                                                                         ; $01B342 |/
    RTS                                                                         ; $01B343

; _menu_magic_get_current_cursor_sprite_coordinates ($01:B344)
;
; Returns the desired coordinates of the cursor sprite in $45.
_menu_magic_get_current_cursor_sprite_coordinates:
    LDA r_menu_magic_cursor_coordinates.spell_current.y.w                       ; $01B344 |\
    ASL A                                                                       ; $01B347 | | Set the cursor sprite Y coordinate to the current Y coordinate
    ASL A                                                                       ; $01B348 | | times 16 plus 86.
    ASL A                                                                       ; $01B349 | |
    ASL A                                                                       ; $01B34A | |
    ADC #86.b                                                                   ; $01B34B | |
    STA <r_menu_draw_cursor_arg_coordinates.y                                   ; $01B34D |/
    LDA r_menu_magic_cursor_coordinates.spell_current.x.w                       ; $01B34F |\
    SEP #FLAG_P_INDEX                                                           ; $01B352 | | Set the cursor X coordinate for the appropriate value for the
    TAX                                                                         ; $01B354 | | column.
    LDA menu_magic_cursor_column_coordinates_data.l,X                           ; $01B355 | |
    REP #FLAG_P_INDEX                                                           ; $01B359 | |
    STA <r_menu_draw_cursor_arg_coordinates.x                                   ; $01B35B |/
    RTS                                                                         ; $01B35D

; _menu_magic_cast_or_swap ($01:B35E)
;
; In the magic menu, upon the second spell selection, this routine handles
; either casting the spell (if the same one was chosen twice) or swapping them
; (if two different ones were chosen).
_menu_magic_cast_or_swap:
    LDX r_menu_magic_cursor_coordinates.spell_current.w                         ; $01B35E |\
    CPX r_menu_magic_cursor_coordinates.spell_selected.w                        ; $01B361 | | If the selected spell matches the current spell, jump to handle
    BNE +                                                                       ; $01B364 | | the casting of the spell.
    JMP _menu_magic_cast                                                        ; $01B366 |/
+   STZ r_menu_magic_spell_selected.w                                           ; $01B369 | Reset the spell selected flag.
    JSR _menu_erase_cursor_2                                                    ; $01B36C | Erase the second cursor.
    LDA r_menu_magic_cursor_coordinates.spell_current.y.w                       ; $01B36F |\
    ASL A                                                                       ; $01B372 | | Set the Y register to the index for the spell currently pointed
    ADC r_menu_magic_cursor_coordinates.spell_current.y.w                       ; $01B373 | | at.
    ADC r_menu_magic_cursor_coordinates.spell_current.x.w                       ; $01B376 | |
    JSR _menu_magic_get_spell_index                                             ; $01B379 | |
    TAY                                                                         ; $01B37C |/
    LDA r_menu_magic_cursor_coordinates.spell_selected.y.w                      ; $01B37D |\
    ASL A                                                                       ; $01B380 | | Set the X register to the index for the previously selected spell.
    ADC r_menu_magic_cursor_coordinates.spell_selected.y.w                      ; $01B381 | |
    ADC r_menu_magic_cursor_coordinates.spell_selected.x.w                      ; $01B384 | |
    JSR _menu_magic_get_spell_index                                             ; $01B387 | |
    TAX                                                                         ; $01B38A |/
    LDA r_spell_lists.w,X                                                       ; $01B38B |\
    PHA                                                                         ; $01B38E | | Swap the position of the two spells.
    LDA r_spell_lists.w,Y                                                       ; $01B38F | |
    STA r_spell_lists.w,X                                                       ; $01B392 | |
    PLA                                                                         ; $01B395 | |
    STA r_spell_lists.w,Y                                                       ; $01B396 |/
    JSR _menu_magic_get_selected_spell_list_index                               ; $01B399 |\ Update the spell window with the updated spell list.
    JMP _menu_update_spell_window                                               ; $01B39C |/

; _menu_magic_get_selected_spell_list_index ($01:B39F)
;
; Returns the index of the currently selected spell list.
_menu_magic_get_selected_spell_list_index:
    LDA r_menu_magic_cursor_coordinates.spell_list.y.w                          ; $01B39F
    JSR _menu_transfer_a_to_x                                                   ; $01B3A2
    LDA r_menu_magic_spell_list_ids.w,X                                         ; $01B3A5
    RTS                                                                         ; $01B3A8

; _menu_magic_get_spell_index ($01:B3A9)
;
; Given the currently selected spell list in the magic menu as well as the
; index of the spell within that list, returns the overall index of the spell
; within the spell lists.
_menu_magic_get_spell_index:
    STA <r_menu_generic_tmp_word_2.lo                                           ; $01B3A9 |\ Store the passed value in a temporary variable.
    STZ <r_menu_generic_tmp_word_2.hi                                           ; $01B3AB |/
    JSR _menu_magic_get_selected_spell_list_index                               ; $01B3AD | Load the index of the selected spell list.
    XBA                                                                         ; $01B3B0 |\
    LDA #0.b                                                                    ; $01B3B1 | | Zero out the high byte of the accumulator.
    XBA                                                                         ; $01B3B3 |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $01B3B4 |\
    ASL A                                                                       ; $01B3B6 | | Multiply the spell list index by 24 and add the previously stored
    ASL A                                                                       ; $01B3B7 | | value.
    ASL A                                                                       ; $01B3B8 | |
    STA <r_menu_generic_tmp_word                                                ; $01B3B9 | |
    ASL A                                                                       ; $01B3BB | |
    ADC <r_menu_generic_tmp_word                                                ; $01B3BC | |
    ADC <r_menu_generic_tmp_word_2                                              ; $01B3BE | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01B3C0 |/
    RTS                                                                         ; $01B3C2

; _menu_magic_update_spell_list_tile_flags ($01:B3C3)
;
; Updates the tile flags of the spell list selection window to highlight the
; currently selected spell list by drawing it in white (and the others in grey).
_menu_magic_update_spell_list_tile_flags:
    LDA #%00100100.b                                                            ; $01B3C3 |\
    LDX #(24 * 2) + (4 * 32 * 2).w                                              ; $01B3C5 | | Write tile flags to the three spell list names to use priority 1
    JSR @write_flags                                                            ; $01B3C8 | | with palette 1 (to draw them in grey).
    LDX #(24 * 2) + (6 * 32 * 2).w                                              ; $01B3CB | |
    JSR @write_flags                                                            ; $01B3CE | |
    LDX #(24 * 2) + (8 * 32 * 2).w                                              ; $01B3D1 | |
    JSR @write_flags                                                            ; $01B3D4 |/
    LDA r_menu_magic_cursor_coordinates.spell_list.y.w                          ; $01B3D7 |\
    BNE +                                                                       ; $01B3DA | | Load the offset to the tiles for the currently selected spell
    LDX #(24 * 2) + (4 * 32 * 2).w                                              ; $01B3DC | | list.
    BRA ++                                                                      ; $01B3DF | |
+   CMP #$01.b                                                                  ; $01B3E1 | |
    BNE +                                                                       ; $01B3E3 | |
    LDX #(24 * 2) + (6 * 32 * 2).w                                              ; $01B3E5 | |
    BRA ++                                                                      ; $01B3E8 | |
+   LDX #(24 * 2) + (8 * 32 * 2).w                                              ; $01B3EA |/
++  LDA #%00100000.b                                                            ; $01B3ED | Set the tile flags to use palette 0 and fall through to write.
@write_flags:
    PHA                                                                         ; $01B3EF |\
    LDY #5.w                                                                    ; $01B3F0 | | Write the tile flags in the accumulator to BG4 at the offset in
-   STA r_menu_tilemap_bg4.w + 1,X                                              ; $01B3F3 | | the X register for five tiles.
    INX                                                                         ; $01B3F6 | |
    INX                                                                         ; $01B3F7 | |
    DEY                                                                         ; $01B3F8 | |
    BNE -                                                                       ; $01B3F9 | |
    PLA                                                                         ; $01B3FB |/
    RTS                                                                         ; $01B3FC


; _menu_magic_get_*_spell_mp_cost ($01:B413)
;
; Returns a spell's MP cost in the accumulator. Depending on the entry point,
; this can either return the cost of a spell ID passed directly in the
; accumulator, or it can return the cost of the currently selected spell if the
; spell selection menu is active.
_menu_magic_get_selected_spell_mp_cost:
    LDA r_menu_magic_spell_selection_active.w                                   ; $01B3FD |\ If spell selection is not active, simply branch to return the
    BEQ __menu_magic_get_spell_mp_cost_load_and_return                          ; $01B400 |/ currently stored value.
    LDA r_menu_magic_cursor_coordinates.spell_current.y.w                       ; $01B402 |\
    ASL A                                                                       ; $01B405 | | Otherwise, multiply the Y coordiante by three and add the X
    ADC r_menu_magic_cursor_coordinates.spell_current.y.w                       ; $01B406 | | coordinate to determine the relative index of the spell and then
    ADC r_menu_magic_cursor_coordinates.spell_current.x.w                       ; $01B409 | | get the overall spell index. Finally, read the value of the spell
    JSR _menu_magic_get_spell_index                                             ; $01B40C | | and fall through to the next code to get the MP cost.
    TAY                                                                         ; $01B40F | |
    LDA r_spell_lists.w,Y                                                       ; $01B410 |/
_menu_magic_get_spell_mp_cost:
    XBA                                                                         ; $01B413 |\
    LDA #0.b                                                                    ; $01B414 | | Zero out the high byte of the accumulator.
    XBA                                                                         ; $01B416 |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $01B417 |\
    ASL A                                                                       ; $01B419 | | Set the X register to the spell ID times six.
    STA <r_menu_generic_tmp_word                                                ; $01B41A | |
    ASL A                                                                       ; $01B41C | |
    ADC <r_menu_generic_tmp_word                                                ; $01B41D | |
    TAX                                                                         ; $01B41F | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01B420 |/
    LDA bank0F.spell_property_data.l + spell.wall_mp,X                          ; $01B422 |\ Load the spell's MP cost and mask out the appropriate bits.
    AND #SPELL_WALL_MP_MP.b                                                     ; $01B426 |/
    STA r_menu_magic_spell_mp_cost.w                                            ; $01B428 | Store the cost in the MP cost variable.
__menu_magic_get_spell_mp_cost_load_and_return:
    LDA r_menu_magic_spell_mp_cost.w                                            ; $01B42B | Load whatever is in the MP cost variable and return.
    RTS                                                                         ; $01B42E

; _menu_magic_load_portraits_and_draw_targeting_menu ($01:B42F)
;
; Loads the character portraits and then draws the targeting menu for the magic
; menu.
_menu_magic_load_portraits_and_draw_targeting_menu:
    LDA #%00001111.b                                                            ; $01B42F |\ Remove sprites from the main screen.
    STA reg_ppu_tm.l                                                            ; $01B431 |/
    JSR _menu_load_portraits                                                    ; $01B435 | Load character portraits.

; _menu_magic_draw_targeting_menu ($01:B438)
;
; In the magic menu, draws the targeting menu.
_menu_magic_draw_targeting_menu:
    LDA #%00100000.b                                                            ; $01B438 |\ Set the character sprite base tile flags for priority 2.
    STA <r_menu_character_sprite_base_tile_flags                                ; $01B43A |/
    JSR _menu_set_current_tilemap_bg1                                           ; $01B43C | Set the current tilemap to BG1.
    JSR _menu_erase_cursors                                                     ; $01B43F | Erase the cursors.
    STZ r_menu_magic_spell_selected.w                                           ; $01B442 | Reset the spell selected flag.
    LDA r_menu_magic_cursor_coordinates.spell_current.y.w                       ; $01B445 |\
    ASL A                                                                       ; $01B448 | | Load the selected spell ID and save it to the casting variable.
    ADC r_menu_magic_cursor_coordinates.spell_current.y.w                       ; $01B449 | |
    ADC r_menu_magic_cursor_coordinates.spell_current.x.w                       ; $01B44C | |
    JSR _menu_magic_get_spell_index                                             ; $01B44F | |
    TAY                                                                         ; $01B452 | |
    LDA r_spell_lists.w,Y                                                       ; $01B453 | |
    STA r_menu_magic_spell_casting.w                                            ; $01B456 |/
    SEC                                                                         ; $01B459 |\
    SBC #SPELL_FIRST_FIELD_CASTABLE.b                                           ; $01B45A | | Load the multi-target property for the current spell.
    JSR _menu_transfer_a_to_x                                                   ; $01B45C | |
    LDA bank14.field_spell_multi_target_enabled_data.l,X                        ; $01B45F | |
    STA r_menu_magic_multi_target_enabled.w                                     ; $01B463 |/
    LDY #menu_window_magic_target_selection_data.w                              ; $01B466 |\ Draw the target selection window.
    JSR _menu_configure_and_draw_window                                         ; $01B469 |/
    LDY #menu_window_magic_whom_data.w                                          ; $01B46C |\ Draw the "Whom?" window.
    JSR _menu_configure_and_draw_window                                         ; $01B46F |/
    LDY #menu_window_magic_details_data.w                                       ; $01B472 |\ Draw the magic details window.
    JSR _menu_configure_and_draw_window                                         ; $01B475 |/
    JSR _menu_set_current_tilemap_bg1                                           ; $01B478 | Set the current tilemap to BG1.
    LDA r_menu_magic_spell_casting.w                                            ; $01B47B |\
    LDX #(2 * 2) + (1 * 32 * 2).w                                               ; $01B47E | | Draw the name of the spell to 2, 1.
    JSR _menu_draw_spell_name_short                                             ; $01B481 |/
    LDY #menu_text_need_mp_data.w                                               ; $01B484 |\ Draw the "Need MP" text.
    JSR _menu_draw_text_indirect                                                ; $01B487 |/
    LDY #menu_text_magic_whom_data.w                                            ; $01B48A |\ Draw the "Whom?" text.
    JSR _menu_draw_text_indirect                                                ; $01B48D |/
    JSR _menu_magic_get_selected_spell_mp_cost                                  ; $01B490 |\
    STA r_menu_magic_spell_mp_cost.w                                            ; $01B493 | | Draw the spell's MP cost to 5, 7. The Japanese version draws to
.if FF4_REGION == "JAPAN"                                                       ;         | | 4, 7 instead.
    LDY #(4 * 2) + (7 * 32 * 2).w                                               ; $01B4BF | |
.else                                                                           ;         | |
    LDY #(5 * 2) + (7 * 32 * 2).w                                               ; $01B496 | |
.endif                                                                          ;         | |
    JSR _menu_draw_two_digit_number                                             ; $01B499 |/
    LDX #(16 * 2) + (11 * 32 * 2).w                                             ; $01B49C |\
    LDY #r_character_field.1.w                                                  ; $01B49F | | Draw the character in slot 0's stats to 16, 11.
    JSR _menu_party_draw_character_basic_stats                                  ; $01B4A2 |/
    LDX #(16 * 2) + (1 * 32 * 2).w                                              ; $01B4A5 |\
    LDY #r_character_field.2.w                                                  ; $01B4A8 | | Draw the character in slot 1's stats to 16, 1.
    JSR _menu_party_draw_character_basic_stats                                  ; $01B4AB |/
    LDX #(16 * 2) + (21 * 32 * 2).w                                             ; $01B4AE |\
    LDY #r_character_field.3.w                                                  ; $01B4B1 | | Draw the character in slot 2's stats to 16, 21.
    JSR _menu_party_draw_character_basic_stats                                  ; $01B4B4 |/
    LDX #(16 * 2) + (6 * 32 * 2).w                                              ; $01B4B7 |\
    LDY #r_character_field.4.w                                                  ; $01B4BA | | Draw the character in slot 3's stats to 16, 6.
    JSR _menu_party_draw_character_basic_stats                                  ; $01B4BD |/
    LDX #(16 * 2) + (16 * 32 * 2).w                                             ; $01B4C0 |\
    LDY #r_character_field.5.w                                                  ; $01B4C3 | | Draw the character in slot 4's stats to 16, 16.
    JSR _menu_party_draw_character_basic_stats                                  ; $01B4C6 |/
    LDA r_party_formation_two_front.w                                           ; $01B4C9 |\
    AND #%00000001.b                                                            ; $01B4CC | | Set the X register to 5 if the two front party formation is set
    ASL A                                                                       ; $01B4CE | | and to zero otherwise.
    STA <r_menu_generic_tmp_count                                               ; $01B4CF | |
    ASL A                                                                       ; $01B4D1 | |
    ASL A                                                                       ; $01B4D2 | |
    ADC <r_menu_generic_tmp_count                                               ; $01B4D3 | |
    JSR _menu_transfer_a_to_x                                                   ; $01B4D5 |/
    LDA #0.b                                                                    ; $01B4D8 |\
    JSR _menu_magic_draw_portrait                                               ; $01B4DA | | Draw the five character portraits.
    JSR _menu_magic_draw_portrait                                               ; $01B4DD | |
    JSR _menu_magic_draw_portrait                                               ; $01B4E0 | |
    JSR _menu_magic_draw_portrait                                               ; $01B4E3 | |
    JSR _menu_magic_draw_portrait                                               ; $01B4E6 |/
    LDA #%00011111.b                                                            ; $01B4E9 |\ Set the main screen to all screens.
    STA reg_ppu_tm.l                                                            ; $01B4EB |/
    RTS                                                                         ; $01B4EF

; _menu_erase_cursors_and_play_error ($01:B4F0)
;
; Erases the first and second cursors and plays the error sound effect.
_menu_erase_cursors_and_play_error:
    JSR _menu_erase_cursors                                                     ; $01B4F0 | Erase the cursors.
    JMP _play_sound_effect_error                                                ; $01B4F3 | Play the error sound effect.

; _menu_erase_cursors ($01:B4F6)
;
; Erases both the first and second cursors.
_menu_erase_cursors:
    JSR _menu_erase_cursor_2                                                    ; $01B4F6 | Erase cursor 2.
    JMP _menu_erase_cursor_1                                                    ; $01B4F9 | Erase cursor 1.

; _menu_magic_handle_warp_wrapper ($01:B4FC)
;
; A wrapper of the Warp handler that resets the selected spell values.
_menu_magic_handle_warp_wrapper:
    STZ r_menu_magic_spell_selection_active.w                                   ; $01B4FC |\ Reset the selection active and selected spell values.
    STZ r_menu_magic_spell_selected.w                                           ; $01B4FF |/
    JMP _menu_magic_handle_warp                                                 ; $01B502 | Execute the Warp event.

; _menu_magic_handle_event ($01:B505)
;
; Handler for spells that call an event and for which their desired menu event
; ID is calculated relative to the ID for the Exit spell.
_menu_magic_handle_event:
    STZ r_menu_magic_spell_selection_active.w                                   ; $01B505 | Reset the selection active flag.
    STZ r_menu_magic_spell_selected.w                                           ; $01B508 | Reset the spell selected flag.
    SEC                                                                         ; $01B50B |\
    SBC #SPELL_EXIT.b                                                           ; $01B50C | | Execute the handler for the specified spell.
    LDX #menu_magic_handler_special_offset_data.w                               ; $01B50E | |
    JMP _menu_execute_jump                                                      ; $01B511 |/

; _menu_magic_cast ($01:B514)
;
; Handles the casting of a spell in the magic menu. For spells that don't need
; the targeting menu, branches immediately to their handlers. Otherwise,
; displays the targeting menu and allows the player to choose a target before
; dispatching to the handler.
_menu_magic_cast:
    STZ r_menu_magic_spell_selection_active.w                                   ; $01B514 | Reset the spell selection active flag.
    JSR _menu_set_current_tilemap_bg1                                           ; $01B517 | Set the current tilemap to BG1.
    STZ r_menu_magic_spell_selected.w                                           ; $01B51A | Reset the spell selected flag.
    LDA r_menu_magic_cursor_coordinates.spell_current.y.w                       ; $01B51D |\
    ASL A                                                                       ; $01B520 | | Read the selected spell ID.
    ADC r_menu_magic_cursor_coordinates.spell_current.y.w                       ; $01B521 | |
    ADC r_menu_magic_cursor_coordinates.spell_current.x.w                       ; $01B524 | |
    JSR _menu_magic_get_spell_index                                             ; $01B527 | |
    TAY                                                                         ; $01B52A | |
    LDA r_spell_lists.w,Y                                                       ; $01B52B |/
    CMP #SPELL_FIRST_FIELD_CASTABLE.b                                           ; $01B52E |\
    BCC _menu_erase_cursors_and_play_error                                      ; $01B530 | | If it's not in the range of field-castable spells, erase the
    CMP #SPELL_LAST_FIELD_CASTABLE.b + 1                                        ; $01B532 | | cursors and play an error sound effect before returning.
    BCS _menu_erase_cursors_and_play_error                                      ; $01B534 |/
    STA r_menu_magic_spell_casting.w                                            ; $01B536 | Store the spell ID as the spell being casted.
    CMP #SPELL_HEAL.b                                                           ; $01B539 |\ If the spell is the Heal spell, skip the following logic and branch
    BEQ ++                                                                      ; $01B53B |/ ahead.
    JSR _menu_get_selected_character_status_1                                   ; $01B53D |\
    AND #STATUS_1_TOAD.b | STATUS_1_PIG                                         ; $01B540 | | Branch ahead if the character is neither a toad or pig.
    BEQ ++                                                                      ; $01B542 |/
    BIT #STATUS_1_TOAD.b                                                        ; $01B544 |\
    BEQ +                                                                       ; $01B546 | | Branch ahead if the character is a toad and the spell is the Toad
    LDA r_menu_magic_spell_casting.w                                            ; $01B548 | | spell.
    CMP #SPELL_TOAD.b                                                           ; $01B54B | |
    BEQ ++                                                                      ; $01B54D |/
+   JSR _menu_get_selected_character_status_1                                   ; $01B54F |\
    BIT #STATUS_1_PIG.b                                                         ; $01B552 | | Branch ahead if the character is a pig and the spell is the Piggy
    BEQ +                                                                       ; $01B554 | | spell.
    LDA r_menu_magic_spell_casting.w                                            ; $01B556 | |
    CMP #SPELL_PIGGY.b                                                          ; $01B559 | |
    BEQ ++                                                                      ; $01B55B |/
+   BRA _menu_erase_cursors_and_play_error                                      ; $01B55D | Otherwise, erase the cursors, play the error sound and return.
++  JSR _menu_magic_get_remaining_mp_after_cast                                 ; $01B55F |\
    BPL +                                                                       ; $01B562 | | If, after the cast, the character would have negative MP, backup
    JSR _menu_backup_oam                                                        ; $01B564 | | the OAM, play the error sound effect, and jump to the done code.
    JSR _play_sound_effect_error                                                ; $01B567 | |
    JMP @done                                                                   ; $01B56A |/
+   LDA r_spell_lists.w,Y                                                       ; $01B56D |\
    CMP #SPELL_EXIT.b                                                           ; $01B570 | | If the spell is Exit, Sight or Warp, branch to the appropriate
    BEQ _menu_magic_handle_event                                                ; $01B572 | | handler, since they don't use the targeting system.
    CMP #SPELL_SIGHT.b                                                          ; $01B574 | |
    BEQ _menu_magic_handle_event                                                ; $01B576 | |
    CMP #SPELL_WARP.b                                                           ; $01B578 | |
    BEQ _menu_magic_handle_warp_wrapper                                         ; $01B57A |/
    JSR _menu_erase_cursor_2                                                    ; $01B57C |\ Erase the two cursors.
    JSR _menu_erase_cursor_1                                                    ; $01B57F |/
    JSR _menu_backup_oam                                                        ; $01B582 |\
    JSR _menu_initialize_oam                                                    ; $01B585 | | Backup the current OAM, erase it, and copy it to the PPU.
    JSR _menu_wait_for_vblank_copy_oam_to_ppu                                   ; $01B588 |/
    JSR _menu_magic_draw_targeting_menu                                         ; $01B58B |\ Draw the magic targeting menu and animate it opening.
    JSR _menu_animate_current_tilemap_50_rows_to_vram                           ; $01B58E |/
    JSR _menu_wait_for_vblank_copy_oam_to_ppu                                   ; $01B591 | Wait for vblank and copy the OAM to the PPU.
    STZ r_menu_magic_target_positions.1.w                                       ; $01B594 |\
    STZ r_menu_magic_target_positions.2.w                                       ; $01B597 | | Initialize the multi-targeting variables to zero.
    STZ r_menu_magic_target_positions.3.w                                       ; $01B59A | |
    STZ r_menu_magic_target_positions.4.w                                       ; $01B59D | |
    STZ r_menu_magic_target_positions.5.w                                       ; $01B5A0 | |
    STZ r_menu_magic_multi_target_active.w                                      ; $01B5A3 |/
-   LDA r_menu_magic_targeting_cursor_index.w                                   ; $01B5A6 |\
    JSR _menu_get_character_id_from_position                                    ; $01B5A9 | | Load the character and if it's not empty, branch forward.
    BNE @loop_start                                                             ; $01B5AC |/
    LDA r_menu_magic_targeting_cursor_index.w                                   ; $01B5AE |\
    INC A                                                                       ; $01B5B1 | | Otherwise, increment the cursor index until it points to a non-
    CMP #5.b                                                                    ; $01B5B2 | | empty slot, looping back to zero as necessary.
    BNE +                                                                       ; $01B5B4 | |
    LDA #0.b                                                                    ; $01B5B6 | |
+   STA r_menu_magic_targeting_cursor_index.w                                   ; $01B5B8 | |
    BRA -                                                                       ; $01B5BB |/
@loop_start:
    LDA r_menu_magic_multi_target_active.w                                      ; $01B5BD |\
    BEQ +                                                                       ; $01B5C0 | | If multi-target is active, erase cursor 1 and branch ahead.
    JSR _menu_erase_cursor_1                                                    ; $01B5C2 | |
    BRA ++                                                                      ; $01B5C5 |/
+   LDA r_menu_magic_targeting_cursor_index.w                                   ; $01B5C7 |\
    ASL A                                                                       ; $01B5CA | | Otherwise, draw cursor 1 to a Y coordinate of 32 plus the cursor
    ASL A                                                                       ; $01B5CB | | index times 40 and an X coordinate of 64.
    ADC r_menu_magic_targeting_cursor_index.w                                   ; $01B5CC | |
    ASL A                                                                       ; $01B5CF | |
    ASL A                                                                       ; $01B5D0 | |
    ASL A                                                                       ; $01B5D1 | |
    ADC #32.b                                                                   ; $01B5D2 | |
    STA <r_menu_draw_cursor_arg_coordinates.y                                   ; $01B5D4 | |
    LDA #64.b                                                                   ; $01B5D6 | |
    STA <r_menu_draw_cursor_arg_coordinates.x                                   ; $01B5D8 | |
    JSR _menu_draw_cursor_1                                                     ; $01B5DA |/
++  LDY #r_oam.5.w                                                              ; $01B5DD |\
    JSR _menu_magic_targeting_draw_multi_cursor                                 ; $01B5E0 | | Draw the potential current multi-target cursor to the OAM.
    JSR _menu_wait_for_vblank_copy_oam_to_ppu                                   ; $01B5E3 |/
    JSR _menu_update_joypad_and_play_sound_effect                               ; $01B5E6 | Update the joypad and play an appropriate sound effect.
    LDA <r_menu_joypad_repeat.hi                                                ; $01B5E9 |\
    AND #JOYPAD_H_B.b                                                           ; $01B5EB | | If the B button isn't pressed, skip past the done code.
    BEQ +                                                                       ; $01B5ED |/
@done:
    JSR _menu_set_current_tilemap_bg1_and_initialize                            ; $01B5EF | Clear BG1.
    LDY #menu_window_magic_list_data.w                                          ; $01B5F2 |\
    JSR _menu_configure_and_draw_window                                         ; $01B5F5 | | Draw the spell window.
    JSR _menu_magic_get_selected_spell_list_index                               ; $01B5F8 | |
    JSR _menu_update_spell_window                                               ; $01B5FB |/
    JSR _menu_restore_oam                                                       ; $01B5FE | Restore the backed up OAM.
    LDA #%00000000.b                                                            ; $01B601 |\ Set the character sprite base tile flags for priority 0.
    STA <r_menu_character_sprite_base_tile_flags                                ; $01B603 |/
    JSR _menu_erase_cursor_2                                                    ; $01B605 |\ Erase the two cursors.
    JSR _menu_erase_cursor_1                                                    ; $01B608 |/
    JSR _menu_set_current_tilemap_bg1                                           ; $01B60B | Set the current tilemap to BG1.
    JSR _menu_wait_for_vblank_copy_oam_to_ppu                                   ; $01B60E | Wait for vblank and copy the OAM to the PPU.
    JMP _menu_copy_tilemap_to_vram_bg1_no_vblank                                ; $01B611 | Copy the BG1 tilemap to VRAM and return.
+   LDA <r_menu_joypad_repeat.lo                                                ; $01B614 |\
    AND #JOYPAD_L_A.b                                                           ; $01B616 | | If the A button is pressed, set the target to the cursor index,
    BEQ +                                                                       ; $01B618 | | execute the chosen spell, and branch to the done code.
    LDA r_menu_magic_targeting_cursor_index.w                                   ; $01B61A | |
    JSR _menu_transfer_a_to_x                                                   ; $01B61D | |
    LDA #$FF.b                                                                  ; $01B620 | |
    STA r_menu_magic_target_positions.w,X                                       ; $01B622 | |
    JSR _menu_magic_handle_targeted_spell                                       ; $01B625 | |
    BRA @done                                                                   ; $01B628 |/
+   LDA <r_menu_joypad_repeat.hi                                                ; $01B62A |\
    AND #JOYPAD_H_UP.b                                                          ; $01B62C | | If up is pressed on the d-pad, decrement the targeting cursor
    BEQ ++                                                                      ; $01B62E | | index, and if it goes negative, reset it to 4. Repeat the process
-   LDA r_menu_magic_targeting_cursor_index.w                                   ; $01B630 | | until the targeted position is not empty.
    DEC A                                                                       ; $01B633 | |
    BPL +                                                                       ; $01B634 | |
    LDA #4.b                                                                    ; $01B636 | |
+   STA r_menu_magic_targeting_cursor_index.w                                   ; $01B638 | |
    JSR _menu_get_character_id_from_position                                    ; $01B63B | |
    BEQ -                                                                       ; $01B63E |/
++  LDA <r_menu_joypad_repeat.hi                                                ; $01B640 |\
    AND #JOYPAD_H_DOWN.b                                                        ; $01B642 | | If down is pressed on the d-pad, increment the targeting cursor
    BEQ ++                                                                      ; $01B644 | | index, and if it reaches five, reset it to zero. Repeat the
-   LDA r_menu_magic_targeting_cursor_index.w                                   ; $01B646 | | process until the targeted position is not empty.
    INC A                                                                       ; $01B649 | |
    CMP #5.b                                                                    ; $01B64A | |
    BNE +                                                                       ; $01B64C | |
    LDA #0.b                                                                    ; $01B64E | |
+   STA r_menu_magic_targeting_cursor_index.w                                   ; $01B650 | |
    JSR _menu_get_character_id_from_position                                    ; $01B653 | |
    BEQ -                                                                       ; $01B656 |/
++  LDA <r_menu_joypad_repeat.hi                                                ; $01B658 |\
    AND #JOYPAD_H_LEFT.b | JOYPAD_H_RIGHT                                       ; $01B65A | | If the left or right d-pad button is not pressed or if multi-
    BEQ ++                                                                      ; $01B65C | | targeting is not enabled for this spell, branch to the end.
    LDA r_menu_magic_multi_target_enabled.w                                     ; $01B65E | |
    BEQ ++                                                                      ; $01B661 |/
    LDY #4.w                                                                    ; $01B663 | Initialize the position number to 4.
-   TYA                                                                         ; $01B666 |\
    JSR _menu_get_position_character_field_offset                               ; $01B667 | | Skip this position if it's empty.
    LDA character_field.id.w,X                                                  ; $01B66A | |
    AND #%00111111.b                                                            ; $01B66D | |
    BEQ +                                                                       ; $01B66F |/
    TYX                                                                         ; $01B671 |\
    LDA r_menu_magic_target_positions.w,X                                       ; $01B672 | | Toggle the bits for this position to toggle its targeted status.
    EOR #%11111111.b                                                            ; $01B675 | |
    STA r_menu_magic_target_positions.w,X                                       ; $01B677 |/
+   DEY                                                                         ; $01B67A |\ Decrement the Y register and loop until it passes zero.
    BPL -                                                                       ; $01B67B |/
    LDA #$FF.b                                                                  ; $01B67D |\
    EOR r_menu_magic_multi_target_active.w                                      ; $01B67F | | Toggle the active state of the multi-targeting.
    STA r_menu_magic_multi_target_active.w                                      ; $01B682 |/
++  JMP @loop_start                                                             ; $01B685

; _menu_magic_draw_portrait ($01:B688)
;
; Given the current index in the X register (where the index is the desired slot
; number times two) and the current slot number in the accumulator, draws the
; portrait for that character to the magic targeting menu. The accumulator and
; X register are both incremented accordingly, so this routine can be called
; multiple times successively to draw all five portraits.
_menu_magic_draw_portrait:
    PHA                                                                         ; $01B688 |\ Preserve the initial values of the accumulator and X register.
    PHX                                                                         ; $01B689 |/
    PHA                                                                         ; $01B68A |\
    REP #FLAG_P_ACCUMULATOR                                                     ; $01B68B | | Load the coordinates for the current slot into the Y register.
    LDA bank1E.menu_magic_target_portrait_coordinates_data.l,X                  ; $01B68D | |
    TAY                                                                         ; $01B691 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01B692 | |
    PLA                                                                         ; $01B694 |/
    JSR _menu_draw_portrait                                                     ; $01B695 | Draw the portrait for this slot.
    PLX                                                                         ; $01B698 |\ Restore the X register and accumulator.
    PLA                                                                         ; $01B699 |/
    INC A                                                                       ; $01B69A |\
    INX                                                                         ; $01B69B | | Increment the accumulator and X register to prepare for the next.
    INX                                                                         ; $01B69C |/
    RTS                                                                         ; $01B69D

; _menu_magic_targeting_draw_multi_cursor ($01:B69E)
;
; Handles drawing the multi-targeting cursor in the magic targeting menu. If
; no multi-targets are enabled, will return without drawing anything.
_menu_magic_targeting_draw_multi_cursor:
    LDA r_menu_magic_multi_target_counter.w                                     ; $01B69E |\ Load the current multi-target counter and push it to the stack.
    PHA                                                                         ; $01B6A1 |/
    PHY                                                                         ; $01B6A2 | Preserve the value in the Y register.
    JSR _menu_transfer_a_to_x                                                   ; $01B6A3 |\
    LDA r_menu_magic_target_positions.w,X                                       ; $01B6A6 | | If the current slot is flagged as targeted, branch ahead.
    BNE +                                                                       ; $01B6A9 |/
    LDA #8.b                                                                    ; $01B6AB |\
    STA <r_menu_generic_tmp_count                                               ; $01B6AD | | Otherwise, write data to the passed OAM offset to erase the
-   LDA #$FF.b                                                                  ; $01B6AF | | cursor in question.
    STA 0.w,Y                                                                   ; $01B6B1 | |
    INY                                                                         ; $01B6B4 | |
    LDA #$F0.b                                                                  ; $01B6B5 | |
    STA 0.w,Y                                                                   ; $01B6B7 | |
    INY                                                                         ; $01B6BA | |
    DEC <r_menu_generic_tmp_count                                               ; $01B6BB | |
    BNE -                                                                       ; $01B6BD | |
    BRA ++                                                                      ; $01B6BF |/
+   LDA <r_menu_generic_tmp_offset                                              ; $01B6C1 |\
    ASL A                                                                       ; $01B6C3 | | Set the Y coordinate for the cursor to 36 plus the value of the
    ASL A                                                                       ; $01B6C4 | | counter times 40. (This variable was set as a side effect to the
    ADC <r_menu_generic_tmp_offset                                              ; $01B6C5 | | transfer from A to X function call earlier.)
    ASL A                                                                       ; $01B6C7 | |
    ASL A                                                                       ; $01B6C8 | |
    ASL A                                                                       ; $01B6C9 | |
    ADC #36.b                                                                   ; $01B6CA | |
    STA <r_menu_generic_tmp_word.hi                                             ; $01B6CC |/
    LDA #68.b                                                                   ; $01B6CE |\ Set the X coordinate to 68.
    STA <r_menu_generic_tmp_word.lo                                             ; $01B6D0 |/
    LDX <r_menu_generic_tmp_word                                                ; $01B6D2 |\
    TDC                                                                         ; $01B6D4 | | Draw the first cursor to those coordinates.
    JSR _menu_draw_cursor_direct                                                ; $01B6D5 |/
++  PLY                                                                         ; $01B6D8 |\
    REP #FLAG_P_ACCUMULATOR                                                     ; $01B6D9 | | Restore the original value of the Y register and add 16.
    TYA                                                                         ; $01B6DB | |
    CLC                                                                         ; $01B6DC | |
    ADC #16.w                                                                   ; $01B6DD | |
    TAY                                                                         ; $01B6E0 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01B6E1 |/
    PLA                                                                         ; $01B6E3 |\
    INC A                                                                       ; $01B6E4 | | Restore the accumulator and increment it. If the value was five,
    CMP #5.b                                                                    ; $01B6E5 | | reset it back to zero. Either way, save it as the updated counter
    BCC +                                                                       ; $01B6E7 | | value.
    TDC                                                                         ; $01B6E9 | |
+   STA r_menu_magic_multi_target_counter.w                                     ; $01B6EA |/
    RTS                                                                         ; $01B6ED

; _menu_magic_handle_targeted_spell ($01:B6EE)
;
; General handler for spells that use the targeting window in the magic menu.
_menu_magic_handle_targeted_spell:
    JSR _menu_magic_get_remaining_mp_after_cast                                 ; $01B6EE |\
    REP #FLAG_P_ACCUMULATOR                                                     ; $01B6F1 | | Update the caster's MP to remove the MP associated with the spell.
    STA character_field.mp.w,X                                                  ; $01B6F3 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01B6F6 |/
    LDA r_menu_magic_spell_casting.w                                            ; $01B6F8 |\
    SEC                                                                         ; $01B6FB | | Play the sound effect associated with the spell.
    SBC #SPELL_FIRST_FIELD_CASTABLE.b                                           ; $01B6FC | |
    PHA                                                                         ; $01B6FE | |
    JSL bank1E.menu_magic_play_spell_sound_effect                               ; $01B6FF | |
    PLA                                                                         ; $01B703 |/
    LDX #menu_magic_handler_offset_data.w                                       ; $01B704 |\ Call the handler for the casted spell.
    JSR _menu_execute_jump                                                      ; $01B707 |/
    JSR _menu_get_selected_character_status_1                                   ; $01B70A |\ Update the status byte of the casting character (for drawing spell
    STA r_menu_magic_character_status_1.w                                       ; $01B70D |/ names).
    JSR _menu_set_current_tilemap_bg1_and_initialize                            ; $01B710 | Clear BG1 and make it the current tilemap.
    LDY #menu_window_magic_list_data.w                                          ; $01B713 |\
    JSR _menu_configure_and_draw_window                                         ; $01B716 | | Draw the spell list window and the spells.
    JSR _menu_magic_get_selected_spell_list_index                               ; $01B719 | |
    JSR _menu_magic_draw_spells                                                 ; $01B71C |/
    JSR _menu_magic_load_portraits_and_draw_targeting_menu                      ; $01B71F | Load the character portraits and draw the targeting menu.
    JSR _menu_erase_cursor_1                                                    ; $01B722 | Erase the first cursor.
    JSR _menu_copy_tilemap_to_vram_bg1                                          ; $01B725 | Copy the tilemap to VRAM.
    JSR _menu_copy_oam_to_ppu                                                   ; $01B728 | Copy the OAM to the PPU.
    JSR _menu_wait_for_input                                                    ; $01B72B | Wait for input.
    JSR _menu_set_current_tilemap_bg3                                           ; $01B72E |\
    JSR _menu_party_draw_selected_character_stats_no_window                     ; $01B731 | | Update the character stats window.
    JMP _menu_copy_tilemap_to_vram_bg3                                          ; $01B734 |/

; menu_magic_handler_offset_data ($01:B737)
;
; For each of the field-castable spells, contains a pointer to the handler for
; that spell. A second label, starting at the handler for spell $16 (Exit), is
; used for certain spells that process through a different routine.
menu_magic_handler_offset_data:
    .addr _menu_magic_handle_cure1                                              ; $01B737.B738 | $0E: Cure1
    .addr _menu_magic_handle_cure2                                              ; $01B739.B73A | $0F: Cure2
    .addr _menu_magic_handle_cure3                                              ; $01B73B.B73C | $10: Cure3
    .addr _menu_magic_handle_cure4                                              ; $01B73D.B73E | $11: Cure4
    .addr _menu_magic_handle_heal                                               ; $01B73F.B740 | $12: Heal
    .addr _menu_magic_handle_life1                                              ; $01B741.B742 | $13: Life1
    .addr _menu_magic_handle_life2                                              ; $01B743.B744 | $14: Life2
    .addr _menu_magic_handle_size                                               ; $01B745.B746 | $15: Size
menu_magic_handler_special_offset_data:
    .addr _menu_magic_handle_exit                                               ; $01B747.B748 | $16: Exit
    .addr _menu_magic_handle_sight                                              ; $01B749.B74A | $17: Sight
    .addr _menu_magic_handle_float                                              ; $01B74B.B74C | $18: Float
    .addr _menu_magic_handle_toad                                               ; $01B74D.B74E | $19: Toad
    .addr _menu_magic_handle_piggy                                              ; $01B74F.B750 | $1A: Piggy
    .addr _menu_magic_handle_warp                                               ; $01B751.B752 | $1B: Warp

; _menu_magic_handle_cure1 ($01:B753)
;
; Spell handler for the Cure1 spell in the magic menu.
_menu_magic_handle_cure1:
    LDA bank0F.spell_property_data.l + SPELL_CURE1 * 6 + spell.power            ; $01B753 |\
    STA r_menu_magic_spell_power.lo.w                                           ; $01B757 | | Load the Cure1 spell power and branch to handle the cure.
    BRA _menu_magic_handle_cure                                                 ; $01B75A |/

; _menu_magic_handle_cure2 ($01:B75C)
;
; Spell handler for the Cure2 spell in the magic menu.
_menu_magic_handle_cure2:
    LDA bank0F.spell_property_data.l + SPELL_CURE2 * 6 + spell.power            ; $01B75C |\
    STA r_menu_magic_spell_power.lo.w                                           ; $01B760 | | Load the Cure2 spell power and branch to handle the cure.
    BRA _menu_magic_handle_cure                                                 ; $01B763 |/

; _menu_magic_handle_cure3 ($01:B765)
;
; Spell handler for the Cure3 spell in the magic menu.
_menu_magic_handle_cure3:
    LDA bank0F.spell_property_data.l + SPELL_CURE3 * 6 + spell.power            ; $01B765 |\
    STA r_menu_magic_spell_power.lo.w                                           ; $01B769 | | Load the Cure3 spell power and branch to handle the cure.
    BRA _menu_magic_handle_cure                                                 ; $01B76C |/

; _menu_magic_handle_cure4 ($01:B76E)
;
; Spell handler for the Cure4 spell in the magic menu.
_menu_magic_handle_cure4:
    LDA r_menu_magic_multi_target_active.w                                      ; $01B76E |\
    BEQ +                                                                       ; $01B771 | | If multi-targeting is active, load the Cure4 spell power and
    LDA bank0F.spell_property_data.l + SPELL_CURE4 * 6 + spell.power            ; $01B773 | | branch to handle the cure.
    STA r_menu_magic_spell_power.lo.w                                           ; $01B777 | |
    BRA _menu_magic_handle_cure                                                 ; $01B77A |/
+   LDA #0.b                                                                    ; $01B77C |\
-   JSR _menu_magic_handle_cure4_single                                         ; $01B77E | | Otherwise, loop through the five positions, curing whoever the
    INC A                                                                       ; $01B781 | | single target is to maximum.
    CMP #5.b                                                                    ; $01B782 | |
    BNE -                                                                       ; $01B784 |/
    RTS                                                                         ; $01B786

; _menu_magic_handle_cure4_single ($01:B787)
;
; Handles Cure4 in the magic menu, specifically its use against a single target.
; It can be called with any target, and will only apply to targets that are
; correctly set in the target array at $1B8B. This routine restores the
; character to their maximum HP.
;
; It also has two entry points that are used by other Cure item handles: one to
; store an updated HP value, and the other to return.
_menu_magic_handle_cure4_single:
    PHA                                                                         ; $01B787 | Preserve the value in the accumulator.
    JSR _menu_transfer_a_to_x                                                   ; $01B788 |\
    LDA r_menu_magic_target_positions.w,X                                       ; $01B78B | | If the passed position is not enabled, branch to return.
    BEQ __menu_magic_handle_cure_done                                           ; $01B78E |/
    LDA <r_menu_generic_tmp_offset.lo                                           ; $01B790 |\
    JSR _menu_get_position_character_field_offset                               ; $01B792 | | If the character in that position has the swoon status, branch to
    LDA character_field.status_1.w,X                                            ; $01B795 | | return.
    BMI __menu_magic_handle_cure_done                                           ; $01B798 |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $01B79A |\ Load the character's maximum HP into the accumulator and fall
    LDA character_field.hp_max.w,X                                              ; $01B79C |/ through to store it.
__menu_magic_handle_cure_store_hp:
    STA character_field.hp.w,X                                                  ; $01B79F |\ Store the HP value in the accumulator as the character's new
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01B7A2 |/ HP value.
__menu_magic_handle_cure_done:
    PLA                                                                         ; $01B7A4 | Restore the accumulator value.
    RTS                                                                         ; $01B7A5

; _menu_magic_handle_cure ($01:B7A6)
;
; Core handler routine for cure spells in the magic menu. The desired spell
; power is passed in $1B91. The restored value will be calculated using the
; following formula:
;
; (caster will // 8 + 2) * (caster will // 2 + spell power)
;
; If being used on multiple targets, the resulting value is divided by four,
; regardless of the number of actual targets.
_menu_magic_handle_cure:
    LDA #0.b                                                                    ; $01B7A6 |\ Zero out the high byte of the accumulator.
    XBA                                                                         ; $01B7A8 |/
    LDA r_menu_magic_spell_power.w                                              ; $01B7A9 | Load the spell power into the accumulator.
    REP #FLAG_P_ACCUMULATOR                                                     ; $01B7AC |\
    ASL A                                                                       ; $01B7AE | | Multiply the spell power by four.
    ASL A                                                                       ; $01B7AF | |
    STA r_menu_magic_spell_power.w                                              ; $01B7B0 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01B7B3 |/
    LDA <r_menu_current_selected_character_slot                                 ; $01B7B5 |\
    JSR _menu_get_character_field_offset                                        ; $01B7B7 | | Set the multiplier to the casting character's will divided by
    LDA character_field.will.w,X                                                ; $01B7BA | | eight, plus one.
    LSR A                                                                       ; $01B7BD | |
    LSR A                                                                       ; $01B7BE | |
    LSR A                                                                       ; $01B7BF | |
    INC A                                                                       ; $01B7C0 | |
    STA <r_menu_magic_multiplier.lo                                             ; $01B7C1 | |
    STZ <r_menu_magic_multiplier.hi                                             ; $01B7C3 |/
    LDA #0.b                                                                    ; $01B7C5 |\ Zero the high byte of the accumulator.
    XBA                                                                         ; $01B7C7 |/
    LDA character_field.will.w,X                                                ; $01B7C8 |\
    LSR A                                                                       ; $01B7CB | | Set the power to the calculated spell power plus half the casting
    REP #FLAG_P_ACCUMULATOR                                                     ; $01B7CC | | character's will.
    CLC                                                                         ; $01B7CE | |
    ADC r_menu_magic_spell_power.w                                              ; $01B7CF | |
    STA <r_menu_magic_tmp_cure_power                                            ; $01B7D2 |/
-   CLC                                                                         ; $01B7D4 |\
    ADC <r_menu_magic_tmp_cure_power                                            ; $01B7D5 | | Add the cure power to the cure power times the multiplier. (In
    DEC <r_menu_magic_multiplier                                                ; $01B7D7 | | other words, multiply by the multiplier plus one.)
    BNE -                                                                       ; $01B7D9 | |
    STA <r_menu_magic_tmp_cure_power                                            ; $01B7DB | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01B7DD |/
    SEP #FLAG_P_INDEX                                                           ; $01B7DF |\ Initialize the X register to zero.
    LDX <r_menu_zero                                                            ; $01B7E1 |/
    TXY                                                                         ; $01B7E3 | Initialize the Y register to zero.
-   LDA r_menu_magic_target_positions.w,X                                       ; $01B7E4 |\
    BEQ +                                                                       ; $01B7E7 | | Set the Y register to the total number of characters being cured.
    INY                                                                         ; $01B7E9 | |
+   INX                                                                         ; $01B7EA | | NOTE: It doesn't seem like this value is ever actually used.
    CPX #5.b                                                                    ; $01B7EB | |
    BNE -                                                                       ; $01B7ED | |
    REP #FLAG_P_INDEX                                                           ; $01B7EF |/
    LDA r_menu_magic_multi_target_active.w                                      ; $01B7F1 |\
    BEQ +                                                                       ; $01B7F4 | | If multi-targeting is active, divide the calculated power by four.
    REP #FLAG_P_ACCUMULATOR                                                     ; $01B7F6 | |
    LDA <r_menu_magic_tmp_cure_power                                            ; $01B7F8 | |
    LSR A                                                                       ; $01B7FA | |
    LSR A                                                                       ; $01B7FB | |
    BRA ++                                                                      ; $01B7FC |/
+   REP #FLAG_P_ACCUMULATOR                                                     ; $01B7FE |\ Otherwise, load the power directly.
    LDA <r_menu_magic_tmp_cure_power                                            ; $01B800 |/
++  STA <r_menu_generic_tmp_word                                                ; $01B802 | Save the result into a temporary variable.
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01B804 |\
    LDA #0.b                                                                    ; $01B806 | | Loop through the five character positions, updating their HP as
-   JSR _menu_magic_handle_cure_attempt_hp_update                               ; $01B808 | | appropriate.
    INC A                                                                       ; $01B80B | |
    CMP #5.b                                                                    ; $01B80C | |
    BNE -                                                                       ; $01B80E |/
    RTS                                                                         ; $01B810

; _menu_magic_handle_cure_attempt_hp_update ($01:B811)
;
; Given the current position in the accumulator and the value to add in $45,
; attempts to add that value to the character's HP. The HP will not be updated
; if the character is not designated for curing in the target array at $1B8B or
; if they have the swoon or stone statuses. Additionally, their HP is capped at
; their maximum HP value.
_menu_magic_handle_cure_attempt_hp_update:
    PHA                                                                         ; $01B811 | Preserve the position value in the accumulator.
    STA r_menu_magic_current_target_position.w                                  ; $01B812 | Store the position in a temporary variable.
    JSR _menu_transfer_a_to_x                                                   ; $01B815 | Transfer the value to the X register and $43.
    LDA r_menu_magic_target_positions.w,X                                       ; $01B818 |\ If this position is not being cured, branch to the end.
    BEQ ++                                                                      ; $01B81B |/
    LDX <r_menu_generic_tmp_offset                                              ; $01B81D |\
    LDA bank14.character_position_to_slot_data.l,X                              ; $01B81F | | If the target character has either the swoon or stone statuses,
    JSR _menu_get_character_field_offset                                        ; $01B823 | | branch to the end.
    LDA character_field.status_1.w,X                                            ; $01B826 | |
    AND #STATUS_1_SWOON.b | STATUS_1_STONE                                      ; $01B829 | |
    BNE ++                                                                      ; $01B82B |/
    LDA r_menu_magic_current_target_position.w                                  ; $01B82D |\
    JSR _menu_get_position_character_field_offset                               ; $01B830 | | Add the character's current HP to the passed value in $45.
    REP #FLAG_P_ACCUMULATOR                                                     ; $01B833 | |
    LDA character_field.hp.w,X                                                  ; $01B835 | |
    CLC                                                                         ; $01B838 | |
    ADC <r_menu_generic_tmp_word                                                ; $01B839 |/
    CMP character_field.hp_max.w,X                                              ; $01B83B |\
    BCC +                                                                       ; $01B83E | | If the new value is greater than their maximum HP, replace it with
    LDA character_field.hp_max.w,X                                              ; $01B840 | | their maximum HP.
+   STA character_field.hp.w,X                                                  ; $01B843 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01B846 |/
++  PLA                                                                         ; $01B848 | Restore the value in the accumulator.
    RTS                                                                         ; $01B849

; _menu_magic_handle_heal ($01:B84A)
;
; Spell handler for the Heal spell in the magic menu.
_menu_magic_handle_heal:
    LDA #0.b                                                                    ; $01B84A |\
-   JSR _menu_magic_handle_heal_single_position                                 ; $01B84C | | Loop through the five positions, applying the Heal spell to each
    INC A                                                                       ; $01B84F | | of them in turn.
    CMP #5.b                                                                    ; $01B850 | |
    BNE -                                                                       ; $01B852 |/
    RTS                                                                         ; $01B854

; _menu_magic_handle_heal_single_position ($01:B855)
;
; Core handler of the Heal spell in the magic menu, which removes the following
; statuses from the character in the position passed in the accumulator, if that
; position is flagged as targeted: stone, toad, small, pig, mute, darkness,
; poison, curse and gradual petrification.
_menu_magic_handle_heal_single_position:
    PHA                                                                         ; $01B855 | Preserve the value in the accumulator.
    JSR _menu_transfer_a_to_x                                                   ; $01B856 | Transfer the position value to the X register and $43.
    LDA r_menu_magic_target_positions.w,X                                       ; $01B859 |\ Branch to the end if this position is not being targeted.
    BEQ +                                                                       ; $01B85C |/
    JSR _menu_get_position_character_field_offset_mem                           ; $01B85E |\
    REP #FLAG_P_ACCUMULATOR                                                     ; $01B861 | | Remove the following status bits from the character: stone, toad,
    LDA character_field.status_1.w,X                                            ; $01B863 | | small, pig, mute, darkness, poison, curse and gradual
    AND #STATUS_1_SWOON.w | (%01111100 << 8)                                    ; $01B866 | | petrification. The last two shouldn't be relevant outside of
    STA character_field.status_1.w,X                                            ; $01B869 | | battle anyway.
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01B86C |/
+   PLA                                                                         ; $01B86E | Restore the value in the accumulator.
    RTS                                                                         ; $01B86F

; _menu_magic_handle_life1 ($01:B870)
;
; Spell handler for the Life1 spell in the magic menu.
_menu_magic_handle_life1:
    LDA #0.b                                                                    ; $01B870 |\ Initialize the life count to zero.
    STA r_menu_magic_life_count.w                                               ; $01B872 |/
-   JSR _menu_magic_handle_life1_attempt_single                                 ; $01B875 |\
    INC A                                                                       ; $01B878 | | Attempt to revive each character.
    CMP #5.b                                                                    ; $01B879 | |
    BNE -                                                                       ; $01B87B |/
    BRA _menu_magic_handle_life_check_restore_mp                                ; $01B87D | Restore the caster's MP if nobody was revived.

; _menu_magic_handle_life_attempt_single ($01:B87F)
;
; Attempts to revive the character in the position passed in the accumulator.
; Only revives the character if they are designated as a target. Increments the
; value at $1BBD if successful.
_menu_magic_handle_life1_attempt_single:
    PHA                                                                         ; $01B87F | Preserve the position value in the accumulator.
    JSR _menu_transfer_a_to_x                                                   ; $01B880 |\
    LDA r_menu_magic_target_positions.w,X                                       ; $01B883 | | Branch to the end if this position is not being targeted.
    BEQ ++                                                                      ; $01B886 |/
    JSR _menu_get_position_character_field_offset_mem                           ; $01B888 |\
    LDA character_field.status_1.w,X                                            ; $01B88B | | Branch to the end if this position is not swooned.
    BPL ++                                                                      ; $01B88E |/
    AND #~STATUS_1_SWOON.b                                                      ; $01B890 |\ Remove the swoon bit from the status byte.
    STA character_field.status_1.w,X                                            ; $01B892 |/
    LDA character_field.vitality.w,X                                            ; $01B895 |\
    STA <r_menu_generic_tmp_offset.lo                                           ; $01B898 | | Set a temporary variable to the character's vitality times five.
    REP #FLAG_P_ACCUMULATOR                                                     ; $01B89A | |
    LDA <r_menu_generic_tmp_offset                                              ; $01B89C | |
    ASL A                                                                       ; $01B89E | |
    ASL A                                                                       ; $01B89F | |
    ADC <r_menu_generic_tmp_offset                                              ; $01B8A0 |/
    CMP character_field.hp_max.w,X                                              ; $01B8A2 |\
    BCC +                                                                       ; $01B8A5 | | If the result is greater than the character's maximum, use the
    LDA character_field.hp_max.w,X                                              ; $01B8A7 |/  maximum instead.
+   STA character_field.hp.w,X                                                  ; $01B8AA |\ Store the calculated HP value.
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01B8AD |/
    INC r_menu_magic_life_count.w                                               ; $01B8AF | Increment the revived character counter.
++  PLA                                                                         ; $01B8B2 | Restore the value in the accumulator.
    RTS                                                                         ; $01B8B3

; _menu_magic_handle_life2 ($01:B8B4)
;
; Handler for the Life2 spell in the magic menu. Falls through to the next
; routine for part of its work.
_menu_magic_handle_life2:
    LDA #0.b                                                                    ; $01B8B4 |\ Initialize the life count to zero.
    STA r_menu_magic_life_count.w                                               ; $01B8B6 |/
-   JSR _menu_magic_handle_life2_attempt_single                                 ; $01B8B9 |\
    INC A                                                                       ; $01B8BC | | Loop through the five characters, attemping to revive them.
    CMP #5.b                                                                    ; $01B8BD | | Afterward, fall through to restore MP if nobody was revived.
    BNE -                                                                       ; $01B8BF |/

; _menu_magic_handle_life_check_restore_mp ($01:B8C1)
;
; Checks the value of the variable at $1BBD. If it is zero, it will add the
; spell's MP cost back to the casting character's MP.
_menu_magic_handle_life_check_restore_mp:
    LDA r_menu_magic_life_count.w                                               ; $01B8C1 |\ Branch to the end if someone was revived.
    BNE +                                                                       ; $01B8C4 |/
    LDA <r_menu_current_selected_character_slot                                 ; $01B8C6 |\
    JSR _menu_get_character_field_offset                                        ; $01B8C8 | | Add the MP cost back to the casting character's MP.
    LDA r_menu_magic_spell_mp_cost.w                                            ; $01B8CB | |
    STA <r_menu_generic_tmp_offset.lo                                           ; $01B8CE | |
    REP #FLAG_P_ACCUMULATOR                                                     ; $01B8D0 | |
    LDA character_field.mp.w,X                                                  ; $01B8D2 | |
    CLC                                                                         ; $01B8D5 | |
    ADC <r_menu_generic_tmp_offset                                              ; $01B8D6 | |
    STA character_field.mp.w,X                                                  ; $01B8D8 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01B8DB |/
+   RTS                                                                         ; $01B8DD

; _menu_magic_handle_life2_attempt_single ($01:B8DE)
;
; Given a position number in the accumulator, attempts to revive that character
; using the Life2 spell if they are a designated target and if they are swooned.
; Increments the value at $1BBD if successful.
_menu_magic_handle_life2_attempt_single:
    PHA                                                                         ; $01B8DE | Preserve the position value in the accumulator.
    JSR _menu_transfer_a_to_x                                                   ; $01B8DF |\
    LDA r_menu_magic_target_positions.w,X                                       ; $01B8E2 | | Branch to the end if this position is not a designated target.
    BEQ +                                                                       ; $01B8E5 |/
    JSR _menu_get_position_character_field_offset_mem                           ; $01B8E7 |\
    LDA character_field.status_1.w,X                                            ; $01B8EA | | Branch to the end if the character is not swooned.
    BPL +                                                                       ; $01B8ED |/
    LDA #%00000000.b                                                            ; $01B8EF |\ Reset all bits in the first status byte.
    STA character_field.status_1.w,X                                            ; $01B8F1 |/
    LDA character_field.status_2.w,X                                            ; $01B8F4 |\
    AND #~STATUS_2_CURSE.b                                                      ; $01B8F7 | | Reset all bits except curse in the second status byte.
    STA character_field.status_2.w,X                                            ; $01B8F9 |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $01B8FC |\
    LDA character_field.hp_max.w,X                                              ; $01B8FE | | Restore the character's HP to their maximum.
    STA character_field.hp.w,X                                                  ; $01B901 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01B904 |/
    INC r_menu_magic_life_count.w                                               ; $01B906 | Increment the life count.
+   PLA                                                                         ; $01B909 | Restore the accumulator.
    RTS                                                                         ; $01B90A

; _menu_magic_handle_size ($01:B90B)
;
; Handler for the Size spell in the magic menu.
_menu_magic_handle_size:
    LDA #STATUS_1_SMALL.b                                                       ; $01B90B |\
    LDY #character_field.status_1.w                                             ; $01B90D | | Toggle the small status on the configured characters.
    BRA _menu_magic_handle_status                                               ; $01B910 |/

; _menu_magic_handle_toad ($01:B912)
;
; Handler for the Toad spell in the magic menu.
_menu_magic_handle_toad:
    LDA #STATUS_1_TOAD.b                                                        ; $01B912 |\
    LDY #character_field.status_1.w                                             ; $01B914 | | Toggle the toad status on the configured characters.
    BRA _menu_magic_handle_status                                               ; $01B917 |/

; _menu_magic_handle_piggy ($01:B919)
;
; Handler for the Piggy spell in the magic menu.
_menu_magic_handle_piggy:
    LDA #STATUS_1_PIG.b                                                         ; $01B919 |\
    LDY #character_field.status_1.w                                             ; $01B91B | | Toggle the pig status on the configured characters.
    BRA _menu_magic_handle_status                                               ; $01B91E |/

; _menu_magic_handle_status ($01:B920)
_menu_magic_handle_status:
    STA <r_menu_magic_status_toggle_arg_set_if_unset                            ; $01B920 | Store the passed mask as statuses to set if unset.
    EOR #%11111111.b                                                            ; $01B922 |\ Store the opposite mask as bits to keep if set.
    STA <r_menu_magic_status_toggle_arg_keep_if_set                             ; $01B924 |/
    STY <r_menu_magic_unknown_014b                                              ; $01B926 | TODO: Save the Y register to a seemingly unused variable.
    LDA #0.b                                                                    ; $01B928 |\
-   JSR _menu_magic_status_toggle                                               ; $01B92A | | Loop through the five characters, adjusting their status as
    INC A                                                                       ; $01B92D | | appropriate.
    CMP #5.b                                                                    ; $01B92E | |
    BNE -                                                                       ; $01B930 |/
    RTS                                                                         ; $01B932

; _menu_magic_status_toggle ($01:B933)
;
; Given a position number in the accumulator, a record offset in the Y register,
; a mask of set bits to unset in $49 and a mask of unset bits to set in $48,
; adjusts the status of that character, if they are designated as a target in
; the array at $1B8B.
_menu_magic_status_toggle:
    PHA                                                                         ; $01B933 | Preserve the position number in the accumulator.
    JSR _menu_transfer_a_to_x                                                   ; $01B934 |\
    LDA r_menu_magic_target_positions.w,X                                       ; $01B937 | | Branch to the end if this position is not set as a target.
    BEQ +                                                                       ; $01B93A |/
    JSR _menu_get_position_character_field_offset_mem                           ; $01B93C |\ Get the offset to the character's record and store it in a
    STX <r_menu_magic_tmp_ptr.address                                           ; $01B93F |/ a temporary variable.
    STZ <r_menu_magic_tmp_ptr.bank                                              ; $01B941 | Pointlessly zero out the unused bank byte.
    LDA (<r_menu_magic_tmp_ptr.address),Y                                       ; $01B943 |\
    PHA                                                                         ; $01B945 | | Reset any bits that are not intended to be kept.
    AND <r_menu_magic_status_toggle_arg_keep_if_set                             ; $01B946 | |
    STA (<r_menu_magic_tmp_ptr.address),Y                                       ; $01B948 |/
    PLA                                                                         ; $01B94A |\
    EOR #%11111111.b                                                            ; $01B94B | | Set any unset bits that were intended to be set.
    AND <r_menu_magic_status_toggle_arg_set_if_unset                            ; $01B94D | |
    ORA (<r_menu_magic_tmp_ptr.address),Y                                       ; $01B94F | |
    STA (<r_menu_magic_tmp_ptr.address),Y                                       ; $01B951 |/
+   PLA                                                                         ; $01B953 | Restore the value in the accumulator.
    RTS                                                                         ; $01B954

; _menu_backup_oam ($01:B955)
;
; Backs up the OAM to the menu backup area at $A200.
_menu_backup_oam:
    REP #FLAG_P_ACCUMULATOR                                                     ; $01B955 |\
    LDA #_sizeof_r_oam.w + _sizeof_r_oam_hi + 56 - 1                            ; $01B957 | | Copy the OAM data to a backup location in memory.
    LDX #r_oam.w                                                                ; $01B95A | |
    LDY #r_menu_generic_backup.w                                                ; $01B95D | | TODO: This copies an additional 56 bytes. Is there a reason for
    MVN :r_oam,:r_menu_generic_backup                                           ; $01B960 | |       this, or is it just incorrect?
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01B963 |/
    RTS                                                                         ; $01B965

; _menu_restore_oam ($01:B966)
;
; Restores a previously backed up copy of the OAM data to the main OAM mirror.
_menu_restore_oam:
    REP #FLAG_P_ACCUMULATOR                                                     ; $01B966 |\
    LDA #_sizeof_r_oam.w + _sizeof_r_oam_hi + 56 - 1                            ; $01B968 | | Copy the backed up OAM data to the main OAM mirror.
    LDX #r_menu_generic_backup.w                                                ; $01B96B | |
    LDY #r_oam.w                                                                ; $01B96E | |
    MVN :r_menu_generic_backup,:r_oam                                           ; $01B971 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01B974 |/
    RTS                                                                         ; $01B976

; _menu_get_position_character_field_offset ($01:B977)
;
; Given a character position in the accumulator (with the top being 0 and
; counting up from there), returns the offset for that character's field record
; in the X register. The _mem variant expects the position number to be passed
; in $43.
_menu_get_position_character_field_offset:
    STA <r_menu_generic_tmp_offset.lo                                           ; $01B977 | Store the passed position to memory.
_menu_get_position_character_field_offset_mem:
    LDX <r_menu_generic_tmp_offset                                              ; $01B979 |\ Determine the slot number for the passed position.
    LDA bank14.character_position_to_slot_data.l,X                              ; $01B97B |/
    JMP _menu_get_character_field_offset                                        ; $01B97F | Get the record offset for that slot and return.

; _menu_erase_cursors_and_play_error_2 ($01:B982)
;
; Erases the first and second cursors and plays an error sound effect.
_menu_erase_cursors_and_play_error_2:
    JSR _menu_erase_cursors                                                     ; $01B982 | Erase the first and second cursors.
    JMP _play_sound_effect_error                                                ; $01B985 | Play an error sound effect and return.

; _menu_magic_handle_warp ($01:B988)
;
; Spell handler for the Warp spell.
_menu_magic_handle_warp:
    LDA r_menu_event_flags.w                                                    ; $01B988 |\
    AND #MENU_EVENT_FLAGS_WARP.b                                                ; $01B98B | | Jump to the error code if Warp is not enabled.
    BEQ _menu_erase_cursors_and_play_error_2                                    ; $01B98D |/
    LDA #MENU_EVENT_WARP.b                                                      ; $01B98F |\ Otherwise, execute the Warp event.
    BRA _menu_magic_event_execute                                               ; $01B991 |/

; _menu_magic_handle_exit ($01:B993)
;
; Spell handler for the Exit spell.
_menu_magic_handle_exit:
    LDA r_menu_event_flags.w                                                    ; $01B993 |\
    AND #MENU_EVENT_FLAGS_EXIT.b                                                ; $01B996 | | Jump to the error code if Exit is not enabled.
    BEQ _menu_erase_cursors_and_play_error_2                                    ; $01B998 |/
    LDA #MENU_EVENT_EXIT.b                                                      ; $01B99A |\ Otherwise, execute the Exit event.
    BRA _menu_magic_event_execute                                               ; $01B99C |/

; _menu_magic_handle_sight ($01:B99E)
;
; Spell handler for the Sight spell.
_menu_magic_handle_sight:
    LDA r_menu_event_flags.w                                                    ; $01B99E |\
    AND #MENU_EVENT_FLAGS_SIGHT.b                                               ; $01B9A1 | | Jump to the error code if Sight is not enabled.
    BEQ _menu_erase_cursors_and_play_error_2                                    ; $01B9A3 |/
    LDA #MENU_EVENT_SIGHT.b                                                     ; $01B9A5 | Otherwise, load the menu event ID and fall through to execute.

; _menu_magic_event_execute ($01:B9A7)
;
; Handles executing a magic event in the menu system, given a menu event ID in
; the accumulator.
_menu_magic_event_execute:
    STA r_menu_event.w                                                          ; $01B9A7 | Store the passed value as the menu event.
    JSR _menu_magic_get_remaining_mp_after_cast                                 ; $01B9AA |\
    REP #FLAG_P_ACCUMULATOR                                                     ; $01B9AD | | Update the character's MP to reflect casting the spell.
    STA character_field.mp.w,X                                                  ; $01B9AF | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01B9B2 |/
    JSL bank1E.menu_magic_save_cursor_coordinates                               ; $01B9B4 | Save the cahracter's magic menu coordinates.
    LDX r_menu_return_stack_pointer.w                                           ; $01B9B8 |\
    TXS                                                                         ; $01B9BB | | Return from the menu system.
    RTS                                                                         ; $01B9BC |/

; _menu_magic_handle_float ($01:B9BD)
;
; Handler for the Float spell in the magic menu.
_menu_magic_handle_float:
    LDA #0.b                                                                    ; $01B9BD | Initialize the position nubmer to zero.
-   PHA                                                                         ; $01B9BF |\
    JSR _menu_transfer_a_to_x                                                   ; $01B9C0 | | Branch to the next iteration if this position is not set in the
    LDA r_menu_magic_target_positions.w,X                                       ; $01B9C3 | | targeting variable.
    BEQ +                                                                       ; $01B9C6 | |
    PLA                                                                         ; $01B9C8 |/
    PHA                                                                         ; $01B9C9 |\
    JSR _menu_get_position_character_field_offset                               ; $01B9CA | | Set the float status on the current character position.
    LDA character_field.status_2.w,X                                            ; $01B9CD | |
    ORA #STATUS_2_FLOAT.b                                                       ; $01B9D0 | |
    STA character_field.status_2.w,X                                            ; $01B9D2 | |
+   PLA                                                                         ; $01B9D5 |/
    INC A                                                                       ; $01B9D6 |\
    CMP #5.b                                                                    ; $01B9D7 | | Loop until all five positions have been checked.
    BNE -                                                                       ; $01B9D9 |/
    RTS                                                                         ; $01B9DB

; _menu_magic_get_remaining_mp_after_cast ($01:B9DC)
;
; Returns the amount of MP the currently selected character would have after
; the casting of the currently selected spell. In addition, the flags would be
; set as if having done the subtraction manually.
_menu_magic_get_remaining_mp_after_cast:
    LDA <r_menu_current_selected_character_slot                                 ; $01B9DC |\ Set the X register to the offset to the selected character's stat
    JSR _menu_get_character_field_offset                                        ; $01B9DE |/ record.
    LDA r_menu_magic_spell_mp_cost.w                                            ; $01B9E1 |\ Store the MP cost in a 16-bit variable.
    STA <r_menu_generic_tmp_offset.lo                                           ; $01B9E4 |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $01B9E6 |\
    LDA character_field.mp.w,X                                                  ; $01B9E8 | | Subtract the spell MP cost from the character's current MP.
    SEC                                                                         ; $01B9EB | |
    SBC <r_menu_generic_tmp_offset                                              ; $01B9EC | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01B9EE |/
    RTS                                                                         ; $01B9F0

; _menu_namingway ($01:B9F1)
;
; Main entry point for the Namingway menu.
_menu_namingway:
    PHB                                                                         ; $01B9F1 |\ Preserve the data bank and direct registers.
    PHD                                                                         ; $01B9F2 |/
    JSR _menu_backup_vram_tiles                                                 ; $01B9F3 | Backup the VRAM tiles that the menu may overwrite.
    JSR _menu_namingway_core                                                    ; $01B9F6 | Run the core Namingway menu.
    JSR _menu_restore_vram_tiles                                                ; $01B9F9 | Restore the backed up VRAM tiles.
    TDC                                                                         ; $01B9FC |\ Zero out the Namingway layout flag.
    STA r_menu_namingway_use_namingway_layout.l & $FFFF                         ; $01B9FD |/
    XBA                                                                         ; $01BA01 | Zero out the high byte of the accumulator.
    PLD                                                                         ; $01BA02 |\ Restore the direct and data bank registers.
    PLB                                                                         ; $01BA03 |/
    RTS                                                                         ; $01BA04

; _menu_namingway_core ($01:BA05)
;
; Core routine for the Namingway menu.
_menu_namingway_core:
    JSR _menu_init                                                              ; $01BA05 | Initialize the menu system.
    LDA #$7E.b                                                                  ; $01BA08 |\
    PHA                                                                         ; $01BA0A | | Set the data bank register to $7E.
    PLB                                                                         ; $01BA0B |/
    INC r_menu_namingway_use_namingway_layout.w                                 ; $01BA0C | Set the flag to use the Namingway layout for the naming screen.
    JSR _menu_set_current_tilemap_bg4                                           ; $01BA0F | Set the currently active tilemap to BG4.
    JSR _menu_initialize_tilemaps                                               ; $01BA12 | Initialize the menu tilemaps.
    JSR _menu_initialize_oam                                                    ; $01BA15 | Initialize the menu OAM.
    LDY #menu_window_namingway_dialog_data.w                                    ; $01BA18 |\ Display the window used for Namingway's dialog.
    JSR _menu_configure_and_draw_window                                         ; $01BA1B |/
    LDY #menu_window_namingway_yes_no_data.w                                    ; $01BA1E |\ Display the window used for the Yes and No options, as well as the
    JSR _menu_draw_text_indirect_plus_window                                    ; $01BA21 |/ starting dialog for the dialog window.
    LDX #(4 * 2 + 6 * 2 * 32).w                                                 ; $01BA24 |\
    LDY #menu_text_namingway_yes_no_data.w                                      ; $01BA27 | | Draw the Yes and No options to the window.
    JSR _menu_expand_tiles_to_tilemap                                           ; $01BA2A |/
    JSR _menu_load_character_sprites                                            ; $01BA2D | Load the character sprites.
    JSR _menu_save_update_character_sprites                                     ; $01BA30 | Initialize the OAM (and do some other things that will be redone).
    JSR _menu_namingway_update_character_sprites                                ; $01BA33 | Update the character sprites.
    LDA #$FF.b                                                                  ; $01BA36 |\ Initialize the character slot to $FF, as no character is currently
    STA r_menu_namingway_character_slot.w                                       ; $01BA38 |/ selected.
    JSR _menu_copy_tilemap_to_vram_bg4_no_vblank                                ; $01BA3B | Copy the BG4 tilemap to VRAM.
    JSR _menu_namingway_draw_portrait                                           ; $01BA3E | Draw the Namingway portrait.
    JSR _menu_copy_oam_to_ppu                                                   ; $01BA41 | Copy the OAM to the PPU.
    JSR _menu_copy_palette_to_cgram                                             ; $01BA44 | Copy the palette data to CG-RAM.
    JSR _menu_ppu_fade_in                                                       ; $01BA47 | Fade the PPU in.
    STZ r_menu_namingway_command_index.w                                        ; $01BA4A | Initialize the command index to zero.
@loop_start:
    LDA r_menu_namingway_command_index.w                                        ; $01BA4D |\
    BNE +                                                                       ; $01BA50 | | Set the X register to the coordinates for the command cursor,
    LDX #(16 + (48 << 8)).w                                                     ; $01BA52 | | depending on the current value of the command index.
    BRA ++                                                                      ; $01BA55 | |
+   LDX #(64 + (48 << 8)).w                                                     ; $01BA57 |/
++  TDC                                                                         ; $01BA5A |\
    LDY #r_oam.1.w                                                              ; $01BA5B | | Draw the cursor to the first OAM entry.
    JSR _menu_draw_cursor_direct                                                ; $01BA5E |/
    JSR _menu_namingway_update_character_sprites                                ; $01BA61 | Update the character sprites for this frame.
    JSR _menu_wait_for_vblank_copy_oam_to_ppu                                   ; $01BA64 | Wait for the next vblank and copy the OAM to the PPU.
    JSR _menu_copy_tilemap_to_vram_bg4_no_vblank                                ; $01BA67 | Copy the BG4 tilemap to VRAM.
    JSR _menu_update_joypad_and_play_sound_effect                               ; $01BA6A | Update the joypad values and play a sound effect if appropriate.
    LDA <r_menu_joypad_repeat.lo                                                ; $01BA6D |\
    AND #JOYPAD_L_A.b                                                           ; $01BA6F | | If the A button is pressed, and the command index is set to zero,
    BEQ ++                                                                      ; $01BA71 | | zero out the joypad values, and jump to the character selection
    LDA r_menu_namingway_command_index.w                                        ; $01BA73 | | menu code. If the command index is one, branch to the completion
    BNE +                                                                       ; $01BA76 | | code.
    STZ <r_menu_joypad_repeat.lo                                                ; $01BA78 | |
    STZ <r_menu_joypad_repeat.hi                                                ; $01BA7A | |
    JMP _menu_namingway_character_selection                                     ; $01BA7C | |
+   BRA __menu_namingway_core_complete                                          ; $01BA7F |/
++  LDA <r_menu_joypad_repeat.hi                                                ; $01BA81 |\
    AND #JOYPAD_H_B.b                                                           ; $01BA83 | | If the B button is pressed, jump to the completion code.
    BNE __menu_namingway_core_complete                                          ; $01BA85 |/
    LDA <r_menu_joypad_repeat.hi                                                ; $01BA87 |\
    AND #(JOYPAD_H_LEFT | JOYPAD_H_RIGHT).b                                     ; $01BA89 | | If either the left or right button is pressed, flip the command
    BEQ +                                                                       ; $01BA8B | | index between 0 and 1.
    INC r_menu_namingway_command_index.w                                        ; $01BA8D | |
    LDA r_menu_namingway_command_index.w                                        ; $01BA90 | |
    AND #%00000001.b                                                            ; $01BA93 | |
    STA r_menu_namingway_command_index.w                                        ; $01BA95 |/
+   JMP @loop_start                                                             ; $01BA98 | Jump back to the next iteration of the loop.
__menu_namingway_core_complete:
    LDY #menu_window_namingway_dialog_data.w                                    ; $01BA9B |\ Draw the window used for Namingway dialog.
    JSR _menu_configure_and_draw_window                                         ; $01BA9E |/
    LDY #menu_text_namingway_very_well_data.w                                   ; $01BAA1 |\ Draw the "Very well." message.
    JSR _menu_draw_text_indirect                                                ; $01BAA4 |/
    JSR _menu_wait_for_vblank                                                   ; $01BAA7 | Wait for vblank.
    JSR _menu_copy_tilemap_to_vram_bg4_no_vblank                                ; $01BAAA | Copy the BG4 tilemap to VRAM.
    JSR _menu_wait_for_input                                                    ; $01BAAD | Wait for input.
    JMP _menu_ppu_fade_out                                                      ; $01BAB0 | Fade out the PPU and return.

; _menu_namingway_update_character_sprites ($01:BAB3)
;
; Updates the character sprites for the Namingway screen.
_menu_namingway_update_character_sprites:
    JSR _menu_character_sprite_set_first_poses_normal                           ; $01BAB3 | Set the first pose for each slot to normal.
    LDA r_menu_namingway_character_slot.w                                       ; $01BAB6 |\
    BMI +                                                                       ; $01BAB9 | | If a character slot is currently set, change the pose for that
    STA <r_menu_generic_tmp_offset.lo                                           ; $01BABB | | slot to the cheering pose.
    REP #FLAG_P_ACCUMULATOR                                                     ; $01BABD | |
    LDA <r_menu_generic_tmp_offset                                              ; $01BABF | |
    ASL A                                                                       ; $01BAC1 | |
    TAX                                                                         ; $01BAC2 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01BAC3 | |
    LDA #MENU_POSE_CHEERING.b                                                   ; $01BAC5 | |
    STA r_menu_character_sprite_pose.1.lo.w,X                                   ; $01BAC7 |/
+   LDX #(136 + (37 << 8)).w                                                    ; $01BACA |\ Update the character sprites starting at 136, 37.
    JMP _menu_namingway_draw_character_sprites                                  ; $01BACD |/

; _menu_namingway_character_selection ($01:BAD0)
;
; Part of the Namingway menu that allows the player to select which character
; they are naming. Note that this odd routine is not meant to be called by JSR,
; but rather by JMP. It either returns to the core Namingway routine, or returns
; to the routine that calls it, by jumping to the PPU fade out routine.
_menu_namingway_character_selection:
    STZ <r_menu_generic_tmp_count                                               ; $01BAD0 | Initialize the slot number to zero.
-   LDA <r_menu_generic_tmp_count                                               ; $01BAD2 |\
    JSR _menu_get_character_id                                                  ; $01BAD4 | | Loop until finding a character slot that isn't empty. Branch ahead
    BNE +                                                                       ; $01BAD7 | | if found.
    INC <r_menu_generic_tmp_count                                               ; $01BAD9 | |
    LDA <r_menu_generic_tmp_count                                               ; $01BADB | | NOTE: If the party is empty (not actually possible), this will
    CMP #5.b                                                                    ; $01BADD | |       fall into an infinite loop. The final two instructions seem
    BNE -                                                                       ; $01BADF | |       pointless, since those should never trigger in normal
    STZ <r_menu_generic_tmp_count                                               ; $01BAE1 | |       conditions.
    BRA -                                                                       ; $01BAE3 |/
+   LDA <r_menu_generic_tmp_count                                               ; $01BAE5 |\ Set the current character slot to the found non-empty slot.
    STA r_menu_namingway_character_slot.w                                       ; $01BAE7 |/
    LDA #1.b                                                                    ; $01BAEA |\ Initially set the frame change delay to 1 to cause an immediate
    STA r_menu_shop_character_sprites_frame_change_delay.w                      ; $01BAEC |/ change.
    LDY #menu_window_namingway_dialog_data.w                                    ; $01BAEF |\ Draw the Namingway dialog window.
    JSR _menu_configure_and_draw_window                                         ; $01BAF2 |/
    LDY #menu_text_namingway_whose_name_data.w                                  ; $01BAF5 |\ Draw the "Whose name?" dialog text.
    JSR _menu_draw_text_indirect                                                ; $01BAF8 |/
    LDY #menu_window_namingway_name_data.w                                      ; $01BAFB |\ Draw the window used for the character names.
    JSR _menu_configure_and_draw_window                                         ; $01BAFE |/
.if FF4_VERSION == "JAPAN_EASYTYPE"
    JSR _menu_copy_tilemap_to_vram_bg4                                          ; $01BB2A | Copy the BG4 tilemap to VRAM.
.else
    JSR _menu_wait_for_vblank                                                   ; $01BB01 | Wait for vblank.
    JSR _menu_copy_tilemap_to_vram_bg4_no_vblank                                ; $01BB04 | Copy the BG4 tilemap to VRAM.
.endif
@loop_start:
    JSR _menu_namingway_update_character_sprites                                ; $01BB07 | Update the character sprites.
    LDA r_menu_namingway_character_slot.w                                       ; $01BB0A |\
    JSR _menu_get_character_field_offset                                        ; $01BB0D | | Draw the name of the currently selected character to the tilemap.
    STX <r_menu_generic_tmp_offset_2                                            ; $01BB10 | |
    LDA (<r_menu_generic_tmp_offset_2)                                          ; $01BB12 | |
    LDY #(9 * 2 + 5 * 32 * 2).w                                                 ; $01BB14 | |
    JSR _menu_draw_character_name                                               ; $01BB17 |/
    JSR _menu_copy_tilemap_to_vram_bg4                                          ; $01BB1A | Copy the BG4 tilemap to VRAM, which also waits for vblank.
    JSR _menu_copy_oam_to_ppu                                                   ; $01BB1D | Copy the OAM to the PPU.
    JSR _menu_update_joypad_and_play_sound_effect                               ; $01BB20 | Update the joypad and play a sound effect if appropriate.
    LDA <r_menu_joypad_repeat.hi                                                ; $01BB23 |\
    AND #JOYPAD_H_RIGHT.b                                                       ; $01BB25 | | Branch ahead unless the right d-pad button is pressed.
    BEQ ++                                                                      ; $01BB27 |/
-   LDA #1.b                                                                    ; $01BB29 |\ Set the character sprite frame change delay to 1 so they'll be
    STA r_menu_shop_character_sprites_frame_change_delay.w                      ; $01BB2B |/ immediately updated.
    LDA r_menu_namingway_character_slot.w                                       ; $01BB2E |\
    INC A                                                                       ; $01BB31 | | Increment the selected character slot, and if it reaches five,
    CMP #5.b                                                                    ; $01BB32 | | set it back to zero to wrap around.
    BNE +                                                                       ; $01BB34 | |
    TDC                                                                         ; $01BB36 | |
+   STA r_menu_namingway_character_slot.w                                       ; $01BB37 |/
    JSR _menu_get_character_field_offset                                        ; $01BB3A |\
    STX <r_menu_generic_tmp_word                                                ; $01BB3D | | If the newly selected slot is empty, loop back to increment the
    LDA (<r_menu_generic_tmp_word)                                              ; $01BB3F | | slot again.
    AND #%00111111.b                                                            ; $01BB41 | |
    BEQ -                                                                       ; $01BB43 |/
++  LDA <r_menu_joypad_repeat.hi                                                ; $01BB45 |\
    AND #JOYPAD_H_LEFT.b                                                        ; $01BB47 | | Branch ahead unless the left d-pad button is pressed.
    BEQ ++                                                                      ; $01BB49 |/
-   LDA #$01.b                                                                  ; $01BB4B |\ Set the character sprite frame change delay to 1 so they'll be
    STA r_menu_shop_character_sprites_frame_change_delay.w                      ; $01BB4D |/ immediately updated.
    LDA r_menu_namingway_character_slot.w                                       ; $01BB50 |\
    DEC A                                                                       ; $01BB53 | | Decrement the selected character slot, and if it goes negative,
    BPL +                                                                       ; $01BB54 | | set it to four to wrap around.
    LDA #4.b                                                                    ; $01BB56 | |
+   STA r_menu_namingway_character_slot.w                                       ; $01BB58 |/
    JSR _menu_get_character_field_offset                                        ; $01BB5B |\
    STX <r_menu_generic_tmp_word                                                ; $01BB5E | | If the newly selected slot is empty, loop back to decrement the
    LDA (<r_menu_generic_tmp_word)                                              ; $01BB60 | | slot again.
    AND #%00111111.b                                                            ; $01BB62 | |
    BEQ -                                                                       ; $01BB64 |/
++  LDA <r_menu_joypad_repeat.lo                                                ; $01BB66 |\
    AND #JOYPAD_L_A.b                                                           ; $01BB68 | | If the A button is pressed, run the menu to change the selected
    BEQ +                                                                       ; $01BB6A | | character's name.
    JMP _menu_namingway_change_name                                             ; $01BB6C |/
+   LDA <r_menu_joypad_repeat.hi                                                ; $01BB6F |\
    AND #JOYPAD_H_B.b                                                           ; $01BB71 | | If the B button is pressed, jump back to the completion code of
    BEQ +                                                                       ; $01BB73 | | the core Namingway routine.
    JMP __menu_namingway_core_complete                                          ; $01BB75 |/
+   JMP @loop_start                                                             ; $01BB78 | Run the next iteration of the loop.

; _menu_namingway_change_name ($01:BB7B)
;
; Given a character slot in $1B4A, presents a menu to the player that allows
; them to change the character's name. Part of the Namingway menu subsystem.
_menu_namingway_change_name:
    LDA r_menu_namingway_character_slot.w                                       ; $01BB7B |\
    JSR _menu_get_character_id                                                  ; $01BB7E | | Get the name index for the selected character slot and save it to
    DEC A                                                                       ; $01BB81 | | a temporary variable.
    JSR _menu_transfer_a_to_x                                                   ; $01BB82 | |
    LDA character_id_to_name_index_data.l,X                                     ; $01BB85 | |
    STA <r_menu_generic_tmp_offset.lo                                           ; $01BB89 |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $01BB8B |\
    LDA <r_menu_generic_tmp_offset                                              ; $01BB8D | | Set the X register to the offset to the selected character's name.
    ASL A                                                                       ; $01BB8F | |
    STA <r_menu_generic_tmp_word                                                ; $01BB90 | |
    ASL A                                                                       ; $01BB92 | |
    ADC <r_menu_generic_tmp_word                                                ; $01BB93 | |
    ADC #r_character_names.w                                                    ; $01BB95 | |
    TAX                                                                         ; $01BB98 |/
    LDA #(6 - 1).w                                                              ; $01BB99 |\
    LDY #r_menu_namingway_name_new.w                                            ; $01BB9C | | Copy the character's name to the Namingway name area.
    PHY                                                                         ; $01BB9F | |
    PHX                                                                         ; $01BBA0 | |
    MVN :r_character_names,:r_menu_namingway_name_new                           ; $01BBA1 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01BBA4 |/
    JSR _menu_namingway_name_change_menu_run                                    ; $01BBA6 | Execute the name change menu.
    PLY                                                                         ; $01BBA9 |\ Restore the X and Y registers, in the opposite order (to flip the
    PLX                                                                         ; $01BBAA |/ locations).
    REP #FLAG_P_ACCUMULATOR                                                     ; $01BBAB |\
    LDA #(6 - 1).w                                                              ; $01BBAD | | Copy the new name back to the character name area in memory.
    MVN :r_menu_namingway_name_new,:r_character_names                           ; $01BBB0 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01BBB3 |/
    RTS                                                                         ; $01BBB5

; _menu_namingway_draw_portrait ($01:BBB6)
;
; Draws the portrait of Namingway to the screen.
_menu_namingway_draw_portrait:
    REP #FLAG_P_ACCUMULATOR                                                     ; $01BBB6 |\
    LDA #_sizeof_palette.w / 2 - 1                                              ; $01BBB8 | | Copy the palette to the CG-RAM mirror in RAM.
    LDX #bank0D.namingway_portrait_palette_data.w                               ; $01BBBB | |
    LDY #r_menu_cgram_data.10.w                                                 ; $01BBBE | |
    MVN :bank0D.namingway_portrait_palette_data.b,:r_menu_cgram_data.b          ; $01BBC1 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01BBC4 |/
    LDY #bank1B.field_sprite_portrait_namingway_data.w                          ; $01BBC6 |\ Load and display the Namingway portrait.
    JMP _menu_load_portrait                                                     ; $01BBC9 |/

; _menu_command_equip ($01:BBCC)
;
; Handler for the Equip command on the main menu.
_menu_command_equip:
    INC r_menu_equip_active.w                                                   ; $01BBCC | Set the equip active flag.
    STZ r_menu_character_selection_change_enabled.w                             ; $01BBCF |\ Disable the ability to change party formation and select a
    JSR _menu_select_character                                                  ; $01BBD2 |/ character.
    LDA <r_menu_current_selected_character_slot                                 ; $01BBD5 |\
    BPL +                                                                       ; $01BBD7 | | If no character was selected, reset the equip active flag and
    STZ r_menu_equip_active.w                                                   ; $01BBD9 | | return.
    RTS                                                                         ; $01BBDC |/
+   STZ r_menu_equip_initialization_complete.w                                  ; $01BBDD | Reset the initialization complete flag.
    JSR _menu_initialize_oam                                                    ; $01BBE0 | Initialize the OAM.
    JSR _menu_init_bg_scroll                                                    ; $01BBE3 | Initialize the background scroll values.
    LDA #%00110000.b                                                            ; $01BBE6 |\
    STA <r_menu_character_sprite_base_tile_flags                                ; $01BBE8 | | Set the character sprite and cursor tile flags for priority 3.
    STA <r_menu_cursor_sprite_flags                                             ; $01BBEA |/
    LDA <r_menu_current_selected_character_slot                                 ; $01BBEC |\ Copy the selected character slot into the portrait transition
    STA <r_menu_portrait_transition_character_slot                              ; $01BBEE |/ variable.
    JSR _menu_party_draw_character_portrait                                     ; $01BBF0 | Draw the character portrait.
    JSR _menu_wait_for_vblank_copy_oam_to_ppu                                   ; $01BBF3 | Wait for vblank and copy the OAM to the PPU.
    LDA <r_menu_current_selected_character_slot                                 ; $01BBF6 |\
    JSR _menu_party_get_portrait_coordinates                                    ; $01BBF8 | | Set the initial coordinates of the character portrait.
    REP #FLAG_P_ACCUMULATOR                                                     ; $01BBFB | |
    TYA                                                                         ; $01BBFD | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01BBFE | |
    STA <r_menu_portrait_transition_coordinates.x.value                         ; $01BC00 | |
    XBA                                                                         ; $01BC02 | |
    STA <r_menu_portrait_transition_coordinates.y.value                         ; $01BC03 | |
    STZ <r_menu_portrait_transition_coordinates.x.fraction                      ; $01BC05 | |
    STZ <r_menu_portrait_transition_coordinates.y.fraction                      ; $01BC07 |/
    LDA #%01111001.b                                                            ; $01BC09 |\ Set the BG4 tilemap address to $7800 and the size to 64x32.
    STA reg_ppu_bg4sc.l                                                         ; $01BC0B |/
    LDA #2.b + %10000000                                                        ; $01BC0F |\ Set BG4 to move to the right by 2 pixels per frame.
    STA <r_menu_scroll_delta_bg4.horizontal.value.lo                            ; $01BC11 |/
    LDA #40.b                                                                   ; $01BC13 |\
    STA <r_menu_transition_scroll_frames                                        ; $01BC15 | | Set the transition to last 40 frames.
    STA <r_menu_portrait_transition_frames_remaining                            ; $01BC17 |/
    LDA <r_menu_current_selected_character_position                             ; $01BC19 |\ Set BG3 to scroll vertically at a rate according to the selected
    STA <r_menu_scroll_delta_bg3.vertical.value.lo                              ; $01BC1B |/ character position.
    STA <r_menu_portrait_transition_delta.y.value                               ; $01BC1D | Set the portrait to scroll vertically at the same rate.
    LDX #_menu_portrait_transition_update.w                                     ; $01BC1F |\
    STX <r_menu_window_transition_custom_function_1.address                     ; $01BC22 | | Set the custom transition functions to handle updating the
    LDX #_menu_copy_oam_to_ppu                                                  ; $01BC24 | | portrait and copying it to the PPU.
    STX <r_menu_window_transition_custom_function_2.address                     ; $01BC27 |/
    JSR _menu_set_current_tilemap_bg3_and_initialize                            ; $01BC29 | Set the current tilemap to BG3 and clear it.
    JSR _menu_party_draw_selected_character_stats                               ; $01BC2C | Draw the stats for the selected character.
    JSR _menu_copy_tilemap_to_vram_bg3                                          ; $01BC2F | Copy the BG3 tilemap to VRAM.
    LDA <r_menu_current_selected_character_position                             ; $01BC32 |\
    ASL A                                                                       ; $01BC34 | | Set the X register to the offset for the character stats window
    STA <r_menu_generic_tmp_offset.lo                                           ; $01BC35 | | for the selected slot.
    LDX <r_menu_generic_tmp_offset                                              ; $01BC37 | |
    REP #FLAG_P_ACCUMULATOR                                                     ; $01BC39 | |
    LDA menu_window_equip_character_stats_position_offset_data.l,X              ; $01BC3B | |
    TAX                                                                         ; $01BC3F | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01BC40 |/
    LDY #menu_window_party_details_data.w                                       ; $01BC42 | Set the Y register to the offset for the party details window.
    PHX                                                                         ; $01BC45 |\ Preserve the X and Y register for later use.
    PHY                                                                         ; $01BC46 |/
    JSR _menu_window_transition                                                 ; $01BC47 | Animate the transition.
    JSR _menu_equip_core                                                        ; $01BC4A | Execute the core equip menu.
    LDA <r_menu_current_selected_character_slot                                 ; $01BC4D |\ Calculate the character stats for the equipped character.
    JSL bank03.calculate_character_stats                                        ; $01BC4F |/
    JSR _menu_erase_cursor_2                                                    ; $01BC53 | Erase the second cursor.
    JSR _menu_initialize_tilemap_bg4                                            ; $01BC56 | Initialize BG4.
    JSR _menu_copy_tilemap_to_vram_bg4                                          ; $01BC59 | Copy the BG4 tilemap to VRAM.
    REP #FLAG_P_ACCUMULATOR                                                     ; $01BC5C |\
    LDX #r_menu_equip_tilemap_backup.w                                          ; $01BC5E | | Restore the backed up tilemap data to BG4.
    LDY #r_menu_tilemap_bg4.w                                                   ; $01BC61 | |
    LDA #_sizeof_r_menu_equip_tilemap_backup.w - 1                              ; $01BC64 | |
    MVN :r_menu_equip_tilemap_backup,:r_menu_tilemap_bg4                        ; $01BC67 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01BC6A |/
    LDA #%01111001.b                                                            ; $01BC6C |\ Set the BG4 tilemap address to $7800 and the size to 64x32.
    STA reg_ppu_bg4sc.l                                                         ; $01BC6E |/
    JSR _menu_set_current_tilemap_bg3                                           ; $01BC72 | Set the current tilemap to BG3.
    JSR _menu_initialize_tilemap_bg2                                            ; $01BC75 |\ Clear the BG1 and BG2 tilemaps.
    JSR _menu_initialize_tilemap_bg1                                            ; $01BC78 |/
    LDX #-80.w                                                                  ; $01BC7B |\ Set the BG4 horizontal scroll value to -80, to reposition the
    STX <r_menu_scroll_bg4.horizontal.value                                     ; $01BC7E |/ command menu just off the right side of the screen.
    LDX <r_menu_zero                                                            ; $01BC80 |\ Set the BG4 vertical scroll to zero.
    STX <r_menu_scroll_bg4.vertical.value                                       ; $01BC82 |/
    JSR _menu_copy_tilemap_to_vram_bg4                                          ; $01BC84 | Copy the BG4 tilemap to VRAM.
    JSR _menu_set_bg_scroll_proxy                                               ; $01BC87 | Set the background scroll values.
    LDX #2048.w                                                                 ; $01BC8A |\
    STX <r_menu_copy_tilemap_to_vram_arg_bytes                                  ; $01BC8D | | Copy 2048 bytes of the BG2 tilemap to VRAM. (One 32x32 section).
    JSR _menu_copy_tilemap_to_vram_bg2                                          ; $01BC8F |/
    JSR _menu_copy_tilemap_to_vram_bg1_no_vblank                                ; $01BC92 | Copy 2048 bytes of the BG1 tilemap to VRAM.
    LDX #_sizeof_r_menu_tilemap_bg1.w                                           ; $01BC95 |\ Reset the tilemap VRAM transfer value to the full size of each
    STX <r_menu_copy_tilemap_to_vram_arg_bytes                                  ; $01BC98 |/ tilemap.
    LDA #2.b                                                                    ; $01BC9A |\ Set BG4 to scroll to the left by 2 pixels per frame.
    STA <r_menu_scroll_delta_bg4.horizontal.value.lo                            ; $01BC9C |/
    LDA <r_menu_current_selected_character_position                             ; $01BC9E |\
    ORA #%10000000.b                                                            ; $01BCA0 | | Set BG3 and the character portrait to scroll downward at a rate
    STA <r_menu_scroll_delta_bg3.vertical.value.lo                              ; $01BCA2 | | depending on the character position.
    STA <r_menu_portrait_transition_delta.y.value                               ; $01BCA4 |/
    LDA #40.b                                                                   ; $01BCA6 |\
    STA <r_menu_transition_scroll_frames                                        ; $01BCA8 | | Set the transition to take 40 frames.
    STA <r_menu_portrait_transition_frames_remaining                            ; $01BCAA |/
    LDX #_menu_portrait_transition_update.w                                     ; $01BCAC |\
    STX <r_menu_window_transition_custom_function_1.address                     ; $01BCAF | | Set the transition custom functions to update the portrait and
    LDX #_menu_copy_oam_to_ppu                                                  ; $01BCB1 | | transfer it to the PPU.
    STX <r_menu_window_transition_custom_function_2.address                     ; $01BCB4 |/
    JSR _menu_erase_cursor_1                                                    ; $01BCB6 | Erase the first cursor.
    PLX                                                                         ; $01BCB9 |\ Restore the window offsets used in the transition, except
    PLY                                                                         ; $01BCBA |/ reversed.
    JSR _menu_window_transition                                                 ; $01BCBB | Animate the window transition.
    LDA #%01111010.b                                                            ; $01BCBE |\ Set BG4 to 32x64 with the tilemap address at $7800.
    STA reg_ppu_bg4sc.l                                                         ; $01BCC0 |/
    JSR _menu_main_draw                                                         ; $01BCC4 | Draw the main menu.
    JSR _menu_copy_tilemap_to_vram_bg3                                          ; $01BCC7 | Copy the BG3 tilemap to VRAM.
    STZ r_menu_equip_active.w                                                   ; $01BCCA | Reset the equip active bit.
    RTS                                                                         ; $01BCCD

; _menu_equip_core ($01:BCCE)
;
; Core routine for handling the input of the equip menu.
_menu_equip_core:
    JSR _menu_set_current_tilemap_bg2_and_initialize                            ; $01BCCE | Set the current itlemap to BG2 and clear it.
    LDA r_menu_equip_initialization_complete.w                                  ; $01BCD1 |\
    BNE +                                                                       ; $01BCD4 | | If the initialization complete flag is not set, copy the the newly
    REP #FLAG_P_ACCUMULATOR                                                     ; $01BCD6 | | clear data from the BG2 tilemap to the backup area to clear it as
    LDX #r_menu_tilemap_bg2.w                                                   ; $01BCD8 | | well. The backup area's size is 2048 bytes, or enough for one
    LDY #r_menu_equip_tilemap_backup.w                                          ; $01BCDB | | 32x32 section of the tilemap.
    LDA #_sizeof_r_menu_equip_tilemap_backup.w - 1                              ; $01BCDE | |
    MVN :r_menu_tilemap_bg2,:r_menu_equip_tilemap_backup                        ; $01BCE1 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01BCE4 |/
+   LDY #menu_window_equip_equipment_data                                       ; $01BCE6 |\ Draw the window for listing the character's currently selected
    JSR _menu_draw_text_indirect_plus_window                                    ; $01BCE9 |/ equipment and relevant stats.
    LDA <r_menu_current_selected_character_slot                                 ; $01BCEC |\
    JSR _menu_get_character_field_offset                                        ; $01BCEE | | Store the offset to the character's stat record.
    STX <r_menu_selected_character_offset                                       ; $01BCF1 |/
    LDA <r_menu_current_selected_character_slot                                 ; $01BCF3 |\ Calculate updated stats for the character in question.
    JSL bank03.calculate_character_stats                                        ; $01BCF5 |/
    LDY #character_field.physical_attack_base.w                                 ; $01BCF9 |\
    LDA (<r_menu_selected_character_offset),Y                                   ; $01BCFC | | Draw the character's physical attack base to 7, 2. The Japanese
.if FF4_REGION == "JAPAN"                                                       ;         | | version draws to 8, 2.
    LDY #(8 * 2) + (2 * 32 * 2).w                                               ; $01BD27 | |
.else                                                                           ;         | |
    LDY #(7 * 2) + (2 * 32 * 2).w                                               ; $01BCFE | |
.endif                                                                          ;         | |
    JSR _menu_draw_four_digit_number_8bit                                       ; $01BD01 |/
    LDY #character_field.physical_defense_base.w                                ; $01BD04 |\
    LDA (<r_menu_selected_character_offset),Y                                   ; $01BD07 | | Draw the character's physical defense base to 7, 4. The Japanese
.if FF4_REGION == "JAPAN"                                                       ;         | | version draws to 8, 4.
    LDY #(8 * 2) + (4 * 32 * 2).w                                               ; $01BD32 | |
.else                                                                           ;         | |
    LDY #(7 * 2) + (4 * 32 * 2).w                                               ; $01BD09 | |
.endif                                                                          ;         | |
    JSR _menu_draw_four_digit_number_8bit                                       ; $01BD0C |/
    LDY #character_field.magic_defense_base.w                                   ; $01BD0F |\
    LDA (<r_menu_selected_character_offset),Y                                   ; $01BD12 | | Draw the character's magic defense base to 7, 6. The Japanese
.if FF4_REGION == "JAPAN"                                                       ;         | | version draws to 8, 6.
    LDY #(8 * 2) + (6 * 32 * 2).w                                               ; $01BD3D | |
.else                                                                           ;         | |
    LDY #(7 * 2) + (6 * 32 * 2).w                                               ; $01BD14 | |
.endif                                                                          ;         | |
    JSR _menu_draw_four_digit_number_8bit                                       ; $01BD17 |/
    LDA #TEXT_ICON_KATANA.b                                                     ; $01BD1A |\
.if FF4_REGION == "JAPAN"                                                       ;         | | Draw a katana icon to 7, 2. The Japanese version draws to 8, 2.
    STA r_menu_tilemap_bg2.w + (8 * 2) + (2 * 32 * 2)                           ; $01BD45 | |
.else                                                                           ;         | |
    STA r_menu_tilemap_bg2.w + (7 * 2) + (2 * 32 * 2)                           ; $01BD1C | |
.endif                                                                          ;         |/
    LDA #TEXT_ICON_SHIELD.b                                                     ; $01BD1F |\
.if FF4_REGION == "JAPAN"                                                       ;         | | Draw a shield icon to 7, 4. The Japanese version draws to 8, 4.
    STA r_menu_tilemap_bg2.w + (8 * 2) + (4 * 32 * 2)                           ; $01BD21 | |
.else                                                                           ;         | |
    STA r_menu_tilemap_bg2.w + (7 * 2) + (4 * 32 * 2)                           ; $01BD21 | |
.endif                                                                          ;         |/
    LDA #TEXT_ICON_CALL_MAGIC.b                                                 ; $01BD24 |\
.if FF4_REGION == "JAPAN"                                                       ;         | | Draw the call magic icon to 7, 6. The Japanese version draws to
    STA r_menu_tilemap_bg2.w + (8 * 2) + (6 * 32 * 2)                           ; $01BD26 | | 8, 6.
.else                                                                           ;         | |
    STA r_menu_tilemap_bg2.w + (7 * 2) + (6 * 32 * 2)                           ; $01BD26 | |
.endif                                                                          ;         |/
    LDA (<r_menu_selected_character_offset)                                     ; $01BD29 |\
    LDY #(3 * 2) + (7 * 32 * 2).w                                               ; $01BD2B | | Draw the character's name to 3, 7.
    JSR _menu_draw_character_name                                               ; $01BD2E |/
    LDA (<r_menu_selected_character_offset)                                     ; $01BD31 |\
    AND #%11000000.b                                                            ; $01BD33 | | Draw the handedness of the character to 4, 9.
    LSR A                                                                       ; $01BD35 | |
    LSR A                                                                       ; $01BD36 | |
    LSR A                                                                       ; $01BD37 | |
    STA <r_menu_generic_tmp_word.lo                                             ; $01BD38 | |
    STZ <r_menu_generic_tmp_word.hi                                             ; $01BD3A | |
    REP #FLAG_P_ACCUMULATOR                                                     ; $01BD3C | |
    LDA #menu_text_equip_handedness_data.w                                      ; $01BD3E | |
    CLC                                                                         ; $01BD41 | |
    ADC <r_menu_generic_tmp_word                                                ; $01BD42 | |
    TAY                                                                         ; $01BD44 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01BD45 | |
    LDX #(4 * 2) + (9 * 32 * 2).w                                               ; $01BD47 | |
    JSR _menu_draw_text_direct                                                  ; $01BD4A |/
    STZ <r_menu_current_tilemap_extra_tile_flags                                ; $01BD4D | Set the extra tilemap flags to zero.
    LDY #character_field.armor_head.w                                           ; $01BD4F |\
    LDX #(18 * 2) + (5 * 32 * 2).w                                              ; $01BD52 | | Draw the currently equipped head armor to 18, 5.
    JSR _menu_draw_item_name_equipped                                           ; $01BD55 | |
    INY                                                                         ; $01BD58 |/
    LDX #(18 * 2) + (7 * 32 * 2).w                                              ; $01BD59 |\
    JSR _menu_draw_item_name_equipped                                           ; $01BD5C | | Draw the currently equipped body armor to 18, 7.
    INY                                                                         ; $01BD5F |/
    LDX #(18 * 2) + (9 * 32 * 2).w                                              ; $01BD60 |\ Draw the currently equipped arms to 18, 9.
    JSR _menu_draw_item_name_equipped                                           ; $01BD63 |/
    LDY #character_field.right_hand_item.w                                      ; $01BD66 |\
    LDX #(18 * 2) + (1 * 32 * 2).w                                              ; $01BD69 | | Draw the item in the right hand to 18, 1.
    JSR _menu_draw_item_name_equipped                                           ; $01BD6C | |
    INY                                                                         ; $01BD6F |/
    LDA (<r_menu_selected_character_offset),Y                                   ; $01BD70 |\
    CMP #2.b                                                                    ; $01BD72 | | If the count of the item is 2 or more, draw the count of the item
    BCC +                                                                       ; $01BD74 | | to 27, 2.
    PHY                                                                         ; $01BD76 | |
    LDY #(27 * 2) + (2 * 32 * 2).w                                              ; $01BD77 | |
    JSR _menu_draw_two_digit_number                                             ; $01BD7A | |
    PLY                                                                         ; $01BD7D | |
+   INY                                                                         ; $01BD7E |/
    LDX #(18 * 2) + (3 * 32 * 2)                                                ; $01BD7F |\
    JSR _menu_draw_item_name_equipped                                           ; $01BD82 | | Draw the equipped left hand item to 18, 3.
    INY                                                                         ; $01BD85 |/
    LDA (<r_menu_selected_character_offset),Y                                   ; $01BD86 |\
    CMP #2.b                                                                    ; $01BD88 | | If the count of that item is 2 or more, draw the count to 27, 4.
    BCC +                                                                       ; $01BD8A | |
    LDY #(27 * 2) + (4 * 32 * 2).w                                              ; $01BD8C | |
    JSR _menu_draw_two_digit_number                                             ; $01BD8F |/
+   LDA r_menu_equip_initialization_complete.w                                  ; $01BD92 |\ If initialization is flagged as complete, skip the next section.
    BNE +                                                                       ; $01BD95 |/
    JSR _menu_set_current_tilemap_bg1                                           ; $01BD97 |\
    LDY #menu_window_equip_equipment_data.w                                     ; $01BD9A | | Set the current tilemap to BG1, draw a blank copy of the equipment
    JSR _menu_configure_and_draw_window                                         ; $01BD9D | | screen and copy the tilemap to VRAM.
    JSR _menu_copy_tilemap_to_vram_bg1                                          ; $01BDA0 |/
    JSR _menu_copy_tilemap_to_vram_bg2                                          ; $01BDA3 | Copy the BG2 tilemap to VRAM as well.
    INC r_menu_equip_initialization_complete.w                                  ; $01BDA6 | Set the initialization flag complete flag.
    REP #FLAG_P_ACCUMULATOR                                                     ; $01BDA9 |\
    LDX #r_menu_tilemap_bg4.w                                                   ; $01BDAB | | Back up the existing data on the first 32x32 section of BG4.
    LDY #r_menu_equip_tilemap_backup.w                                          ; $01BDAE | |
    LDA #_sizeof_r_menu_equip_tilemap_backup.w - 1                              ; $01BDB1 | |
    MVN :r_menu_tilemap_bg4,:r_menu_equip_tilemap_backup                        ; $01BDB4 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01BDB7 |/
    JSR _menu_initialize_tilemap_bg4                                            ; $01BDB9 |\ Clear BG4 and copy the new tilemap to VRAM.
    JSR _menu_copy_tilemap_to_vram_bg4                                          ; $01BDBC |/
    LDA #%01111010.b                                                            ; $01BDBF |\ Set BG4 to 32x64 with the base address at $7800.
    STA reg_ppu_bg4sc.l                                                         ; $01BDC1 |/
    STZ <r_menu_scroll_bg4.horizontal.value.lo                                  ; $01BDC5 |\ Set the BG4 horizontal scroll value to zero.
    STZ <r_menu_scroll_bg4.horizontal.value.hi                                  ; $01BDC7 |/
    JSR _menu_set_current_tilemap_bg2                                           ; $01BDC9 | Set the current tilemap to BG2.
    BRA @loop_start                                                             ; $01BDCC | Branch ahead to skip the already initialized code.
+   JSR _menu_copy_tilemap_to_vram_bg2                                          ; $01BDCE | If already initialized, simply set the current tilemap to BG2.
@loop_start:
    LDA #0.b                                                                    ; $01BDD1 |\ Zero out the high byte of the accumulator.
    XBA                                                                         ; $01BDD3 |/
    LDA r_menu_equip_cursor_index.w                                             ; $01BDD4 |\
    ASL A                                                                       ; $01BDD7 | | Set the current Y coordinate pointer by multiply the cursor index
    ADC r_menu_equip_cursor_index.w                                             ; $01BDD8 | | by three and adding the base offset for the cursor coordinates.
    REP #FLAG_P_ACCUMULATOR                                                     ; $01BDDB | |
    ADC #r_menu_equip_cursor_coordinates.w                                      ; $01BDDD | |
    STA <r_menu_equip_current_y_coordinate_ptr                                  ; $01BDE0 |/
    INC A                                                                       ; $01BDE2 |\ Set the X coordinate pointer.
    STA <r_menu_equip_current_x_coordinate_ptr                                  ; $01BDE3 |/
    INC A                                                                       ; $01BDE5 |\ Set the first row pointer.
    STA <r_menu_equip_current_first_row_ptr                                     ; $01BDE6 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01BDE8 |/
    LDA r_menu_equip_cursor_index.w                                             ; $01BDEA |\
    ASL A                                                                       ; $01BDED | | Draw the first cursor. The X coordinate is set to 88. The Y
    ASL A                                                                       ; $01BDEE | | coordinate is set to 16 plus the cursor index times 16. The
    ASL A                                                                       ; $01BDEF | | Japanese version uses an X coordinate of 96.
    ASL A                                                                       ; $01BDF0 | |
    ADC #16.b                                                                   ; $01BDF1 | |
    STA <r_menu_draw_cursor_arg_coordinates.y                                   ; $01BDF3 | |
.if FF4_REGION == "JAPAN"                                                       ;         | |
    LDA #96.b                                                                   ; $01BE1E | |
.else                                                                           ;         | |
    LDA #88.b                                                                   ; $01BDF5 | |
.endif                                                                          ;         | |
    STA <r_menu_draw_cursor_arg_coordinates.x                                   ; $01BDF7 | |
    JSR _menu_draw_cursor_1                                                     ; $01BDF9 |/
    JSR _menu_copy_tilemap_to_vram_bg2                                          ; $01BDFC | Copy the BG2 tilemap to VRAM.
    JSR _menu_copy_oam_to_ppu                                                   ; $01BDFF | Copy the OAM to the PPU.
    JSR _menu_update_joypad_and_play_sound_effect                               ; $01BE02 | Update the joypad values.
    LDA <r_menu_joypad_repeat.hi                                                ; $01BE05 |\
    AND #JOYPAD_H_UP.b                                                          ; $01BE07 | | If up is pressed on the d-pad, decrement the cursor index and wrap
    BEQ ++                                                                      ; $01BE09 | | it around to four if it goes negative.
    LDA r_menu_equip_cursor_index.w                                             ; $01BE0B | |
    DEC A                                                                       ; $01BE0E | |
    BPL +                                                                       ; $01BE0F | |
    LDA #4.b                                                                    ; $01BE11 | |
+   STA r_menu_equip_cursor_index.w                                             ; $01BE13 |/
++  LDA <r_menu_joypad_repeat.hi                                                ; $01BE16 |\
    AND #JOYPAD_H_DOWN.b                                                        ; $01BE18 | | If down is pressed on the d-pad, increment the cursor index and
    BEQ ++                                                                      ; $01BE1A | | wrap it around to zero if it reaches five.
    LDA r_menu_equip_cursor_index.w                                             ; $01BE1C | |
    INC A                                                                       ; $01BE1F | |
    CMP #5.b                                                                    ; $01BE20 | |
    BNE +                                                                       ; $01BE22 | |
    LDA #0.b                                                                    ; $01BE24 | |
+   STA r_menu_equip_cursor_index.w                                             ; $01BE26 |/
++  LDA <r_menu_joypad_repeat.lo                                                ; $01BE29 |\
    AND #JOYPAD_L_A.b                                                           ; $01BE2B | | If A is pressed on the d-pad, execute the inventory menu for
    BEQ +                                                                       ; $01BE2D | | equipping the currently selected location.
    LDA r_menu_equip_cursor_index.w                                             ; $01BE2F | |
    ASL A                                                                       ; $01BE32 | |
    JSR _menu_transfer_a_to_x                                                   ; $01BE33 | |
    LDA menu_equip_item_range_data.l + 0,X                                      ; $01BE36 | |
    STA r_menu_inventory_enabled_item_range.lo.w                                ; $01BE3A | |
    LDA menu_equip_item_range_data.l + 1,X                                      ; $01BE3D | |
    STA r_menu_inventory_enabled_item_range.hi.w                                ; $01BE41 | |
    JSR _menu_equip_execute_item_menu                                           ; $01BE44 | |
    JSR _menu_erase_cursor_2                                                    ; $01BE47 | |
    JSR _menu_initialize_tilemap_bg4                                            ; $01BE4A | |
    JSR _menu_copy_tilemap_to_vram_bg4                                          ; $01BE4D | |
    JSR _menu_copy_oam_to_ppu                                                   ; $01BE50 | |
    JMP _menu_equip_core                                                        ; $01BE53 |/
+   LDA <r_menu_joypad_repeat.hi                                                ; $01BE56 |\
    AND #JOYPAD_H_B.b                                                           ; $01BE58 | | If the B button is pressed, return.
    BEQ +                                                                       ; $01BE5A | |
    RTS                                                                         ; $01BE5C |/
+   JMP @loop_start                                                             ; $01BE5D | Otherwise, jump to repeat the loop.

; _menu_equip_execute_item_menu ($01:BE60)
;
; Handles the equipment selection menu in the equip menu. Specifically, choosing
; an item from the list.
_menu_equip_execute_item_menu:
    LDA #0.b                                                                    ; $01BE60 |\ Zero out the high byte of the accumulator.
    XBA                                                                         ; $01BE62 |/
    LDA (<r_menu_equip_current_first_row_ptr)                                   ; $01BE63 |\
    REP #FLAG_P_ACCUMULATOR                                                     ; $01BE65 | | Set the BG4 scroll value to the first visible row times 16 minus
    ASL A                                                                       ; $01BE67 | | 104.
    ASL A                                                                       ; $01BE68 | |
    ASL A                                                                       ; $01BE69 | |
    ASL A                                                                       ; $01BE6A | |
    CLC                                                                         ; $01BE6B | |
    ADC #-104.w                                                                 ; $01BE6C | |
    STA <r_menu_scroll_bg4.vertical.value                                       ; $01BE6F | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01BE71 |/
    JSR _menu_set_current_tilemap_bg4                                           ; $01BE73 | Set the current tilemap to BG4.
    LDA <r_menu_current_selected_character_slot                                 ; $01BE76 |\
    JSR _menu_get_character_field_offset                                        ; $01BE78 | | Calculate the stat offset for the selected character.
    STX <r_menu_current_character_offset                                        ; $01BE7B |/
    JSR _menu_inventory_draw_window                                             ; $01BE7D | Draw the inventory window to the tilemap.
    JSR _menu_copy_tilemap_to_vram_bg4                                          ; $01BE80 | Copy the BG4 tilemap to VRAM.
    JSR _menu_set_bg_scroll_proxy                                               ; $01BE83 | Set the BG scroll values.
    LDA <r_menu_current_selected_character_slot                                 ; $01BE86 |\
    JSR _menu_get_character_field_offset                                        ; $01BE88 | | Store the character stat offset to another variable.
    STX <r_menu_selected_character_offset                                       ; $01BE8B |/
@loop_start:
    LDA (<r_menu_equip_current_y_coordinate_ptr)                                ; $01BE8D |\
    ASL A                                                                       ; $01BE8F | | Set the cursor Y coordinate to 118 plus the Y coordinate times 16.
    ASL A                                                                       ; $01BE90 | |
    ASL A                                                                       ; $01BE91 | |
    ASL A                                                                       ; $01BE92 | |
    ADC #118.b                                                                  ; $01BE93 | |
    STA <r_menu_draw_cursor_arg_coordinates.y                                   ; $01BE95 |/
    LDA (<r_menu_equip_current_x_coordinate_ptr)                                ; $01BE97 |\
    BEQ +                                                                       ; $01BE99 | | Set the cursor X coordinate to either 8 or 104, depending on the
    LDA #104.b                                                                  ; $01BE9B | | currently chosen column.
+   ADC #8.b                                                                    ; $01BE9D | |
    STA <r_menu_draw_cursor_arg_coordinates.x                                   ; $01BE9F |/
    JSR _menu_draw_cursor_2                                                     ; $01BEA1 | Draw the second cursor.
    JSR _menu_wait_for_vblank_copy_oam_to_ppu                                   ; $01BEA4 | Wait for vblank and copy the OAM to the PPU.
    JSR _menu_update_joypad_and_play_sound_effect                               ; $01BEA7 | Update the joypad values and play a sound effect if appropriate.
@check_input:
    LDA <r_menu_joypad_repeat.hi                                                ; $01BEAA |\
    AND #JOYPAD_H_RIGHT.b                                                       ; $01BEAC | | If right is pressed on the d-pad, toggle the X coordinate between
    BEQ +                                                                       ; $01BEAE | | zero and one. If the result is zero, branch to the code to
    LDA (<r_menu_equip_current_x_coordinate_ptr)                                ; $01BEB0 | | simulate a down press.
    INC A                                                                       ; $01BEB2 | |
    AND #%00000001.b                                                            ; $01BEB3 | |
    STA (<r_menu_equip_current_x_coordinate_ptr)                                ; $01BEB5 | |
    BEQ @down                                                                   ; $01BEB7 |/
+   LDA <r_menu_joypad_repeat.hi                                                ; $01BEB9 |\
    AND #JOYPAD_H_LEFT.b                                                        ; $01BEBB | | If left is pressed on the d-pad, toggle the X coordinate between
    BEQ +                                                                       ; $01BEBD | | zero and one. If the result is one, branch to the code to simulate
    LDA (<r_menu_equip_current_x_coordinate_ptr)                                ; $01BEBF | | an up press.
    INC A                                                                       ; $01BEC1 | |
    AND #%00000001.b                                                            ; $01BEC2 | |
    STA (<r_menu_equip_current_x_coordinate_ptr)                                ; $01BEC4 | |
    BNE @up                                                                     ; $01BEC6 |/
+   LDA <r_menu_joypad_repeat.hi                                                ; $01BEC8 |\
    AND #JOYPAD_H_UP.b                                                          ; $01BECA | | If up is not pressed on the d-pad, skip this next block.
    BEQ ++                                                                      ; $01BECC |/
@up:
    LDA (<r_menu_equip_current_y_coordinate_ptr)                                ; $01BECE |\ Decrement the current Y coordinate in the accumulator.
    DEC A                                                                       ; $01BED0 |/
    BPL +                                                                       ; $01BED1 | If it remains positive, skip the next block.
    LDA (<r_menu_equip_current_first_row_ptr)                                   ; $01BED3 |\
    DEC A                                                                       ; $01BED5 | | Attempt to decrement the first row. If the result would be
    BMI ++                                                                      ; $01BED6 | | negative, skip ahead, as there is no further to scroll.
    STA (<r_menu_equip_current_first_row_ptr)                                   ; $01BED8 |/  Otherwise, save the updated value.
    LDA #8.b                                                                    ; $01BEDA |\
-   REP #FLAG_P_ACCUMULATOR                                                     ; $01BEDC | | Otherwise, decrement the BG4 vertical scroll value by 16, moving
    DEC <r_menu_scroll_bg4.vertical.value                                       ; $01BEDE | | it two pixels per frame.
    DEC <r_menu_scroll_bg4.vertical.value                                       ; $01BEE0 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01BEE2 | |
    JSR _menu_set_bg_scroll_proxy_vblank                                        ; $01BEE4 | |
    DEC A                                                                       ; $01BEE7 | |
    BNE -                                                                       ; $01BEE8 |/
    JSR _menu_input_check_left_right                                            ; $01BEEA |\ If left or right is repeating on this frame, branch to immediately
    BCC @check_input                                                            ; $01BEED |/ check input again.
    BRA ++                                                                      ; $01BEEF | Otherwise, branch ahead to skip storing the updated Y coordinate.
+   STA (<r_menu_equip_current_y_coordinate_ptr)                                ; $01BEF1 | Store the updated Y coordinate (if there was no scrolling).
++  LDA <r_menu_joypad_repeat.hi                                                ; $01BEF3 |\
    AND #JOYPAD_H_DOWN.b                                                        ; $01BEF5 | | Skip this next block unless down is pressed on the d-pad.
    BEQ ++                                                                      ; $01BEF7 |/
@down:
    LDA (<r_menu_equip_current_y_coordinate_ptr)                                ; $01BEF9 |\
    INC A                                                                       ; $01BEFB | | Attempt to increment the Y coordinate. if the value would be less
    CMP #6.b                                                                    ; $01BEFC | | than 6, skip the following block (which scrolls).
    BNE +                                                                       ; $01BEFE |/
    LDA (<r_menu_equip_current_first_row_ptr)                                   ; $01BF00 |\
    INC A                                                                       ; $01BF02 | | Attempt to increment the first row. If the value would be 19, skip
    CMP #19.b                                                                   ; $01BF03 | | ahead since there is no further to scroll.
    BEQ ++                                                                      ; $01BF05 |/
    STA (<r_menu_equip_current_first_row_ptr)                                   ; $01BF07 |\
    LDA #8.b                                                                    ; $01BF09 | | Increment the BG4 vertical scroll by 16, increasing the value by
-   REP #FLAG_P_ACCUMULATOR                                                     ; $01BF0B | | 2 pixels per frame.
    INC <r_menu_scroll_bg4.vertical.value                                       ; $01BF0D | |
    INC <r_menu_scroll_bg4.vertical.value                                       ; $01BF0F | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01BF11 | |
    JSR _menu_set_bg_scroll_proxy_vblank                                        ; $01BF13 | |
    DEC A                                                                       ; $01BF16 | |
    BNE -                                                                       ; $01BF17 |/
    JSR _menu_input_check_left_right                                            ; $01BF19 |\ If left or right is repeating on this frame, branch to immediately
    BCC @check_input                                                            ; $01BF1C |/ check input again.
    BRA ++                                                                      ; $01BF1E | Otherwise, branch ahead to skip storing the updated Y coordinate.
+   STA (<r_menu_equip_current_y_coordinate_ptr)                                ; $01BF20 | Store the updated Y coordinate (if there was no scrolling).
++  LDA <r_menu_joypad_repeat.lo                                                ; $01BF22 |\
    AND #JOYPAD_L_A.b                                                           ; $01BF24 | | If the A button is not pressed, branch to check cancel.
    BEQ @check_cancel                                                           ; $01BF26 |/
    LDX <r_menu_selected_character_offset                                       ; $01BF28 |\ Copy the character offset to another variable.
    STX <r_menu_equip_tmp_character_offset                                      ; $01BF2A |/
    LDA (<r_menu_equip_current_y_coordinate_ptr)                                ; $01BF2C |\
    CLC                                                                         ; $01BF2E | | Set the X register to the offset for the item currently pointed
    ADC (<r_menu_equip_current_first_row_ptr)                                   ; $01BF2F | | to by the cursor.
    ASL A                                                                       ; $01BF31 | |
    ADC (<r_menu_equip_current_x_coordinate_ptr)                                ; $01BF32 | |
    ASL A                                                                       ; $01BF34 | |
    JSR _menu_transfer_a_to_x                                                   ; $01BF35 |/
    LDA r_inventory.1.id.w,X                                                    ; $01BF38 | Load the item ID into the accumulator.
    STX <r_menu_equip_tmp_selected_item_offset                                  ; $01BF3B | Save the offset to a variable.
    BEQ +                                                                       ; $01BF3D |\
    LDX <r_menu_equip_tmp_character_offset                                      ; $01BF3F | | If the character's location is empty or if the equipment passes
    STX <r_menu_current_character_offset                                        ; $01BF41 | | the equipment compatibility checks, equip the selected item and
    JSR _menu_equip_check_equipment_compatibility                               ; $01BF43 | | return.
    BCC ++                                                                      ; $01BF46 | |
+   JMP _menu_equip_equip_selected_item                                         ; $01BF48 |/
++  JSR _play_sound_effect_error                                                ; $01BF4B | Otherwise, play the error sound effect.
    LDA <r_menu_equip_two_handed                                                ; $01BF4E |\
    BEQ @check_cancel                                                           ; $01BF50 | | If a two handed weapon was involved in the failed equipment
    JSR _menu_erase_cursor_2                                                    ; $01BF52 | | change, display an error message dialog and wait for input before
    JSR _menu_set_current_tilemap_bg1                                           ; $01BF55 | | restoring BG1 to its original state.
    LDY #menu_window_two_handed_error_data.w                                    ; $01BF58 | |
    JSR _menu_draw_text_indirect_plus_window                                    ; $01BF5B | |
    JSR _menu_copy_tilemap_to_vram_bg1                                          ; $01BF5E | |
    JSR _menu_copy_oam_to_ppu                                                   ; $01BF61 | |
    JSR _menu_wait_for_input                                                    ; $01BF64 | |
    JSR _menu_initialize_tilemap_bg1                                            ; $01BF67 | |
    LDY #menu_window_equip_equipment_data.w                                     ; $01BF6A | |
    JSR _menu_configure_and_draw_window                                         ; $01BF6D | |
    JSR _menu_copy_tilemap_to_vram_bg1                                          ; $01BF70 |/
@check_cancel:
    LDA <r_menu_joypad_repeat.hi                                                ; $01BF73 |\
    AND #JOYPAD_H_B.b                                                           ; $01BF75 | | Return if the B button is pressed.
    BEQ +                                                                       ; $01BF77 | |
    RTS                                                                         ; $01BF79 |/
+   JMP @loop_start                                                             ; $01BF7A | Jump back to repeat the input loop.

; _menu_equip_check_equipment_compatibility ($01:BF7D)
;
; Given the currently selected item ID in $1B39, determines if the item can be
; equipped to the currently chosen location. Sets the carry flag if so, and
; clears it otherwise.
_menu_equip_check_equipment_compatibility:
    STZ r_menu_equip_two_handed.w                                               ; $01BF7D | Reset the two handed flag.
    CMP #ITEM_FIRST_BATTLE_ITEM.b                                               ; $01BF80 |\
    BCS +                                                                       ; $01BF82 | | Ensure that the chosen item is a piece of equipment, that it makes
    JSR _menu_equip_check_can_equip                                             ; $01BF84 | | sense to equip that item to that location (including checking
    BCS ++                                                                      ; $01BF87 | | weapon compatibility), and that the character can equip that piece
+   CLC                                                                         ; $01BF89 | | of equipment. If any of these checks fails, clear the carry flag
    RTS                                                                         ; $01BF8A | | and return.
++  JSR _menu_shop_check_character_equipment                                    ; $01BF8B | |
    BCS +                                                                       ; $01BF8E | |
    RTS                                                                         ; $01BF90 |/
+   LDA r_menu_equip_cursor_index.w                                             ; $01BF91 |\
    CMP #2.b                                                                    ; $01BF94 | | If the cursor is pointing to head, body or arms, return. (The
    BCC +                                                                       ; $01BF96 | | carry flag will still be set by the previous operations.)
    RTS                                                                         ; $01BF98 |/
+   LDA (<r_menu_current_character_offset)                                      ; $01BF99 |\
    AND #%11000000.b                                                            ; $01BF9B | | If the character is ambidextrous or if the equipment location is
    CMP #%11000000.b                                                            ; $01BF9D | | their dominant hand, set the carry flag if the selected item is a
    BEQ +                                                                       ; $01BF9F | | weapon. Otherwise, clear it.
    CLC                                                                         ; $01BFA1 | |
    ROL A                                                                       ; $01BFA2 | |
    ROL A                                                                       ; $01BFA3 | |
    ROL A                                                                       ; $01BFA4 | |
    JSR _menu_transfer_a_to_x                                                   ; $01BFA5 | |
    LDA menu_equip_handedness_weapon_location_data.l,X                          ; $01BFA8 | |
    CMP r_menu_equip_cursor_index.w                                             ; $01BFAC | |
    BNE ++                                                                      ; $01BFAF | |
+   LDA r_menu_equip_selected_item_id.w                                         ; $01BFB1 | |
    LDX #ITEM_NONE + (ITEM_LAST_ARROW << 8).w                                   ; $01BFB4 | |
    JMP _menu_check_item_range                                                  ; $01BFB7 |/
++  LDA r_menu_equip_selected_item_id.w                                         ; $01BFBA |\
    LDX #ITEM_FIRST_BOW + (ITEM_LAST_ARROW << 8).w                              ; $01BFBD | | If the equipment location is a character's non-dominant hand, set
    JSR _menu_check_item_range                                                  ; $01BFC0 | | the carry flag if the item is a bow, arrow or shield.
    BCS +                                                                       ; $01BFC3 | |
    LDX #ITEM_FIRST_SHIELD + (ITEM_LAST_SHIELD << 8).w                          ; $01BFC5 | |
    JMP _menu_check_item_range                                                  ; $01BFC8 | |
+   SEC                                                                         ; $01BFCB |/
    RTS                                                                         ; $01BFCC

; menu_equip_handedness_weapon_location_data ($01:BFCD)
;
; For each value of the handedness bits, determines which cursor index
; corresponds to the weapon slot for that character. Only the values for left
; handed and right handed are valid. The other values are meaningless.
menu_equip_handedness_weapon_location_data:
    .db MENU_EQUIP_CURSOR_HEAD                                                  ; $01BFCD | $00: <unused>
    .db MENU_EQUIP_CURSOR_L_HAND                                                ; $01BFCE | $01: Left Handed
    .db MENU_EQUIP_CURSOR_R_HAND                                                ; $01BFCF | $02: Right Handed
    .db MENU_EQUIP_CURSOR_HEAD                                                  ; $01BFD0 | $03: Both Handed

; _menu_check_item_* ($01:BFD1)
;
; Checks an item ID for membership in a particular range. The _range variant
; accepts an item ID in the accumulator and an item range in the X register with
; the low byte being the minimum value of the range and the high byte being the
; maximum value. The _armor_* variants check the item ID stored in $1B39 to see
; if they are a helm, body armor or arms. If the item ID is within the
; (inclusive) range, the carry flag is set. Otherwise, it is cleared.
_menu_check_item_armor_body:
    LDX #ITEM_FIRST_BODY + (ITEM_LAST_BODY << 8).w                              ; $01BFD1 |\ Load the body armor range into the X register and branch to the
    BRA __menu_check_item_range_common                                          ; $01BFD4 |/ common code.
_menu_check_item_armor_arms:
    LDX #ITEM_FIRST_ARMS + (ITEM_LAST_ARMS << 8).w                              ; $01BFD6 |\ Load the arms range into the X register and branch to the common
    BRA __menu_check_item_range_common                                          ; $01BFD9 |/ code.
_menu_check_item_armor_helm:
    LDX #ITEM_FIRST_HELM + (ITEM_LAST_HELM << 8).w                              ; $01BFDB | Load the helm range into the X register and fall through.
__menu_check_item_range_common:
    LDA r_menu_equip_selected_item_id.w                                         ; $01BFDE | Load the item ID to check.
_menu_check_item_range:
    STX <r_menu_generic_tmp_word                                                ; $01BFE1 | Store the item range to a variable.
    CMP <r_menu_generic_tmp_word.lo                                             ; $01BFE3 |\ If the item ID is less than the minimum ID, branch to clear the
    BCC _clear_carry_and_return                                                 ; $01BFE5 |/ carry flag and return.
    CMP <r_menu_generic_tmp_word.hi                                             ; $01BFE7 |\ If the item ID is equal to the maximum ID, branch to set the
    BEQ _set_carry_and_return                                                   ; $01BFE9 |/ carry flag and return.
    BCS _clear_carry_and_return                                                 ; $01BFEB | If the item ID is greater than the maximum, clear the carry flag.

; _set_carry_and_return ($01:BFED)
;
; This routine merely sets the carry flag and returns. It only makes sense to
; call via a jump or branch instruction.
_set_carry_and_return:
    SEC                                                                         ; $01BFED
    RTS                                                                         ; $01BFEE

; _clear_carry_and_return ($01:BFEF)
;
; This routine merely clears the carry flag and returns. It only makes sense to
; call via a jump or branch instruction.
_clear_carry_and_return:
    CLC                                                                         ; $01BFEF
    RTS                                                                         ; $01BFF0

; _menu_equip_check_can_equip ($01:BFF1)
;
; Given the current selected item ID in $1B39, determines if the current
; character is able to equip the item in question in terms of whether or not
; it's compatible with their other currently equipped equipment. It ensures
; that only helms are equipped to the head, only body armor is equipped to the
; body and only arms are equipped to the arms. It also ensures that the
; resulting weapon combination makes sense. (Such as ensuring that only one
; two handed weapon is equipped, and that a bow can only be equipped with an
; arrow and so on.)
_menu_equip_check_can_equip:
    STA r_menu_equip_selected_item_id.w                                         ; $01BFF1 | Save the passed value as the selected item ID.
    BEQ _set_carry_and_return                                                   ; $01BFF4 | If the item ID is zero, set the carry flag and return.
    LDA r_menu_equip_cursor_index.w                                             ; $01BFF6 |\
    JSR _menu_transfer_a_to_x                                                   ; $01BFF9 | | Load the offset to the selected equip location.
    LDA menu_equip_cursor_index_record_offset_data.l,X                          ; $01BFFC | |
    STA r_menu_equip_selected_equip_location_offset.w                           ; $01C000 |/
    CMP #character_field.armor_head.b                                           ; $01C003 |\ If equipping the head, branch to check if the item is a helm.
    BEQ _menu_check_item_armor_helm                                             ; $01C005 |/
    CMP #character_field.armor_body.b                                           ; $01C007 |\ If equipping the body, branch to check if the item is body armor.
    BEQ _menu_check_item_armor_body                                             ; $01C009 |/
    CMP #character_field.armor_arms.b                                           ; $01C00B |\ If equipping the arms, branch to check if the item is a gauntlet
    BEQ _menu_check_item_armor_arms                                             ; $01C00D |/ or ring.
    LDA r_menu_equip_selected_item_id.w                                         ; $01C00F | Pointlessly load the item ID into the accumulator.
    LDA r_menu_equip_cursor_index.w                                             ; $01C012 |\
    BEQ +                                                                       ; $01C015 | | Since a hand is being equipped, determine which one and load the
    LDA #character_field.right_hand_item                                        ; $01C017 | | currently equipped item ID in the other hand and save it to a
    BRA ++                                                                      ; $01C019 | | temporary variable.
+   LDA #character_field.left_hand_item                                         ; $01C01B | |
++  STA <r_menu_generic_tmp_offset.lo                                           ; $01C01D | |
    LDY <r_menu_generic_tmp_offset                                              ; $01C01F | |
    LDA (<r_menu_current_character_offset),Y                                    ; $01C021 | |
    STA r_menu_equip_current_equipped_other_hand_item.w                         ; $01C023 |/
    BNE +                                                                       ; $01C026 |\
    SEC                                                                         ; $01C028 | | If nothing is equipped in the other hand, set the carry flag and
    RTS                                                                         ; $01C029 |/  return.
+   LDX #ITEM_FIRST_TWO_HANDED + (ITEM_LAST_TWO_HANDED << 8).w                  ; $01C02A |\
    JSR _menu_check_item_range                                                  ; $01C02D | | If the equipped item in the other hand is in the two handed range,
    BCC +                                                                       ; $01C030 | | set the flag that indicates a two handed weapon is involved, clear
-   INC <r_menu_equip_two_handed                                                ; $01C032 | | the carry flag and return.
    CLC                                                                         ; $01C034 | |
    RTS                                                                         ; $01C035 |/
+   LDA r_menu_equip_selected_item_id.w                                         ; $01C036 |\
    LDX #ITEM_FIRST_TWO_HANDED + (ITEM_LAST_TWO_HANDED << 8).w                  ; $01C039 | | If the selected item is in the two handed range, branch to set a
    JSR _menu_check_item_range                                                  ; $01C03C | | flag, clear the carry flag and return.
    BCS -                                                                       ; $01C03F |/
    LDA r_menu_equip_selected_item_id.w                                         ; $01C041 |\
    LDX #ITEM_NONE + ((ITEM_FIRST_TWO_HANDED - 1) << 8).w                       ; $01C044 | | If the selected item ID is not a one-handed weapon, skip the next
    JSR _menu_check_item_range                                                  ; $01C047 | | block.
    BCC ++                                                                      ; $01C04A |/
    LDA (<r_menu_current_character_offset)                                      ; $01C04C |\
    AND #%11000000.b                                                            ; $01C04E | | If the character is one-handed, set the carry flag and return if
    CMP #%11000000.b                                                            ; $01C050 | | the item in the other hand is a shield. Otherwise, clear the carry
    BEQ +                                                                       ; $01C052 | | flag and return.
-   LDA r_menu_equip_current_equipped_other_hand_item.w                         ; $01C054 | |
    LDX #ITEM_FIRST_SHIELD + (ITEM_LAST_SHIELD << 8).w                          ; $01C057 | |
    JMP _menu_check_item_range                                                  ; $01C05A |/
+   LDA r_menu_equip_current_equipped_other_hand_item.w                         ; $01C05D |\
    LDX #ITEM_NONE + ((ITEM_FIRST_TWO_HANDED - 1) << 8).w                       ; $01C060 | | If the character is ambidextrous, and if the equipped item is a
    JSR _menu_check_item_range                                                  ; $01C063 | | one handed weapon, set the carry flag and return. Otherwise, set
    BCC -                                                                       ; $01C066 | | the carry flag if the equipped item is a shield.
    RTS                                                                         ; $01C068 |/
++  LDX #ITEM_FIRST_SHIELD + (ITEM_LAST_SHIELD << 8).w                          ; $01C069 |\
    JSR _menu_check_item_range                                                  ; $01C06C | | If the selected item is a shield, set the carry flag if the
    BCC +                                                                       ; $01C06F | | equipped item in the other hand is a one handed weapon. Otherwise,
    LDA r_menu_equip_current_equipped_other_hand_item.w                         ; $01C071 | | clear it and return.
    LDX #ITEM_NONE + ((ITEM_FIRST_TWO_HANDED - 1) << 8).w                       ; $01C074 | |
    JMP _menu_check_item_range                                                  ; $01C077 |/
+   LDX #ITEM_FIRST_BOW + (ITEM_LAST_BOW << 8).w                                ; $01C07A |\
    JSR _menu_check_item_range                                                  ; $01C07D | | If the selected item is a bow, set the carry flag if the other
    BCC +                                                                       ; $01C080 | | equipped item is an arrow. Otherwise, clear it.
    LDA r_menu_equip_current_equipped_other_hand_item.w                         ; $01C082 | |
    LDX #ITEM_FIRST_ARROW + (ITEM_LAST_ARROW << 8).w                            ; $01C085 | |
    JMP _menu_check_item_range                                                  ; $01C088 |/
+   LDX #ITEM_FIRST_ARROW + (ITEM_LAST_ARROW << 8).w                            ; $01C08B |\
    JSR _menu_check_item_range                                                  ; $01C08E | | If the selected item is an arrow, set the carry flag if the other
    BCC +                                                                       ; $01C091 | | equipped item is a bow. Otherwise, clear it.
    LDA r_menu_equip_current_equipped_other_hand_item.w                         ; $01C093 | |
    LDX #ITEM_FIRST_BOW + (ITEM_LAST_BOW << 8).w                                ; $01C096 | |
    JMP _menu_check_item_range                                                  ; $01C099 |/
+   CLC                                                                         ; $01C09C | If no condition matched, clear the carry flag.
    RTS                                                                         ; $01C09D

; menu_equip_item_range_data ($01:C09E)
;
; For each equipment location in the equip menu, determines the acceptable range
; of items for that slot.
menu_equip_item_range_data:
    .db ITEM_FIRST_HAND, ITEM_LAST_HAND                                         ; $01C09E.C09F | $00: Right Hand
    .db ITEM_FIRST_HAND, ITEM_LAST_HAND                                         ; $01C0A0.C0A1 | $01: Left Hand
    .db ITEM_FIRST_HELM, ITEM_LAST_HELM                                         ; $01C0A2.C0A3 | $02: Head
    .db ITEM_FIRST_BODY, ITEM_LAST_BODY                                         ; $01C0A4.C0A5 | $03: Body
    .db ITEM_FIRST_ARMS, ITEM_LAST_ARMS                                         ; $01C0A6.C0A7 | $04: Arms

; menu_equip_cursor_index_record_offset_data ($01:C0A8)
;
; For each possible value of the cursor index in the equip menu, determines the
; offset in the character record for the equipment associated with that index.
menu_equip_cursor_index_record_offset_data:
    .db character_field.right_hand_item                                         ; $01C0A8
    .db character_field.left_hand_item                                          ; $01C0A9
    .db character_field.armor_head                                              ; $01C0AA
    .db character_field.armor_body                                              ; $01C0AB
    .db character_field.armor_arms                                              ; $01C0AC

; _menu_equip_equip_selected_item ($01:C0AD)
;
; Part of the equip menu, equips the selected item to the selected location.
_menu_equip_equip_selected_item:
    LDA r_menu_equip_cursor_index.w                                             ; $01C0AD |\
    JSR _menu_transfer_a_to_x                                                   ; $01C0B0 | | Set the X register to the offset in the inventory to the selected
    LDA menu_equip_cursor_index_record_offset_data.l,X                          ; $01C0B3 | | item and set the Y register to the offset in the character record
    LDX <r_menu_equip_tmp_selected_item_offset                                  ; $01C0B7 | | to the selected equipment location.
    STA <r_menu_generic_tmp_offset.lo                                           ; $01C0B9 | |
    LDY <r_menu_generic_tmp_offset                                              ; $01C0BB |/
    LDA r_menu_equip_cursor_index.w                                             ; $01C0BD |\
    CMP #MENU_EQUIP_CURSOR_HEAD.b                                               ; $01C0C0 | | If equipping to the hand, branch ahead to separate code.
    BCC @hand                                                                   ; $01C0C2 |/
    LDA (<r_menu_selected_character_offset),Y                                   ; $01C0C4 |\
    BNE ++                                                                      ; $01C0C6 | | If both spots are empty, return without doing anything.
    LDA r_inventory.1.id.w,X                                                    ; $01C0C8 | |
    BNE +                                                                       ; $01C0CB | |
    RTS                                                                         ; $01C0CD |/
+   STA (<r_menu_selected_character_offset),Y                                   ; $01C0CE |\
    DEC r_inventory.1.count.w,X                                                 ; $01C0D0 | | If the character location is empty, but the inventory location is
    BNE @return                                                                 ; $01C0D3 | | not, decrement the inventory count, and if it reaches zero,
    LDA #ITEM_NONE.b                                                            ; $01C0D5 | | replace the item in the inventory with nothing, and then return.
    STA r_inventory.1.id.w,X                                                    ; $01C0D7 |/
@return:
    RTS                                                                         ; $01C0DA |
++  LDA r_inventory.1.id.w,X                                                    ; $01C0DB |\
    BNE +                                                                       ; $01C0DE | | If the character location is not empty, but the inventory location
    LDA (<r_menu_selected_character_offset),Y                                   ; $01C0E0 | | is, copy the item ID to the inventory, increment the count to 1,
    STA r_inventory.1.id.w,X                                                    ; $01C0E2 | | and set the item in the character location to nothing. Return
    INC r_inventory.1.count.w,X                                                 ; $01C0E5 | | afterward.
    LDA #ITEM_NONE.b                                                            ; $01C0E8 | |
    STA (<r_menu_selected_character_offset),Y                                   ; $01C0EA | |
    RTS                                                                         ; $01C0EC |/
+   CMP (<r_menu_selected_character_offset),Y                                   ; $01C0ED |\ If the selected item and the already equipped item are the same,
    BEQ @return                                                                 ; $01C0EF |/ return.
    LDA r_inventory.1.count.w,X                                                 ; $01C0F1 |\
    CMP #1.b                                                                    ; $01C0F4 | | If there is only one of the item in the inventory, simply swap the
    BNE +                                                                       ; $01C0F6 | | two items.
    LDA (<r_menu_selected_character_offset),Y                                   ; $01C0F8 | |
    PHA                                                                         ; $01C0FA | |
    LDA r_inventory.1.id.w,X                                                    ; $01C0FB | |
    STA (<r_menu_selected_character_offset),Y                                   ; $01C0FE | |
    PLA                                                                         ; $01C100 | |
    STA r_inventory.1.id.w,X                                                    ; $01C101 | |
    RTS                                                                         ; $01C104 |/
+   LDA (<r_menu_selected_character_offset),Y                                   ; $01C105 |\
    PHX                                                                         ; $01C107 | | Scan the inventory for either a slot with the equipped item with
    JSR _menu_find_available_inventory_slot                                     ; $01C108 | | free space or an empty slot. If neither is found, branch ahead to
    BEQ +                                                                       ; $01C10B | | handle that case.
    TDC                                                                         ; $01C10D | |
    JSR _menu_find_available_inventory_slot                                     ; $01C10E | |
    BNE ++                                                                      ; $01C111 |/
+   LDA (<r_menu_selected_character_offset),Y                                   ; $01C113 |\
    STA r_inventory.1.id.w,X                                                    ; $01C115 | | Store the equipped item in the found location.
    INC r_inventory.1.count.w,X                                                 ; $01C118 |/
    PLX                                                                         ; $01C11B |\
    LDA r_inventory.1.id.w,X                                                    ; $01C11C | | Copy the selected item into the character location, decrement the
    STA (<r_menu_selected_character_offset),Y                                   ; $01C11F | | count, and if it reaches zero, zero out the item ID as well.
    DEC r_inventory.1.count.w,X                                                 ; $01C121 | |
    BNE +                                                                       ; $01C124 | |
    STZ r_inventory.1.id.w,X                                                    ; $01C126 | |
+   RTS                                                                         ; $01C129 |/
++  PLX                                                                         ; $01C12A |\ If there was no free location, play the error sound effect and
@error:
    JMP _play_sound_effect_error                                                ; $01C12B |/ return.
@hand:
    LDA (<r_menu_selected_character_offset),Y                                   ; $01C12E |\ If the character's hand is not empty, branch ahead to handle that
    BNE @non_empty_hand                                                         ; $01C130 |/ case.
    LDA r_inventory.1.id.w,X                                                    ; $01C132 |\
    BNE +                                                                       ; $01C135 | | If both locations are empty, return without doing anything.
    RTS                                                                         ; $01C137 |/
+   STA (<r_menu_selected_character_offset),Y                                   ; $01C138 | Store the item ID in the character's hand.
    JSR _menu_equip_check_item_arrow                                            ; $01C13A |\
    BCC +                                                                       ; $01C13D | | If the selected item is an arrow, transfer the count from the
    INY                                                                         ; $01C13F | | inventory to the character's hand. Fall through to remove the
    LDA r_inventory.1.count.w,X                                                 ; $01C140 | | arrows from the inventory.
    STA (<r_menu_selected_character_offset),Y                                   ; $01C143 |/
@remove_from_inventory:
    LDA #0.b                                                                    ; $01C145 |\
    STA r_inventory.1.id.w,X                                                    ; $01C147 | | Set both the item ID and count to zero and return.
    STA r_inventory.1.count.w,X                                                 ; $01C14A | |
    RTS                                                                         ; $01C14D |/
+   INY                                                                         ; $01C14E |\
    LDA (<r_menu_selected_character_offset),Y                                   ; $01C14F | | Set the count on the item in the character's hand to 1.
    INC A                                                                       ; $01C151 | | Decrement the count for the item in the inventory. If the value
    STA (<r_menu_selected_character_offset),Y                                   ; $01C152 | | reaches zero, set the item ID to none. Afterward, return.
    DEC r_inventory.1.count.w,X                                                 ; $01C154 | |
    BNE @return_2                                                               ; $01C157 | |
    LDA #ITEM_NONE.b                                                            ; $01C159 | |
    STA r_inventory.1.id.w,X                                                    ; $01C15B |/
@return_2:
    RTS                                                                         ; $01C15E |
@non_empty_hand:
    LDA r_inventory.1.id.w,X                                                    ; $01C15F |\
    BNE +                                                                       ; $01C162 | | If the chosen inventory location is empty, copy the item ID and
    LDA (<r_menu_selected_character_offset),Y                                   ; $01C164 | | count from the hand to the inventory. Afterward, zero out both the
    STA r_inventory.1.id.w,X                                                    ; $01C166 | | item ID and count in the character's hand before returning.
    INY                                                                         ; $01C169 | |
    LDA (<r_menu_selected_character_offset),Y                                   ; $01C16A | |
    STA r_inventory.1.count.w,X                                                 ; $01C16C | |
    LDA #0.b                                                                    ; $01C16F | |
    STA (<r_menu_selected_character_offset),Y                                   ; $01C171 | |
    DEY                                                                         ; $01C173 | |
    STA (<r_menu_selected_character_offset),Y                                   ; $01C174 | |
    RTS                                                                         ; $01C176 |/
+   CMP (<r_menu_selected_character_offset),Y                                   ; $01C177 |\ If the two items are different, branch ahead to handle that case.
    BNE ++                                                                      ; $01C179 |/
    JSR _menu_equip_check_item_arrow                                            ; $01C17B |\ If the item is not an arrow, return without doing anything.
    BCC @return_2                                                               ; $01C17E |/
    LDA r_inventory.1.count.w,X                                                 ; $01C180 |\
    INY                                                                         ; $01C183 | | Otherwise, add the character's total to the value in the
    CLC                                                                         ; $01C184 | | inventory.
    ADC (<r_menu_selected_character_offset),Y                                   ; $01C185 |/
    CMP #100.b                                                                  ; $01C187 |\
    BCS +                                                                       ; $01C189 | | If the result is 99 or less, store the updated count and branch to
    STA (<r_menu_selected_character_offset),Y                                   ; $01C18B | | remove the item from the inventory.
    BRA @remove_from_inventory                                                  ; $01C18D |/
+   SEC                                                                         ; $01C18F |\
    SBC #99.b                                                                   ; $01C190 | | Otherwise, store the overflow in the inventory and leave 99 in the
    STA r_inventory.1.count.w,X                                                 ; $01C192 | | character's hand.
    LDA #99.b                                                                   ; $01C195 | |
    STA (<r_menu_selected_character_offset),Y                                   ; $01C197 | |
    RTS                                                                         ; $01C199 |/
++  LDA r_inventory.1.id.w,X                                                    ; $01C19A |\
    JSR _menu_equip_check_item_arrow                                            ; $01C19D | | If the selected item is an arrow or if the count of the item in
    BCC +                                                                       ; $01C1A0 | | the inventory is one, simply swap the two items and their counts.
    BRA ++                                                                      ; $01C1A2 | |
+   LDA r_inventory.1.count.w,X                                                 ; $01C1A4 | |
    CMP #1.b                                                                    ; $01C1A7 | |
    BNE +                                                                       ; $01C1A9 | |
++  JSR _menu_equip_swap_inventory_and_hand                                     ; $01C1AB | |
    INY                                                                         ; $01C1AE | |
    INX                                                                         ; $01C1AF | |
    JMP _menu_equip_swap_inventory_and_hand                                     ; $01C1B0 |/
+   INY                                                                         ; $01C1B3 |\
    LDA #99.b                                                                   ; $01C1B4 | | Search for an inventory location of the item in the character's
    SEC                                                                         ; $01C1B6 | | hand that has room for all of the count in the hand.
    SBC (<r_menu_selected_character_offset),Y                                   ; $01C1B7 | |
    STA <r_menu_shop_maximum_item_count                                         ; $01C1B9 | |
    DEY                                                                         ; $01C1BB | |
    LDA (<r_menu_selected_character_offset),Y                                   ; $01C1BC | |
    JSR _menu_find_available_inventory_slot                                     ; $01C1BE |/
    BEQ +                                                                       ; $01C1C1 |\
    LDA #ITEM_NONE.b                                                            ; $01C1C3 | | If none is found, instead search for an empty inventory slot.
    JSR _menu_find_available_inventory_slot                                     ; $01C1C5 |/
    BEQ +                                                                       ; $01C1C8 |\ If none is found, branch to play the error sound effect and return.
    JMP @error                                                                  ; $01C1CA |/
+   LDA (<r_menu_selected_character_offset),Y                                   ; $01C1CD |\
    STA r_inventory.1.id.w,X                                                    ; $01C1CF | | Otherwise, copy the item ID to the inventory location and add the
    INY                                                                         ; $01C1D2 | | count from the character into the inventory.
    LDA (<r_menu_selected_character_offset),Y                                   ; $01C1D3 | |
    CLC                                                                         ; $01C1D5 | |
    ADC r_inventory.1.count.w,X                                                 ; $01C1D6 | |
    STA r_inventory.1.count.w,X                                                 ; $01C1D9 |/
    LDX <r_menu_equip_tmp_selected_item_offset                                  ; $01C1DC |\
    LDA r_inventory.1.id.w,X                                                    ; $01C1DE | | If the selected item is not an arrow, set the count in the
    JSR _menu_equip_check_item_arrow                                            ; $01C1E1 | | character's hand to 1, and copy the selected ID into the hand.
    BCS ++                                                                      ; $01C1E4 | | Decrement the count in the inventory, and if it reaches zero,
    LDA #1.b                                                                    ; $01C1E6 | | remove the item entirely.
    STA (<r_menu_selected_character_offset),Y                                   ; $01C1E8 | |
    DEY                                                                         ; $01C1EA | |
    LDA r_inventory.1.id.w,X                                                    ; $01C1EB | |
    STA (<r_menu_selected_character_offset),Y                                   ; $01C1EE | |
    DEC r_inventory.1.count.w,X                                                 ; $01C1F0 | |
    BNE +                                                                       ; $01C1F3 | |
    LDA #ITEM_NONE.b                                                            ; $01C1F5 | |
    STA r_inventory.1.id.w,X                                                    ; $01C1F7 | |
+   RTS                                                                         ; $01C1FA |/
++  LDA r_inventory.1.count.w,X                                                 ; $01C1FB |\
    STA (<r_menu_selected_character_offset),Y                                   ; $01C1FE | | If the selected item is an arrow, transfer the entire count to the
    DEY                                                                         ; $01C200 | | hand and remove the items from the inventory.
    LDA r_inventory.1.id.w,X                                                    ; $01C201 | |
    STA (<r_menu_selected_character_offset),Y                                   ; $01C204 | |
    LDA #0.b                                                                    ; $01C206 | |
    STA r_inventory.1.id.w,X                                                    ; $01C208 | |
    STA r_inventory.1.count.w,X                                                 ; $01C20B |/
    RTS                                                                         ; $01C20E

; _menu_find_available_inventory_slot ($01:C20F)
;
; Given an item ID in the accumulator, scans the inventory for a slot that has
; that item and is not already at the maximum item count. If one is found, a
; zero is returned in the accumulator. Otherwise, a 1 is returned. The offset
; to the slot is returned in the X register.
_menu_find_available_inventory_slot:
    PHY                                                                         ; $01C20F | Preserve the original value of the Y register.
    LDY #48.w                                                                   ; $01C210 | Initialize the Y register to 48.
    LDX <r_menu_zero                                                            ; $01C213 | Initialize the X register to zero.
-   CMP r_inventory.1.id.w,X                                                    ; $01C215 |\ If the current item matches the parameter, branch ahead to process
    BEQ +                                                                       ; $01C218 |/ that item.
--  INX                                                                         ; $01C21A |\
    INX                                                                         ; $01C21B | | Otherwise, increment the X register by two, decrement the Y
    DEY                                                                         ; $01C21C | | register and loop until it reaches zero.
    BNE -                                                                       ; $01C21D |/
    PLY                                                                         ; $01C21F | Restore the Y register to its original value.
    LDA #1.b                                                                    ; $01C220 |\ Set the accumulator to 1 and return.
    RTS                                                                         ; $01C222 |/
+   PHA                                                                         ; $01C223 |\
    LDA r_inventory.1.count.w,X                                                 ; $01C224 | | If the count of the item is equal to the maximum count, branch
    CMP <r_menu_shop_maximum_item_count                                         ; $01C227 | | back to continue the search.
    BCC +                                                                       ; $01C229 | |
    PLA                                                                         ; $01C22B | |
    BRA --                                                                      ; $01C22C |/
+   PLA                                                                         ; $01C22E |\
    PLY                                                                         ; $01C22F | | Otherwise, restore the Y register and set the accumulator to zero.
    LDA #0.b                                                                    ; $01C230 |/
    RTS                                                                         ; $01C232

; _menu_equip_check_item_arrow ($01:C233)
;
; Given an item ID in the accumulator, sets the carry flag if the item is an
; arrow (determined by item range) and clears it if it is not.
_menu_equip_check_item_arrow:
    CMP #ITEM_FIRST_ARROW.b                                                     ; $01C233 |\
    BCC +                                                                       ; $01C235 | | If the item ID in the accumulator is in the arrow range, set the
    CMP #ITEM_LAST_ARROW.b + 1                                                  ; $01C237 | | carry flag and return.
    BCS +                                                                       ; $01C239 | |
    SEC                                                                         ; $01C23B | |
    RTS                                                                         ; $01C23C |/
+   CLC                                                                         ; $01C23D | Otherwise, clear the carry flag.
    RTS                                                                         ; $01C23E

; _menu_equip_swap_inventory_and_hand ($01:C23F)
;
; This equip menu helper function simply swaps the item IDs for the currently
; being examined character location and inventory location. It is also used to
; swap the counts by incrementing the X and Y registers.
_menu_equip_swap_inventory_and_hand:
    LDA (<r_menu_selected_character_offset),Y                                   ; $01C23F |\
    PHA                                                                         ; $01C241 | | Swap the IDs of the item in the inventory and the one in the
    LDA r_inventory.1.id.w,X                                                    ; $01C242 | | character's hand.
    STA (<r_menu_selected_character_offset),Y                                   ; $01C245 | |
    PLA                                                                         ; $01C247 | |
    STA r_inventory.1.id.w,X                                                    ; $01C248 |/
    RTS                                                                         ; $01C24B

; _menu_shop_check_character_equipment ($01:C24C)
;
; Given the currently selected item ID in $1B39 and the current character
; record offset in $E5, determines if that character can equip the item in
; question. If so, sets the carry bit. Otherwise, clears the carry bit.
_menu_shop_check_character_equipment:
    LDA #0.b                                                                    ; $01C24C |\ Zero out the high byte of the accumulator.
    XBA                                                                         ; $01C24E |/
    LDA r_menu_equip_selected_item_id.w                                         ; $01C24F |\
    CMP #ITEM_FIRST_BATTLE_ITEM.b                                               ; $01C252 | | If the item is a consumable, branch to clear the carry bit.
    BCS @clear                                                                  ; $01C254 |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $01C256 |\
    ASL A                                                                       ; $01C258 | | Set the X register to the item ID times eight to index the
    ASL A                                                                       ; $01C259 | | equipment properties.
    ASL A                                                                       ; $01C25A | |
    TAX                                                                         ; $01C25B | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01C25C |/
    LDA bank0F.equipment_property_data.l + equipment.flags,X                    ; $01C25E |\
    AND #EQUIPMENT_FLAG_CHARACTER_INDEX.b                                       ; $01C262 | | Set the X register to the equipment character index for the item.
    ASL A                                                                       ; $01C264 | |
    JSR _menu_transfer_a_to_x                                                   ; $01C265 |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $01C268 |\
    LDA bank0F.equipment_character_equip_data.l,X                               ; $01C26A | | Store the list of classes that can use this equipment in a
    STA <r_menu_generic_tmp_word                                                ; $01C26E | | temporary variable.
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01C270 |/
    LDY #character_field.sprite_class.w                                         ; $01C272 |\
    LDA (<r_menu_current_character_offset),Y                                    ; $01C275 | | Extract the current character's class, and add one to represent
    AND #%00001111.b                                                            ; $01C277 | | the number of bits that need to be shifted in the mask.
    INC A                                                                       ; $01C279 | |
    STA <r_menu_shop_check_character_equipment_tmp_class.lo                     ; $01C27A | |
    STZ <r_menu_shop_check_character_equipment_tmp_class.hi                     ; $01C27C |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $01C27E |\
    LDA #1.w                                                                    ; $01C280 | |
-   DEC <r_menu_shop_check_character_equipment_tmp_class                        ; $01C283 | | Shift a single bit to the left that number of times to generate
    BEQ +                                                                       ; $01C285 | | the class mask for this character.
    ASL A                                                                       ; $01C287 | |
    BRA -                                                                       ; $01C288 |/
+   AND <r_menu_generic_tmp_word                                                ; $01C28A |\
    BNE @set                                                                    ; $01C28C | | If the character can use this equipment, branch to set.
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01C28E |/
@clear:
    CLC                                                                         ; $01C290 | Clear the carry bit.
    RTS                                                                         ; $01C291
@set:
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01C292 |\ Set the carry bit.
    SEC                                                                         ; $01C294 |/
    RTS                                                                         ; $01C295

; _menu_shop ($01:C296)
;
; Displays and handles a shop menu.
_menu_shop:
    PHB                                                                         ; $01C296 |\ Preserve the values of the data bank and direct registers.
    PHD                                                                         ; $01C297 |/
    LDX #$0100.w                                                                ; $01C298 |\
    PHX                                                                         ; $01C29B | | Set the direct register to $0100.
    PLD                                                                         ; $01C29C |/
    LDA #$7E.b                                                                  ; $01C29D |\
    PHA                                                                         ; $01C29F | | Set the data bank register to $7E.
    PLB                                                                         ; $01C2A0 |/
    JSR _menu_backup_vram_tiles                                                 ; $01C2A1 | Back up the area of VRAM used for the menu text tiles.
    JSR _menu_init                                                              ; $01C2A4 | Initialize much of the menu system.
    LDX #ITEM_NONE + ((ITEM_FIRST_UNSELLABLE_KEY_ITEM - 1) << 8).w              ; $01C2A7 |\ Enable all items except unsellable key items.
    STX r_menu_inventory_enabled_item_range.w                                   ; $01C2AA |/
    LDA #%00100000.b                                                            ; $01C2AD |\ Set the base flags for the menu character sprites to priority 2.
    STA <r_menu_character_sprite_base_tile_flags                                ; $01C2AF |/
    STZ r_menu_shop_command_index.w                                             ; $01C2B1 | Initialize the command index to zero.
    STZ r_menu_shop_quantity_index.w                                            ; $01C2B4 | Initialize the quantity index to zero.
    JSR _menu_set_bg_scroll_proxy                                               ; $01C2B7 | Set the current BG scroll values.
    LDA #%00100000.b                                                            ; $01C2BA |\ Set the cursor flags for priority 2.
    STA <r_menu_cursor_sprite_flags                                             ; $01C2BC |/
    STZ r_menu_shop_sell_inventory_cursor_coordinates.y.w                       ; $01C2BE | Set the sell cursor Y coordinate to zero.
    JSR _menu_initialize_tilemaps                                               ; $01C2C1 | Initialize the menu tilemaps.
    JSR _menu_initialize_oam                                                    ; $01C2C4 | Initialize the menu OAM.
    JSR _menu_copy_tilemaps_to_vram                                             ; $01C2C7 | Copy the tilemaps to VRAM.
    JSR _menu_copy_oam_to_ppu                                                   ; $01C2CA | Copy the OAM to the PPU.
    JSR _menu_shop_initialize_buy_sell_cursor_rows                              ; $01C2CD | Initialize the cursor rows.
    LDA #10.b                                                                   ; $01C2D0 |\ Set the initial custom quantity to 10.
    STA r_menu_shop_quantity_custom_count.w                                     ; $01C2D2 |/
    JSR _menu_shop_main_loop                                                    ; $01C2D5 | Execute the shop main loop.
    JSR _menu_ppu_fade_out                                                      ; $01C2D8 | After it returns, fade out the PPU.
    JSR _menu_restore_vram_tiles                                                ; $01C2DB | Restore the original VRAM tiles.
    TDC                                                                         ; $01C2DE |\ Set the high byte of the accumulator to zero.
    XBA                                                                         ; $01C2DF |/
    PLD                                                                         ; $01C2E0 |\ Restore the original direct and data bank registers.
    PLB                                                                         ; $01C2E1 |/
    RTS                                                                         ; $01C2E2

; _menu_shop_draw_base_windows ($01:C2E3)
;
; Initializes character sprite properties for the shop menu, and draws many of
; the base windows used by the shop.
_menu_shop_draw_base_windows:
    JSR _menu_set_current_tilemap_bg4                                           ; $01C2E3 | Set BG4 as the currently active tilemap.
    LDX #(192 + (72 << 8)).w                                                    ; $01C2E6 |\ Set the base coordinates for the party sprites to 192, 72.
    STX r_menu_party_sprites_base_coordinates.w                                 ; $01C2E9 |/
    JSR _menu_copy_character_sprite_palettes_to_cgram                           ; $01C2EC | Copy the character sprite palettes to CG-RAM.
    JSR _menu_init_character_sprite_properties                                  ; $01C2EF | Initialize the character sprite properties.
    LDY #menu_window_shop_gp_data.w                                             ; $01C2F2 |\ Draw the GP window to the tilemap data.
    JSR _menu_configure_and_draw_window                                         ; $01C2F5 |/
    JSR _menu_shop_draw_party_gp                                                ; $01C2F8 | Draw the party's GP to the tilemap data.
    LDY #menu_window_shop_buy_sell_exit_data.w                                  ; $01C2FB |\ Draw the Buy/Sell/Exit window to the tilemap data.
    JSR _menu_configure_and_draw_window                                         ; $01C2FE |/
    LDY #menu_window_shop_name_data.w                                           ; $01C301 |\ Draw the shop name window to the tilemap data.
    JSR _menu_configure_and_draw_window                                         ; $01C304 |/
    LDY #menu_window_shop_greeting_data.w                                       ; $01C307 |\ Draw the greeting window to the tilemap data.
    JSR _menu_configure_and_draw_window                                         ; $01C30A |/
    LDA #0.b                                                                    ; $01C30D |\ Zero out the high byte of the accumulator.
    XBA                                                                         ; $01C30F |/
.if FF4_REGION == "JAPAN"
    LDA r_shop_type.w                                                           ; $01C339 |\
    ASL A                                                                       ; $01C33C | | Determine the offset to the shop name by multiplying the shop type
    ASL A                                                                       ; $01C33D | | by five and adding the offset for the shop name data. Transfer the
    ADC r_shop_type.w                                                           ; $01C33E | | result into the Y register.
    REP #FLAG_P_ACCUMULATOR                                                     ; $01C341 | |
    CLC                                                                         ; $01C343 | |
    ADC #shop_name_data.w                                                       ; $01C344 | |
    TAY                                                                         ; $01C347 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01C348 |/
    LDX #(3 * 2) + (1 * 32 * 2).w                                               ; $01C34A |\ Draw the shop name to the tilemap within the shop name window.
    JSR _menu_draw_text_direct                                                  ; $01C34D |/
.else
    LDA r_shop_type.w                                                           ; $01C310 |\
    ASL A                                                                       ; $01C313 | | Determine the offset to the shop name by multiplying the shop type
    ASL A                                                                       ; $01C314 | | by eight and adding the offset for the shop name data. Transfer
    ASL A                                                                       ; $01C315 | | the result into the Y register.
    REP #FLAG_P_ACCUMULATOR                                                     ; $01C316 | |
    CLC                                                                         ; $01C318 | |
    ADC #shop_name_data.w                                                       ; $01C319 | |
    TAY                                                                         ; $01C31C | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01C31D |/
    LDX #(2 * 2) + (1 * 32 * 2).w                                               ; $01C31F |\ Draw the shop name to the tilemap within the shop name window.
    JSR _menu_draw_text_direct                                                  ; $01C322 |/
.endif
    LDY #menu_text_shop_greeting_buy_sell_exit_data.w                           ; $01C325 |\ Draw the shop greeting and the Buy/Sell/Exit options.
    JMP _menu_draw_text_indirect                                                ; $01C328 |/

; _menu_shop_draw_base_and_character_windows ($01:C32B)
;
; Given the 16-bit offset to the desired tilemap array in $29, draws the base
; shop menu windows and the character sprite window to that tilemap.
_menu_shop_draw_base_and_character_windows:
    JSR _menu_shop_draw_base_windows                                            ; $01C32B | Draw the base shop windows.
    LDY #menu_window_shop_character_sprites_data.w                              ; $01C32E |\ Draw the character sprite shop window.
    JMP _menu_configure_and_draw_window                                         ; $01C331 |/

; _menu_shop_main_loop ($01:C334)
;
; The main shop handling loop, which executes either the buy or sell submenus as
; selected by the user.
_menu_shop_main_loop:
    JSR _menu_load_character_sprites                                            ; $01C334 | Load the character sprites.
    JSR _menu_shop_draw_base_and_character_windows                              ; $01C337 | Draw the base and character windows.
    JSR _menu_copy_tilemap_to_vram_bg4                                          ; $01C33A | Copy the BG4 tilemap to VRAM.
    JSR _menu_ppu_fade_in                                                       ; $01C33D | Fade the PPU in.
    BRA @start                                                                  ; $01C340
@start_with_redraw:
    JSR _menu_initialize_tilemaps                                               ; $01C342 | Re-initialize all the tilemaps.
    JSR _menu_shop_draw_base_and_character_windows                              ; $01C345 | Draw the base and character windows.
    JSR _menu_copy_tilemap_to_vram_bg3                                          ; $01C348 |\
    JSR _menu_copy_tilemap_to_vram_bg1                                          ; $01C34B | | Copy the BG1, BG3 and BG4 tilemaps to VRAM.
    JSR _menu_copy_tilemap_to_vram_bg4                                          ; $01C34E |/
@start:
    LDA r_menu_shop_command_index.w                                             ; $01C351 |\
    ASL A                                                                       ; $01C354 | | Set the X coordinate for the cursor by multiplying the command
    ASL A                                                                       ; $01C355 | | index by 40 and then adding 8 (16 in the Japanese version).
    ASL A                                                                       ; $01C356 | |
    STA <r_menu_draw_cursor_arg_coordinates.x                                   ; $01C357 | |
    ASL A                                                                       ; $01C359 | |
    ASL A                                                                       ; $01C35A | |
    ADC <r_menu_draw_cursor_arg_coordinates.x                                   ; $01C35B | |
.if FF4_REGION == "JAPAN"                                                       ;         | |
    ADC #16.b                                                                   ; $01C388 | |
.else                                                                           ;         | |
    ADC #8.b                                                                    ; $01C35D | |
.endif                                                                          ;         | |
    STA <r_menu_draw_cursor_arg_coordinates.x                                   ; $01C35F |/
    LDA #48.b                                                                   ; $01C361 |\ Set the Y coordinate explicitly to 48.
    STA <r_menu_draw_cursor_arg_coordinates.y                                   ; $01C363 |/
    JSR _menu_draw_cursor_1                                                     ; $01C365 | Draw the first cursor with the configured coordinates.
    JSR _menu_shop_update_character_sprites                                     ; $01C368 | Update the character sprites for this frame.
    JSR _menu_wait_for_vblank_copy_oam_to_ppu                                   ; $01C36B | Wait for vblank and copy the OAM to the PPU.
    JSR _menu_copy_tilemap_to_vram_bg4_no_vblank                                ; $01C36E | Copy the BG4 tilemap to VRAM without waiting for vblank.
    JSR _menu_copy_palette_to_cgram                                             ; $01C371 | Copy the current palette data to CG-RAM.
    JSR _menu_update_joypad_and_play_sound_effect                               ; $01C374 | Update the joypads and play a cursor sound effect if appropriate.
    LDA <r_menu_joypad_repeat.hi                                                ; $01C377 |\
    AND #JOYPAD_H_RIGHT.b                                                       ; $01C379 | | If the right d-pad button is pressed, increment the shop command
    BEQ ++                                                                      ; $01C37B | | index. If the value exceeds the value for shop, reset it to the
    LDA r_menu_shop_command_index.w                                             ; $01C37D | | value for buy, to wrap back around.
    INC A                                                                       ; $01C380 | |
    CMP #SHOP_COMMAND_EXIT.b + 1                                                ; $01C381 | |
    BNE +                                                                       ; $01C383 | |
    LDA #SHOP_COMMAND_BUY.b                                                     ; $01C385 | |
+   STA r_menu_shop_command_index.w                                             ; $01C387 |/
++  LDA <r_menu_joypad_repeat.hi                                                ; $01C38A |\
    AND #JOYPAD_H_LEFT.b                                                        ; $01C38C | | If the left d-pad button is pressed, decrement the shop command
    BEQ ++                                                                      ; $01C38E | | index. If the value wrapped into the negatives, reset it to the
    LDA r_menu_shop_command_index.w                                             ; $01C390 | | value for exit, to wrap around.
    DEC A                                                                       ; $01C393 | |
    BPL +                                                                       ; $01C394 | |
    LDA #SHOP_COMMAND_EXIT.b                                                    ; $01C396 | |
+   STA r_menu_shop_command_index.w                                             ; $01C398 |/
++  LDA <r_menu_joypad_repeat.lo                                                ; $01C39B |\
    AND #JOYPAD_L_A.b                                                           ; $01C39D | | If the A button isn't pressed, branch ahead.
    BEQ ++                                                                      ; $01C39F |/
    LDA r_menu_shop_command_index.w                                             ; $01C3A1 |\
    CMP #SHOP_COMMAND_EXIT.b                                                    ; $01C3A4 | | If the selected command was Exit, return to close the shop.
    BNE +                                                                       ; $01C3A6 | |
    RTS                                                                         ; $01C3A8 |/
+   PHA                                                                         ; $01C3A9 |\ Pointlessly push and pop the accumulator.
    PLA                                                                         ; $01C3AA |/
    LDX #menu_shop_buy_sell_jump_data.w                                         ; $01C3AB |\ Execute either the buy or sell handler as appropriate.
    JSR _menu_execute_jump                                                      ; $01C3AE |/
    JSR _menu_erase_cursor_2                                                    ; $01C3B1 | Erase the second cursor (which may be the quantity at this point).
    JMP @start_with_redraw                                                      ; $01C3B4 | Jump back to the start of the input loop with a redraw.
++  LDA <r_menu_joypad_repeat.hi                                                ; $01C3B7 |\
    AND #JOYPAD_H_B.b                                                           ; $01C3B9 | | If the B button is pressed, return.
    BEQ +                                                                       ; $01C3BB | |
    RTS                                                                         ; $01C3BD |/
+   JMP @start                                                                  ; $01C3BE | Otherwise, jump back to the start of the input loop.

; _menu_shop_draw_party_gp ($01:C3C1)
;
; Draws the party GP to the 16-bit tilemap address specified in $29. The actual
; data is offset, as it assumes the tilemap address is the base address for the
; entire tilemap, and this routine sets its own coordinates within that tilemap.
; The _no_label variant only updates the GP, and does not bother with the "GP"
; text.
_menu_shop_draw_party_gp:
    LDY #menu_text_shop_party_gp_data.w                                         ; $01C3C1 |\ Draw the "GP" text into the party GP window.
    JSR _menu_draw_text_indirect                                                ; $01C3C4 |/
_menu_shop_draw_party_gp_no_label:
    JSR _menu_set_current_tilemap_bg4                                           ; $01C3C7 | Set BG4 as the currently active tilemap.
    LDY #$01A6.w                                                                ; $01C3CA |\
    LDA r_party_gp.hi.w                                                         ; $01C3CD | | Write the party's GP as a decimal number to the tilemap,
    LDX r_party_gp.lo.w                                                         ; $01C3D0 | | immediately before the "GP" text.
    JMP _menu_draw_number_as_decimal                                            ; $01C3D3 |/

; menu_shop_buy_sell_jump_data ($01:C3D6)
;
; For either buying or selling, contains pointers to the respective handlers.
menu_shop_buy_sell_jump_data:
    .addr _menu_shop_buy_check_and_run                                          ; $01C3D6.C3D7
    .addr _menu_shop_sell                                                       ; $01C3D8.C3D9

; _menu_shop_buy_check_and_run ($01:C3DA)
;
; Does some preliminary setup, checks to see if there is an empty inventory
; slot, and if so, calls the buy menu. Otherwise, displays a full inventory
; message.
_menu_shop_buy_check_and_run:
    LDA <r_menu_current_tilemap_base_tile_flags                                 ; $01C3DA |\ Duplicate the base tile flags as the extra tile flags.
    STA <r_menu_current_tilemap_extra_tile_flags                                ; $01C3DC |/
    LDA #ITEM_NONE.b                                                            ; $01C3DE |\ Search for an empty inventory slot.
    JSR _menu_find_available_inventory_slot                                     ; $01C3E0 |/
    CMP #0.b                                                                    ; $01C3E3 |\ If one is available, branch to the main buy menu. Otherwise, fall
    BEQ _menu_shop_buy_main                                                     ; $01C3E5 |/ through to the full inventory code.

; _menu_shop_buy_full_inventory ($01:C3E7)
;
; Handles the situation where the player is attempting to buy an item but their
; inventory is full.
_menu_shop_buy_full_inventory:
    JSR _menu_shop_update_character_sprites                                     ; $01C3E7 | Update the character sprites.
    JSR _menu_erase_cursor_1                                                    ; $01C3EA | Erase the first cursor.
    JSR _menu_wait_for_vblank_copy_oam_to_ppu                                   ; $01C3ED | Wait for vblank and copy the OAM to the PPU.
    JSR _menu_set_current_tilemap_bg1                                           ; $01C3F0 | Set the current tilemap to BG1.
    LDY #menu_window_shop_full_inventory_data.w                                 ; $01C3F3 |\ Draw the full inventory dialog.
    JSR _menu_draw_text_indirect_plus_window                                    ; $01C3F6 |/
    JSR _menu_animate_current_tilemap_50_rows_to_vram                           ; $01C3F9 | Animate the window opening from the top.
    JMP _menu_wait_for_input                                                    ; $01C3FC | Wait for input and then return.

; _menu_shop_buy_main ($01:C3FF)
;
; Main function to handle the buy menu. Its main loop is actually the quantity
; selection menu, and it delegates to a subroutine to handle the actual buy
; menu.
_menu_shop_buy_main:
    JSR _menu_initialize_oam                                                    ; $01C3FF | Initialize the menu OAM.
    JSR _menu_set_current_tilemap_bg4                                           ; $01C402 | Set the current tilemap to BG4.
    LDY #menu_window_shop_buy_sell_exit_data.w                                  ; $01C405 |\ Draw the buy/sell/exit window.
    JSR _menu_configure_and_draw_window                                         ; $01C408 |/
    JSR _menu_shop_draw_party_gp                                                ; $01C40B | Draw the party's GP.
    LDY #menu_window_shop_greeting_data.w                                       ; $01C40E |\ Draw the shop greeting window.
    JSR _menu_configure_and_draw_window                                         ; $01C411 |/
    LDY #menu_text_shop_which_one_quantity_data.w                               ; $01C414 |\ Draw the "Which one?" window.
    JSR _menu_draw_text_indirect                                                ; $01C417 |/
    LDY #menu_window_buy_inventory_data.w                                       ; $01C41A |\ Draw the shop inventory window.
    JSR _menu_configure_and_draw_window                                         ; $01C41D |/
    JSR _menu_shop_load_items                                                   ; $01C420 | Load the shop's items for sale.
    TYA                                                                         ; $01C423 |\ Store the item count for later use.
    STA r_menu_shop_item_count.w                                                ; $01C424 |/
    JSR _menu_wait_for_vblank_copy_oam_to_ppu                                   ; $01C427 | Wait for vblank and copy the OAM to the PPU.
    JSR _menu_animate_current_tilemap_50_rows_to_vram                           ; $01C42A | Animate the current tilemap opening from the top.
    STZ r_menu_shop_update_prices.w                                             ; $01C42D | Reset the flag that indicates prices should be updated.
@loop_start:
    JSR _menu_shop_draw_quantity_cursor                                         ; $01C430 | Draw the quantity cursor.
    JSR _menu_shop_update_character_sprites                                     ; $01C433 | Update the character sprites.
    LDA r_menu_shop_quantity_custom_count.w                                     ; $01C436 |\
    LDY #$019A.w                                                                ; $01C439 | | Draw the updated custom quantity.
    JSR _menu_draw_two_digit_number                                             ; $01C43C |/
    JSR _menu_wait_for_vblank_copy_oam_to_ppu                                   ; $01C43F | Wait for vblank and copy the OAM to the PPU.
    JSR _menu_copy_tilemap_to_vram_bg4_no_vblank                                ; $01C442 | Copy the BG4 tilemap to VRAM without waiting for vblank.
    JSR _menu_update_joypad_and_play_sound_effect                               ; $01C445 | Update the joypad values and play any cursor sound effect.
    JSR _menu_shop_quantity_handle_input                                        ; $01C448 | Handle the quantity input.
    LDA r_menu_shop_update_prices.w                                             ; $01C44B |\
    BEQ +                                                                       ; $01C44E | | Update prices if the flag is set.
    STZ r_menu_shop_update_prices.w                                             ; $01C450 | |
    JSR _menu_shop_update_item_prices                                           ; $01C453 |/
+   LDA <r_menu_joypad_repeat.lo                                                ; $01C456 |\
    AND #JOYPAD_L_A.b                                                           ; $01C458 | | If the A button is pressed, pointlessly load the OAM offset for
    BEQ +                                                                       ; $01C45A | | the second cursor into the Y register and then call the buy
    LDY #r_oam.5.w                                                              ; $01C45C | | menu routine. Afterward, erase the second cursor. This routine
    JSR _menu_shop_buy_core                                                     ; $01C45F | | doesn't exit until we return to the quantity menu.
    JMP _menu_erase_cursor_2                                                    ; $01C462 |/
+   LDA <r_menu_joypad_repeat.hi                                                ; $01C465 |\
    AND #JOYPAD_H_B.b                                                           ; $01C467 | | If the B button is pressed, return.
    BEQ +                                                                       ; $01C469 | |
    RTS                                                                         ; $01C46B |/
+   JMP @loop_start                                                             ; $01C46C | Otherwise, jump back to run the loop again.

; _menu_shop_update_item_prices ($01:C46F)
;
; This routine technically loads the shop items and then copies the BG4 tilemap
; to VRAM. The practical effect is to recalculate the prices (after adjusting
; the quantity).
_menu_shop_update_item_prices:
    JSR _menu_shop_load_items                                                   ; $01C46F | Load the shop items and update prices.
    JMP _menu_copy_tilemap_to_vram_bg4                                          ; $01C472 | Copy the tilemap to VRAM.

; _menu_shop_load_items ($01:C475)
;
; Given the current shop index in $1A00, loads the items for sale in that shop
; and stores their IDs and prices in the array at $1B55, and then draws the
; item names and prices to the BG4 tilemap mirror in RAM. Returns the number of
; items in the shop in the Y register.
_menu_shop_load_items:
    LDX <r_menu_zero                                                            ; $01C475 |\
    STX r_menu_shop_buy_item_price_overflow.w + 0                               ; $01C477 | | Set the item price overflow flags for all item indexes to zero.
    STX r_menu_shop_buy_item_price_overflow.w + 2                               ; $01C47A | |
    STX r_menu_shop_buy_item_price_overflow.w + 4                               ; $01C47D | |
    STX r_menu_shop_buy_item_price_overflow.w + 6                               ; $01C480 |/
    JSR _menu_set_current_tilemap_bg4                                           ; $01C483 | Set the current active tilemap to BG4.
    LDX #r_menu_shop_buy_items.w                                                ; $01C486 |\  Set the item pointer to the address to the item array.
    STX <r_menu_shop_load_items_tmp_buy_items_ptr                               ; $01C489 |/
    LDA #0.b                                                                    ; $01C48B |\ Zero out the high byte of the accumulator.
    XBA                                                                         ; $01C48D |/
    LDA r_shop_index.w                                                          ; $01C48E |\
    ASL A                                                                       ; $01C491 | | Calculate the offset for the items in this shop and save it to the
    ASL A                                                                       ; $01C492 | | pointer variable. Each shop can have eight items.
    ASL A                                                                       ; $01C493 | |
    REP #FLAG_P_ACCUMULATOR                                                     ; $01C494 | |
    ADC #bank13.shop_item_data.w                                                ; $01C496 | |
    STA <r_menu_shop_load_items_tmp_shop_items_ptr.address                      ; $01C499 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01C49B | |
    LDA #:bank13.shop_item_data.b                                               ; $01C49D | |
    STA <r_menu_shop_load_items_tmp_shop_items_ptr.bank                         ; $01C49F |/
    LDY <r_menu_zero                                                            ; $01C4A1 | Initialize the Y register to zero.
@loop_start:
    STY r_menu_shop_load_items_tmp_item_index.w                                 ; $01C4A3 | Save the current Y register value as the item index.
    LDA [<r_menu_shop_load_items_tmp_shop_items_ptr],Y                          ; $01C4A6 |\
    CMP #$FF.b                                                                  ; $01C4A8 | | Read the next item in the shop, and if the value is $FF, return as
    BNE +                                                                       ; $01C4AA | | all items have been loaded.
    RTS                                                                         ; $01C4AC |/
+   STA <r_menu_shop_load_items_tmp_item_id                                     ; $01C4AD |\ Save the item ID to a temporary variable and to the shop items
    STA (<r_menu_shop_load_items_tmp_buy_items_ptr)                             ; $01C4AF |/ array.
    JSR _menu_shop_load_items_increment_buy_items_ptr                           ; $01C4B1 | Increment the buy items pointer to now point to the price.
    PHY                                                                         ; $01C4B4 | Preserve the item index.
    JSR _menu_transfer_a_to_x                                                   ; $01C4B5 |\ Read the purchase price byte for the item.
    LDA bank0F.item_purchase_price_data.l,X                                     ; $01C4B8 |/
    BPL +                                                                       ; $01C4BC | Branch forward if the high bit is not set.
    AND #%01111111.b                                                            ; $01C4BE |\
    STA reg_cpu_wrmpya.l                                                        ; $01C4C0 | | Set the multiplication registers to multiply the lower seven bits
    LDA #250.b                                                                  ; $01C4C4 | | by 250.
    STA reg_cpu_wrmpyb.l                                                        ; $01C4C6 |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $01C4CA |\
    TYA                                                                         ; $01C4CC | | While waiting for the multiplication, set the Y register to the
    ASL A                                                                       ; $01C4CD | | offset for the price coordinates of the current item.
    TAX                                                                         ; $01C4CE | |
    LDA menu_shop_buy_item_price_coordinates_data.l,X                           ; $01C4CF | |
    TAY                                                                         ; $01C4D3 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01C4D4 |/
    LDA reg_cpu_rdmpyl.l                                                        ; $01C4D6 |\
    STA <r_menu_generic_tmp_long.lo                                             ; $01C4DA | | Shift the multiplication result left twice to multiply by four,
    LDA reg_cpu_rdmpyh.l                                                        ; $01C4DC | | resulting in a total multiplication of 1000.
    STA <r_menu_generic_tmp_long.md                                             ; $01C4E0 | |
    LDA #0.b                                                                    ; $01C4E2 | |
    STA <r_menu_generic_tmp_long.hi                                             ; $01C4E4 | |
    ROL <r_menu_generic_tmp_long.lo                                             ; $01C4E6 | |
    ROL <r_menu_generic_tmp_long.md                                             ; $01C4E8 | |
    ROL <r_menu_generic_tmp_long.hi                                             ; $01C4EA | |
    ROL <r_menu_generic_tmp_long.lo                                             ; $01C4EC | |
    ROL <r_menu_generic_tmp_long.md                                             ; $01C4EE | |
    ROL <r_menu_generic_tmp_long.hi                                             ; $01C4F0 |/
    LDX <r_menu_generic_tmp_long.lo                                             ; $01C4F2 |\
    REP #FLAG_P_ACCUMULATOR                                                     ; $01C4F4 | | Transfer the resulting 24-bit price into the buy items array, and
    TXA                                                                         ; $01C4F6 | | in the process, increment the buy items pointer to the next item.
    STA (<r_menu_shop_load_items_tmp_buy_items_ptr)                             ; $01C4F7 | | Afterward, branch ahead to the common code.
    INC <r_menu_shop_load_items_tmp_buy_items_ptr                               ; $01C4F9 | |
    INC <r_menu_shop_load_items_tmp_buy_items_ptr                               ; $01C4FB | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01C4FD | |
    LDA <r_menu_generic_tmp_long.hi                                             ; $01C4FF | |
    STA (<r_menu_shop_load_items_tmp_buy_items_ptr)                             ; $01C501 | |
    JSR _menu_shop_load_items_increment_buy_items_ptr                           ; $01C503 | |
    BRA ++                                                                      ; $01C506 |/
+   STA reg_cpu_wrmpya.l                                                        ; $01C508 |\
    LDA #10.b                                                                   ; $01C50C | | If the high bit wasn't set, prepare to multiply the value by 10.
    STA reg_cpu_wrmpyb.l                                                        ; $01C50E |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $01C512 |\
    TYA                                                                         ; $01C514 | | While waiting for the multiplication to finish, set the Y register
    ASL A                                                                       ; $01C515 | | to the offset within the tilemap for the price.
    TAX                                                                         ; $01C516 | |
    LDA menu_shop_buy_item_price_coordinates_data.l,X                           ; $01C517 | |
    TAY                                                                         ; $01C51B |/
    LDA reg_cpu_rdmpy.l                                                         ; $01C51C |\
    TAX                                                                         ; $01C520 | | Transfer the multiplication result to the buy items array, and
    STA (<r_menu_shop_load_items_tmp_buy_items_ptr)                             ; $01C521 | | make sure the pointer is incremented to the ID for the next item.
    INC <r_menu_shop_load_items_tmp_buy_items_ptr                               ; $01C523 | |
    INC <r_menu_shop_load_items_tmp_buy_items_ptr                               ; $01C525 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01C527 | |
    LDA #0.b                                                                    ; $01C529 | |
    STA (<r_menu_shop_load_items_tmp_buy_items_ptr)                             ; $01C52B | |
    JSR _menu_shop_load_items_increment_buy_items_ptr                           ; $01C52D |/
++  JSR _menu_shop_buy_draw_price                                               ; $01C530 | Draw the price to the tilemap.
    REP #FLAG_P_ACCUMULATOR                                                     ; $01C533 |\
    TYA                                                                         ; $01C535 | | Set the X register to the tilemap offset for the tile 8 tiles to
    SEC                                                                         ; $01C536 | | the right and one row above the price coordinates. (Numbers are
    SBC #(-8 + 32) * 2.w                                                        ; $01C537 | | drawn on a single row, but text is drawn with a diacritic row.)
    TAX                                                                         ; $01C53A | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01C53B |/
    LDY #menu_text_shop_party_gp_text_only_data.w                               ; $01C53D |\ Draw the GP text to the chosen location.
    JSR _menu_draw_text_direct                                                  ; $01C540 |/
    PLY                                                                         ; $01C543 | Restore the item index to the Y register.
    LDA <r_menu_shop_load_items_tmp_item_id                                     ; $01C544 | Load the item ID into the accumulator.
    PHY                                                                         ; $01C546 | Preserve the item index again.
    REP #FLAG_P_ACCUMULATOR                                                     ; $01C547 |\
    TYA                                                                         ; $01C549 | | Set the Y register to the coordinates for the item name in the
    ASL A                                                                       ; $01C54A | | tilemap.
    TAX                                                                         ; $01C54B | |
    LDA menu_shop_buy_item_name_coordinates_data.l,X                            ; $01C54C | |
    TAY                                                                         ; $01C550 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01C551 |/
    LDA <r_menu_shop_load_items_tmp_item_id                                     ; $01C553 |\ Draw the item name to the tilemap.
    JSR _menu_draw_item_name_direct                                             ; $01C555 |/
    PLY                                                                         ; $01C558 | Restore the item index to the Y register.
    INY                                                                         ; $01C559 |\
    CPY #8.w                                                                    ; $01C55A | | Increment the index and loop until it reaches eight.
    BEQ +                                                                       ; $01C55D | |
    JMP @loop_start                                                             ; $01C55F |/
+   RTS                                                                         ; $01C562

; menu_shop_buy_item_name_coordinates_data ($01:C563)
;
; For each of the eight item slots when purchasing items, determines the
; coordinates for the name of the item. Item names are drawn using a two row
; routine, so this actually points to the blank row above the name that could
; be used for diacritics.
menu_shop_buy_item_name_coordinates_data:
    MENU_COORDINATES 3, 9                                                       ; $01C563.C564
    MENU_COORDINATES 3, 11                                                      ; $01C565.C566
    MENU_COORDINATES 3, 13                                                      ; $01C567.C568
    MENU_COORDINATES 3, 15                                                      ; $01C569.C56A
    MENU_COORDINATES 3, 17                                                      ; $01C56B.C56C
    MENU_COORDINATES 3, 19                                                      ; $01C56D.C56E
    MENU_COORDINATES 3, 21                                                      ; $01C56F.C570
    MENU_COORDINATES 3, 23                                                      ; $01C571.C572

; menu_shop_buy_item_price_coordinates_data ($01:C573)
;
; For each of the eight item slots when purchasing items, determines the
; coordinates for the price of the item. Note that this points to a location
; that would allow the display of eight digits in the price. Using that many
; digits would also overlap with the item name. Numbers are drawn using a one
; row routine, as they never use diacritics.
menu_shop_buy_item_price_coordinates_data:
    MENU_COORDINATES 11, 10                                                     ; $01C573.C574
    MENU_COORDINATES 11, 12                                                     ; $01C575.C576
    MENU_COORDINATES 11, 14                                                     ; $01C577.C578
    MENU_COORDINATES 11, 16                                                     ; $01C579.C57A
    MENU_COORDINATES 11, 18                                                     ; $01C57B.C57C
    MENU_COORDINATES 11, 20                                                     ; $01C57D.C57E
    MENU_COORDINATES 11, 22                                                     ; $01C57F.C580
    MENU_COORDINATES 11, 24                                                     ; $01C581.C582

; _menu_shop_load_items_increment_buy_items_ptr ($01:C583)
;
; Increments the 16-bit value in $51 by one.
_menu_shop_load_items_increment_buy_items_ptr:
    REP #FLAG_P_ACCUMULATOR                                                     ; $01C583 |\
    INC <r_menu_shop_load_items_tmp_buy_items_ptr                               ; $01C585 | | Increment the pointer.
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01C587 |/
    RTS                                                                         ; $01C589

; _menu_shop_buy_core ($01:C58A)
;
; The handler for the core buy menu.
_menu_shop_buy_core:
    LDA r_menu_shop_selected_item_index.w                                       ; $01C58A |\
    ASL A                                                                       ; $01C58D | | Draw the first cursor at coordinates of 16, 80. The Y coordinate
    ASL A                                                                       ; $01C58E | | is added to the selected item index times 16.
    ASL A                                                                       ; $01C58F | |
    ASL A                                                                       ; $01C590 | |
    ADC #80.b                                                                   ; $01C591 | |
    STA <r_menu_draw_cursor_arg_coordinates.y                                   ; $01C593 | |
    LDA #16.b                                                                   ; $01C595 | |
    STA <r_menu_draw_cursor_arg_coordinates.x                                   ; $01C597 | |
    JSR _menu_draw_cursor_1                                                     ; $01C599 |/
    JSR _menu_shop_update_character_poses                                       ; $01C59C | Update the character poses for the selected item.
    JSR _menu_shop_update_character_sprites                                     ; $01C59F | Update the character sprites.
    JSR _menu_wait_for_vblank_copy_oam_to_ppu                                   ; $01C5A2 | Wait for vblank and copy the OAM to the PPU.
    JSR _menu_update_joypad_and_play_sound_effect                               ; $01C5A5 | Update the joypad values and play any cursor sound effect.
    LDA <r_menu_joypad_repeat.hi                                                ; $01C5A8 |\
    AND #JOYPAD_H_B.b                                                           ; $01C5AA | | If the B button is pressed, return, as this menu is being exited.
    BEQ +                                                                       ; $01C5AC | |
    RTS                                                                         ; $01C5AE |/
+   LDA <r_menu_joypad_repeat.lo                                                ; $01C5AF |\
    AND #JOYPAD_L_A.b                                                           ; $01C5B1 | | If the A button is pressed, attempt to execute the purchase, and
    BEQ +                                                                       ; $01C5B3 | | then clear BG1 and update the party's GP on the tilemap.
    JSR _menu_shop_execute_purchase                                             ; $01C5B5 | |
    JSR _menu_initialize_tilemap_bg1                                            ; $01C5B8 | |
    JSR _menu_copy_tilemap_to_vram_bg1                                          ; $01C5BB | |
    JSR _menu_shop_draw_party_gp_no_label                                       ; $01C5BE | |
    JSR _menu_copy_tilemap_to_vram_bg4                                          ; $01C5C1 |/
+   LDA <r_menu_joypad_repeat.hi                                                ; $01C5C4 |\
    AND #JOYPAD_H_UP.b                                                          ; $01C5C6 | | Skip this next block unless up is pressed.
    BEQ ++                                                                      ; $01C5C8 |/
-   LDA r_menu_shop_selected_item_index.w                                       ; $01C5CA |\
    DEC A                                                                       ; $01C5CD | | Decrement the selected item index by one, and if it goes negative,
    BPL +                                                                       ; $01C5CE | | set it to the total number of items minus one.
    LDA r_menu_shop_item_count.w                                                ; $01C5D0 | |
    DEC A                                                                       ; $01C5D3 | |
+   STA r_menu_shop_selected_item_index.w                                       ; $01C5D4 |/
    JSR _menu_transfer_a_to_x                                                   ; $01C5D7 |\
    LDA r_menu_shop_buy_item_price_overflow.w,X                                 ; $01C5DA | | Repeat until an item is selected that did not overflow the price.
    BNE -                                                                       ; $01C5DD |/
++  LDA <r_menu_joypad_repeat.hi                                                ; $01C5DF |\
    AND #JOYPAD_H_DOWN.b                                                        ; $01C5E1 | | Skip the next block unless down is pressed.
    BEQ ++                                                                      ; $01C5E3 |/
-   LDA r_menu_shop_selected_item_index.w                                       ; $01C5E5 |\
    INC A                                                                       ; $01C5E8 | | Increment the selected item index, and if it reaches the item
    CMP r_menu_shop_item_count.w                                                ; $01C5E9 | | count, reset it back to zero.
    BCC +                                                                       ; $01C5EC | |
    LDA #0.b                                                                    ; $01C5EE | |
+   STA r_menu_shop_selected_item_index.w                                       ; $01C5F0 |/
    JSR _menu_transfer_a_to_x                                                   ; $01C5F3 |\
    LDA r_menu_shop_buy_item_price_overflow.w,X                                 ; $01C5F6 | | Repeat the down movement until a non-overflowed item is selected.
    BNE -                                                                       ; $01C5F9 |/
++  LDA <r_menu_joypad_repeat.hi                                                ; $01C5FB |\
    AND #JOYPAD_H_LEFT.b | JOYPAD_H_RIGHT                                       ; $01C5FD | | If either left or right is pressed, toggle the quantity index
    BEQ +                                                                       ; $01C5FF | | between 0 and 1, update the cursor location, update the item
    LDA r_menu_shop_quantity_index.w                                            ; $01C601 | | prices, and copy the OAM to the PPU.
    EOR #%11111111.b                                                            ; $01C604 | |
    AND #%00000001.b                                                            ; $01C606 | |
    STA r_menu_shop_quantity_index.w                                            ; $01C608 | |
    JSR _menu_shop_draw_quantity_cursor                                         ; $01C60B | |
    JSR _menu_shop_update_item_prices                                           ; $01C60E | |
    JSR _menu_copy_oam_to_ppu                                                   ; $01C611 |/
+   LDA <r_menu_joypad_repeat.lo                                                ; $01C614 |\
    AND #JOYPAD_L_X.b                                                           ; $01C616 | | Skip this last block unless the X button is pressed and the
    BEQ ++                                                                      ; $01C618 | | quantity index is set to 1.
    LDA r_menu_shop_quantity_index.w                                            ; $01C61A | |
    BEQ ++                                                                      ; $01C61D |/
    LDA r_menu_shop_quantity_custom_count.w                                     ; $01C61F |\
    CLC                                                                         ; $01C622 | | Add 10 to the custom quantity, and if it reaches 100, set it
    ADC #10.b                                                                   ; $01C623 | | explicitly back to 10.
    CMP #100.b                                                                  ; $01C625 | |
    BCC +                                                                       ; $01C627 | |
    LDA #10.b                                                                   ; $01C629 | |
+   STA r_menu_shop_quantity_custom_count.w                                     ; $01C62B |/
    LDY #$019A.w                                                                ; $01C62E |\ Update the display of the custom count.
    JSR _menu_draw_two_digit_number                                             ; $01C631 |/
    JSR _menu_shop_update_item_prices                                           ; $01C634 | Update item prices.
++  JMP _menu_shop_buy_core                                                     ; $01C637 | Jump back to continue with this routine.

; _menu_shop_execute_purchase ($01:C63A)
;
; Executes the currently configured purchase, if the party has the necessary GP.
; Otherwise, will display an appropriate dialog.
_menu_shop_execute_purchase:
    LDA r_menu_shop_quantity_index.w                                            ; $01C63A |\
    BEQ +                                                                       ; $01C63D | | Load the current count into the accumulator. If the quantity index
    LDA r_menu_shop_quantity_custom_count.w                                     ; $01C63F | | is zero, then we can add one to get the count. Otherwise, subtract
    DEC A                                                                       ; $01C642 | | one and then add it back from the custom count.
+   INC A                                                                       ; $01C643 |/
    STA <r_menu_generic_tmp_count                                               ; $01C644 | Save the count in a temporary count variable.
    STA r_menu_shop_buy_count.w                                                 ; $01C646 | Save the count additionally in another location.
    LDA r_menu_shop_selected_item_index.w                                       ; $01C649 |\
    ASL A                                                                       ; $01C64C | | Transfer the purchase price of the selected item to a temporary
    ASL A                                                                       ; $01C64D | | variable.
    JSR _menu_transfer_a_to_x                                                   ; $01C64E | |
    LDA r_menu_shop_buy_items.1.price.lo.w,X                                    ; $01C651 | |
    STA <r_menu_shop_gp_tmp_1.lo.lo                                             ; $01C654 | |
    LDA r_menu_shop_buy_items.1.price.md.w,X                                    ; $01C656 | |
    STA <r_menu_shop_gp_tmp_1.lo.hi                                             ; $01C659 | |
    LDA r_menu_shop_buy_items.1.price.hi.w,X                                    ; $01C65B | |
    STA <r_menu_shop_gp_tmp_1.hi.lo                                             ; $01C65E | |
    STZ <r_menu_shop_gp_tmp_1.hi.hi                                             ; $01C660 |/
    STZ <r_menu_shop_gp_tmp_2.lo.lo                                             ; $01C662 |\
    STZ <r_menu_shop_gp_tmp_2.lo.hi                                             ; $01C664 | | Zero out the other temporary GP variable, used for the total price.
    STZ <r_menu_shop_gp_tmp_2.hi.lo                                             ; $01C666 | |
    STZ <r_menu_shop_gp_tmp_2.hi.hi                                             ; $01C668 |/
-   REP #FLAG_P_ACCUMULATOR                                                     ; $01C66A |\
    LDA <r_menu_shop_gp_tmp_1.lo                                                ; $01C66C | | Add the per-item price to the total price.
    CLC                                                                         ; $01C66E | |
    ADC <r_menu_shop_gp_tmp_2.lo                                                ; $01C66F | |
    STA <r_menu_shop_gp_tmp_2.lo                                                ; $01C671 | |
    LDA <r_menu_shop_gp_tmp_1.hi                                                ; $01C673 | |
    ADC <r_menu_shop_gp_tmp_2.hi                                                ; $01C675 | |
    STA <r_menu_shop_gp_tmp_2.hi                                                ; $01C677 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01C679 |/
    DEC <r_menu_generic_tmp_count                                               ; $01C67B |\ Loop until the price has been added the number of times being
    BNE -                                                                       ; $01C67D |/ purchased.
    LDX r_party_gp.lo.w                                                         ; $01C67F |\
    STX <r_menu_shop_gp_tmp_1.lo                                                ; $01C682 | | Set the first temporary GP variable to the party's current GP
    LDA r_party_gp.hi.w                                                         ; $01C684 | | total.
    STA <r_menu_shop_gp_tmp_1.hi.lo                                             ; $01C687 | |
    STZ <r_menu_shop_gp_tmp_1.hi.hi                                             ; $01C689 |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $01C68B |\
    LDA <r_menu_shop_gp_tmp_1.lo                                                ; $01C68D | | Subtract the total price from the party's GP.
    SEC                                                                         ; $01C68F | |
    SBC <r_menu_shop_gp_tmp_2.lo                                                ; $01C690 | |
    STA <r_menu_shop_gp_tmp_1.lo                                                ; $01C692 | |
    LDA <r_menu_shop_gp_tmp_1.hi                                                ; $01C694 | |
    SBC <r_menu_shop_gp_tmp_2.hi                                                ; $01C696 | |
    STA <r_menu_shop_gp_tmp_1.hi                                                ; $01C698 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01C69A |/
    LDA <r_menu_shop_gp_tmp_1.hi.hi                                             ; $01C69C |\ If the high byte of the party's updated GP is still positive,
    BPL @success                                                                ; $01C69E |/ branch to the success code.
    LDX #(192 + (80 << 8)).w                                                    ; $01C6A0 |\ Set the party sprite base coordinates to 192, 80.
    STX r_menu_party_sprites_base_coordinates.w                                 ; $01C6A3 |/
    JSR _menu_init_character_sprite_properties                                  ; $01C6A6 | Initialize the character sprite properties.
    LDA #MENU_POSE_SWOON.b                                                      ; $01C6A9 |\
    STA r_menu_character_sprite_properties_frame_1.1.pose.w                     ; $01C6AB | | Set the pose for all characters to swoon.
    STA r_menu_character_sprite_properties_frame_1.2.pose.w                     ; $01C6AE | |
    STA r_menu_character_sprite_properties_frame_1.3.pose.w                     ; $01C6B1 | |
    STA r_menu_character_sprite_properties_frame_1.4.pose.w                     ; $01C6B4 | |
    STA r_menu_character_sprite_properties_frame_1.5.pose.w                     ; $01C6B7 | |
    STA r_menu_character_sprite_properties_frame_2.1.pose.w                     ; $01C6BA | |
    STA r_menu_character_sprite_properties_frame_2.2.pose.w                     ; $01C6BD | |
    STA r_menu_character_sprite_properties_frame_2.3.pose.w                     ; $01C6C0 | |
    STA r_menu_character_sprite_properties_frame_2.4.pose.w                     ; $01C6C3 | |
    STA r_menu_character_sprite_properties_frame_2.5.pose.w                     ; $01C6C6 |/
    STZ r_menu_shop_character_sprites_frame_change_delay.w                      ; $01C6C9 | Set the sprite frame change delay to zero to immediately switch.
    JSR _menu_shop_update_character_sprites                                     ; $01C6CC | Update the character sprites.
    JSR _menu_wait_for_vblank_copy_oam_to_ppu                                   ; $01C6CF | Wait for vblank and copy the updated OAM to the PPU.
    JSR _menu_set_current_tilemap_bg1                                           ; $01C6D2 | Set the current tilemap to BG1.
    LDY #menu_window_shop_not_enough_gp_data.w                                  ; $01C6D5 |\ Draw the not enough GP dialog to the tilemap.
    JSR _menu_draw_text_indirect_plus_window                                    ; $01C6D8 |/
    JSR _menu_animate_current_tilemap_50_rows_to_vram                           ; $01C6DB | Animate the tilemap opening from the top.
    JSR _play_sound_effect_error                                                ; $01C6DE | Play the error sound effect.
    JSR _menu_wait_for_input                                                    ; $01C6E1 | Wait for input.
    LDX #(192 + (72 << 8)).w                                                    ; $01C6E4 |\ Set the party sprite base coordinates back to 192, 72.
    STX r_menu_party_sprites_base_coordinates.w                                 ; $01C6E7 |/
    JSR _menu_init_character_sprite_properties                                  ; $01C6EA | Initialize the character sprite properties.
    JSR _menu_initialize_tilemap_bg1                                            ; $01C6ED | Initialize the BG1 tilemap to erase it.
    JMP _menu_copy_tilemap_to_vram_bg1                                          ; $01C6F0 | Copy the BG1 tilemap to VRAM and return.
@success:
    LDA #ITEM_NONE.b                                                            ; $01C6F3 |\ Find the index of an empty inventory slot.
    JSR _menu_find_available_inventory_slot                                     ; $01C6F5 |/
    CMP #0.b                                                                    ; $01C6F8 |\
    BEQ +                                                                       ; $01C6FA | | If no slot was found, jump to the full inventory handler.
    JMP _menu_shop_buy_full_inventory                                           ; $01C6FC |/
+   PHX                                                                         ; $01C6FF |\
    LDA <r_menu_shop_gp_tmp_1.lo.lo                                             ; $01C700 | | Update the party's GP with the calculated value.
    STA r_party_gp.lo.w                                                         ; $01C702 | |
    LDX <r_menu_shop_gp_tmp_1.lo.hi                                             ; $01C705 | |
    STX r_party_gp.md.w                                                         ; $01C707 | |
    PLX                                                                         ; $01C70A |/
    LDA r_menu_shop_selected_item_index.w                                       ; $01C70B |\
    ASL A                                                                       ; $01C70E | | Read the ID of the selected item and save it to the inventory in
    ASL A                                                                       ; $01C70F | | the empty slot.
    STA <r_menu_generic_tmp_offset.lo                                           ; $01C710 | |
    LDY <r_menu_generic_tmp_offset                                              ; $01C712 | |
    LDA r_menu_shop_buy_items.1.id.w,Y                                          ; $01C714 | |
    STA r_inventory.1.id.w,X                                                    ; $01C717 |/
    LDA r_menu_shop_buy_count.w                                                 ; $01C71A |\ Set the count to the purchased count.
    STA r_inventory.1.count.w,X                                                 ; $01C71D |/
    JSR _menu_set_current_tilemap_bg1                                           ; $01C720 | Set the current tilemap to BG1.
    LDY #menu_window_shop_thank_you_data.w                                      ; $01C723 |\ Draw the thank you dialog to the tilemap.
    JSR _menu_draw_text_indirect_plus_window                                    ; $01C726 |/
    JSR _menu_shop_update_character_sprites                                     ; $01C729 | Update the character sprites.
    JSR _menu_wait_for_vblank_copy_oam_to_ppu                                   ; $01C72C | Wait for vblank and copy the OAM to the PPU.
    LDA #AUDIO_EFFECT_CASH_REGISTER.b                                           ; $01C72F |\ Play the cash register sound effect.
    JSR _play_sound_effect                                                      ; $01C731 |/
    JSR _menu_copy_tilemap_to_vram_bg1                                          ; $01C734 | Copy the BG1 tilemap to VRAM.
    JSR _menu_wait_for_input                                                    ; $01C737 | Wait for input.
-   JSR _menu_wait_for_vblank_copy_oam_to_ppu                                   ; $01C73A |\
    JSR _menu_update_joypad_and_play_sound_effect                               ; $01C73D | | Wait for the input to be released before returning.
    LDA <r_menu_joypad_pressed.lo                                               ; $01C740 | |
    ORA <r_menu_joypad_pressed.hi                                               ; $01C742 | |
    BNE -                                                                       ; $01C744 |/
    RTS                                                                         ; $01C746

; _menu_shop_update_character_poses ($01:C747)
;
; Given the currently selected item, updates the poses of the five characters
; depending on if they can equip the item or not.
_menu_shop_update_character_poses:
    STZ r_menu_character_sprite_properties_frame_2.1.pose.w                     ; $01C747 |\
    STZ r_menu_character_sprite_properties_frame_2.2.pose.w                     ; $01C74A | | Initialize the second pose of all five characters to normal.
    STZ r_menu_character_sprite_properties_frame_2.3.pose.w                     ; $01C74D | |
    STZ r_menu_character_sprite_properties_frame_2.4.pose.w                     ; $01C750 | |
    STZ r_menu_character_sprite_properties_frame_2.5.pose.w                     ; $01C753 |/
    LDA r_menu_shop_selected_item_index.w                                       ; $01C756 |\
    ASL A                                                                       ; $01C759 | | Load the item ID for the selected item into the accumulator.
    ASL A                                                                       ; $01C75A | |
    JSR _menu_transfer_a_to_x                                                   ; $01C75B | |
    LDA r_menu_shop_buy_items.1.id.w,X                                          ; $01C75E |/
    BNE +                                                                       ; $01C761 |\
-   RTS                                                                         ; $01C763 | | If there is no item or if it's a field consumable, return without
+   CMP #ITEM_FIRST_FIELD_ITEM.b                                                ; $01C764 | | doing anything.
    BCS -                                                                       ; $01C766 |/
    STA r_menu_equip_selected_item_id.w                                         ; $01C768 | Save the selected item ID for later use.
    LDA #0.b                                                                    ; $01C76B |\
-   JSR _menu_shop_update_character_pose_if_can_equip                           ; $01C76D | | Loop through the five character slots, updating their pose if they
    INC A                                                                       ; $01C770 | | can equip the selected item.
    CMP #5.b                                                                    ; $01C771 | |
    BNE -                                                                       ; $01C773 |/
    RTS                                                                         ; $01C775

; _menu_shop_update_character_pose_if_can_equip ($01:C776)
;
; Given an item ID in $1B39 and the current character slot in the accumulator,
; determines if the character can equip that item, and if so, changes the
; second frame of their pose to the cheering pose.
_menu_shop_update_character_pose_if_can_equip:
    PHA                                                                         ; $01C776 | Preserve the value in the accumulator.
    STA <r_menu_current_character_slot                                          ; $01C777 | Save the passed value as the current slot.
    JSR _menu_get_character_id                                                  ; $01C779 | Get the character ID and character record offset for this slot.
    BEQ +                                                                       ; $01C77C | Skip to the end if this slot is empty.
    STX <r_menu_current_character_offset                                        ; $01C77E | Save the current character offset.
    JSR _menu_shop_check_character_equipment                                    ; $01C780 |\
    BCC +                                                                       ; $01C783 | | If the character can equip the currently selected item, set their
    LDA <r_menu_current_character_slot                                          ; $01C785 | | second pose to cheering.
    ASL A                                                                       ; $01C787 | |
    ASL A                                                                       ; $01C788 | |
    JSR _menu_transfer_a_to_x                                                   ; $01C789 | |
    LDA #MENU_POSE_CHEERING.b                                                   ; $01C78C | |
    STA r_menu_character_sprite_properties_frame_2.1.pose.w,X                   ; $01C78E |/
+   PLA                                                                         ; $01C791 | Restore the value in the accumulator.
    RTS                                                                         ; $01C792

; _menu_shop_sell ($01:C793)
;
; Handles the sale menu in a shop.
_menu_shop_sell:
    JSR _menu_shop_initialize_buy_sell_cursor_rows                              ; $01C793 | Initialize the buy and sell cursor Y coordinates to zero.
    LDX #-72.w                                                                  ; $01C796 |\ Set the intial BG3 vertical scroll value to -72 to shift the window
    STX <r_menu_scroll_bg3.vertical.value                                       ; $01C799 |/ down 72 pixels.
    JSR _menu_initialize_tilemap_bg4                                            ; $01C79B | Initialize the BG4 tilemap.
    JSR _menu_shop_draw_base_windows                                            ; $01C79E | Draw the base shop window to BG4.
    JSR _menu_initialize_oam                                                    ; $01C7A1 | Initialize the OAM.
    JSR _menu_copy_tilemap_to_vram_bg4                                          ; $01C7A4 | Copy the BG4 tilemap to VRAM.
    JSR _menu_copy_oam_to_ppu                                                   ; $01C7A7 | Copy the OAM to the PPU.
    JSR _menu_set_current_tilemap_bg1                                           ; $01C7AA | Set the current tilemap to BG1.
    LDY #menu_window_shop_buy_sell_exit_data.w                                  ; $01C7AD |\ Draw the buy/sell/exit window to BG1.
    JSR _menu_configure_and_draw_window                                         ; $01C7B0 |/
    LDY #menu_text_shop_sell_shopkeeper_data.w                                  ; $01C7B3 |\ BUG: Draw the shopkeeper's sell dialog. This doesn't work because
    JSR _menu_draw_text_indirect                                                ; $01C7B6 |/      the data does not set any coordinates, and this uses indirect.
    LDY #menu_text_shop_quantity_data.w                                         ; $01C7B9 |\ Draw the quantity text.
    JSR _menu_draw_text_indirect                                                ; $01C7BC |/
    JSR _menu_set_current_tilemap_bg3                                           ; $01C7BF | Set the current tilemap to BG3.
    JSR _menu_set_bg_scroll_proxy                                               ; $01C7C2 | Set the current BG scroll values to the configured values.
    JSR _menu_inventory_draw_window                                             ; $01C7C5 | Draw the inventory window.
    JSR _menu_copy_tilemap_to_vram_bg3                                          ; $01C7C8 | Copy the BG3 tilemap to VRAM.
    JSR _menu_set_current_tilemap_bg1                                           ; $01C7CB | Set the current tilemap to BG1.
    JSR _menu_wait_for_vblank_copy_oam_to_ppu                                   ; $01C7CE | Wait for vblank and copy the OAM to the PPU.
    JSR _menu_copy_tilemap_to_vram_bg1_no_vblank                                ; $01C7D1 | Copy the BG1 tilemap to VRAM without waiting for vblank.
    JSR _menu_animate_current_tilemap_50_rows_to_vram                           ; $01C7D4 | Animate the first 50 rows of the tilemap from the top.
@loop_start:
    LDA #%00100000                                                              ; $01C7D7 |\ Set the cursor sprite flags to priority 2.
    STA <r_menu_cursor_sprite_flags                                             ; $01C7D9 |/
    LDA r_menu_shop_quantity_index.w                                            ; $01C7DB |\
    BEQ +                                                                       ; $01C7DE | | Depending on the current quantity index, draw the first cursor at
    LDX #(88 + (48 << 8)).w                                                     ; $01C7E0 | | either 64, 48 or 88, 48.
    BRA ++                                                                      ; $01C7E3 | |
+   LDX #(64 + (48 << 8)).w                                                     ; $01C7E5 | | NOTE: The loading of zero into the accumulator seems to be
++  LDY #r_oam.1.w                                                              ; $01C7E8 | |       entirely pointless, as the first thing the called routine
    LDA #0.b                                                                    ; $01C7EB | |       does is load a value into the accumulator.
    JSR _menu_draw_cursor_direct                                                ; $01C7ED |/
    LDA r_menu_shop_quantity_custom_count.w                                     ; $01C7F0 |\
    LDY #(6 * 32 * 2 + 13 * 2).w                                                ; $01C7F3 | | Draw the configured custom quantity to 13, 6.
    JSR _menu_draw_two_digit_number.w                                           ; $01C7F6 |/
    JSR _menu_wait_for_vblank_copy_oam_to_ppu                                   ; $01C7F9 | Wait for vblank and copy the OAM to the PPU.
    JSR _menu_copy_tilemap_to_vram_bg1_no_vblank                                ; $01C7FC | Copy the BG1 tilemap to VRAM.
    JSR _menu_update_joypad_and_play_sound_effect                               ; $01C7FF | Update the joypad values and play a sound effect if appropriate.
    JSR _menu_shop_quantity_handle_input                                        ; $01C802 | Handle input for the quantity sub-menu.
    LDA <r_menu_joypad_repeat.lo                                                ; $01C805 |\
    AND #JOYPAD_L_A.b                                                           ; $01C807 | | If the A button is pressed, back up the quantity cursor to another
    BEQ +                                                                       ; $01C809 | | entry, and then handle the inventory dialog.
    LDY #r_oam.5.w                                                              ; $01C80B | |
    JSR _menu_copy_cursor_1                                                     ; $01C80E | |
    JMP _menu_shop_handle_sale_inventory                                        ; $01C811 |/
+   LDA <r_menu_joypad_repeat.hi                                                ; $01C814 |\
    AND #JOYPAD_H_B.b                                                           ; $01C816 | | If the B button is pressed, return.
    BEQ +                                                                       ; $01C818 | |
    RTS                                                                         ; $01C81A |/
+   JMP @loop_start                                                             ; $01C81B | Otherwise, jump to the start of the input loop.

; _menu_shop_handle_sale_inventory ($01:C81E)
;
; Handles the inventory dialog while selling items at a shop.
_menu_shop_handle_sale_inventory:
    LDA #%00100000.b                                                            ; $01C81E |\ Set the cursor sprite flags to priority 2.
    STA <r_menu_cursor_sprite_flags                                             ; $01C820 |/
    LDA r_menu_shop_sell_inventory_cursor_coordinates.y.w                       ; $01C822 |\
    ASL A                                                                       ; $01C825 | | Set the cursor Y coordinate to the inventory Y coordinate times 16
    ASL A                                                                       ; $01C826 | | plus 88.
    ASL A                                                                       ; $01C827 | |
    ASL A                                                                       ; $01C828 | |
    ADC #88.b                                                                   ; $01C829 | |
    STA <r_menu_draw_cursor_arg_coordinates.y                                   ; $01C82B |/
    LDA r_menu_shop_sell_inventory_cursor_coordinates.x.w                       ; $01C82D |\
    BEQ +                                                                       ; $01C830 | | Set the cursor X coordinate to 8 if the inventory X coordinate is
    LDA #120.b                                                                  ; $01C832 | | zero. Otherwise, set it to 120.
    BRA ++                                                                      ; $01C834 | |
+   LDA #8.b                                                                    ; $01C836 | |
++  STA <r_menu_draw_cursor_arg_coordinates.x                                   ; $01C838 |/
    JSR _menu_draw_cursor_1                                                     ; $01C83A | Draw the first cursor.
    JSR _menu_wait_for_vblank_copy_oam_to_ppu                                   ; $01C83D | Wait for vblank and copy the OAM to the PPU.
    JSR _menu_update_joypad_and_play_sound_effect                               ; $01C840 | Update the joypad values and play a sound effect if appropriate.
@loop_start:
    LDA <r_menu_joypad_repeat.hi                                                ; $01C843 |\
    AND #JOYPAD_H_B.b                                                           ; $01C845 | | If the B button is pressed, clear the carry flag and return.
    BEQ +                                                                       ; $01C847 | |
    CLC                                                                         ; $01C849 | |
    RTS                                                                         ; $01C84A |/
+   LDA <r_menu_joypad_repeat.lo                                                ; $01C84B |\
    AND #JOYPAD_L_A.b                                                           ; $01C84D | | Branch ahead unless the A button is pressed.
    BEQ ++                                                                      ; $01C84F |/
    JSR _menu_shop_handle_sale_confirmation                                     ; $01C851 | Show the sale confirmation dialog.
    BCC +                                                                       ; $01C854 |\
    JSR _menu_initialize_oam                                                    ; $01C856 | | If the sale was executed, re-initialize the OAM and the tilemaps
    JSR _menu_set_current_tilemap_bg3_and_initialize                            ; $01C859 | | to redraw the inventory.
    JSR _menu_inventory_draw_window                                             ; $01C85C | |
    JSR _menu_copy_tilemap_to_vram_bg3                                          ; $01C85F | | BUG: Initializing the OAM is probably a bug here, It ends up
    JSR _menu_shop_draw_party_gp_no_label                                       ; $01C862 | |      clearing the cursor that's currently used to show the
    JSR _menu_copy_tilemap_to_vram_bg4                                          ; $01C865 | |      quantity being sold.
    JSR _menu_initialize_tilemap_bg2_and_copy_to_vram                           ; $01C868 |/
+   LDA #%00100000.b                                                            ; $01C86B |\
    STA <r_menu_cursor_sprite_flags                                             ; $01C86D | | Erase the cursor in the eighth OAM entry. This was used during the
    JSR _menu_set_current_tilemap_bg4                                           ; $01C86F | | sale confirmation dialog to hold the item cursor.
    LDY #r_oam.8.w                                                              ; $01C872 | |
    JSR _menu_erase_cursor_direct                                               ; $01C875 |/
++  LDA <r_menu_joypad_repeat.hi                                                ; $01C878 |\
    AND #JOYPAD_H_RIGHT.b                                                       ; $01C87A | | If the right d-pad button is pressed, toggle the item cursor X
    BEQ +                                                                       ; $01C87C | | coordinate between 0 and 1. If the result is zero, branch ahead to
    LDA r_menu_shop_sell_inventory_cursor_coordinates.x.w                       ; $01C87E | | increment the Y coordinate.
    INC A                                                                       ; $01C881 | |
    AND #%00000001.b                                                            ; $01C882 | |
    STA r_menu_shop_sell_inventory_cursor_coordinates.x.w                       ; $01C884 | |
    BEQ @increment_y                                                            ; $01C887 |/
+   LDA <r_menu_joypad_repeat.hi                                                ; $01C889 |\
    AND #JOYPAD_H_LEFT                                                          ; $01C88B | | If the left d-pad button is pressed, toggle the item cursor X
    BEQ +                                                                       ; $01C88D | | coordinate between 0 and 1. If the result was 1, branch ahead to
    LDA r_menu_shop_sell_inventory_cursor_coordinates.x.w                       ; $01C88F | | decrement the Y coordinate.
    INC A                                                                       ; $01C892 | |
    AND #%00000001.b                                                            ; $01C893 | |
    STA r_menu_shop_sell_inventory_cursor_coordinates.x.w                       ; $01C895 | |
    BNE ++                                                                      ; $01C898 |/
+   LDA <r_menu_joypad_repeat.hi                                                ; $01C89A |\
    AND #JOYPAD_H_UP.b                                                          ; $01C89C | | If the up button is not pressed, branch ahead to check down.
    BEQ @check_down                                                             ; $01C89E |/
++  LDA r_menu_shop_sell_inventory_cursor_coordinates.y.w                       ; $01C8A0 |\
    DEC A                                                                       ; $01C8A3 | | Decrement the current Y cursor coordinate, and if it's not
    BMI +                                                                       ; $01C8A4 | | negative, branch ahead to check down (as we're done here).
    STA r_menu_shop_sell_inventory_cursor_coordinates.y.w                       ; $01C8A6 | | Only update it if it doesn't go negative.
    BRA @check_down                                                             ; $01C8A9 |/
+   LDA r_menu_shop_sell_inventory_first_row.w                                  ; $01C8AB |\
    DEC A                                                                       ; $01C8AE | | If the result was negative, decrement the first row. If positive,
    BMI @check_down                                                             ; $01C8AF | | save the new result, otherwise, branch to check the down button.
    STA r_menu_shop_sell_inventory_first_row.w                                  ; $01C8B1 |/
    LDA #8.b                                                                    ; $01C8B4 |\ We reach this point if scrolling up is necessary. Initialize the
    STA <r_menu_generic_tmp_count                                               ; $01C8B6 |/ counter to eight.
-   REP #FLAG_P_ACCUMULATOR                                                     ; $01C8B8 |\
    DEC <r_menu_scroll_bg3.vertical.value                                       ; $01C8BA | | Decrement the vertical BG3 scroll value by two.
    DEC <r_menu_scroll_bg3.vertical.value                                       ; $01C8BC | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01C8BE |/
    JSR _menu_set_bg_scroll_proxy_vblank                                        ; $01C8C0 | Wait for vblank and update the scroll values.
    DEC <r_menu_generic_tmp_count                                               ; $01C8C3 |\ Decrement the count and loop until it reaches zero.
    BNE -                                                                       ; $01C8C5 |/
    JSR _menu_input_check_left_right                                            ; $01C8C7 |\
    BCS @check_down                                                             ; $01C8CA | | If left or right is either not pressed or pressed but not
    JMP @loop_start                                                             ; $01C8CC |/  repeating on this frame, branch to the inner loop start.
@check_down:
    LDA <r_menu_joypad_repeat.hi                                                ; $01C8CF |\
    AND #JOYPAD_H_DOWN.b                                                        ; $01C8D1 | | If down is not pressed, branch to jump to the next loop.
    BEQ @next                                                                   ; $01C8D3 |/
@increment_y:
    LDA r_menu_shop_sell_inventory_cursor_coordinates.y.w                       ; $01C8D5 |\
    INC A                                                                       ; $01C8D8 | | Increment the cursor Y coordinate. If the value is not eight, save
    CMP #8.b                                                                    ; $01C8D9 | | the updated value and branch to the next iteration of the loop.
    BEQ +                                                                       ; $01C8DB | |
    STA r_menu_shop_sell_inventory_cursor_coordinates.y.w                       ; $01C8DD | |
    BRA @next                                                                   ; $01C8E0 |/
+   LDA r_menu_shop_sell_inventory_first_row.w                                  ; $01C8E2 |\
    INC A                                                                       ; $01C8E5 | | Since the cursor reached the last row, increment the starting row.
    CMP #17.b                                                                   ; $01C8E6 | | If the value is 17, simply branch to the next iteration, because
    BEQ @next                                                                   ; $01C8E8 | | that's too far. Otherwise, save the updated value.
    STA r_menu_shop_sell_inventory_first_row.w                                  ; $01C8EA |/
    LDA #8.b                                                                    ; $01C8ED |\ Initialize the temporary counter to eight.
    STA <r_menu_generic_tmp_count                                               ; $01C8EF |/
-   REP #FLAG_P_ACCUMULATOR                                                     ; $01C8F1 |\
    INC <r_menu_scroll_bg3.vertical.value                                       ; $01C8F3 | | Increment the BG3 vertical scroll value by two.
    INC <r_menu_scroll_bg3.vertical.value                                       ; $01C8F5 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01C8F7 |/
    JSR _menu_set_bg_scroll_proxy_vblank                                        ; $01C8F9 | Wait for vblank and update the scroll values.
    DEC <r_menu_generic_tmp_count                                               ; $01C8FC |\ Decrement the counter and loop until it reaches zero.
    BNE -                                                                       ; $01C8FE |/
    JSR _menu_input_check_left_right                                            ; $01C900 |\
    BCS @next                                                                   ; $01C903 | | If left or right is either not pressed or pressed but not
    JMP @loop_start                                                             ; $01C905 |/  repeating on this frame, branch to the inner loop start.
@next:
    JMP _menu_shop_handle_sale_inventory                                        ; $01C908 | Branch to the start of the function to repeat.

; _menu_shop_handle_sale_confirmation ($01:C90B)
;
; Handles the confirmation of a sale in the shop menu. Handles all input for the
; dialog and updates the inventory and party GP as appropriate. Suffers from a
; bug that prevents it from capping the party GP to 9,999,999 in all cases as
; intended. If the sale was successfully executed, sets the carry flag.
; Otherwise, the flag is cleared.
_menu_shop_handle_sale_confirmation:
    LDA #%00110000.b                                                            ; $01C90B |\ Set the cursor sprite flags to priority 3.
    STA <r_menu_cursor_sprite_flags                                             ; $01C90D |/
    LDA r_menu_shop_sell_inventory_cursor_coordinates.y.w                       ; $01C90F |\
    CLC                                                                         ; $01C912 | | Calculate the selected inventory offset by taking the current
    ADC r_menu_shop_sell_inventory_first_row.w                                  ; $01C913 | | cursor Y coordinate, adding the first row, multiplying by four,
    ASL A                                                                       ; $01C916 | | and then adding twice the X coordinate. Store the result both in
    ASL A                                                                       ; $01C917 | | the X register and a variable.
    ADC r_menu_shop_sell_inventory_cursor_coordinates.x.w                       ; $01C918 | |
    ADC r_menu_shop_sell_inventory_cursor_coordinates.x.w                       ; $01C91B | |
    JSR _menu_transfer_a_to_x                                                   ; $01C91E | |
    STX r_menu_shop_sell_inventory_selected_offset.w                            ; $01C921 |/
    LDA r_inventory.1.id.w,X                                                    ; $01C924 | Load the item ID for that inventory location into the accumulator.
    CMP #ITEM_LEGEND.b                                                          ; $01C927 |\
    BEQ +                                                                       ; $01C929 | | If the item is either the Legend sword, the Crystal or any item
    CMP #ITEM_CRYSTAL.b                                                         ; $01C92B | | starting at Package ($EE) or above, branch to clear the carry flag
    BEQ +                                                                       ; $01C92D | | and return.
    CMP #ITEM_FIRST_UNSELLABLE_KEY_ITEM.b                                       ; $01C92F | |
    BCS +                                                                       ; $01C931 |/
    PHX                                                                         ; $01C933 |\
    JSR _menu_set_current_tilemap_bg2_and_initialize                            ; $01C934 | | Draw the transaction confirmation window.
    LDY #menu_window_shop_confirmation_data.w                                   ; $01C937 | |
    JSR _menu_draw_text_indirect_plus_window                                    ; $01C93A | |
    PLX                                                                         ; $01C93D |/
    LDA r_inventory.1.id.w,X                                                    ; $01C93E |\ Load the item ID into the accumulator and branch to the next
    BNE ++                                                                      ; $01C941 |/ section.
+   CLC                                                                         ; $01C943 |\ Clear the carry flag and return.
    RTS                                                                         ; $01C944 |/
++  STA <r_menu_shop_sell_tmp_item_id                                           ; $01C945 |\ Save the item ID to a couple of temporary locations.
    STA <r_menu_generic_tmp_offset.lo                                           ; $01C947 |/
    LDA r_inventory.1.count.w,X                                                 ; $01C949 |\ Copy the item count to a temporary location.
    STA <r_menu_shop_sell_tmp_item_count                                        ; $01C94C |/
    LDX <r_menu_generic_tmp_offset                                              ; $01C94E |\ Load the item price byte.
    LDA bank0F.item_purchase_price_data.l,X                                     ; $01C950 |/
    BMI +                                                                       ; $01C954 |\
    STA <r_menu_generic_tmp_offset.lo                                           ; $01C956 | | If the byte is in the range from $00 to $7F, multiply the value by
    REP #FLAG_P_ACCUMULATOR                                                     ; $01C958 | | five to determine the price.
    LDA <r_menu_generic_tmp_offset                                              ; $01C95A | |
    ASL A                                                                       ; $01C95C | |
    ASL A                                                                       ; $01C95D | |
    ADC <r_menu_generic_tmp_offset                                              ; $01C95E | |
    STA <r_menu_shop_sell_tmp_item_price                                        ; $01C960 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01C962 | |
    BRA ++                                                                      ; $01C964 |/
+   ASL A                                                                       ; $01C966 |\
    STA reg_cpu_wrmpya.l                                                        ; $01C967 | | Otherwise, multiply the byte by 500 to determine the price,
    LDA #250.b                                                                  ; $01C96B | | ensuring the high byte is eliminated in the process.
    STA reg_cpu_wrmpyb.l                                                        ; $01C96D | |
    PHX                                                                         ; $01C971 | |
    PLX                                                                         ; $01C972 | |
    REP #FLAG_P_ACCUMULATOR                                                     ; $01C973 | |
    LDA reg_cpu_rdmpy.l                                                         ; $01C975 | |
    STA <r_menu_shop_sell_tmp_item_price                                        ; $01C979 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01C97B |/
++  LDA <r_menu_shop_sell_tmp_item_id                                           ; $01C97D |\
    CMP #ITEM_LIFE.b                                                            ; $01C97F | | If the item is in the range from $D1 to $D3 (Ether1, Ether2 and
    BCS +                                                                       ; $01C981 | | Elixir), explicitly set the price to 1.
    CMP #ITEM_ETHER1.b                                                          ; $01C983 | |
    BCC +                                                                       ; $01C985 | |
    LDA #1.b                                                                    ; $01C987 | |
    STA <r_menu_shop_sell_tmp_item_price.lo                                     ; $01C989 | |
    STZ <r_menu_shop_sell_tmp_item_price.hi                                     ; $01C98B |/
+   LDA r_menu_shop_quantity_index.w                                            ; $01C98D |\
    BEQ +                                                                       ; $01C990 | | Set the accumulator to the desired count (either 1 or the custom
    LDA r_menu_shop_quantity_custom_count.w                                     ; $01C992 | | quantity).
    DEC A                                                                       ; $01C995 | |
+   INC A                                                                       ; $01C996 |/
    CMP <r_menu_shop_sell_tmp_item_count                                        ; $01C997 |\
    BCC +                                                                       ; $01C999 | | Ensure the count is no greater than the count in the inventory.
    LDA <r_menu_shop_sell_tmp_item_count                                        ; $01C99B |/
+   STA <r_menu_shop_sell_tmp_count.lo                                          ; $01C99D |\
    STA r_menu_shop_sell_count.w                                                ; $01C99F | | Save the sale count to a couple of variables.
    STZ <r_menu_shop_sell_tmp_count.hi                                          ; $01C9A2 |/
    STZ <r_menu_shop_gp_tmp_1.lo.lo                                             ; $01C9A4 |\
    STZ <r_menu_shop_gp_tmp_1.lo.hi                                             ; $01C9A6 | | Initialize the total price to zero.
    STZ <r_menu_shop_gp_tmp_1.hi.lo                                             ; $01C9A8 | |
    STZ <r_menu_shop_gp_tmp_1.hi.hi                                             ; $01C9AA |/
.if FF4_REGION == "JAPAN"                                                       ;         |\
    LDY #(11 * 2) + (14 * 32 * 2).w                                             ; $01C9D7 | | Draw the number of items being sold to the confirmation window
.else                                                                           ;         | | tilemap.
    LDY #(14 * 2) + (14 * 32 * 2).w                                             ; $01C9AC | |
.endif                                                                          ;         | |
    JSR _menu_draw_two_digit_number                                             ; $01C9AF |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $01C9B2 |\
    LDA #0.w                                                                    ; $01C9B4 | | Loop until the counter reaches zero, each time adding per-item
-   CLC                                                                         ; $01C9B7 | | price to the total. Save the total price.
    ADC <r_menu_shop_sell_tmp_item_price                                        ; $01C9B8 | |
    BCC +                                                                       ; $01C9BA | | NOTE: If the item count is zero, this ends up adding the price
    INC <r_menu_shop_gp_tmp_1.hi                                                ; $01C9BC | |       65536 times (until the counter wraps around back to zero).
+   DEC <r_menu_shop_sell_tmp_count                                             ; $01C9BE | |       This shouldn't normally happen, but does with glitches.
    BNE -                                                                       ; $01C9C0 | |
    STA <r_menu_shop_gp_tmp_1.lo                                                ; $01C9C2 |/
    LDA <r_menu_shop_gp_tmp_1.hi                                                ; $01C9C4 |\
    LDX <r_menu_shop_gp_tmp_1.lo                                                ; $01C9C6 | | Draw the total price to the confirmation window.
.if FF4_REGION == "JAPAN"                                                       ;         | |
    LDY #(10 * 2) + (16 * 32 * 2).w                                             ; $01C9F3 | |
.else                                                                           ;         | |
    LDY #(10 * 2) + (18 * 32 * 2).w                                             ; $01C9C8 | |
.endif                                                                          ;         | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01C9CB | |
    JSR _menu_draw_number_as_decimal                                            ; $01C9CD |/
    STZ <r_menu_current_tilemap_extra_tile_flags                                ; $01C9D0 | Reset the extra tile flags to zero.
    LDA <r_menu_shop_sell_tmp_item_id                                           ; $01C9D2 |\
    LDY #(11 * 32 * 2 + 10 * 2).w                                               ; $01C9D4 | | Draw the item name to the confirmation window.
    JSR _menu_draw_item_name_direct                                             ; $01C9D7 |/
    LDA r_menu_shop_sell_inventory_cursor_coordinates.x.w                       ; $01C9DA |\
    BNE +                                                                       ; $01C9DD | | If the item cursor is in the left column, copy the cursor sprite
    LDY #r_oam.8.w                                                              ; $01C9DF | | to another location. BUG: There are a couple of slots on the right
    JSR _menu_copy_cursor_1                                                     ; $01C9E2 |/  side that should retain the cursor as well.
+   STZ <r_menu_shop_sell_confirmation_cursor_index                             ; $01C9E5 | Initialize the cursor index to zero.
    JSR _menu_animate_current_tilemap_50_rows_to_vram                           ; $01C9E7 | Animate the confirmation dialog opening from the top.
    LDA #%00110000.b                                                            ; $01C9EA |\ Set the cursor flags for priority 3.
    STA <r_menu_cursor_sprite_flags                                             ; $01C9EC |/
@loop_start:
.if FF4_REGION == "JAPAN"                                                       ;         |\
    LDA #176.b                                                                  ; $01CA19 | | Set the Y cursor coordinate to 160 (or 176 in the Japanese
.else                                                                           ;         | | version).
    LDA #160.b                                                                  ; $01C9EE | |
.endif                                                                          ;         | |
    STA <r_menu_draw_cursor_arg_coordinates.y                                   ; $01C9F0 |/
    LDA <r_menu_shop_sell_confirmation_cursor_index                             ; $01C9F2 |\
    BNE +                                                                       ; $01C9F4 | | Set the X cursor coordinates to 80 if the cursor index is zero.
    LDA #80.b                                                                   ; $01C9F6 | | Otherwise, set it to 120 (or 112 in the Japanese version).
    BRA ++                                                                      ; $01C9F8 | |
.if FF4_REGION == "JAPAN"                                                       ;         | |
+   LDA #112.b                                                                  ; $01CA25 | |
.else                                                                           ;         | |
+   LDA #120.b                                                                  ; $01C9FA | |
.endif                                                                          ;         | |
++  STA <r_menu_draw_cursor_arg_coordinates.x                                   ; $01C9FC |/
    JSR _menu_draw_cursor_1                                                     ; $01C9FE | Draw the cursor.
    JSR _menu_wait_for_vblank_copy_oam_to_ppu                                   ; $01CA01 | Wait for vblank and copy the OAM to the PPU.
    JSR _menu_update_joypad_and_play_sound_effect                               ; $01CA04 | Update the joypad values and play an appropriate sound effect.
    LDA <r_menu_joypad_repeat.hi                                                ; $01CA07 |\
    AND #JOYPAD_H_B.b                                                           ; $01CA09 | | If the B button is pressed, reset the tilemap for BG2 and copy it
    BEQ +                                                                       ; $01CA0B | | to VRAM to erase the confirmation dialog. Afterward, clear the
    JSR _menu_initialize_tilemap_bg2_and_copy_to_vram                           ; $01CA0D | | carry flag and return.
    CLC                                                                         ; $01CA10 | |
    RTS                                                                         ; $01CA11 |/
+   LDA <r_menu_joypad_repeat.lo                                                ; $01CA12 |\
    AND #JOYPAD_L_A.b                                                           ; $01CA14 | | If the A button is not pressed, branch ahead to later code.
    BEQ @non_confirm                                                            ; $01CA16 |/
    LDA <r_menu_shop_sell_confirmation_cursor_index                             ; $01CA18 |\
    BEQ +                                                                       ; $01CA1A | | If the player selected "No", clear the tilemap for BG2, clear the
    JSR _menu_initialize_tilemap_bg2_and_copy_to_vram                           ; $01CA1C | | carry flag and return.
    CLC                                                                         ; $01CA1F | |
    RTS                                                                         ; $01CA20 |/
+   REP #FLAG_P_ACCUMULATOR                                                     ; $01CA21 |\
    LDA r_party_gp.lo.w                                                         ; $01CA23 | | Add the low two bytes of the total price to the low two bytes of
    CLC                                                                         ; $01CA26 | | the party GP, which will set the carry flag if it overflows.
    ADC <r_menu_shop_gp_tmp_1.lo                                                ; $01CA27 | |
    STA r_party_gp.lo.w                                                         ; $01CA29 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01CA2C |/
    LDA r_party_gp.hi.w                                                         ; $01CA2E |\
    ADC <r_menu_shop_gp_tmp_1.hi.lo                                             ; $01CA31 | | Now add the third byte, including any carry.
    STA r_party_gp.hi.w                                                         ; $01CA33 |/
    CMP #$98.b                                                                  ; $01CA36 |\
    BCC +                                                                       ; $01CA38 | | Cap the resulting party GP at 9999999.
    LDX #$967F.w                                                                ; $01CA3A | |
    CPX r_party_gp.lo.w                                                         ; $01CA3D | | BUG: This code doesn't quite work right. The way it checks for
    BCS +                                                                       ; $01CA40 | |      values greater than $98967F (9,999,999) will miss any value
    STX r_party_gp.lo.w                                                         ; $01CA42 | |      of $990000 or greater, if the low two bytes are also less
    LDA #$98.b                                                                  ; $01CA45 | |      than $967F.
    STA r_party_gp.hi.w                                                         ; $01CA47 |/
+   LDX r_menu_shop_sell_inventory_selected_offset.w                            ; $01CA4A |\
    LDA r_inventory.1.count.w,X                                                 ; $01CA4D | | Update the item count in the inventory to remove the sold items.
    SEC                                                                         ; $01CA50 | |
    SBC r_menu_shop_sell_count.w                                                ; $01CA51 | |
    STA r_inventory.1.count.w,X                                                 ; $01CA54 |/
    BNE +                                                                       ; $01CA57 |\ If it reaches zero, remove the item from the inventory entirely.
    STA r_inventory.1.id.w,X                                                    ; $01CA59 |/
+   JSR _menu_initialize_tilemap_bg2_and_copy_to_vram                           ; $01CA5C |\
    SEC                                                                         ; $01CA5F | | Clear the BG2 tilemap, set the carry flag and return.
    RTS                                                                         ; $01CA60 |/
@non_confirm:
    LDA <r_menu_joypad_repeat.hi                                                ; $01CA61 |\
    AND #(JOYPAD_H_LEFT | JOYPAD_H_RIGHT).b                                     ; $01CA63 | | If either the left or right joypad button was pressed, toggle the
    BEQ +                                                                       ; $01CA65 | | cursor index between 0 and 1.
    LDA <r_menu_shop_sell_confirmation_cursor_index                             ; $01CA67 | |
    INC A                                                                       ; $01CA69 | |
    AND #%00000001.b                                                            ; $01CA6A | |
    STA <r_menu_shop_sell_confirmation_cursor_index                             ; $01CA6C |/
+   JMP @loop_start                                                             ; $01CA6E | return to the start of the input loop.

; _menu_copy_cursor_1 ($01:CA71)
;
; Given a target offset within bank $7E in the Y register, copies the four OAM
; sprites for the first cursor (though they only use one) to the target address.
_menu_copy_cursor_1:
    REP #FLAG_P_ACCUMULATOR                                                     ; $01CA71 |\
    LDA #_sizeof_oam_sprite.w * 4 - 1                                           ; $01CA73 | | Copy the first four sprite entries to the offset passed in the Y
    LDX #r_oam.1.w                                                              ; $01CA76 | | register.
    MVN :r_oam.b,:r_oam.b                                                       ; $01CA79 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01CA7C |/
    RTS                                                                         ; $01CA7E

; _menu_shop_buy_draw_price ($01:CA7F)
;
; Draws the price for the currently being processed item (the index of which is
; in $1A80). The price of a single item itself should be passed in the X
; register. The Y register should be set to the offset within the tilemap where
; to draw the price.
_menu_shop_buy_draw_price:
    PHA                                                                         ; $01CA7F |\
    LDA r_menu_shop_quantity_index.w                                            ; $01CA80 | | If the quantity index is currently zero (so the quantity is one),
    BNE +                                                                       ; $01CA83 | | simply draw the passed number as a decimal.
    PLA                                                                         ; $01CA85 | |
    JMP _menu_draw_number_as_decimal                                            ; $01CA86 |/
+   PLA                                                                         ; $01CA89 |\
    STZ <r_menu_shop_buy_draw_price_tmp_total_price.hi.hi                       ; $01CA8A | | Initialize both the single item price and the total price to the
    STA <r_menu_shop_buy_draw_price_tmp_total_price.hi.lo                       ; $01CA8C | | value passed in the X register.
    STZ <r_menu_shop_buy_draw_price_tmp_single_price.hi.hi                      ; $01CA8E | |
    STA <r_menu_shop_buy_draw_price_tmp_single_price.hi.lo                      ; $01CA90 | |
    STX <r_menu_shop_buy_draw_price_tmp_total_price.lo                          ; $01CA92 | |
    STX <r_menu_shop_buy_draw_price_tmp_single_price.lo                         ; $01CA94 |/
    LDA r_menu_shop_quantity_custom_count.w                                     ; $01CA96 |\
    DEC A                                                                       ; $01CA99 | | Initialize the counter to the custom quantity minus one (as we've
    STA <r_menu_shop_buy_draw_price_tmp_count.lo                                ; $01CA9A | | already added the first one).
    STZ <r_menu_shop_buy_draw_price_tmp_count.hi                                ; $01CA9C |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $01CA9E |\
-   LDA <r_menu_shop_buy_draw_price_tmp_total_price.lo                          ; $01CAA0 | | Add the single item price to the total until the total price
    CLC                                                                         ; $01CAA2 | | represents the single item price times the custom quantity.
    ADC <r_menu_shop_buy_draw_price_tmp_single_price.lo                         ; $01CAA3 | |
    STA <r_menu_shop_buy_draw_price_tmp_total_price.lo                          ; $01CAA5 | |
    LDA <r_menu_shop_buy_draw_price_tmp_total_price.hi                          ; $01CAA7 | |
    ADC <r_menu_shop_buy_draw_price_tmp_single_price.hi                         ; $01CAA9 | |
    STA <r_menu_shop_buy_draw_price_tmp_total_price.hi                          ; $01CAAB | |
    DEC <r_menu_shop_buy_draw_price_tmp_count                                   ; $01CAAD | |
    BNE -                                                                       ; $01CAAF | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01CAB1 |/
    LDA <r_menu_shop_buy_draw_price_tmp_total_price.hi                          ; $01CAB3 |\
    CMP #$98.b                                                                  ; $01CAB5 | | BUG: This attempts to draw the price if the total is less than 10
    BCS +                                                                       ; $01CAB7 | |      million, and fall through to the next section otherwise, but
    LDX <r_menu_shop_buy_draw_price_tmp_total_price.lo                          ; $01CAB9 | |      it has several bugs: 1) It checks the wrong byte positions
    JMP _menu_draw_number_as_decimal                                            ; $01CABB | |      for $9680 ($989680 is 10 million). 2) It assumes that the
+   LDX <r_menu_shop_buy_draw_price_tmp_total_price.hi                          ; $01CABE | |      first byte will never be more than $98, which is wrong. It's
    CPX #$9680.w                                                                ; $01CAC0 | |      possible they simply abandoned this code and instead made
    BCS +                                                                       ; $01CAC3 | |      sure the maximum item price would never trigger this code. As
    JMP _menu_draw_number_as_decimal                                            ; $01CAC5 |/       a result, this code does not cause problems in vanilla.
+   TYX                                                                         ; $01CAC8 |\
    LDY #menu_text_shop_gp_overflow_data.w                                      ; $01CAC9 | | Copy the "EXPEND" overflow text to the tilemap instead.
    JSR _menu_expand_tiles_to_tilemap                                           ; $01CACC |/
    LDX r_menu_shop_load_items_tmp_item_index.w                                 ; $01CACF |\
    LDA #1.b                                                                    ; $01CAD2 | | Set the flag for this item to indicate its price overflowed.
    STA r_menu_shop_buy_item_price_overflow.w,X                                 ; $01CAD4 |/
    RTS                                                                         ; $01CAD7

; _menu_shop_initialize_buy_sell_cursor_rows ($01:CAD8)
;
; Initializes the cursor rows for the by and sell shop menus to zero.
_menu_shop_initialize_buy_sell_cursor_rows:
    STZ r_menu_shop_selected_item_index.w                                       ; $01CAD8 | Initialize the buying cursor index to zero.
    STZ r_menu_shop_sell_inventory_cursor_coordinates.y.w                       ; $01CADB | Initialize the selling cursor row to zero.
    STZ r_menu_shop_sell_inventory_first_row.w                                  ; $01CADE | Initialize the selling cursor scroll to zero.
    RTS                                                                         ; $01CAE1

; _menu_shop_draw_quantity_cursor ($01:CAE2)
;
; Draws the quantity cursor.
_menu_shop_draw_quantity_cursor:
    LDA r_menu_shop_quantity_index.w                                            ; $01CAE2 |\
    BEQ +                                                                       ; $01CAE5 | | If the quantity index is currently set to 0, set the cursor
    LDX #(88 + (48 << 8)).w                                                     ; $01CAE7 | | coordinates to 64, 48. Otherwise, set it to 88, 48.
    BRA ++                                                                      ; $01CAEA | |
+   LDX #(64 + (48 << 8)).w                                                     ; $01CAEC | |
++  STX <r_menu_draw_cursor_arg_coordinates                                     ; $01CAEF |/
    JMP _menu_draw_cursor_2                                                     ; $01CAF1 | Draw the cursor.

; _menu_shop_quantity_handle_input ($01:CAF4)
;
; Handles the quantity-specific input during the quantity selection part of the
; shop menu.
_menu_shop_quantity_handle_input:
    LDA <r_menu_joypad_repeat.lo                                                ; $01CAF4 |\
    AND #JOYPAD_L_X.b                                                           ; $01CAF6 | | Skip this next block unless the quantity index is set to 1 and the
    BEQ ++                                                                      ; $01CAF8 | | X button is pressed.
    LDA r_menu_shop_quantity_index.w                                            ; $01CAFA | |
    BEQ ++                                                                      ; $01CAFD |/
    LDA r_menu_shop_quantity_custom_count.w                                     ; $01CAFF |\
    CLC                                                                         ; $01CB02 | | Add 10 to the custom count, and if the result is 100 or greater,
    ADC #10.b                                                                   ; $01CB03 | | set the result back to 10. Either way, set the flag to recalculate
    CMP #100.b                                                                  ; $01CB05 | | prices.
    BCC +                                                                       ; $01CB07 | |
    LDA #10.b                                                                   ; $01CB09 | |
+   STA r_menu_shop_quantity_custom_count.w                                     ; $01CB0B | |
    INC r_menu_shop_update_prices.w                                             ; $01CB0E |/
++  LDA <r_menu_joypad_repeat.hi                                                ; $01CB11 |\
    AND #JOYPAD_H_UP.b                                                          ; $01CB13 | | Skip this next block unless up is pressed and the quantity index
    BEQ ++                                                                      ; $01CB15 | | is set to 1.
    LDA r_menu_shop_quantity_index.w                                            ; $01CB17 | |
    BEQ ++                                                                      ; $01CB1A |/
    LDA r_menu_shop_quantity_custom_count.w                                     ; $01CB1C |\
    INC A                                                                       ; $01CB1F | | Increment the custom count by 1, and if the result is 100 or
    CMP #100.b                                                                  ; $01CB20 | | greater, set it explicitly back to 2. Either way, set the flag to
    BCC +                                                                       ; $01CB22 | | recalculate prices.
    LDA #2.b                                                                    ; $01CB24 | |
+   STA r_menu_shop_quantity_custom_count.w                                     ; $01CB26 | |
    INC r_menu_shop_update_prices.w                                             ; $01CB29 |/
++  LDA <r_menu_joypad_repeat.hi                                                ; $01CB2C |\
    AND #JOYPAD_H_DOWN.b                                                        ; $01CB2E | | Skip this next block unless down is pressed and the quantity index
    BEQ ++                                                                      ; $01CB30 | | is set to 1.
    LDA r_menu_shop_quantity_index.w                                            ; $01CB32 | |
    BEQ ++                                                                      ; $01CB35 |/
    LDA r_menu_shop_quantity_custom_count.w                                     ; $01CB37 |\
    DEC A                                                                       ; $01CB3A | | Decrement the custom count by 1, and if the result is less than 2,
    CMP #2.b                                                                    ; $01CB3B | | set the count to 99. Either way, set the flag to recalculate
    BCS +                                                                       ; $01CB3D | | prices.
    LDA #99.b                                                                   ; $01CB3F | |
+   STA r_menu_shop_quantity_custom_count.w                                     ; $01CB41 | |
    INC r_menu_shop_update_prices.w                                             ; $01CB44 |/
++  LDA <r_menu_joypad_repeat.hi                                                ; $01CB47 |\
    AND #JOYPAD_H_LEFT.b | JOYPAD_H_RIGHT                                       ; $01CB49 | | If either the left or right buttons is pressed, toggle the
    BEQ +                                                                       ; $01CB4B | | quantity index between 0 and 1. Additionally set the flag to
    LDA r_menu_shop_quantity_index.w                                            ; $01CB4D | | recalculate prices.
    EOR #%11111111.b                                                            ; $01CB50 | |
    AND #%00000001.b                                                            ; $01CB52 | |
    STA r_menu_shop_quantity_index.w                                            ; $01CB54 | |
    INC r_menu_shop_update_prices.w                                             ; $01CB57 |/
+   RTS                                                                         ; $01CB5A

; _menu_command_save ($01:CB5B)
;
; Handler for the Save command in the main menu.
_menu_command_save:
    LDA r_saving_enabled.w                                                      ; $01CB5B |\
    BNE +                                                                       ; $01CB5E | | If saving is not enabled, play an error sound and return.
    JMP _play_sound_effect_error                                                ; $01CB60 |/
+   JSR _menu_ppu_fade_out                                                      ; $01CB63 | Fade out the PPU.
    JSR _menu_initialize_tilemaps                                               ; $01CB66 | Initialize the four tilemaps.
    JSR _menu_initialize_oam                                                    ; $01CB69 | Initialize the OAM.
    JSR _menu_init_bg_scroll                                                    ; $01CB6C | Initialize the background scroll values.
    JSR _menu_copy_oam_to_ppu                                                   ; $01CB6F | Copy the OAM to the PPU.
    TDC                                                                         ; $01CB72 |\
    JSR _menu_save_get_checksum                                                 ; $01CB73 | | Calculate the current checksum for the current save.
    STX r_checksum.w                                                            ; $01CB76 |/
    JSR _menu_save_backup                                                       ; $01CB79 | Back up the current save data (as it will be overwritten).
    JSR _menu_save_draw_menu                                                    ; $01CB7C | Draw the save menu.
    JSR _menu_set_current_tilemap_bg2                                           ; $01CB7F | Set the current tilemap to BG2.
    LDY #menu_text_save_title_data.w                                            ; $01CB82 |\ Draw the "Save" text that appears as the title.
    JSR _menu_draw_text_indirect                                                ; $01CB85 |/
    JSR _menu_copy_tilemaps_to_vram                                             ; $01CB88 | Copy the tilemaps to VRAM.
    JSR _menu_initialize_oam                                                    ; $01CB8B | Initialize the OAM.
    LDA #1.b                                                                    ; $01CB8E |\ Flag that save unfolding is done so it won't animate opening.
    STA r_menu_save_unfolding_done.w                                            ; $01CB90 |/
    JSR _menu_save_fade_in                                                      ; $01CB93 | Fade in the save menu.
    LDA #1.b                                                                    ; $01CB96 |\ Set the flag that indicates saving is enabled for the menu.
    STA r_menu_save_saving_enabled.w                                            ; $01CB98 |/
    LDA r_menu_save_cursor_index.w                                              ; $01CB9B |\
    BNE +                                                                       ; $01CB9E | | If the save cursor is set to zero, set it to 1, as zero is not a
    LDA #1.b                                                                    ; $01CBA0 | | valid value on the save menu.
    STA r_menu_save_cursor_index.w                                              ; $01CBA2 |/
+   JSR _menu_load_save_slot                                                    ; $01CBA5 | Load the currently selected save slot.
    JSR _menu_load_character_sprites                                            ; $01CBA8 | Load the current character sprites.
    JSR _menu_save_update_character_sprites                                     ; $01CBAB | Update the visible character sprites for the selected save slot.
    JSR _menu_save_main_loop                                                    ; $01CBAE | Execute the main loop for the save menu.
    BCC @canceled                                                               ; $01CBB1 | Branch to the canceled code if no slot was chosen.
    JSR _menu_save_load_confirm_execute                                         ; $01CBB3 | Allow the player to confirm their choice to save.
    BCC @canceled_confirm                                                       ; $01CBB6 | If they cancel, branch to the canceled confirmation code.
    LDA r_menu_save_cursor_index.w                                              ; $01CBB8 |\
    DEC A                                                                       ; $01CBBB | | Calculate the correct offset for the selected save slot and copy
    BMI +                                                                       ; $01CBBC | | the previously backed up save data to that slot.
    ASL A                                                                       ; $01CBBE | |
    ASL A                                                                       ; $01CBBF | |
    ASL A                                                                       ; $01CBC0 | |
    STA <r_menu_generic_tmp_word.hi                                             ; $01CBC1 | |
    STZ <r_menu_generic_tmp_word.lo                                             ; $01CBC3 | |
    LDY <r_menu_generic_tmp_word                                                ; $01CBC5 | |
    LDX #r_menu_save_tmp_data.w                                                 ; $01CBC7 | |
    PHB                                                                         ; $01CBCA | |
    REP #FLAG_P_ACCUMULATOR                                                     ; $01CBCB | |
    LDA #_sizeof_r_menu_save_tmp_data.w - 1                                     ; $01CBCD | |
    MVN :r_menu_save_tmp_data,:s_save_slots                                     ; $01CBD0 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01CBD3 | |
    PLB                                                                         ; $01CBD5 |/
+   JSR _play_sound_effect_menu_chime                                           ; $01CBD6 | Play the menu chime sound effect.
    JSR _menu_set_current_tilemap_bg2                                           ; $01CBD9 | Set the current tilemap to BG2.
    LDY #menu_window_save_done_data.w                                           ; $01CBDC |\ Draw the window for displaying the done text.
    JSR _menu_configure_and_draw_window                                         ; $01CBDF |/
    LDY #menu_text_save_done_data                                               ; $01CBE2 |\ Load the offset for the done message and branch to draw it and
    BRA @draw_message_and_finish                                                ; $01CBE5 |/ finish the routine.
@canceled:
    LDY #menu_text_save_cancelled_data.w                                        ; $01CBE7 | Load the offset for the canceled message and fall through.
@draw_message_and_finish:
    JSR _menu_draw_text_indirect                                                ; $01CBEA | Draw the message whose offset is in the Y register.
    JSR _menu_save_restore                                                      ; $01CBED | Restore the previously backed up save data.
    JSR _menu_copy_tilemap_to_vram_bg2                                          ; $01CBF0 | Copy the BG2 tilemap to VRAM.
    JSR _menu_wait_for_input                                                    ; $01CBF3 | Wait for input to let the player acknowledge the message.
    JSR _menu_ppu_fade_out                                                      ; $01CBF6 | Fade the PPU out.
    JSR _menu_set_palette_window_color                                          ; $01CBF9 |\ Ensure that the correct window color is set.
    JSR _menu_copy_palette_to_cgram                                             ; $01CBFC |/
    JMP _menu_main_fade_in                                                      ; $01CBFF | Fade in the main menu and return.
@canceled_confirm:
    LDY #menu_window_save_done_data.w                                           ; $01CC02 |\ Draw the window for displaying the "Done!" message.
    JSR _menu_configure_and_draw_window                                         ; $01CC05 |/
    LDY #menu_text_save_cancel_data.w                                           ; $01CC08 |\ Branch to draw the cancel message and finish.
    BRA @draw_message_and_finish                                                ; $01CC0B |/ BUG: This won't be drawn as the current tilemap is BG1 right now.

; _menu_save_backup ($01:CC0D)
;
; Backs up the current save data to $F600.
_menu_save_backup:
    LDA #1.b                                                                    ; $01CC0D |\ Set the saved flag.
    STA r_saved.w                                                               ; $01CC0F |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $01CC12 |\
    LDA #_sizeof_r_menu_save_tmp_data.w - 1                                     ; $01CC14 | | Back up the current data to another location in memory.
    LDX #r_character_field.w                                                    ; $01CC17 | |
    LDY #r_menu_save_tmp_data.w                                                 ; $01CC1A | |
    MVN :r_character_field,:r_menu_save_tmp_data                                ; $01CC1D | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01CC20 |/
    RTS                                                                         ; $01CC22

; _menu_save_restore ($01:CC23)
;
; Restores the previously backed up save data.
_menu_save_restore:
    REP #FLAG_P_ACCUMULATOR                                                     ; $01CC23 |\
    LDA #_sizeof_r_menu_save_tmp_data.w - 1                                     ; $01CC25 | | Restore the backed up data to the main memory location.
    LDX #r_menu_save_tmp_data.w                                                 ; $01CC28 | |
    LDY #r_character_field.w                                                    ; $01CC2B | |
    MVN :r_menu_save_tmp_data,:r_character_field                                ; $01CC2E | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01CC31 |/
    RTS                                                                         ; $01CC33 |

; _menu_save_get_checksum ($01:CC34)
;
; Given a number from 0-4 in the accumulator, where 0 refers to memory and 1-4
; refer to the corresponding save slots in SRAM, calculates the checksum for
; that save data. The result is returned in the X register.
_menu_save_get_checksum:
    STA <r_menu_save_tmp_ptr.address.lo                                         ; $01CC34 |\
    ASL A                                                                       ; $01CC36 | | Set the X register to the passed save slot number times 3.
    ADC <r_menu_save_tmp_ptr.address.lo                                         ; $01CC37 | |
    JSR _menu_transfer_a_to_x                                                   ; $01CC39 |/
    LDA save_offset_data.l + 0,X                                                ; $01CC3C |\
    STA <r_menu_save_tmp_ptr.address.lo                                         ; $01CC40 | | Load the desired save address and save it to a pointer variable.
    REP #FLAG_P_ACCUMULATOR                                                     ; $01CC42 | |
    LDA save_offset_data.l + 1,X                                                ; $01CC44 | |
    STA <r_menu_save_tmp_ptr.address.hi                                         ; $01CC48 |/
    LDA <r_menu_zero                                                            ; $01CC4A | Reset the accumulator to zero.
    LDY #_sizeof_save_slot.w - 6                                                ; $01CC4C | Initialize the Y register to the size of a save slot minus six.
    CLC                                                                         ; $01CC4F | Clear the carry bit to prepare for addition.
-   ADC [<r_menu_save_tmp_ptr]                                                  ; $01CC50 |\
    INC <r_menu_save_tmp_ptr.address                                            ; $01CC52 | | Loop through, adding all the bytes in the range.
    DEY                                                                         ; $01CC54 | |
    BNE -                                                                       ; $01CC55 |/
    TAX                                                                         ; $01CC57 | Transfer the result to the X register.
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01CC58 | Switch back to 8-bit accumulator mode.
    RTS                                                                         ; $01CC5A

; save_offset_data ($01:CC5B)
;
; Provides offsets to the five places save-related code might be interested in.
; A value of zero references $1000 through $17FF in memory, which is the data
; that makes up a save. Values 1 through 4 correspond to the same numbered save
; slots in SRAM.
save_offset_data:
    .dl r_character_field                                                       ; $01CC5B.CC5D
    .dl s_save_slots.1                                                          ; $01CC5E.CC60
    .dl s_save_slots.2                                                          ; $01CC61.CC63
    .dl s_save_slots.3                                                          ; $01CC64.CC66
    .dl s_save_slots.4                                                          ; $01CC67.CC69

; _menu_big_chocobo ($01:CC6A)
;
; Run the Big Chocobo menu. Primarily does the environment setup before calling
; the core Big Chocobo routine.
_menu_big_chocobo:
    PHP                                                                         ; $01CC6A |\
    PHB                                                                         ; $01CC6B | | Preserve the process flags and the data bank and direct registers.
    PHD                                                                         ; $01CC6C |/
    LDX #$0100.w                                                                ; $01CC6D |\
    PHX                                                                         ; $01CC70 | | Set the direct register to $0100.
    PLD                                                                         ; $01CC71 |/
    LDA #$7E.b                                                                  ; $01CC72 |\
    PHA                                                                         ; $01CC74 | | Set the data bank register to $7E.
    PLB                                                                         ; $01CC75 |/
    JSR _menu_backup_vram_tiles                                                 ; $01CC76 | Backup certain VRAM tiles the menu system will overwrite.
    STZ r_menu_big_chocobo_from_whistle.w                                       ; $01CC79 | Reset the Whistle flag.
    JSR _menu_big_chocobo_core                                                  ; $01CC7C | Run the Big Chocobo menu.
    TDC                                                                         ; $01CC7F |\ Zero out the high byte of the accumulator.
    XBA                                                                         ; $01CC80 |/
    JSR _menu_restore_vram_tiles                                                ; $01CC81 | Restore the backed up VRAM tiles.
    PLD                                                                         ; $01CC84 |\
    PLB                                                                         ; $01CC85 | | Restore the saved registers.
    PLP                                                                         ; $01CC86 |/
    RTS                                                                         ; $01CC87

; _menu_item_whistle ($01:CC88)
;
; Handles using the Whistle item, which calls the Big Chocobo. This routine
; does not return directly to the caller. Instead, it loads the full return
; stack pointer, which will cause it to exit the menu code upon return.
_menu_item_whistle:
    LDA r_play_audio_current_track.w                                            ; $01CC88 |\ Preserve the value of the currently playing audio track.
    PHA                                                                         ; $01CC8B |/
    STZ r_menu_item_selected.w                                                  ; $01CC8C | Unset the selected item flag.
    LDA #1.b                                                                    ; $01CC8F |\ Set the flag that indicates the Big Chocobo was called from the
    STA r_menu_big_chocobo_from_whistle.w                                       ; $01CC91 |/ Whistle.
    LDX <r_menu_scroll_bg1.vertical.value                                       ; $01CC94 |\ Copy the BG1 vertical scroll value to another location.
    STX r_menu_bg_scroll_vertical_bg1_backup.w                                  ; $01CC96 |/
    LDA #AUDIO_MODE_VOLUME_FADE_OUT_SLOW.b                                      ; $01CC99 |\
    STA r_play_audio_arg_mode.w                                                 ; $01CC9B | | Fade out the currently playing music.
    JSL bank04.play_audio                                                       ; $01CC9E |/
    JSR _menu_ppu_fade_out                                                      ; $01CCA2 | Fade out the PPU.
    LDA #AUDIO_EFFECT_WHISTLE.b                                                 ; $01CCA5 |\ Play the Whistle sound effect.
    JSR _play_sound_effect                                                      ; $01CCA7 |/
    LDA #240.b                                                                  ; $01CCAA |\
-   JSR _menu_wait_for_vblank                                                   ; $01CCAC | | Wait 240 frames.
    DEC A                                                                       ; $01CCAF | |
    BNE -                                                                       ; $01CCB0 |/
    LDA #AUDIO_TRACK_ENTER_FAT_CHOCOBO.b                                        ; $01CCB2 |\ Play the Big Chocobo music.
    JSR _play_audio_track                                                       ; $01CCB4 |/
    JSR _menu_big_chocobo_core                                                  ; $01CCB7 | Execute the Big Chocobo menu.
    PLA                                                                         ; $01CCBA |\ Restore the originally playing music.
    JSR _play_audio_track                                                       ; $01CCBB |/
    LDA #0.b                                                                    ; $01CCBE |\ Zero out the high byte of the accumulator.
    XBA                                                                         ; $01CCC0 |/
    LDX r_menu_return_stack_pointer.w                                           ; $01CCC1 |\ Load the return stack pointer so the return will completely leave
    TXS                                                                         ; $01CCC4 |/ the menu code.
    RTS                                                                         ; $01CCC5

; _play_audio_track ($01:CCC6)
;
; Given a track number in the accumulator, plays that audio track.
_play_audio_track:
    STA r_play_audio_arg_track.w                                                ; $01CCC6 | Set the parameter as the track.
    LDA #AUDIO_MODE_NORMAL.b                                                    ; $01CCC9 |\ Set the audio mode to normal.
    STA r_play_audio_arg_mode.w                                                 ; $01CCCB |/
    JSL bank04.play_audio                                                       ; $01CCCE | Play the audio.
    RTS                                                                         ; $01CCD2

; _menu_big_chocobo_core ($01:CCD3)
;
; Executes the Big Chocobo menu.
_menu_big_chocobo_core:
    JSR _menu_init                                                              ; $01CCD3 | Initialize the menu system.
    JSR _menu_load_character_sprites                                            ; $01CCD6 | Load the character sprites.
    LDA #1.b                                                                    ; $01CCD9 |\ Set the character sprite frame change delay to 1 so updates will
    STA r_menu_shop_character_sprites_frame_change_delay.w                      ; $01CCDB |/ be immediate.
    REP #FLAG_P_ACCUMULATOR                                                     ; $01CCDE |\
    LDA (r_irq_handler.l & $FFFF) + 0                                           ; $01CCE0 | | Preserve the existing IRQ handler address.
    PHA                                                                         ; $01CCE4 | |
    LDA (r_irq_handler.l & $FFFF) + 2                                           ; $01CCE5 | |
    PHA                                                                         ; $01CCE9 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01CCEA |/
    SEI                                                                         ; $01CCEC | Disable interrupts.
    LDA #<menu_big_chocobo_irq_handler                                          ; $01CCED |\
    STA (r_irq_handler.l & $FFFF) + 1                                           ; $01CCEF | | Temporarily set the IRQ handler to the Big Chocobo IRQ handler.
    LDA #>menu_big_chocobo_irq_handler                                          ; $01CCF3 | |
    STA (r_irq_handler.l & $FFFF) + 2                                           ; $01CCF5 | |
    LDA #:menu_big_chocobo_irq_handler                                          ; $01CCF9 | |
    STA (r_irq_handler.l & $FFFF) + 3                                           ; $01CCFB |/
    LDA #%00100001.b                                                            ; $01CCFF |\ Enable automatic joypad reading and the vertical IRQ timer.
    STA reg_cpu_nmitimen.l                                                      ; $01CD01 |/
    LDA reg_cpu_timeup.l                                                        ; $01CD05 | Reset the IRQ flag.
    CLI                                                                         ; $01CD09 | Enable interrupts.
    INC r_menu_namingway_use_namingway_layout.w                                 ; $01CD0A | Set the Namingway layout flag.
    JSR _menu_initialize_tilemaps                                               ; $01CD0D | Initialize the menu tilemaps.
    JSR _menu_initialize_oam                                                    ; $01CD10 | Initialize the OAM.
    JSR _menu_copy_tilemaps_to_vram                                             ; $01CD13 | Copy the tilemaps to VRAM.
    JSR _menu_big_chocobo_init                                                  ; $01CD16 | Do the basic Big Chocobo menu initialization.
    JSR _menu_load_portrait_big_chocobo                                         ; $01CD19 | Load the Big Chocobo portrait and palette.
    JSR _menu_copy_oam_to_ppu                                                   ; $01CD1C | Copy the OAM to the PPU.
    JSR _menu_copy_palette_to_cgram                                             ; $01CD1F | Copy the palette data to CG-RAM.
    JSR _menu_ppu_fade_in                                                       ; $01CD22 | Fade in the PPU.
    JSR _menu_big_chocobo_handle_command_menu                                   ; $01CD25 | Handle the command selection menu.
    STZ r_menu_namingway_use_namingway_layout.w                                 ; $01CD28 | Reset the Namingway layout flag.
    JSR _menu_ppu_fade_out                                                      ; $01CD2B | Fade out the PPU.
    SEI                                                                         ; $01CD2E | Disable interrupts.
    REP #FLAG_P_ACCUMULATOR                                                     ; $01CD2F |\
    PLA                                                                         ; $01CD31 | | Restore the original IRQ handler.
    STA (r_irq_handler.l & $FFFF) + 2                                           ; $01CD32 | |
    PLA                                                                         ; $01CD36 | |
    STA (r_irq_handler.l & $FFFF) + 0                                           ; $01CD37 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01CD3B |/
    RTS                                                                         ; $01CD3D

; _menu_big_chocobo_init ($01:CD3E)
;
; Does some basic initialization of the Big Chocobo menu, by setting up the
; character sprites and drawing the two main windows for the Big Chocobo's
; dialog and the command menu.
_menu_big_chocobo_init:
    LDX #(192 + (72 << 8)).w                                                    ; $01CD3E |\ Set the party sprite base coordinates to 192, 72.
    STX r_menu_party_sprites_base_coordinates.w                                 ; $01CD41 |/ NOTE: These coordinates aren't actually used for anything.
    JSR _menu_copy_character_sprite_palettes_to_cgram                           ; $01CD44 | Copy the character sprite palettes to CG-RAM
    JSR _menu_init_character_sprite_properties                                  ; $01CD47 | Initialize the character sprite properties.
    STZ <r_menu_big_chocobo_irq_index.b                                         ; $01CD4A | Set the IRQ index to zero.
    JSR _menu_set_current_tilemap_bg3                                           ; $01CD4C | Set the current tilemap to BG3.
    LDY #menu_window_big_chocobo_dialog_data.w                                  ; $01CD4F |\ Draw the window used for the Big Chocobo's dialog.
    JSR _menu_configure_and_draw_window                                         ; $01CD52 |/
    LDY #menu_window_big_chocobo_command_menu_data.w                            ; $01CD55 |\ Draw the window and text for the command menu.
    JMP _menu_draw_text_indirect_plus_window                                    ; $01CD58 |/

; _menu_big_chocobo_handle_command_menu ($01:CD5B)
;
; Handles the command menu in the Big Chocobo menu, where the user chooses from
; either Give or Take.
_menu_big_chocobo_handle_command_menu:
    JSR _menu_set_portrait_oam                                                  ; $01CD5B | Set the OAM for the Big Chocobo portrait.
@loop_start_with_redraw:
    JSR _menu_set_current_tilemap_bg3                                           ; $01CD5E | Set the current tilemap to BG3.
    LDA r_menu_big_chocobo_from_whistle.w                                       ; $01CD61 |\
    BEQ +                                                                       ; $01CD64 | | If the Big Chocobo was called with the Whistle and saving is not
    LDA r_saving_enabled.w                                                      ; $01CD66 | | enabled, display the "Did you call me" greeting. Otherwise,
    BNE +                                                                       ; $01CD69 | | display the "What do you want" greeting.
    LDY #menu_text_big_chocobo_did_you_call_me_data.w                           ; $01CD6B | |
    BRA ++                                                                      ; $01CD6E | |
+   LDY #menu_text_big_chocobo_what_do_you_want_data.w                          ; $01CD70 | |
++  JSR _menu_draw_text_indirect                                                ; $01CD73 | |
    STZ r_menu_big_chocobo_from_whistle.w                                       ; $01CD76 |/
    JSR _menu_copy_tilemap_to_vram_bg3                                          ; $01CD79 | Copy the BG3 tilemap to VRAM.
    LDA #%00010111.b                                                            ; $01CD7C |\ Set the active screens to BG1, BG2, BG3 and sprites.
    STA reg_ppu_tm.l                                                            ; $01CD7E |/
    CLI                                                                         ; $01CD82 | Enable interrupts.
@loop_start:
    LDA r_menu_big_chocobo_command_index.w                                      ; $01CD83 |\
    BEQ +                                                                       ; $01CD86 | | Draw the cursor to 16, 64 if the command index is zero, and 64, 64
    LDX #(64 + (64 << 8)).w                                                     ; $01CD88 | | if it's one.
    BRA ++                                                                      ; $01CD8B | |
+   LDX #(16 + (64 << 8)).w                                                     ; $01CD8D | |
++  LDY #r_oam.5.w                                                              ; $01CD90 | |
    JSR _menu_draw_cursor_direct                                                ; $01CD93 |/
    JSR _menu_character_sprite_set_first_poses_normal                           ; $01CD96 | Set the character sprite poses to normal.
    LDX #(136 + (49 << 8)).w                                                    ; $01CD99 |\ Draw the character sprites to 136,49.
    JSR _menu_namingway_draw_character_sprites                                  ; $01CD9C |/
    JSR _menu_wait_for_vblank_copy_oam_to_ppu                                   ; $01CD9F | Wait for vblank and copy the OAM to the PPU.
    JSR _menu_update_joypad_and_play_sound_effect                               ; $01CDA2 | Update the joypad and play a sound effect.
    LDA <r_menu_joypad_repeat.hi                                                ; $01CDA5 |\
    AND #(JOYPAD_H_LEFT | JOYPAD_H_RIGHT).b                                     ; $01CDA7 | | If either left or right are pressed, toggle the command index
    BEQ +                                                                       ; $01CDA9 | | between 0 and 1.
    LDA r_menu_big_chocobo_command_index.w                                      ; $01CDAB | |
    INC A                                                                       ; $01CDAE | |
    AND #%00000001.b                                                            ; $01CDAF | |
    STA r_menu_big_chocobo_command_index.w                                      ; $01CDB1 |/
+   LDA <r_menu_joypad_repeat.hi                                                ; $01CDB4 |\
    AND #JOYPAD_H_B.b                                                           ; $01CDB6 | | If the B button is pressed, return.
    BEQ +                                                                       ; $01CDB8 | |
    RTS                                                                         ; $01CDBA |/
+   LDA <r_menu_joypad_repeat.lo                                                ; $01CDBB |\
    AND #JOYPAD_L_A.b                                                           ; $01CDBD | | If the A button is not pressed, skip this next block.
    BEQ ++                                                                      ; $01CDBF |/
    STZ r_menu_big_chocobo_inventory_first_row.w                                ; $01CDC1 |\
    STZ r_menu_big_chocobo_inventory_cursor_coordinates.y.w                     ; $01CDC4 | | Set the first row and the cursor coordinates to zero.
    STZ r_menu_big_chocobo_inventory_cursor_coordinates.x.w                     ; $01CDC7 |/
    LDX #r_big_chocobo_inventory.w                                              ; $01CDCA |\ Sort the Big Chocobo inventory.
    JSR _menu_sort_inventory                                                    ; $01CDCD |/
    LDX #ITEM_NONE + ((ITEM_FIRST_UNSELLABLE_KEY_ITEM - 1) << 8).w              ; $01CDD0 |\ Enable all items except the unsellable key items.
    STX r_menu_inventory_enabled_item_range.w                                   ; $01CDD3 |/
    LDX #menu_big_chocobo_command_handler_offset_data.w                         ; $01CDD6 |\
    LDA r_menu_big_chocobo_command_index.w                                      ; $01CDD9 | | Dispatch to the handler for the selected command.
    JSR _menu_execute_jump                                                      ; $01CDDC |/
    JSR _menu_initialize_tilemap_bg4                                            ; $01CDDF |\ Clear BG3 and BG4.
    JSR _menu_initialize_tilemap_bg3                                            ; $01CDE2 |/
    JSR _menu_big_chocobo_init                                                  ; $01CDE5 | Initialize the Big Chocobo menu again.
    JSR _menu_erase_cursor_1                                                    ; $01CDE8 |\ Erase the two cursors.
    JSR _menu_erase_cursor_2                                                    ; $01CDEB |/
    JSR _menu_copy_tilemap_to_vram_bg4                                          ; $01CDEE |\ Copy the BG3 and BG4 tilemaps to VRAM.
    JSR _menu_copy_tilemap_to_vram_bg3                                          ; $01CDF1 |/
    JSR _menu_copy_oam_to_ppu                                                   ; $01CDF4 | Copy the OAM to the PPU.
    JMP @loop_start_with_redraw                                                 ; $01CDF7 | Loop to the start and redraw the menu.
++  JMP @loop_start                                                             ; $01CDFA | Loop to the start (if A was not pressed).

; menu_big_chocobo_command_handler_offset_data ($01:CDFD)
;
; For the two values of the command index in the Big Chocobo menu, provides the
; offset to the handler for that command.
menu_big_chocobo_command_handler_offset_data:
    .addr _menu_big_chocobo_handle_command_give                                 ; $01CDFD.CDFE | $00: Give
    .addr _menu_big_chocobo_handle_command_take                                 ; $01CDFF.CE00 | $01: Take

; menu_big_chocobo_irq_handler ($01:CE01)
;
; Handler for IRQ interrupts during the Big Chocobo menu. Handles the mid-frame
; switch to displaying BG4, and then subsequently turning it off later in the
; frame.
menu_big_chocobo_irq_handler:
    PHP                                                                         ; $01CE01 | Preserve the existing processor status register.
    REP #FLAG_P_ACCUMULATOR                                                     ; $01CE02 |\
    PHA                                                                         ; $01CE04 | | Preserve the 16-bit accumulator.
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01CE05 |/
    PHB                                                                         ; $01CE07 | Preserve the data bank register.
    LDA #$00.b                                                                  ; $01CE08 |\
    PHA                                                                         ; $01CE0A | | Set the data bank register to $00.
    PLB                                                                         ; $01CE0B |/
    LDA reg_cpu_timeup.w                                                        ; $01CE0C | Reset the IRQ flag.
    LDA #15.b                                                                   ; $01CE0F |\
-   DEC A                                                                       ; $01CE11 | | Loop for a few cycles to delay until the end of the line.
    BNE -                                                                       ; $01CE12 |/
    LDA r_menu_big_chocobo_irq_index.w                                          ; $01CE14 |\
    BEQ +                                                                       ; $01CE17 | | If this is the second IRQ call this frame, set the IRQ line to 88,
    LDA #88.b                                                                   ; $01CE19 | | zero out the IRQ index, and set the active screens to BG1, BG2,
    STA reg_cpu_vtimel.w                                                        ; $01CE1B | | BG3 and sprites.
    LDA #0.b                                                                    ; $01CE1E | |
    STA reg_cpu_vtimeh.w                                                        ; $01CE20 | |
    STZ r_menu_big_chocobo_irq_index.w                                          ; $01CE23 | |
    LDA #%00010111.b                                                            ; $01CE26 | |
    STA reg_ppu_tm.w                                                            ; $01CE28 | |
    BRA ++                                                                      ; $01CE2B |/
+   LDA #%00011111.b                                                            ; $01CE2D |\
    STA reg_ppu_tm.w                                                            ; $01CE2F | | If this is the first IRQ call this frame, set the IRQ line to 203,
    INC r_menu_big_chocobo_irq_index.w                                          ; $01CE32 | | set the currently configured BG4 scroll register and increment the
    LDA #203.b                                                                  ; $01CE35 | | IRQ index.
    STA reg_cpu_vtimel.w                                                        ; $01CE37 | |
    LDA #0.b                                                                    ; $01CE3A | |
    STA reg_cpu_vtimeh.w                                                        ; $01CE3C | |
    LDA r_menu_scroll_bg4.vertical.value.hi.w                                   ; $01CE3F | |
    XBA                                                                         ; $01CE42 | |
    LDA r_menu_scroll_bg4.vertical.value.lo.w                                   ; $01CE43 | |
    STA reg_ppu_bg4v0fs.w                                                       ; $01CE46 | |
    STA reg_ppu_bg4v0fs.w                                                       ; $01CE49 | |
    XBA                                                                         ; $01CE4C | |
    STA reg_ppu_bg4v0fs.w                                                       ; $01CE4D |/
++  PLB                                                                         ; $01CE50 |\
    REP #FLAG_P_ACCUMULATOR                                                     ; $01CE51 | | Restore the registers.
    PLA                                                                         ; $01CE53 | |
    PLP                                                                         ; $01CE54 |/
    RTI                                                                         ; $01CE55

; _menu_big_chocobo_handle_command_give ($01:CE56)
;
; Handler for the Give command in the Big Chocobo menu. Falls through to the
; next routine.
_menu_big_chocobo_handle_command_give:
    JSR _menu_set_current_tilemap_bg3                                           ; $01CE56 |\
    LDY #menu_text_big_chocobo_what_ll_you_give_me_data.w                       ; $01CE59 | | Draw the Big Chocobo Give dialog to BG3 and transfer it to VRAM.
    JSR _menu_draw_text_indirect                                                ; $01CE5C | |
    JSR _menu_copy_tilemap_to_vram_bg3                                          ; $01CE5F |/
    JSR _menu_set_current_tilemap_bg4_and_initialize                            ; $01CE62 |\ Initialize the BG4 tilemap and draw the inventory window on BG4.
    JSR _menu_inventory_draw_window                                             ; $01CE65 |/
    LDA #17.b                                                                   ; $01CE68 |\ Set the maximum first row to 17, which including the 6 other
    STA <r_menu_inventory_maximum_first_row                                     ; $01CE6A |/ visible rows, gives a max row index of 23.
    LDX #-80.w                                                                  ; $01CE6C |\ Set the BG4 vertical scroll to align it with the inventory window
    STX <r_menu_scroll_bg4.vertical.value                                       ; $01CE6F |/ on BG3.

; _menu_big_chocobo_handle_inventory_menu ($01:CE71)
;
; Handles the actual inventory menu within the Big Chocobo. Distinguishes
; between Give and Take commands by checking the maximum first row value.
_menu_big_chocobo_handle_inventory_menu:
    JSR _menu_set_current_tilemap_bg3                                           ; $01CE71 |\
    LDY #menu_window_big_chocobo_inventory_data.w                               ; $01CE74 | | Draw the inventory window on BG3.
    JSR _menu_configure_and_draw_window                                         ; $01CE77 |/
    JSR _menu_copy_tilemap_to_vram_bg4                                          ; $01CE7A |\ Copy both the BG3 and BG4 tilemaps to VRAM.
    JSR _menu_copy_tilemap_to_vram_bg3                                          ; $01CE7D |/
@outer_start:
    JSR _menu_update_joypad_and_play_sound_effect                               ; $01CE80 | Update the joypad and play any sound effect.
    JSR _menu_big_chocobo_inventory_update_cursor                               ; $01CE83 | Update the cursor display and scrolling.
    JSR _menu_big_chocobo_update_character_sprite_poses                         ; $01CE86 | Update the character sprite poses.
    LDX #(136 + (49 << 8)).w                                                    ; $01CE89 |\ Draw the character sprites to 136, 49.
    JSR _menu_namingway_draw_character_sprites                                  ; $01CE8C |/
    JSR _menu_wait_for_vblank_copy_oam_to_ppu                                   ; $01CE8F | Wait for vblank and copy the OAM to the PPU.
    JSR _menu_copy_tilemap_to_vram_bg4_no_vblank                                ; $01CE92 | Copy the BG4 tilemap to VRAM.
@inner_start:
    LDA <r_menu_joypad_repeat.hi                                                ; $01CE95 |\
    AND #JOYPAD_H_B.b                                                           ; $01CE97 | | If the B button is pressed, sort the Big Chocobo inventory and
    BEQ +                                                                       ; $01CE99 | | return.
    LDX #r_big_chocobo_inventory.w                                              ; $01CE9B | |
    JSR _menu_sort_inventory                                                    ; $01CE9E | |
    CLC                                                                         ; $01CEA1 | |
    RTS                                                                         ; $01CEA2 |/
+   LDA <r_menu_joypad_repeat.lo                                                ; $01CEA3 |\
    AND #JOYPAD_L_A.b                                                           ; $01CEA5 | | If the A button is pressed, determine if the maximum first row
    BEQ ++                                                                      ; $01CEA7 | | corresponds to the player inventory or the Big Chocobo inventory
    LDA <r_menu_inventory_maximum_first_row                                     ; $01CEA9 | | and then call either the give item or take item routine as
    CMP #17.b                                                                   ; $01CEAB | | appropriate.
    BEQ +                                                                       ; $01CEAD | |
    JSR _menu_big_chocobo_take_item                                             ; $01CEAF | |
    BRA ++                                                                      ; $01CEB2 | |
+   JSR _menu_big_chocobo_give_item                                             ; $01CEB4 |/
++  LDA <r_menu_joypad_repeat.hi                                                ; $01CEB7 |\
    AND #JOYPAD_H_RIGHT.b                                                       ; $01CEB9 | | If the right d-pad button is pressed, update the X coordinate. If
    BEQ ++                                                                      ; $01CEBB | | zero, it becomes one. Otherwise, set to zero and then branch to
    LDA r_menu_big_chocobo_inventory_cursor_coordinates.x.w                     ; $01CEBD | | also move down.
    BEQ +                                                                       ; $01CEC0 | |
    STZ r_menu_big_chocobo_inventory_cursor_coordinates.x.w                     ; $01CEC2 | |
    BRA @down                                                                   ; $01CEC5 | |
+   INC r_menu_big_chocobo_inventory_cursor_coordinates.x.w                     ; $01CEC7 |/
++  LDA <r_menu_joypad_repeat.hi                                                ; $01CECA |\
    AND #JOYPAD_H_LEFT.b                                                        ; $01CECC | | If the left d-pad button is pressed, update the X coordinate. If
    BEQ ++                                                                      ; $01CECE | | one, decrement it to zero. Otherwise, increment it to 1 and then
    LDA r_menu_big_chocobo_inventory_cursor_coordinates.x.w                     ; $01CED0 | | branch to also move up.
    BNE +                                                                       ; $01CED3 | |
    INC r_menu_big_chocobo_inventory_cursor_coordinates.x.w                     ; $01CED5 | |
    BRA @up                                                                     ; $01CED8 | |
+   STZ r_menu_big_chocobo_inventory_cursor_coordinates.x.w                     ; $01CEDA |/
++  LDA <r_menu_joypad_repeat.hi                                                ; $01CEDD |\
    AND #JOYPAD_H_UP.b                                                          ; $01CEDF | | Skip the next block unless the up d-pad button is pressed.
    BEQ ++                                                                      ; $01CEE1 |/
@up:
    LDA r_menu_big_chocobo_inventory_cursor_coordinates.y.w                     ; $01CEE3 |\ If the Y coordinate is not zero, branch to simply decrement the
    BNE +                                                                       ; $01CEE6 |/ cursor Y coordinate.
    LDA r_menu_big_chocobo_inventory_first_row.w                                ; $01CEE8 |\ If the first row is already zero, skip the remaining up code as
    BEQ ++                                                                      ; $01CEEB |/ there is no further to go.
    DEC r_menu_big_chocobo_inventory_first_row.w                                ; $01CEED | Otherwise, decrement the first row.
    LDA #8.b                                                                    ; $01CEF0 | Initialize the counter to eight.
-   REP #FLAG_P_ACCUMULATOR                                                     ; $01CEF2 |\
    DEC <r_menu_scroll_bg4.vertical.value                                       ; $01CEF4 | | Decrement the vertical scroll by two.
    DEC <r_menu_scroll_bg4.vertical.value                                       ; $01CEF6 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01CEF8 |/
    PHA                                                                         ; $01CEFA |\
    JSR _menu_big_chocobo_inventory_update_cursor                               ; $01CEFB | | Update the cursor location, and copy the tilemap to VRAM.
    JSR _menu_wait_for_vblank_copy_oam_to_ppu                                   ; $01CEFE | |
    JSR _menu_copy_tilemap_to_vram_bg4_no_vblank                                ; $01CF01 | |
    PLA                                                                         ; $01CF04 |/
    DEC A                                                                       ; $01CF05 |\ Loop until a total of sixteen pixels have been scrolled.
    BNE -                                                                       ; $01CF06 |/
    JSR _menu_update_joypad_and_play_sound_effect                               ; $01CF08 | Update the joypad and play a sound effect.
    LDX <r_menu_joypad_pressed                                                  ; $01CF0B |\ Transfer the pressed joypad values to the repeat joypad values to
    STX <r_menu_joypad_repeat                                                   ; $01CF0D |/ immediately pick up held down buttons.
    JMP @inner_start                                                            ; $01CF0F | Jump to consider the current state of input.
+   DEC r_menu_big_chocobo_inventory_cursor_coordinates.y.w                     ; $01CF12 | Decrement the cursor Y coordinate.
++  LDA <r_menu_joypad_repeat.hi                                                ; $01CF15 |\
    AND #JOYPAD_H_DOWN.b                                                        ; $01CF17 | | Skip the next block unless the down d-pad button is pressed.
    BEQ ++                                                                      ; $01CF19 |/
@down:
    LDA r_menu_big_chocobo_inventory_cursor_coordinates.y.w                     ; $01CF1B |\
    CMP #6.b                                                                    ; $01CF1E | | If the Y coordinate isn't already 6, branch to increment it.
    BNE +                                                                       ; $01CF20 |/
    LDA r_menu_big_chocobo_inventory_first_row.w                                ; $01CF22 |\
    CMP <r_menu_inventory_maximum_first_row                                     ; $01CF25 | | Do nothing if the first row is already at the maximum.
    BEQ ++                                                                      ; $01CF27 |/
    INC r_menu_big_chocobo_inventory_first_row.w                                ; $01CF29 | Increment the first row.
    LDA #8.b                                                                    ; $01CF2C |\
-   REP #FLAG_P_ACCUMULATOR                                                     ; $01CF2E | | Scroll BG4 by sixteen pixels, moving two pixels per frame.
    INC <r_menu_scroll_bg4.vertical.value                                       ; $01CF30 | |
    INC <r_menu_scroll_bg4.vertical.value                                       ; $01CF32 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01CF34 | |
    PHA                                                                         ; $01CF36 | |
    JSR _menu_big_chocobo_inventory_update_cursor                               ; $01CF37 | |
    JSR _menu_wait_for_vblank_copy_oam_to_ppu                                   ; $01CF3A | |
    JSR _menu_copy_tilemap_to_vram_bg4_no_vblank                                ; $01CF3D | |
    PLA                                                                         ; $01CF40 | |
    DEC A                                                                       ; $01CF41 | |
    BNE -                                                                       ; $01CF42 |/
    JSR _menu_update_joypad_and_play_sound_effect                               ; $01CF44 | Update the joypad and play the sound effect.
    LDX <r_menu_joypad_pressed                                                  ; $01CF47 |\ Transfer the pressed joypad value to the repeat joypad value to
    STX <r_menu_joypad_repeat                                                   ; $01CF49 |/ immediately pick up any held buttons.
    JMP @inner_start                                                            ; $01CF4B | Jump back to evaluate the current input.
+   INC r_menu_big_chocobo_inventory_cursor_coordinates.y.w                     ; $01CF4E | Increment the Y cursor coordinate.
++  JMP @outer_start                                                            ; $01CF51 | Jump to the main loop.

; _menu_big_chocobo_inventory_update_cursor ($01:CF54)
;
; Updates the cursor sprite for the Big Chocobo inventory, and ensures that the
; first non-visible row in each direction is correctly drawn to BG4. (Does not,
; however, actually transfer the BG4 tilemap to VRAM.)
_menu_big_chocobo_inventory_update_cursor:
    LDA r_menu_big_chocobo_inventory_cursor_coordinates.y.w                     ; $01CF54 |\
    ASL A                                                                       ; $01CF57 | | Set the Y coordinate of the cursor sprite to the cursor Y
    ASL A                                                                       ; $01CF58 | | coordinate times 16 plus 95.
    ASL A                                                                       ; $01CF59 | |
    ASL A                                                                       ; $01CF5A | |
    CLC                                                                         ; $01CF5B | |
    ADC #95.b                                                                   ; $01CF5C | |
    STA <r_menu_load_inventory_tmp_inventory_ptr.hi                             ; $01CF5E |/
    LDA r_menu_big_chocobo_inventory_cursor_coordinates.x.w                     ; $01CF60 |\
    BEQ +                                                                       ; $01CF63 | | Set the X coordinate of the cursor sprite to either 8 or 120,
    LDA #120.b                                                                  ; $01CF65 | | depending on if the left or right column is selected.
    BRA ++                                                                      ; $01CF67 | |
+   LDA #8.b                                                                    ; $01CF69 | |
++  STA <r_menu_load_inventory_tmp_inventory_ptr.lo                             ; $01CF6B |/
    LDX <r_menu_load_inventory_tmp_inventory_ptr                                ; $01CF6D |\
    LDY #r_oam.1.w                                                              ; $01CF6F | | Draw the cursor to the first OAM entry.
    TDC                                                                         ; $01CF72 | |
    JSR _menu_draw_cursor_direct                                                ; $01CF73 |/
    JSL bank1E.menu_inventory_update_bg4_scroll                                 ; $01CF76 | Update BG4 with any new entries just above or below the visible.
    RTS                                                                         ; $01CF7A

; _menu_big_chocobo_inventory_get_cursor_offset ($01:CF7B)
;
; Returns the offset to the currently selected item in the Big Chocobo
; inventory. The offset is relative to the base offset for the inventory being
; examined.
_menu_big_chocobo_inventory_get_cursor_offset:
    LDA r_menu_big_chocobo_inventory_first_row.w                                ; $01CF7B |\
    CLC                                                                         ; $01CF7E | | Calculate the offset by adding the Y coordinate to the first row,
    ADC r_menu_big_chocobo_inventory_cursor_coordinates.y.w                     ; $01CF7F | | multiplying by two, adding the X coordinate, and then multiplying
    ASL A                                                                       ; $01CF82 | | by two again.
    ADC r_menu_big_chocobo_inventory_cursor_coordinates.x.w                     ; $01CF83 | |
    ASL A                                                                       ; $01CF86 | |
    STA <r_menu_generic_tmp_offset.lo                                           ; $01CF87 |/
    LDX <r_menu_generic_tmp_offset                                              ; $01CF89 | Load the offset into the X register.
    RTS                                                                         ; $01CF8B

; _menu_big_chocobo_give_item ($01:CF8C)
;
; Handles giving the currently selected item in the player inventory to the Big
; Chocobo.
_menu_big_chocobo_give_item:
    JSR _menu_big_chocobo_inventory_get_cursor_offset                           ; $01CF8C |\
    LDA r_inventory.1.id.w,X                                                    ; $01CF8F | | Read the currently selected inventory item. If the item is the
    BEQ +                                                                       ; $01CF92 | | Legend sword, the Crystal, or a key item (items $EE and higher),
    CMP #ITEM_LEGEND.b                                                          ; $01CF94 | | return without doing anything.
    BEQ +                                                                       ; $01CF96 | |
    CMP #ITEM_CRYSTAL.b                                                         ; $01CF98 | |
    BEQ +                                                                       ; $01CF9A | |
    CMP #ITEM_FIRST_UNSELLABLE_KEY_ITEM.b                                       ; $01CF9C | |
    BCC ++                                                                      ; $01CF9E | |
+   BRA __menu_big_chocobo_give_item_done                                       ; $01CFA0 |/
++  LDA #_sizeof_r_big_chocobo_inventory.b / 2                                  ; $01CFA2 |\ Initialize the counter to the size of the Big Chocobo inventory in
    STA <r_menu_generic_tmp_count                                               ; $01CFA4 |/ items.
    LDY <r_menu_zero                                                            ; $01CFA6 | Initialize the Y register to zero.
-   LDA r_big_chocobo_inventory.1.id.w,Y                                        ; $01CFA8 |\ If the current location is empty, branch to the next code.
    BEQ __menu_big_chocobo_give_item_next                                       ; $01CFAB |/
    CMP r_inventory.1.id.w,X                                                    ; $01CFAD |\
    BNE +                                                                       ; $01CFB0 | | If the item in the current inventory slot is the same as the item
    LDA r_big_chocobo_inventory.1.count.w,Y                                     ; $01CFB2 | | in the Big Chocobo inventory slot, and if the total count is less
    CLC                                                                         ; $01CFB5 | | than 100, branch to the next code.
    ADC r_inventory.1.count.w,X                                                 ; $01CFB6 | |
    CMP #100.b                                                                  ; $01CFB9 | |
    BCC __menu_big_chocobo_give_item_next                                       ; $01CFBB |/
+   INY                                                                         ; $01CFBD |\
    INY                                                                         ; $01CFBE | | Otherwise, loop to check the next slot.
    DEC <r_menu_generic_tmp_count                                               ; $01CFBF | |
    BNE -                                                                       ; $01CFC1 |/
    JSR _menu_set_current_tilemap_bg3                                           ; $01CFC3 |\
    LDY #menu_text_big_chocobo_im_full_data.w                                   ; $01CFC6 | | If no slot was found, display an error message and return.
    JSR _menu_draw_text_indirect                                                ; $01CFC9 | |
    JSR _menu_copy_tilemap_to_vram_bg3                                          ; $01CFCC |/
__menu_big_chocobo_give_item_done:
    RTS                                                                         ; $01CFCF
__menu_big_chocobo_give_item_next:
    LDA r_inventory.1.id.w,X                                                    ; $01CFD0 |\ Transfer the item ID from the inventory to the Big Chocobo
    STA r_big_chocobo_inventory.1.id.w,Y                                        ; $01CFD3 |/ inventory.
    LDA r_inventory.1.count.w,X                                                 ; $01CFD6 |\
    CLC                                                                         ; $01CFD9 | | Add the inventory count to the Big Chocobo count.
    ADC r_big_chocobo_inventory.1.count.w,Y                                     ; $01CFDA | |
    STA r_big_chocobo_inventory.1.count.w,Y                                     ; $01CFDD |/
    STZ r_inventory.1.id.w,X                                                    ; $01CFE0 |\ Remove the item from the regular inventory.
    STZ r_inventory.1.count.w,X                                                 ; $01CFE3 |/
    JSR _menu_set_current_tilemap_bg4_and_initialize                            ; $01CFE6 |\
    JSR _menu_inventory_draw_window                                             ; $01CFE9 | | Update the display and return.
    JMP _menu_copy_tilemap_to_vram_bg4                                          ; $01CFEC |/

; _menu_big_chocobo_take_item ($01:CFEF)
;
; Takes the currently selected from the Big Chocobo inventory and transfers it
; to the regular inventory.
_menu_big_chocobo_take_item:
    JSR _menu_big_chocobo_inventory_get_cursor_offset                           ; $01CFEF |\
    LDA r_big_chocobo_inventory.1.id.w,X                                        ; $01CFF2 | | Skip this routine if the current spot is empty.
    BEQ __menu_big_chocobo_give_item_done                                       ; $01CFF5 |/
    LDA #_sizeof_r_inventory.b / 2                                              ; $01CFF7 |\ Initialize the count to the size of the regular inventory in items.
    STA <r_menu_generic_tmp_count                                               ; $01CFF9 |/
    LDY <r_menu_zero                                                            ; $01CFFB | Initialize the Y register to zero.
-   LDA r_inventory.1.id.w,Y                                                    ; $01CFFD |\
    BEQ +                                                                       ; $01D000 | | Search for an empty spot in the inventory. If one is found, branch
    INY                                                                         ; $01D002 | | to the later code.
    INY                                                                         ; $01D003 | |
    DEC <r_menu_generic_tmp_count                                               ; $01D004 | |
    BNE -                                                                       ; $01D006 |/
    JSR _menu_set_current_tilemap_bg3                                           ; $01D008 |\
    LDY #menu_text_big_chocobo_clean_your_bag_data.w                            ; $01D00B | | If an empty spot is not found, display an error message and
    JSR _menu_draw_text_indirect                                                ; $01D00E | | return.
    JMP _menu_copy_tilemap_to_vram_bg3                                          ; $01D011 |/
+   REP #FLAG_P_ACCUMULATOR                                                     ; $01D014 |\
    LDA r_big_chocobo_inventory.w,X                                             ; $01D016 | | Transfer the Big Chocobo item to the player's inventory in this
    STA r_inventory.w,Y                                                         ; $01D019 | | spot.
    STZ r_big_chocobo_inventory.w,X                                             ; $01D01C | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01D01F |/
    JSR _menu_big_chocobo_draw_current_inventory                                ; $01D021 | Draw the Big Chocobo inventory from scratch.
    JMP _menu_copy_tilemap_to_vram_bg4                                          ; $01D024 | Transfer the BG4 tilemap to VRAM and return.

; _menu_big_chocobo_draw_current_inventory ($01:D027)
;
; Erases the BG2 and BG1 tilemaps, draws the Big Chocobo inventory to those
; tilemaps (BG2 precedes BG1 in memory), and then transfers the currently
; visible entries to BG4.
_menu_big_chocobo_draw_current_inventory:
    JSR _menu_initialize_tilemap_bg1                                            ; $01D027 | Initialize the BG1 tilemap.
    JSR _menu_set_current_tilemap_bg2_and_initialize                            ; $01D02A | Initialize the BG2 tilemap and set it as current.
    JSR _menu_big_chocobo_draw_inventory                                        ; $01D02D | Draw the Big Chocobo inventory to BG2 and BG1.
    JSL bank1E.menu_big_chocobo_inventory_initialize_bg4                        ; $01D030 | Transfer the currently visible items to BG4.
    RTS                                                                         ; $01D034

; _menu_big_chocobo_handle_command_take ($01:D035)
;
; Handler for the Take command in the Big Chocobo menu.
;
; NOTE: This code sets an odd flag that causes the inventory item drawing code
;       to shift its drawing by one row. While this does eliminate a single
;       wasted row at the top, it doesn't seem to actually be necessary. More
;       testing is required, however. (The scroll value of -88 set here could
;       instead be set to -80, but there may still be something missed.)
_menu_big_chocobo_handle_command_take:
    LDX #-88.w                                                                  ; $01D035 |\ Set the scroll value to align the inventory with the window on BG3.
    STX <r_menu_scroll_bg4.vertical.value                                       ; $01D038 |/
    INC r_menu_inventory_shift_one_row.w                                        ; $01D03A | Set the flag to shift the inventory drawing by one row.
    JSR _menu_set_current_tilemap_bg3                                           ; $01D03D |\
    LDY #menu_text_big_chocobo_what_are_you_taking_data.w                       ; $01D040 | | Draw the new Big Chocobo dialog.
    JSR _menu_draw_text_indirect                                                ; $01D043 | |
    JSR _menu_copy_tilemap_to_vram_bg3                                          ; $01D046 |/
    LDA #56.b                                                                   ; $01D049 |\ Set the maximum first row to 56 (plus 6 other visible rows is a
    STA <r_menu_inventory_maximum_first_row                                     ; $01D04B |/ maximum row of 62).
    JSR _menu_big_chocobo_draw_current_inventory                                ; $01D04D | Draw the currently visible inventory to BG4.
    JSR _menu_big_chocobo_handle_inventory_menu                                 ; $01D050 | Handle the input for the inventory menu.
    STZ r_menu_inventory_shift_one_row.w                                        ; $01D053 | Reset the row shifting flag.
    RTS                                                                         ; $01D056

; _menu_load_portrait_big_chocobo ($01:D057)
;
; Loads the palette for the Big Chocobo portrait into the tenth palette and then
; falls through to the next function to load the portrait itself.
_menu_load_portrait_big_chocobo:
    REP #FLAG_P_ACCUMULATOR                                                     ; $01D057 |\
    LDA #_sizeof_palette.w / 2 - 1                                              ; $01D059 | | Copy the Big Chocobo sprite palette to the CG-RAM mirror.
    LDX #bank0D.big_chocobo_portrait_palette_data.w                             ; $01D05C | |
    LDY #r_menu_cgram_data.10.w                                                 ; $01D05F | |
    MVN :bank0D.big_chocobo_portrait_palette_data,:r_menu_cgram_data            ; $01D062 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01D065 |/
    LDY #bank1B.field_sprite_portrait_big_chocobo_data.w                        ; $01D067 | Load the offset for the Big Chocobo sprite and fall through.

; _menu_load_portrait ($01:D06A)
;
; Given the offset to the portrait tile data (from bank $1B) in the Y register,
; loads that 4x4 (in tiles) portrait to VRAM and loads the corresponding OAM
; entries to display that portrait at 8,8. This is used for the Namingway and
; Fat Chocobo portraits.
_menu_load_portrait:
    PHB                                                                         ; $01D06A |\ Preserve the data bank and direct register values.
    PHD                                                                         ; $01D06B |/
    LDA #$1B.b                                                                  ; $01D06C |\
    PHA                                                                         ; $01D06E | | Set the data bank register to $1B.
    PLB                                                                         ; $01D06F |/
    LDX #$2100.w                                                                ; $01D070 |\
    PHX                                                                         ; $01D073 | | Set the direct register to $2100.
    PLD                                                                         ; $01D074 |/
    LDA #%10000000.b                                                            ; $01D075 |\ Set the VRAM increment to 1 by 1 after two bytes.
    STA <reg_ppu_vmainc                                                         ; $01D077 |/
    LDX #$4600.w                                                                ; $01D079 |\ Set the VRAM address to $4600.
    STX <reg_ppu_vmadd                                                          ; $01D07C |/
    LDA #16.b                                                                   ; $01D07E |\ Initialize the count to 16.
    STA r_menu_generic_tmp_count.w                                              ; $01D080 |/
--  LDX #8.w                                                                    ; $01D083 |\
-   LDA 0.w,Y                                                                   ; $01D086 | | Copy 16 bytes of data directly to VRAM at the target address.
    STA <reg_ppu_vmdatal_write                                                  ; $01D089 | |
    LDA 1.w,Y                                                                   ; $01D08B | |
    STA <reg_ppu_vmdatah_write                                                  ; $01D08E | |
    INY                                                                         ; $01D090 | |
    INY                                                                         ; $01D091 | |
    DEX                                                                         ; $01D092 | |
    BNE -                                                                       ; $01D093 |/
    LDX #8.w                                                                    ; $01D095 |\
-   LDA 0.w,Y                                                                   ; $01D098 | | Copy the next 8 bytes to VRAM, expanding the data to two bytes
    STA <reg_ppu_vmdatal_write                                                  ; $01D09B | | each in the process (to expand from 3bpp to 4bpp).
    STZ <reg_ppu_vmdatah_write                                                  ; $01D09D | |
    INY                                                                         ; $01D09F | |
    DEX                                                                         ; $01D0A0 | |
    BNE -                                                                       ; $01D0A1 |/
    DEC r_menu_generic_tmp_count.w                                              ; $01D0A3 |\ Decrement the count and loop until it reaches zero.
    BNE --                                                                      ; $01D0A6 |/
    JSR _menu_set_portrait_oam                                                  ; $01D0A8 | Set the OAM data for the Namingway portrait.
    PLD                                                                         ; $01D0AB |\ Restore the values of the direct and data bank registers.
    PLB                                                                         ; $01D0AC |/
    RTS                                                                         ; $01D0AD

; _menu_set_portrait_oam ($01:D0AE)
;
; Sets the OAM data for the Namingway portrait in the Namingway menu.
_menu_set_portrait_oam:
    REP #FLAG_P_ACCUMULATOR                                                     ; $01D0AE |\
    LDA #bank1E._sizeof_portrait_oam_data.w - 1                                 ; $01D0B0 | | Transfer the OAM data for a portrait to the OAM mirror in RAM.
    LDX #bank1E.portrait_oam_data.w                                             ; $01D0B3 | |
    LDY #r_oam.97.w                                                             ; $01D0B6 | |
    MVN :bank1E.portrait_oam_data.b,:r_oam.b                                    ; $01D0B9 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01D0BC |/
    RTS                                                                         ; $01D0BE

; _menu_big_chocobo_update_character_sprite_poses ($01:D0BF)
;
; In the Big Chocobo menu, updates the character sprite poses to reflect whether
; the character can equip the currently selected item.
_menu_big_chocobo_update_character_sprite_poses:
    JSR _menu_character_sprite_set_first_poses_normal                           ; $01D0BF | Set the character sprite poses to normal.
    JSR _menu_big_chocobo_inventory_get_cursor_offset                           ; $01D0C2 | Get the offset to the currently selected item.
    LDA r_menu_big_chocobo_command_index.w                                      ; $01D0C5 |\
    BEQ +                                                                       ; $01D0C8 | | If the player is in the "Give" menu, load the offset for the main
    LDA r_big_chocobo_inventory.w,X                                             ; $01D0CA | | inventory. Otherwise, load the offset for the Big Chocobo
    BRA ++                                                                      ; $01D0CD | | inventory.
+   LDA r_inventory.w,X                                                         ; $01D0CF |/
++  BNE +                                                                       ; $01D0D2 |\ Return if the selected item slot is empty.
-   RTS                                                                         ; $01D0D4 |/
+   CMP #ITEM_FIRST_FIELD_ITEM.b                                                ; $01D0D5 |\ Return if the selected item is a field item or higher ID.
    BCS -                                                                       ; $01D0D7 |/
    STA r_menu_equip_selected_item_id.w                                         ; $01D0D9 | Save the selected item ID to the parameter.
    TDC                                                                         ; $01D0DC |\
-   JSR _menu_character_sprite_set_cheering_if_can_equip                        ; $01D0DD | | Loop through the five character slots, updating their pose if they
    INC A                                                                       ; $01D0E0 | | can equip the item.
    CMP #5.b                                                                    ; $01D0E1 | |
    BNE -                                                                       ; $01D0E3 |/
    RTS                                                                         ; $01D0E5

; _menu_character_sprite_set_cheering_if_can_equip ($01:D0E6)
;
; Given a character slot in the accumulator and the currently selected item ID
; in $1B39, determines if the character can equip that item, and if so, sets
; their pose to cheering.
_menu_character_sprite_set_cheering_if_can_equip:
    PHA                                                                         ; $01D0E6 | Preserve the value of the accumulator.
    STA <r_menu_current_character_slot                                          ; $01D0E7 | Save the accumulator value as the character slot.
    JSR _menu_get_character_id                                                  ; $01D0E9 | Get the character ID and offset for this slot.
    BEQ +                                                                       ; $01D0EC | Branch to return if the slot is empty.
    STX <r_menu_current_character_offset                                        ; $01D0EE | Save the offset to a variable.
    JSR _menu_shop_check_character_equipment                                    ; $01D0F0 | Determine if the character can equip the current item.
    BCC +                                                                       ; $01D0F3 | Return if the character cannot.
    LDA <r_menu_current_character_slot                                          ; $01D0F5 |\
    ASL A                                                                       ; $01D0F7 | | Otherwise, set the character's pose to cheering.
    STA <r_menu_generic_tmp_offset.lo                                           ; $01D0F8 | |
    LDX <r_menu_generic_tmp_offset                                              ; $01D0FA | |
    LDA #MENU_POSE_CHEERING.b                                                   ; $01D0FC | |
    STA r_menu_character_sprite_pose.w,X                                        ; $01D0FE |/
+   PLA                                                                         ; $01D101 | Restore the value of the accumulator.
    RTS                                                                         ; $01D102

; _menu_character_sprite_set_first_poses_normal ($01:D103)
;
; For the five character slots, sets their first pose in the various menu
; screens to the normal pose.
_menu_character_sprite_set_first_poses_normal:
    REP #FLAG_P_ACCUMULATOR                                                     ; $01D103 |\
    STZ r_menu_character_sprite_pose.1.lo.w                                     ; $01D105 | | Set the first pose for each of the five slots to the normal pose.
    STZ r_menu_character_sprite_pose.2.lo.w                                     ; $01D108 | |
    STZ r_menu_character_sprite_pose.3.lo.w                                     ; $01D10B | |
    STZ r_menu_character_sprite_pose.4.lo.w                                     ; $01D10E | |
    STZ r_menu_character_sprite_pose.5.lo.w                                     ; $01D111 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01D114 |/
    RTS                                                                         ; $01D116

; _menu_command_custom ($01:D117)
;
; Handler for the Custom command in the main menu.
_menu_command_custom:
    LDA #%00110000.b                                                            ; $01D117 |\ Set the cursor sprite flags for priority 3.
    STA <r_menu_cursor_sprite_flags                                             ; $01D119 |/
    JSR _menu_init_bg_scroll                                                    ; $01D11B | Initialize the background scroll values.
    LDX #-4.w                                                                   ; $01D11E |\
    STX <r_menu_scroll_bg2.vertical.value                                       ; $01D121 | | Set the BG2 scroll values both to -4.
    STX <r_menu_scroll_bg2.horizontal.value                                     ; $01D123 |/
    JSR _menu_set_bg_scroll_proxy                                               ; $01D125 | Set the background scroll values.
    JSR _menu_ppu_fade_out                                                      ; $01D128 | Fade out the PPU.
    LDA #%00010011.b                                                            ; $01D12B |\ Set the main screens to BG1, BG2 and sprites.
    STA reg_ppu_tm.l                                                            ; $01D12D |/
    LDX #$4040.w                                                                ; $01D131 |\
    STX <r_menu_copy_to_vram_arg_target_vram_address                            ; $01D134 | | Copy the slider sprite to VRAM.
    LDX #bank1E.sprite_menu_slider_handle_data.w                                ; $01D136 | |
    STX <r_menu_copy_to_vram_arg_source_address                                 ; $01D139 | |
    LDA #:bank1E.sprite_menu_slider_handle_data                                 ; $01D13B | |
    STA r_menu_copy_to_vram_arg_source_bank.w                                   ; $01D13D | |
    LDX #bank1E._sizeof_sprite_menu_slider_handle_data.w                        ; $01D140 | |
    STX r_menu_copy_to_vram_arg_bytes.w                                         ; $01D143 | |
    JSR _menu_copy_to_vram                                                      ; $01D146 |/
    JSR _menu_initialize_oam                                                    ; $01D149 | Initialize the OAM.
    JSR _menu_copy_oam_to_ppu                                                   ; $01D14C | Copy the OAM to the PPU.
    JSR _initialize_joypad_maps                                                 ; $01D14F | Initialize the joypad maps.
    JSR _menu_custom_core                                                       ; $01D152 | Execute the custom menu input handler.
    JSR _menu_ppu_fade_out                                                      ; $01D155 | Fade the PPU out.
    LDA #%00011111.b                                                            ; $01D158 |\ Set all screens as the main screen.
    STA reg_ppu_tm.l                                                            ; $01D15A |/
    JSR _menu_initialize_tilemap_bg2                                            ; $01D15E |\ Initialize the BG1 and BG2 tilemaps.
    JSR _menu_initialize_tilemap_bg1                                            ; $01D161 |/
    JSR _menu_copy_tilemap_to_vram_bg2_no_vblank                                ; $01D164 | Copy the BG2 tilemap to VRAM.
    JSR _menu_initialize_oam                                                    ; $01D167 | Initialize the OAM.
    JSR _menu_party_draw_character_portraits                                    ; $01D16A | Draw the party character portraits.
    JSR _menu_copy_oam_to_ppu                                                   ; $01D16D | Copy the OAM to the PPU.
    JSR _menu_copy_tilemap_to_vram_bg1_no_vblank                                ; $01D170 | Copy the BG1 tilemap to VRAM.
    JMP _menu_ppu_fade_in                                                       ; $01D173 | Fade the PPU in.

; _menu_custom_core ($01:D176)
;
; Core input handler for the custom menu.
_menu_custom_core:
    JSR _menu_set_current_tilemap_bg1                                           ; $01D176 | Set the current tilemap to BG1.
    LDY #menu_window_custom_data.w                                              ; $01D179 |\ Draw most of the Custom menu.
    JSR _menu_draw_text_indirect_plus_window                                    ; $01D17C |/
    LDY #menu_window_custom_title_data.w                                        ; $01D17F |\ Draw the title window.
    JSR _menu_configure_and_draw_window                                         ; $01D182 |/
    LDY #menu_text_customizer_data.w                                            ; $01D185 |\ Draw the title text for the menu.
    JSR _menu_draw_text_indirect                                                ; $01D188 |/
.if FF4_VERSION == "JAPAN_EASYTYPE"
    LDA #TEXT_UPPERCASE_R.b                                                     ; $01D1B3 |\ Draw an "R" to 15, 16.
    STA r_menu_tilemap_bg1.w + (15 * 2) + (16 * 32 * 2)                         ; $01D1B5 |/
    LDA #TEXT_UPPERCASE_G.b                                                     ; $01D1B8 |\ Draw a "G" to 15, 18.
    STA r_menu_tilemap_bg1.w + (15 * 2) + (18 * 32 * 2)                         ; $01D1BA |/
    LDA #TEXT_UPPERCASE_B.b                                                     ; $01D1BD |\ Draw a "B" to 15, 20.
    STA r_menu_tilemap_bg1.w + (15 * 2) + (20 * 32 * 2)                         ; $01D1BF |/
.else
    LDA #TEXT_UPPERCASE_R.b                                                     ; $01D18B |\ Draw an "R" to 15, 20.
    STA r_menu_tilemap_bg1.w + (15 * 2) + (20 * 32 * 2)                         ; $01D18D |/
    LDA #TEXT_UPPERCASE_G.b                                                     ; $01D190 |\ Draw a "G" to 15, 22.
    STA r_menu_tilemap_bg1.w + (15 * 2) + (22 * 32 * 2)                         ; $01D192 |/
    LDA #TEXT_UPPERCASE_B.b                                                     ; $01D195 |\ Draw a "B" to 15, 24.
    STA r_menu_tilemap_bg1.w + (15 * 2) + (24 * 32 * 2)                         ; $01D197 |/
.endif
.if FF4_REGION == "JAPAN"                                                       ;         |\
    LDX #(15 * 2) + (10 * 32 * 2).w                                             ; $01D1C5 | | Draw the numbers from 1 to 6 at 15, 12 (or 15, 10 in the Japanese
.else                                                                           ;         | | version).
    LDX #(15 * 2) + (12 * 32 * 2).w                                             ; $01D19A | |
.endif                                                                          ;         | |
    LDY #menu_text_numbers_1_6_data.w                                           ; $01D19D | |
    JSR _menu_expand_tiles_to_tilemap                                           ; $01D1A0 |/
    LDX #(15 * 2) + (8 * 32 * 2).w                                              ; $01D1A3 |\
    LDY #menu_text_numbers_1_6_data.w                                           ; $01D1A6 | | Draw the numbers from 1 to 6 at 15, 8.
    JSR _menu_expand_tiles_to_tilemap                                           ; $01D1A9 |/
    JSR _menu_custom_initialize_number_tile_flags                               ; $01D1AC | Initialize the number tile flags to grey.
.if FF4_VERSION == "JAPAN_EASYTYPE"
    LDY #r_menu_tilemap_bg1.w + (17 * 2) + (16 * 32 * 2)                        ; $01D1D7 |\ Draw a slider to 17, 16.
    JSR _menu_custom_draw_slider                                                ; $01D1DA |/
    LDY #r_menu_tilemap_bg1.w + (17 * 2) + (18 * 32 * 2)                        ; $01D1DD |\ Draw a slider to 17, 18.
    JSR _menu_custom_draw_slider                                                ; $01D1E0 |/
    LDY #r_menu_tilemap_bg1.w + (17 * 2) + (20 * 32 * 2)                        ; $01D1E3 |\ Draw a slider to 17, 20.
    JSR _menu_custom_draw_slider                                                ; $01D1E6 |/
.else
    LDY #r_menu_tilemap_bg1.w + (17 * 2) + (20 * 32 * 2)                        ; $01D1AF |\ Draw a slider to 17, 20.
    JSR _menu_custom_draw_slider                                                ; $01D1B2 |/
    LDY #r_menu_tilemap_bg1.w + (17 * 2) + (22 * 32 * 2)                        ; $01D1B5 |\ Draw a slider to 17, 22.
    JSR _menu_custom_draw_slider                                                ; $01D1B8 |/
    LDY #r_menu_tilemap_bg1.w + (17 * 2) + (24 * 32 * 2)                        ; $01D1BB |\ Draw a slider to 17, 24.
    JSR _menu_custom_draw_slider                                                ; $01D1BE |/
.endif
    JSR _menu_copy_tilemap_to_vram_bg1_no_vblank                                ; $01D1C1 | Copy the BG1 tilemap to VRAM.
    LDX r_window_color.w                                                        ; $01D1C4 |\  Set the current RGB cursor indexes.
    JSR _menu_custom_set_rgb_indexes                                            ; $01D1C7 |/
    JSR _menu_ppu_fade_in                                                       ; $01D1CA | Fade the PPU in.
@loop_start:
.if FF4_REGION == "JAPAN"
    LDA r_config.single_multi.w                                                 ; $01D1F8 |\
    JSR _menu_custom_get_two_option_cursor_x_coordinate                         ; $01D1FB | | Set the cursor location for the single/multi configuration option.
    STA r_oam.2.x.w                                                             ; $01D1FE | |
.if FF4_EASYTYPE == 1                                                           ;         | |
    LDA #112.b                                                                  ; $01D1FE | |
.else                                                                           ;         | |
    LDA #128.b                                                                  ; $01D201 | |
.endif                                                                          ;         | |
    STA r_oam.2.y.w                                                             ; $01D203 |/
    LDA r_config.atb_active.w                                                   ; $01D206 |\
    JSR _menu_custom_get_two_option_cursor_x_coordinate                         ; $01D209 | | Draw the cursor for the ATB configuration option.
    STA <r_menu_draw_cursor_arg_coordinates.x                                   ; $01D20C | |
    LDA #48.b                                                                   ; $01D20E | |
    STA <r_menu_draw_cursor_arg_coordinates.y                                   ; $01D210 | |
    JSR _menu_draw_cursor_1                                                     ; $01D212 |/
.endif
    JSR _menu_custom_initialize_number_tile_flags                               ; $01D1CD | Initialize the number tile flags.
    LDA r_battle_speed.w                                                        ; $01D1D0 |\
    ASL A                                                                       ; $01D1D3 | | Set the tile flags for the current battle speed to draw it in
    ASL A                                                                       ; $01D1D4 | | white.
    JSR _menu_transfer_a_to_x                                                   ; $01D1D5 | |
    LDA #%00000000.b                                                            ; $01D1D8 | |
    STA r_menu_tilemap_bg1.w + (15 * 2) + (8 * 32 * 2) + 1,X                    ; $01D1DA |/
    LDA r_battle_message_speed.w                                                ; $01D1DD |\
    ASL A                                                                       ; $01D1E0 | | Set the tile flags for the current battle message speed to draw it
    ASL A                                                                       ; $01D1E1 | | in white.
    JSR _menu_transfer_a_to_x                                                   ; $01D1E2 | |
    LDA #%00000000.b                                                            ; $01D1E5 | |
.if FF4_REGION == "JAPAN"                                                       ;         | |
    STA r_menu_tilemap_bg1.w + (15 * 2) + (10 * 32 * 2) + 1,X                   ; $01D22F | |
.else                                                                           ;         | |
    STA r_menu_tilemap_bg1.w + (15 * 2) + (12 * 32 * 2) + 1,X                   ; $01D1E7 |/
.endif
.if FF4_REGION == "JAPAN"
    LDA r_menu_custom_cursor_index.w                                            ; $01D232 |\
    PHA                                                                         ; $01D235 | | Set the cursor Y coordiante based on the current cursor index. The
    ASL A                                                                       ; $01D236 | | Japanese version has equally distributed options, making this a
    ASL A                                                                       ; $01D237 | | simple multiplication.
    ASL A                                                                       ; $01D238 | |
    ASL A                                                                       ; $01D239 | |
    ADC #48.b                                                                   ; $01D23A | |
    STA <r_menu_draw_cursor_arg_coordinates.y                                   ; $01D23C |/
.else
    LDA r_menu_custom_cursor_index.w                                            ; $01D1EA |\
    PHA                                                                         ; $01D1ED | | Set the cursor Y coordinate based on the current cursor index. The
    JSR _menu_transfer_a_to_x                                                   ; $01D1EE | | USA version has to look up the coordinates from a table.
    LDA menu_custom_cursor_y_coordinate_data.l,X                                ; $01D1F1 | |
    STA <r_menu_draw_cursor_arg_coordinates.y                                   ; $01D1F5 |/
.endif
    PLA                                                                         ; $01D1F7 |\
    CMP #MENU_CUSTOM_INDEX_RGB_BASE.b                                           ; $01D1F8 | | Set the cursor X coordinate to 24 if not pointing to RGB, and to
    BCC +                                                                       ; $01D1FA | | 104 if pointing at one of the RGB options.
    LDA #104.b                                                                  ; $01D1FC | |
    BRA ++                                                                      ; $01D1FE | |
+   LDA #24.b                                                                   ; $01D200 | |
++  STA <r_menu_draw_cursor_arg_coordinates.x                                   ; $01D202 |/
    JSR _menu_draw_cursor_2                                                     ; $01D204 | Draw the second cursor at those coordinates.
    LDA r_menu_custom_rgb_cursor_index.red.w                                    ; $01D207 |\
    ASL A                                                                       ; $01D20A | | Set the coordinates of the red handle.
    ADC #134.b                                                                  ; $01D20B | |
    STA r_oam.9.x.w                                                             ; $01D20D | |
.if FF4_VERSION == "JAPAN_EASYTYPE"                                             ;         | |
    LDA #128.b                                                                  ; $01D254 | |
.else                                                                           ;         | |
    LDA #160.b                                                                  ; $01D210 | |
.endif                                                                          ;         | |
    STA r_oam.9.y.w                                                             ; $01D212 |/
    LDA r_menu_custom_rgb_cursor_index.green.w                                  ; $01D215 |\
    ASL A                                                                       ; $01D218 | | Set the coordinates of the green handle.
    ADC #134.b                                                                  ; $01D219 | |
    STA r_oam.10.x.w                                                            ; $01D21B | |
.if FF4_VERSION == "JAPAN_EASYTYPE"                                             ;         | |
    LDA #144.b                                                                  ; $01D262 | |
.else                                                                           ;         | |
    LDA #176.b                                                                  ; $01D21E | |
.endif                                                                          ;         | |
    STA r_oam.10.y.w                                                            ; $01D220 |/
    LDA r_menu_custom_rgb_cursor_index.blue.w                                   ; $01D223 |\
    ASL A                                                                       ; $01D226 | | Set the coordinates of the blue handle.
    ADC #134.b                                                                  ; $01D227 | |
    STA r_oam.11.x.w                                                            ; $01D229 | |
.if FF4_VERSION == "JAPAN_EASYTYPE"                                             ;         | |
    LDA #160.b                                                                  ; $01D270 | |
.else                                                                           ;         | |
    LDA #192.b                                                                  ; $01D22C | |
.endif                                                                          ;         | |
    STA r_oam.11.y.w                                                            ; $01D22E |/
    JSR _menu_custom_calculate_window_color                                     ; $01D231 |\
    LDX <r_menu_generic_tmp_word                                                ; $01D234 | | Update the current window color to match the sliders.
    STX r_window_color.w                                                        ; $01D236 | |
    JSR _menu_set_palette_window_color                                          ; $01D239 |/
    LDA #TILE_MENU_SPRITE_SLIDER_HANDLE.b                                       ; $01D23C |\
    STA r_oam.9.tile.w                                                          ; $01D23E | | Set the three handle sprites to use the correct tile number.
    STA r_oam.10.tile.w                                                         ; $01D241 | |
    STA r_oam.11.tile.w                                                         ; $01D244 |/
    LDA #%00110000.b                                                            ; $01D247 |\
    STA r_oam.9.flags.w                                                         ; $01D249 | | Set the three handles to use tile flags that set priority 3 and
    STA r_oam.10.flags.w                                                        ; $01D24C | | palette 0.
    STA r_oam.11.flags.w                                                        ; $01D24F |/
    LDA r_config.stereo_mono.w                                                  ; $01D252 |\
    JSR _menu_custom_get_two_option_cursor_x_coordinate                         ; $01D255 | | Set the coordinates of the stereo/mono cursor.
    STA r_oam.4.x.w                                                             ; $01D258 | |
    LDA #MENU_CUSTOM_CURSOR_Y_STEREO_MONO.b                                     ; $01D25B | |
    STA r_oam.4.y.w                                                             ; $01D25D |/
.if FF4_REGION == "JAPAN"
.if FF4_EASYTYPE != 1
    LDA r_config_joypad_map_index.w                                             ; $01D2A7 |\
    JSR _menu_custom_get_two_option_cursor_x_coordinate                         ; $01D2AA | | Set the cursor for the joypad normal/custom configuration option.
    STA r_oam.3.x.w                                                             ; $01D2AD | |
    LDA #112.b                                                                  ; $01D2B0 | |
    STA r_oam.3.y.w                                                             ; $01D2B2 |/
    LDA r_config.memory.w                                                       ; $01D2B5 |\
    JSR _menu_custom_get_two_option_cursor_x_coordinate                         ; $01D2B8 | | Set the cursor for the cursor memory option.
    STA r_oam.6.x.w                                                             ; $01D2BB | |
    LDA #144.b                                                                  ; $01D2BE | |
    STA r_oam.6.y.w                                                             ; $01D2C0 |/
.endif
.endif
    LDX #$300A.w                                                                ; $01D260 |\
    STX r_oam.2.tile.w                                                          ; $01D263 | | Set several OAM entries used for cursors to use the cursor tile
.if FF4_VERSION != "JAPAN_EASYTYPE"                                             ;         | | with flags for priority 3.
    STX r_oam.3.tile.w                                                          ; $01D266 | |
.endif                                                                          ;         | | NOTE: Not all of the cursors are used in the US version. The
    STX r_oam.4.tile.w                                                          ; $01D269 | |       Easytype version actually removes a couple of the lines.
.if FF4_VERSION != "JAPAN_EASYTYPE"                                             ;         | |
    STX r_oam.6.tile.w                                                          ; $01D26C | |
.endif                                                                          ;         | |
    STX r_oam.7.tile.w                                                          ; $01D26F |/
    JSR _menu_wait_for_vblank_copy_oam_to_ppu                                   ; $01D272 | Wait for vblank and copy the OAM to the PPU.
    JSR _menu_copy_tilemap_to_vram_bg1_no_vblank                                ; $01D275 | Copy the BG1 tilemap to VRAM.
    JSR _menu_copy_palette_to_cgram                                             ; $01D278 | Copy the palette data to CG-RAM.
    JSR _menu_update_joypad_and_play_sound_effect                               ; $01D27B | Update the joypad values and play an appropriate sound effect.
    LDA <r_menu_joypad_repeat.hi                                                ; $01D27E |\
    AND #JOYPAD_H_B.b                                                           ; $01D280 | | If the B button is pressed, return.
    BEQ +                                                                       ; $01D282 | |
    RTS                                                                         ; $01D284 |/
.if FF4_REGION == "JAPAN"
+   LDA <r_menu_joypad_repeat.lo                                                ; $01D2E8 |\
    AND #JOYPAD_L_A.b                                                           ; $01D2EA | | If the A button is pressed and if the cursor is pointing to the
    BEQ +                                                                       ; $01D2EC | | joypad normal/custom option, execute the custom joypad function.
    LDA r_menu_custom_cursor_index.w                                            ; $01D2EE | |
.if FF4_EASYTYPE != 1                                                           ;         | |
    CMP #MENU_CUSTOM_INDEX_JOYPAD.b                                             ; $01D2F1 | |
    BNE ++                                                                      ; $01D2F3 | |
    LDA r_config_joypad_map_index.w                                             ; $01D2F5 | |
    BEQ +++                                                                     ; $01D2F8 | |
    JSR _menu_custom_joypad                                                     ; $01D2FA |/
.endif
++  CMP #MENU_CUSTOM_INDEX_SINGLE_MULTI.b                                       ; $01D2FD |\
    BNE +                                                                       ; $01D2FF | | If the A button is pressed, if the cursor is pointing to the
    LDA r_config.single_multi.w                                                 ; $01D301 | | single/multi option, and if multi is selected, display the joypad
    BEQ +                                                                       ; $01D304 | | selector menu.
    JSR _menu_custom_joypad_selector                                            ; $01D306 | |
    JSR _menu_initialize_oam                                                    ; $01D309 |/
.endif
+   LDA <r_menu_joypad_repeat.hi                                                ; $01D285 |\
    AND #JOYPAD_H_UP.b                                                          ; $01D287 | | If up is pressed on the d-pad, decrement the cursor index. If it
    BEQ +++                                                                     ; $01D289 | | goes negative, wrap it around to the maximum value.
    LDA r_menu_custom_cursor_index.w                                            ; $01D28B | |
    DEC A                                                                       ; $01D28E | |
    BPL +                                                                       ; $01D28F | |
    LDA #MENU_CUSTOM_INDEX_MAXIMUM.b                                            ; $01D291 | |
+   STA r_menu_custom_cursor_index.w                                            ; $01D293 |/
+++ LDA <r_menu_joypad_repeat.hi                                                ; $01D296 |\
    AND #JOYPAD_H_DOWN.b                                                        ; $01D298 | | If down is pressed on the d-pad, increment the cursor index. If it
    BEQ ++                                                                      ; $01D29A | | reaches past the maximum, wrap it around to zero.
    LDA r_menu_custom_cursor_index.w                                            ; $01D29C | |
    INC A                                                                       ; $01D29F | |
    CMP #MENU_CUSTOM_INDEX_MAXIMUM.b + 1                                        ; $01D2A0 | |
    BNE +                                                                       ; $01D2A2 | |
    TDC                                                                         ; $01D2A4 | |
+   STA r_menu_custom_cursor_index.w                                            ; $01D2A5 |/
++  LDA <r_menu_joypad_repeat.hi                                                ; $01D2A8 |\
    AND #JOYPAD_H_LEFT.b                                                        ; $01D2AA | | If left on the d-pad is not pressed, branch to check right.
    BEQ @check_right                                                            ; $01D2AC |/
.if FF4_REGION == "JAPAN"
    LDA r_menu_custom_cursor_index.w                                            ; $01D335 |\
    BNE +                                                                       ; $01D338 | | For the Japanese version, if the cursor index is set to zero,
    JSR _config_toggle_atb                                                      ; $01D33A | | toggle the ATB mode.
    BRA @check_right                                                            ; $01D33D | |
+   DEC A                                                                       ; $01D33F | |
    BNE +                                                                       ; $01D340 |/
.else
    LDA r_menu_custom_cursor_index.w                                            ; $01D2AE |\
    BNE +                                                                       ; $01D2B1 | | If the cursor index is set to zero, decrement the battle speed,
.endif
    LDA r_battle_speed.w                                                        ; $01D2B3 | | and if it's still zero or above, store the result back. Afterward,
    DEC A                                                                       ; $01D2B6 | | branch to check the right d-pad button.
    BMI @check_right                                                            ; $01D2B7 | |
    STA r_battle_speed.w                                                        ; $01D2B9 | |
    BRA @check_right                                                            ; $01D2BC |/
+   DEC A                                                                       ; $01D2BE |\
    BNE +                                                                       ; $01D2BF | | If the cursor index is set to one (two in the Japanese version),
    LDA r_battle_message_speed.w                                                ; $01D2C1 | | do the same as above, except with the battle message speed.
    DEC A                                                                       ; $01D2C4 | |
    BMI @check_right                                                            ; $01D2C5 | |
    STA r_battle_message_speed.w                                                ; $01D2C7 | |
    BRA @check_right                                                            ; $01D2CA |/
+   DEC A                                                                       ; $01D2CC |\
    BNE +                                                                       ; $01D2CD | | If the cursor index is set to two (three in the Japanese version),
    JSR _audio_toggle_stereo_mono                                               ; $01D2CF | | toggle the audio between stereo and mono.
    BRA @check_right                                                            ; $01D2D2 |/
.if FF4_REGION == "JAPAN"
.if FF4_EASYTYPE != 1
+   DEC A                                                                       ; $01D363 |\
    BNE +                                                                       ; $01D364 | | For the Japanese version, if the cursor index is set to four,
    JSR _config_toggle_normal_custom                                            ; $01D366 | | toggle the controller between normal and custom, then branch to
    BRA @check_right                                                            ; $01D369 |/  check right.
.endif
+   DEC A                                                                       ; $01D36B |\
    BNE +                                                                       ; $01D36C | | For the Japanese version, if the cursor index is set to five,
    JSR _config_toggle_single_multi                                             ; $01D36E | | toggle the single/multi option, before branching to check right.
    BRA @check_right                                                            ; $01D371 |/
.if FF4_EASYTYPE != 1
+   DEC A                                                                       ; $01D373 |\ If the cursor index is set to six, branch to toggle memory.
    BEQ @toggle_memory                                                          ; $01D374 |/
.endif
.endif
+   DEC A                                                                       ; $01D2D4 |\
    ASL A                                                                       ; $01D2D5 | | For all other values, load the offset to the relevant cursor RGB
    JSR _menu_transfer_a_to_x                                                   ; $01D2D6 | | cursor index and update the value by decrementing it and storing
    REP #FLAG_P_ACCUMULATOR                                                     ; $01D2D9 | | the new value if it is still positive.
    LDA menu_custom_rgb_cursor_index_offset_data.l,X                            ; $01D2DB | |
    STA <r_menu_generic_tmp_word                                                ; $01D2DF | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01D2E1 | |
    LDA (<r_menu_generic_tmp_word)                                              ; $01D2E3 | |
    DEC A                                                                       ; $01D2E5 | |
    BMI @check_right                                                            ; $01D2E6 | |
    STA (<r_menu_generic_tmp_word)                                              ; $01D2E8 |/
.if FF4_REGION == "JAPAN"
    BRA @check_right                                                            ; $01D38C | Branch now to check the right button.
.if FF4_EASYTYPE != 1
@toggle_memory:
    LDA r_config.memory.w                                                       ; $01D38E |\
    EOR #%00000001.b                                                            ; $01D391 | | Toggle the memory option.
    STA r_config.memory.w                                                       ; $01D393 |/
.endif
.endif
@check_right:
    LDA <r_menu_joypad_repeat.hi                                                ; $01D2EA |\
    AND #JOYPAD_H_RIGHT.b                                                       ; $01D2EC | | Skip to the next iteration if right is not pressed on the d-pad.
    BEQ @next                                                                   ; $01D2EE |/
    LDA r_menu_custom_cursor_index.w                                            ; $01D2F0 | Load the current cursor index into the accumulator.
.if FF4_REGION == "JAPAN"
    BNE +                                                                       ; $01D39F |\
    JSR _config_toggle_atb                                                      ; $01D3A1 | | If the cursor index is set to zero, toggle the ATB mode.
    BRA @next                                                                   ; $01D3A4 |/
+   DEC A                                                                       ; $01D3A6 | Decrement the cursor index to test the next value.
.endif
    BNE +                                                                       ; $01D2F3 |\
    LDA r_battle_speed.w                                                        ; $01D2F5 | | If the cursor index is set to zero (one in the Japanese version),
    INC A                                                                       ; $01D2F8 | | increment the battle speed and store the updated value if it is
    CMP #6.b                                                                    ; $01D2F9 | | less than six.
    BEQ @next                                                                   ; $01D2FB | |
    STA r_battle_speed.w                                                        ; $01D2FD | |
    BRA @next                                                                   ; $01D300 |/
+   DEC A                                                                       ; $01D302 |\
    BNE +                                                                       ; $01D303 | | If the cursor index is set to one (two in the Japanese version),
    LDA r_battle_message_speed.w                                                ; $01D305 | | do the same as above except with the battle message speed.
    INC A                                                                       ; $01D308 | |
    CMP #6.b                                                                    ; $01D309 | |
    BEQ @next                                                                   ; $01D30B | |
    STA r_battle_message_speed.w                                                ; $01D30D | |
    BRA @next                                                                   ; $01D310 |/
+   DEC A                                                                       ; $01D312 |\
    BNE +                                                                       ; $01D313 | | If the cursor index is set to two (three in the Japanese version),
    JSR _audio_toggle_stereo_mono                                               ; $01D315 | | toggle the audio mode between stereo and mono.
    BRA @next                                                                   ; $01D318 |/
.if FF4_REGION == "JAPAN"
.if FF4_EASYTYPE != 1
+   DEC A                                                                       ; $01D3CE |\
    BNE +                                                                       ; $01D3CF | | In the Japanese version, if the cursor index is set to four,
    JSR _config_toggle_normal_custom                                            ; $01D3D1 | | toggle the normal/custom option.
    BRA @next                                                                   ; $01D3D4 |/
.endif
+   DEC A                                                                       ; $01D3D6 |\
    BNE +                                                                       ; $01D3D7 | | In the Japanese version, if the cursor index is set to five,
    JSR _config_toggle_single_multi                                             ; $01D3D9 | | toggle the single/multi option.
    BRA @next                                                                   ; $01D3DC |/
.if FF4_EASYTYPE != 1
+   DEC A                                                                       ; $01D3DE |\ If the cursor index is set to six, branch to toggle the memory
    BEQ @toggle_memory_2                                                        ; $01D3DF |/ option.
.endif
.endif
+   DEC A                                                                       ; $01D31A |\
    ASL A                                                                       ; $01D31B | | For all other values, adjust the appropriate RGB cursor index to
    JSR _menu_transfer_a_to_x                                                   ; $01D31C | | increase the value, as long as the result would not be 32 or
    REP #FLAG_P_ACCUMULATOR                                                     ; $01D31F | | greater.
    LDA menu_custom_rgb_cursor_index_offset_data.l,X                            ; $01D321 | |
    STA <r_menu_generic_tmp_word                                                ; $01D325 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01D327 | |
    LDA (<r_menu_generic_tmp_word)                                              ; $01D329 | |
    INC A                                                                       ; $01D32B | |
    CMP #32.b                                                                   ; $01D32C | |
    BEQ @next                                                                   ; $01D32E | |
    STA (<r_menu_generic_tmp_word)                                              ; $01D330 |/
.if FF4_REGION == "JAPAN"
    BRA @next                                                                   ; $01D3F9 | Branch to the next iteration.
.if FF4_EASYTYPE != 1
@toggle_memory_2:
    LDA r_config.memory.w                                                       ; $01D3FB |\
    EOR #%00000001.b                                                            ; $01D3FE | | Toggle the memory option.
    STA r_config.memory.w                                                       ; $01D400 |/
.endif
.endif
@next:
    JMP @loop_start                                                             ; $01D332

; _menu_custom_draw_slider ($01:D335)
;
; Draws a slider control to the offset passed in the Y register.
_menu_custom_draw_slider:
    LDX <r_menu_zero                                                            ; $01D335 |\
-   LDA menu_custom_slider_tile_data.l,X                                        ; $01D337 | | Draw the slider to the offset passed in Y.
    STA 0.w,Y                                                                   ; $01D33B | |
    INY                                                                         ; $01D33E | |
    INY                                                                         ; $01D33F | |
    INX                                                                         ; $01D340 | |
    CPX #_sizeof_menu_custom_slider_tile_data.w                                 ; $01D341 | |
    BNE -                                                                       ; $01D344 |/
    RTS                                                                         ; $01D346

; menu_custom_slider_tile_data ($01:D347)
;
; For the custom menu, provides the tile numbers used to draw the slider itself.
menu_custom_slider_tile_data:
    .db $01, $02, $02, $02, $01, $02, $02, $02, $03                             ; $01D347.D34F

; menu_custom_rgb_cursor_index_offset_data ($01:D350)
;
; Provides the offset to the cursor index for each of the red, green and blue
; sliders in the custom menu. Used to determine which value to affect based on
; the current value of the main custom menu cursor index.
menu_custom_rgb_cursor_index_offset_data:
    .addr r_menu_custom_rgb_cursor_index.red                                    ; $01D350.D351
    .addr r_menu_custom_rgb_cursor_index.green                                  ; $01D352.D353
    .addr r_menu_custom_rgb_cursor_index.blue                                   ; $01D354.D355

; _menu_custom_calculate_window_color ($01:D356)
;
; Calculates the current window color to match the current values of the
; sliders in the custom menu. Returns the 16-bit value in $45.
_menu_custom_calculate_window_color:
    LDA r_menu_custom_rgb_cursor_index.green.w                                  ; $01D356 |\
    STA <r_menu_generic_tmp_offset.lo                                           ; $01D359 | | Shift the green index left by 5 bits and save that to a temporary
    REP #FLAG_P_ACCUMULATOR                                                     ; $01D35B | | variable.
    LDA <r_menu_generic_tmp_offset                                              ; $01D35D | |
    ASL A                                                                       ; $01D35F | |
    ASL A                                                                       ; $01D360 | |
    ASL A                                                                       ; $01D361 | |
    ASL A                                                                       ; $01D362 | |
    ASL A                                                                       ; $01D363 | |
    STA <r_menu_generic_tmp_word                                                ; $01D364 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01D366 |/
    LDA r_menu_custom_rgb_cursor_index.red.w                                    ; $01D368 |\
    ORA <r_menu_generic_tmp_word.lo                                             ; $01D36B | | Add in the red bits.
    STA <r_menu_generic_tmp_word.lo                                             ; $01D36D |/
    LDA r_menu_custom_rgb_cursor_index.blue.w                                   ; $01D36F |\
    ASL A                                                                       ; $01D372 | | Add in the blue bits, shifted to the left twice to properly align
    ASL A                                                                       ; $01D373 | | them.
    ORA <r_menu_generic_tmp_word.hi                                             ; $01D374 | |
    STA <r_menu_generic_tmp_word.hi                                             ; $01D376 |/
    RTS                                                                         ; $01D378

; _menu_custom_set_rgb_indexes ($01:D379)
;
; Sets the current RGB index values. The current color should be passed in the
; X register. However, do note that the routine ignores the passed value for the
; green channel, and instead loads it directly from $16AA.
_menu_custom_set_rgb_indexes:
    STX <r_menu_generic_tmp_word                                                ; $01D379 | Save the passed color to a temporary variable.
    LDA <r_menu_generic_tmp_word.lo                                             ; $01D37B |\
    AND #%00011111.b                                                            ; $01D37D | | Extract the current value of the red index.
    STA r_menu_custom_rgb_cursor_index.red.w                                    ; $01D37F |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $01D382 |\
    LDA r_window_color.w                                                        ; $01D384 | | Extract the current value of the green index.
    LSR A                                                                       ; $01D387 | |
    LSR A                                                                       ; $01D388 | | NOTE: For some reason, this loads the window color directly
    LSR A                                                                       ; $01D389 | |       instead of using the passed value.
    LSR A                                                                       ; $01D38A | |
    LSR A                                                                       ; $01D38B | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01D38C | |
    AND #%00011111.b                                                            ; $01D38E | |
    STA r_menu_custom_rgb_cursor_index.green.w                                  ; $01D390 |/
    LDA <r_menu_generic_tmp_word.hi                                             ; $01D393 |\
    LSR A                                                                       ; $01D395 | | Extract the current value of the blue index.
    LSR A                                                                       ; $01D396 | |
    STA r_menu_custom_rgb_cursor_index.blue.w                                   ; $01D397 |/
    RTS                                                                         ; $01D39A

; _audio_set_stereo_mono ($01:D39B)
;
; Reads the configured value for the stereo/mono option at $16B6 and uses it to
; set the audio system to either stereo or mono.
_audio_set_stereo_mono:
    LDA #AUDIO_MODE_SET_STEREO_MONO.b                                           ; $01D39B |\
    STA r_play_audio_arg_mode.w                                                 ; $01D39D | | Send the command to the audio system to set either stereo or mono
    LDA r_config.stereo_mono.w                                                  ; $01D3A0 | | depending on the configured value.
    AND #%00000001.b                                                            ; $01D3A3 | |
    STA r_play_audio_arg_track.w                                                ; $01D3A5 | |
    JSL bank04.play_audio                                                       ; $01D3A8 |/
    RTS                                                                         ; $01D3AC

.if FF4_REGION == "JAPAN"
.if FF4_EASYTYPE != 1
; _menu_custom_joypad ($01:D47E)
;
; Draws the custom joypad menu and executes its input handler. Only used in the
; Japanese version, to allow the player to customize their input settings.
_menu_custom_joypad:
    JSR _menu_set_current_tilemap_bg2                                           ; $01D47E | Set the current tilemap to BG2.
    LDY #menu_window_custom_joypad_data.w                                       ; $01D481 |\ Draw the controller customization window to BG2.
    JSR _menu_configure_and_draw_window                                         ; $01D484 |/
    LDY #menu_window_custom_title_data.w                                        ; $01D487 |\ Draw the title of the custom menu to BG2.
    JSR _menu_configure_and_draw_window                                         ; $01D48A |/
    LDY #menu_text_custom_joypad_data.w                                         ; $01D48D |\ Draw the labels of the controller customization window.
    JSR _menu_draw_text_indirect                                                ; $01D490 |/
    LDX #(10 * 2) + (14 * 32 * 2).w                                             ; $01D493 |\
    LDY #menu_text_custom_joypad_l_start_options_data.w                         ; $01D496 | | Draw the options for the L button to 10, 14.
    JSR _menu_draw_text_direct                                                  ; $01D499 |/
    LDX #(10 * 2) + (16 * 32 * 2).w                                             ; $01D49C |\
    LDY #menu_text_custom_joypad_l_start_options_data.w                         ; $01D49F | | Draw the options for the Start button to 10, 16.
    JSR _menu_draw_text_direct                                                  ; $01D4A2 |/
    LDY #menu_text_custom_joypad_confirm_cancel_menu_options_data.w             ; $01D4A5 |\
    LDX #(10 * 2) + (10 * 32 * 2).w                                             ; $01D4A8 | | Draw the options for the cancel button to 10, 10.
    JSR _menu_draw_text_direct                                                  ; $01D4AB |/
    LDY #menu_text_custom_joypad_confirm_cancel_menu_options_data.w             ; $01D4AE |\
    LDX #(10 * 2) + (12 * 32 * 2).w                                             ; $01D4B1 | | Draw the options for the menu button to 10, 12.
    JSR _menu_draw_text_direct                                                  ; $01D4B4 |/
    LDY #menu_text_custom_joypad_confirm_cancel_menu_options_data.w             ; $01D4B7 |\
    LDX #(10 * 2) + (8 * 32 * 2).w                                              ; $01D4BA | | Draw the options for the confirm button to 10, 8.
    JSR _menu_draw_text_direct                                                  ; $01D4BD |/
    JSR _menu_initialize_oam                                                    ; $01D4C0 | Initialize the OAM.
    JSR _menu_wait_for_vblank_copy_oam_to_ppu                                   ; $01D4C3 | Wait for vblank and copy the OAM to the PPU.
    JSR _menu_animate_current_tilemap_50_rows_to_vram                           ; $01D4C6 | Animate the opening of the window.
    JSR _menu_custom_joypad_core                                                ; $01D4C9 | Execute the custom joypad menu core.
    JSR _menu_initialize_tilemap_bg2                                            ; $01D4CC | Clear BG2.
    JSR _menu_initialize_oam                                                    ; $01D4CF | Initialize the OAM to clear the cursors.
    JSR _menu_wait_for_vblank_copy_oam_to_ppu                                   ; $01D4D2 | Wait for vblank and copy the OAM to the PPU.
    JSR _menu_animate_current_tilemap_50_rows_to_vram_reversed                  ; $01D4D5 | Animate the closing of the window.
    JMP _menu_set_current_tilemap_bg1                                           ; $01D4D8 | Set the current tilemap to BG1 and return.

; _menu_custom_joypad_core ($01:D4DB)
;
; Core input handler of the custom joypad menu.
_menu_custom_joypad_core:
    LDA r_menu_custom_joypad_cursor_index.w                                     ; $01D4DB |\
    ASL A                                                                       ; $01D4DE | | Draw the cursor for the main controller customization cursor index
    ASL A                                                                       ; $01D4DF | | to the index times 16 plus 75 as the Y coordinate, and 10 as the X
    ASL A                                                                       ; $01D4E0 | | coordinate.
    ASL A                                                                       ; $01D4E1 | |
    ADC #75.b                                                                   ; $01D4E2 | |
    STA <r_menu_draw_cursor_arg_coordinates.y                                   ; $01D4E4 | |
    LDA #10.b                                                                   ; $01D4E6 | |
    STA <r_menu_draw_cursor_arg_coordinates.x                                   ; $01D4E8 | |
    LDY #r_oam.6.w                                                              ; $01D4EA | |
    JSR _menu_draw_cursor_direct_memory                                         ; $01D4ED |/
    LDA r_config_joypad_confirm.w                                               ; $01D4F0 |\
    JSR _menu_custom_joypad_set_confirm_cancel_menu_cursor_x_coordinate         ; $01D4F3 | | Draw the cursor for the confirm option.
    LDA #74.b                                                                   ; $01D4F6 | |
    STA <r_menu_draw_cursor_arg_coordinates.y                                   ; $01D4F8 | |
    JSR _menu_draw_cursor_1                                                     ; $01D4FA |/
    LDA r_config_joypad_cancel.w                                                ; $01D4FD |\
    JSR _menu_custom_joypad_set_confirm_cancel_menu_cursor_x_coordinate         ; $01D500 | | Draw the cursor for the cancel option.
    LDA #90.b                                                                   ; $01D503 | |
    STA <r_menu_draw_cursor_arg_coordinates.y                                   ; $01D505 | |
    JSR _menu_draw_cursor_2                                                     ; $01D507 |/
    LDA r_config_joypad_menu.w                                                  ; $01D50A |\
    JSR _menu_custom_joypad_set_confirm_cancel_menu_cursor_x_coordinate         ; $01D50D | | Draw the cursor for the menu option.
    LDA #106.b                                                                  ; $01D510 | |
    STA <r_menu_draw_cursor_arg_coordinates.y                                   ; $01D512 | |
    LDY #r_oam.4.w                                                              ; $01D514 | |
    JSR _menu_draw_cursor_direct_memory                                         ; $01D517 |/
    LDA r_config_joypad_l_button.w                                              ; $01D51A |\
    JSR _menu_transfer_a_to_x                                                   ; $01D51D | | Draw the cursor for the L button option.
    LDA menu_custom_joypad_l_start_cursor_x_coordinate_data.l,X                 ; $01D520 | |
    STA <r_menu_draw_cursor_arg_coordinates.x                                   ; $01D524 | |
    LDA #122.b                                                                  ; $01D526 | |
    STA <r_menu_draw_cursor_arg_coordinates.y                                   ; $01D528 | |
    LDY #r_oam.3.w                                                              ; $01D52A | |
    JSR _menu_draw_cursor_direct_memory                                         ; $01D52D |/
    LDA r_config_joypad_start.w                                                 ; $01D530 |\
    JSR _menu_transfer_a_to_x                                                   ; $01D533 | | Draw the cursor for the Start button option.
    LDA menu_custom_joypad_l_start_cursor_x_coordinate_data.l,X                 ; $01D536 | |
    STA <r_menu_draw_cursor_arg_coordinates.x                                   ; $01D53A | |
    LDA #138.b                                                                  ; $01D53C | |
    STA <r_menu_draw_cursor_arg_coordinates.y                                   ; $01D53E | |
    LDY #r_oam.7.w                                                              ; $01D540 | |
    JSR _menu_draw_cursor_direct_memory                                         ; $01D543 |/
    JSR _menu_wait_for_vblank_copy_oam_to_ppu                                   ; $01D546 | Wait for vblank and copy the OAM to the PPU.
    JSR _menu_update_joypad_and_play_sound_effect                               ; $01D549 | Update the joypad and play an appropriate sound effect.
    LDA <r_menu_joypad_repeat.hi                                                ; $01D54C |\
    AND #JOYPAD_H_B.b                                                           ; $01D54E | | If the B button is pressed, set the cursor index to 5 (end).
    BEQ +                                                                       ; $01D550 | |
    LDA #5.b                                                                    ; $01D552 | |
    STA r_menu_custom_joypad_cursor_index.w                                     ; $01D554 |/
+   LDA <r_menu_joypad_repeat.hi                                                ; $01D557 |\
    AND #JOYPAD_H_UP.b                                                          ; $01D559 | | If up is pressed on the d-pad, decrement the cursor index. If it
    BEQ ++                                                                      ; $01D55B | | goes negative, reset its value to five.
    LDA r_menu_custom_joypad_cursor_index.w                                     ; $01D55D | |
    DEC A                                                                       ; $01D560 | |
    BPL +                                                                       ; $01D561 | |
    LDA #5.b                                                                    ; $01D563 | |
+   STA r_menu_custom_joypad_cursor_index.w                                     ; $01D565 |/
++  LDA <r_menu_joypad_repeat.hi                                                ; $01D568 |\
    AND #JOYPAD_H_DOWN.b                                                        ; $01D56A | | If down is pressed on the d-pad, increment the cursor index. If
    BEQ ++                                                                      ; $01D56C | | the value reaches six, set it to zero.
    LDA r_menu_custom_joypad_cursor_index.w                                     ; $01D56E | |
    INC A                                                                       ; $01D571 | |
    CMP #6.b                                                                    ; $01D572 | |
    BNE +                                                                       ; $01D574 | |
    LDA #0.b                                                                    ; $01D576 | |
+   STA r_menu_custom_joypad_cursor_index.w                                     ; $01D578 |/
++  LDA <r_menu_joypad_repeat.hi                                                ; $01D57B |\
    AND #JOYPAD_H_RIGHT.b                                                       ; $01D57D | | If right is pressed on the d-pad, and the cursor index is not
    BEQ ++                                                                      ; $01D57F | | equal to five (end), increment the current configuration option.
    LDA r_menu_custom_joypad_cursor_index.w                                     ; $01D581 | | If the new value reaches the maximum value, reset it to zero.
    CMP #5.b                                                                    ; $01D584 | |
    BEQ @check_confirm                                                          ; $01D586 | |
    JSR _menu_transfer_a_to_x                                                   ; $01D588 | |
    LDA r_config_joypad.w,X                                                     ; $01D58B | |
    INC A                                                                       ; $01D58E | |
    CMP menu_custom_joypad_limit_value_data.l,X                                 ; $01D58F | |
    BNE +                                                                       ; $01D593 | |
    LDA #0.b                                                                    ; $01D595 | |
+   STA r_config_joypad.w,X                                                     ; $01D597 |/
++  LDA <r_menu_joypad_repeat.hi                                                ; $01D59A |\
    AND #JOYPAD_H_LEFT.b                                                        ; $01D59C | | If left is pressed on the d-pad, and the cursor index is not
    BEQ @check_confirm                                                          ; $01D59E | | equal to five (end), decrement the current configuration option.
    LDA r_menu_custom_joypad_cursor_index.w                                     ; $01D5A0 | | If the value goes negative, reset it to the limit value and then
    CMP #5.b                                                                    ; $01D5A3 | | subtract one (so it's a valid index).
    BEQ @check_confirm                                                          ; $01D5A5 | |
    JSR _menu_transfer_a_to_x                                                   ; $01D5A7 | |
    LDA r_config_joypad.w,X                                                     ; $01D5AA | |
    DEC A                                                                       ; $01D5AD | |
    BPL +                                                                       ; $01D5AE | |
    LDA menu_custom_joypad_limit_value_data.l,X                                 ; $01D5B0 | |
    DEC A                                                                       ; $01D5B4 | |
+   STA r_config_joypad.w,X                                                     ; $01D5B5 |/
@check_confirm:
    LDA <r_menu_joypad_repeat.lo                                                ; $01D5B8 |\
    AND #JOYPAD_L_A.b                                                           ; $01D5BA | | If the A button is pressed and the cursor index is currently set
    BEQ +                                                                       ; $01D5BC | | to 5, attempt to validate the configuration and finalize it. If
    LDA r_menu_custom_joypad_cursor_index.w                                     ; $01D5BE | | valid, that routine returns (by manipulating the stack).
    CMP #5.b                                                                    ; $01D5C1 | |
    BNE +                                                                       ; $01D5C3 | |
    JSR _menu_custom_joypad_validate_and_finalize                               ; $01D5C5 |/
+   LDA <r_menu_joypad_repeat.hi                                                ; $01D5C8 |\
    AND #JOYPAD_H_B.b | JOYPAD_H_Y                                              ; $01D5CA | | If any of A, B, X or Y is pressed, attempt to validate and
    BNE +                                                                       ; $01D5CC | | finalize. Otherwise, jump back to the start of the function.
    LDA <r_menu_joypad_repeat.lo                                                ; $01D5CE | |
    AND #JOYPAD_L_A.b | JOYPAD_L_X                                              ; $01D5D0 | |
    BNE +                                                                       ; $01D5D2 | |
-   JMP _menu_custom_joypad_core                                                ; $01D5D4 | |
+   JSR _menu_custom_joypad_validate_and_finalize                               ; $01D5D7 |/
    BRA -                                                                       ; $01D5DA

; _menu_custom_joypad_validate_and_finalize ($01:D5DC)
;
; In the custom joypad menu, validates the currently chosen configuration
; settings, and if they are valid, transfers them to the current configuration
; and initializes the joypad maps. Otherwise, plays an error sound effect. If
; there was no error, manipulates the stack to return to the caller's caller.
; In other words, only call this if you want it to act as an RTS if validated.
_menu_custom_joypad_validate_and_finalize:
    LDA r_config_joypad_confirm.w                                               ; $01D5DC |\
    CMP r_config_joypad_cancel.w                                                ; $01D5DF | | If the confirm and cancel options are the same, error.
    BEQ +                                                                       ; $01D5E2 |/
    CMP r_config_joypad_menu.w                                                  ; $01D5E4 |\ If the confirm and menu options are the same, error.
    BEQ +                                                                       ; $01D5E7 |/
    LDA r_config_joypad_cancel.w                                                ; $01D5E9 |\
    CMP r_config_joypad_menu.w                                                  ; $01D5EC | | If the cancel and menu options are the same, error.
    BEQ +                                                                       ; $01D5EF |/
    PLX                                                                         ; $01D5F1 | No error, so pull the return address to return an extra level.
_menu_set_custom_joypad:
    LDX r_config_joypad_confirm.w                                               ; $01D5F2 |\
    STX r_joypad_custom_confirm.w                                               ; $01D5F5 | | Copy the new configuration values to the joypad configuration
    LDX r_config_joypad_menu.w                                                  ; $01D5F8 | | values.
    STX r_joypad_custom_menu.w                                                  ; $01D5FB | |
    LDA r_config_joypad_start.w                                                 ; $01D5FE | |
    STA r_joypad_custom_start.w                                                 ; $01D601 |/
    JMP _initialize_joypad_maps                                                 ; $01D604 | Initialize the joypad maps and return.
+   JMP _play_sound_effect_error                                                ; $01D607 | If an error, play an error sound effect.
.endif
.endif

; _menu_custom_joypad_set_confirm_cancel_menu_cursor_x_coordinate ($01:D3AD)
;
; Given a value of one of the confirm, cancel or menu options in the
; accumulator, sets the appropriate X coordinate for the corresponding cursor
; in $45.
_menu_custom_joypad_set_confirm_cancel_menu_cursor_x_coordinate:
    JSR _menu_transfer_a_to_x                                                   ; $01D3AD |\
    LDA menu_custom_joypad_confirm_cancel_menu_cursor_x_coordinate_data.l,X     ; $01D3B0 | | Set the X coordinate for the passed value.
    STA <r_menu_draw_cursor_arg_coordinates.x                                   ; $01D3B4 |/
    RTS                                                                         ; $01D3B6

; menu_custom_joypad_confirm_cancel_menu_cursor_x_coordinate_data ($01:D3B7)
;
; For each value of the confirm, cancel and menu options, determines the X
; coordinate for the cursor to point at the correct option.
menu_custom_joypad_confirm_cancel_menu_cursor_x_coordinate_data:
    .db  68                                                                     ; $01D3B7 | $00: A
    .db  92                                                                     ; $01D3B8 | $01: B
    .db 116                                                                     ; $01D3B9 | $02: X
    .db 140                                                                     ; $01D3BA | $03: Y
    .db 164                                                                     ; $01D3BB | $04: SELECT

; menu_custom_joypad_l_start_cursor_x_coordinate_data ($01:D3BC)
;
; For each value of the L and Start button options, determines the X coordinate
; for the cursor to point at the correct option.
menu_custom_joypad_l_start_cursor_x_coordinate_data:
    .db  68                                                                     ; $01D3BC | $00: Ignore
    .db 108                                                                     ; $01D3BD | $01: Confirm
    .db 148                                                                     ; $01D3BE | $02: Cancel
    .db 188                                                                     ; $01D3BF | $03: Menu

; _menu_custom_get_two_option_cursor_x_coordinate ($01:D3C0)
;
; Given the value of a configuration option with two choices in the accumulator,
; returns the desired X coordinate for the cursor in the accumulator.
_menu_custom_get_two_option_cursor_x_coordinate:
    AND #%00000001.b                                                            ; $01D3C0 |\
    BEQ +                                                                       ; $01D3C2 | | Load the value of 104 if the index mod 2 is zero. Otherwise, load
    LDA #160.b                                                                  ; $01D3C4 | | 160.
    BRA ++                                                                      ; $01D3C6 | |
+   LDA #104.b                                                                  ; $01D3C8 |/
++  RTS                                                                         ; $01D3CA

; _audio_toggle_stereo_mono ($01:D3CB)
;
; Toggles the current audio state between stereo and mono.
_audio_toggle_stereo_mono:
    LDA r_config.stereo_mono.w                                                  ; $01D3CB
    EOR #%00000001.b                                                            ; $01D3CE
    STA r_config.stereo_mono.w                                                  ; $01D3D0
    JMP _audio_set_stereo_mono                                                  ; $01D3D3

; _config_toggle_single_multi ($01:D3D6)
;
; Toggles the single/multi configuration value. Only used in the Japanese
; version.
_config_toggle_single_multi:
    LDA r_config.single_multi.w                                                 ; $01D3D6
    EOR #%00000001.b                                                            ; $01D3D9
    STA r_config.single_multi.w                                                 ; $01D3DB
    RTS                                                                         ; $01D3DE

.if FF4_REGION == "JAPAN"
; _config_toggle_atb ($01:D63C)
;
; Toggles the ATB mode between active and wait. Only exists in the Japanese
; version.
_config_toggle_atb:
    LDA r_config.atb_active.w                                                   ; $01D63C
    EOR #%00000001.b                                                            ; $01D63F
    STA r_config.atb_active.w                                                   ; $01D641
    RTS                                                                         ; $01D644
.endif

.if FF4_VERSION != "JAPAN_EASYTYPE"
; _config_toggle_normal_custom ($01:D3DF)
;
; Toggles between normal and custom joypad. Only used in the Japanese version.
_config_toggle_normal_custom:
    LDA r_config_joypad_map_index.w                                             ; $01D3DF
    EOR #%00000001.b                                                            ; $01D3E2
    STA r_config_joypad_map_index.w                                             ; $01D3E4
    STA r_joypad_map_index.w                                                    ; $01D3E7
    RTS                                                                         ; $01D3EA
.endif

; menu_custom_joypad_limit_value_data ($01:D3EB)
;
; For each of the custom joypad options, determines the lowest value that is
; out of bounds for each.
menu_custom_joypad_limit_value_data:
    .db 5                                                                       ; $01D3EB | $00: Confirm
    .db 5                                                                       ; $01D3EC | $01: Cancel
    .db 5                                                                       ; $01D3ED | $02: Menu
    .db 4                                                                       ; $01D3EF | $03: L Button
    .db 4                                                                       ; $01D3EE | $04: Start Button

.if FF4_REGION == "JAPAN"
; _menu_custom_joypad_selector ($01:D656)
;
; Displays and executes the custom joypad selector menu. Only used in the
; Japanese version.
_menu_custom_joypad_selector:
    JSR _menu_set_current_tilemap_bg2                                           ; $01D656 | Set the current tilemap to BG2.
    LDY #menu_window_custom_title_data.w                                        ; $01D659 |\ Draw the custom window title dialog.
    JSR _menu_configure_and_draw_window                                         ; $01D65C |/
    LDY #menu_window_custom_joypad_selector_data.w                              ; $01D65F |\ Draw the joypad selector menu and its title.
    JSR _menu_draw_text_indirect_plus_window                                    ; $01D662 |/
    STZ <r_menu_custom_joypad_selector_tmp_position.lo                          ; $01D665 |\ Initialize the position to zero.
    STZ <r_menu_custom_joypad_selector_tmp_position.hi                          ; $01D667 |/
    LDY #(9 * 2) + (8 * 32 * 2).w                                               ; $01D669 | Initialize the Y register to point to 9, 8.
-   LDX <r_menu_custom_joypad_selector_tmp_position                             ; $01D66C | Set the X register to the current position.
    LDA bank14.character_position_to_slot_data.l,X                              ; $01D66E | Load the corresponding slot for that position.
    PHY                                                                         ; $01D672 |\
    JSR _menu_get_character_field_offset                                        ; $01D673 | | Draw the name of the character in that slot.
    LDA 0.w,X                                                                   ; $01D676 | |
    JSR _menu_draw_character_name                                               ; $01D679 | |
    PLY                                                                         ; $01D67C |/
    PHY                                                                         ; $01D67D |\
    JSR _increment_y_by_8                                                       ; $01D67E | | Draw the word controller to the tilemap in the same row, shifted
    JSR _increment_y_by_4                                                       ; $01D681 | | to the right by 6 spaces.
    TYX                                                                         ; $01D684 | |
    LDY #menu_text_controller_data.w                                            ; $01D685 | |
    JSR _menu_draw_text_direct                                                  ; $01D688 | |
    PLY                                                                         ; $01D68B |/
    JSR _increment_y_by_64                                                      ; $01D68C |\ Increment Y by 128 to move down two rows.
    JSR _increment_y_by_64                                                      ; $01D68F |/
    INC <r_menu_custom_joypad_selector_tmp_position                             ; $01D692 |\
    LDA <r_menu_custom_joypad_selector_tmp_position                             ; $01D694 | | Increment the current position and loop until it reaches 5.
    CMP #5.b                                                                    ; $01D696 | |
    BNE -                                                                       ; $01D698 |/
    LDA r_menu_custom_joypad_selector_cursor_index.w                            ; $01D69A |\
    STA <r_menu_generic_tmp_count                                               ; $01D69D | | Starting at the current value of the cursor index, loop until
-   LDA <r_menu_generic_tmp_count                                               ; $01D69F | | finding a position that has a valid character in it, and then
    JSR _menu_get_character_id_from_position                                    ; $01D6A1 | | update the cursor index.
    BNE +                                                                       ; $01D6A4 | |
    INC <r_menu_generic_tmp_count                                               ; $01D6A6 | |
    LDA <r_menu_generic_tmp_count                                               ; $01D6A8 | |
    CMP #5.b                                                                    ; $01D6AA | |
    BNE -                                                                       ; $01D6AC | |
    STZ <r_menu_generic_tmp_count                                               ; $01D6AE | |
    BRA -                                                                       ; $01D6B0 | |
+   LDA <r_menu_generic_tmp_count                                               ; $01D6B2 | |
    STA r_menu_custom_joypad_selector_cursor_index.w                            ; $01D6B4 |/
    JSR _menu_initialize_oam                                                    ; $01D6B7 | Initialize the OAM.
    JSR _menu_wait_for_vblank_copy_oam_to_ppu                                   ; $01D6BA | Wait for vblank and copy the OAM to the PPU.
    JSR _menu_animate_current_tilemap_50_rows_to_vram                           ; $01D6BD | Animate the window opening.
@loop_start:
    LDA r_menu_custom_joypad_selector_cursor_index.w                            ; $01D6C0 |\
    ASL A                                                                       ; $01D6C3 | | Draw the cursor with an X coordinate of 56 and a Y coordinate of
    ASL A                                                                       ; $01D6C4 | | 74 plus the index times sixteen.
    ASL A                                                                       ; $01D6C5 | |
    ASL A                                                                       ; $01D6C6 | |
    ADC #74.b                                                                   ; $01D6C7 | |
    STA <r_menu_draw_cursor_arg_coordinates.y                                   ; $01D6C9 | |
    LDA #56.b                                                                   ; $01D6CB | |
    STA <r_menu_draw_cursor_arg_coordinates.x                                   ; $01D6CD | |
    JSR _menu_draw_cursor_1                                                     ; $01D6CF |/
    STZ <r_menu_generic_tmp_word.lo                                             ; $01D6D2 |\ Initialize the position to zero.
    STZ <r_menu_generic_tmp_word.hi                                             ; $01D6D4 |/
-   LDA <r_menu_generic_tmp_word.lo                                             ; $01D6D6 |\
    ASL A                                                                       ; $01D6D8 | | Set the Y register to the tilemap coordinates for the controller
    JSR _menu_transfer_a_to_x                                                   ; $01D6D9 | | index for this position.
    REP #FLAG_P_ACCUMULATOR                                                     ; $01D6DC | |
    LDA menu_custom_joypad_selector_controller_index_coordinate_data.l,X        ; $01D6DE | |
    TAY                                                                         ; $01D6E2 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01D6E3 |/
    LDA <r_menu_generic_tmp_word.lo                                             ; $01D6E5 |\
    JSR _menu_custom_joypad_get_position_value_direct                           ; $01D6E7 | | Write the currently assigned controller value to that location in
    LSR A                                                                       ; $01D6EA | | the tilemap.
    CLC                                                                         ; $01D6EB | |
    ADC #TILE_MENU_NUMBER_BASE.b + 1                                            ; $01D6EC | |
    STA r_menu_tilemap_bg2.w,Y                                                  ; $01D6EE |/
    INC <r_menu_generic_tmp_word.lo                                             ; $01D6F1 |\
    LDA <r_menu_generic_tmp_word.lo                                             ; $01D6F3 | | Increment the position and loop until all five have been done.
    CMP #5.b                                                                    ; $01D6F5 | |
    BNE -                                                                       ; $01D6F7 |/
    JSR _menu_copy_tilemap_to_vram_bg2                                          ; $01D6F9 | Copy the BG2 tilemap to VRAM.
    JSR _menu_copy_oam_to_ppu                                                   ; $01D6FC | Copy the OAM to the PPU.
    JSR _menu_update_joypad_and_play_sound_effect                               ; $01D6FF | Update the joypad and play an appropriate sound effect.
    LDA <r_menu_joypad_repeat.hi                                                ; $01D702 |\
    AND #JOYPAD_H_B.b                                                           ; $01D704 | | If the B button is pressed, clear BG2, copy it to VRAM and return.
    BEQ +                                                                       ; $01D706 | |
    JMP _menu_initialize_tilemap_bg2_and_copy_to_vram                           ; $01D708 |/
+   LDA <r_menu_joypad_repeat.hi                                                ; $01D70B |\
    AND #JOYPAD_H_UP.b                                                          ; $01D70D | | If up on the d-pad is pressed, decrement the cursor index until it
    BEQ ++                                                                      ; $01D70F | | points to a position with a valid character in it, automatically
-   LDA r_menu_custom_joypad_selector_cursor_index.w                            ; $01D711 | | cycling back to 4 when it goes negative.
    DEC A                                                                       ; $01D714 | |
    BPL +                                                                       ; $01D715 | |
    LDA #4.b                                                                    ; $01D717 | |
+   STA r_menu_custom_joypad_selector_cursor_index.w                            ; $01D719 | |
    JSR _menu_get_position_character_id                                         ; $01D71C | |
    BEQ -                                                                       ; $01D71F |/
++  LDA <r_menu_joypad_repeat.hi                                                ; $01D721 |\
    AND #JOYPAD_H_DOWN.b                                                        ; $01D723 | | If down is pressed on the d-pad, increment the cursor index until
    BEQ ++                                                                      ; $01D725 | | it points to a position with a valid character in it, cycling
-   LDA r_menu_custom_joypad_selector_cursor_index.w                            ; $01D727 | | around to zero when it reaches five.
    INC A                                                                       ; $01D72A | |
    CMP #5.b                                                                    ; $01D72B | |
    BNE +                                                                       ; $01D72D | |
    LDA #0.b                                                                    ; $01D72F | |
+   STA r_menu_custom_joypad_selector_cursor_index.w                            ; $01D731 | |
    JSR _menu_get_position_character_id                                         ; $01D734 | |
    BEQ -                                                                       ; $01D737 |/
++  LDA <r_menu_joypad_repeat.hi                                                ; $01D739 |\
    AND #JOYPAD_H_LEFT.b | JOYPAD_H_RIGHT                                       ; $01D73B | | If either left or right is pressed on the d-pad, toggle the
    BEQ ++                                                                      ; $01D73D | | controller value for the current position between 0 and 2.
    JSR _menu_custom_joypad_get_position_value_cursor                           ; $01D73F | |
    DEC A                                                                       ; $01D742 | |
    DEC A                                                                       ; $01D743 | |
    BPL +                                                                       ; $01D744 | |
    LDA #2.b                                                                    ; $01D746 | |
+   STA r_config.multi.w,X                                                      ; $01D748 |/
++  JMP @loop_start                                                             ; $01D74B | Jump back to the start of the loop.
.endif

; _menu_custom_joypad_get_position_value_* ($01:D3F0)
;
; For the custom joypad selector menu, loads the currently assigned controller
; to the chosen position. The _cursor variant loads the position pointed to by
; the cursor, and the _direct variant reads the position directly from the
; accumulator.
_menu_custom_joypad_get_position_value_cursor:
    LDA r_menu_custom_joypad_selector_cursor_index.w                            ; $01D3F0 | Load the current cursor index.
_menu_custom_joypad_get_position_value_direct:
    JSR _menu_transfer_a_to_x                                                   ; $01D3F3 |\
    LDA bank14.character_position_to_slot_data.l,X                              ; $01D3F6 | | Read the controller value for the character in the position passed
    JSR _menu_transfer_a_to_x                                                   ; $01D3FA | | in the accumulator.
    LDA r_config.multi.w,X                                                      ; $01D3FD |/
    RTS                                                                         ; $01D400

; _menu_get_position_character_id ($01:D401)
;
; Given a character position in the accumulator, returns the character ID for
; that position in the accumulator.
_menu_get_position_character_id:
    JSR _menu_transfer_a_to_x                                                   ; $01D401 |\
    LDA bank14.character_position_to_slot_data.l,X                              ; $01D404 | | Read the character ID for the position passed in the accumulator.
    JSR _menu_get_character_field_offset                                        ; $01D408 | |
    LDA character_field.id.w,X                                                  ; $01D40B | |
    AND #%00111111.b                                                            ; $01D40E |/
    RTS                                                                         ; $01D410

; menu_custom_joypad_selector_controller_index_coordinate_data ($01:D411)
;
; Only used in the Japanese version, this provides the tilemap coordinates to
; draw the controller index assigned to each character in the joypad selector
; menu.
menu_custom_joypad_selector_controller_index_coordinate_data:
    .dw (23 * 2) + ( 9 * 32 * 2)                                                ; $01D411
    .dw (23 * 2) + (11 * 32 * 2)                                                ; $01D413
    .dw (23 * 2) + (13 * 32 * 2)                                                ; $01D415
    .dw (23 * 2) + (15 * 32 * 2)                                                ; $01D417
    .dw (23 * 2) + (17 * 32 * 2)                                                ; $01D419

; _menu_custom_initialize_number_tile_flags ($01:D41B)
;
; Sets the tile flags for the 1 through 6 numbers used for the battle speed and
; battle message speed settings to set their palette to 1, making them grey.
_menu_custom_initialize_number_tile_flags:
    LDY #r_menu_tilemap_bg1.w + (15 * 2) + (8 * 32 * 2) + 1                     ; $01D41B |\ Call the part of this routine once to set the flags on the first
    JSR +                                                                       ; $01D41E |/ row.
.if FF4_REGION == "JAPAN"
    LDY #r_menu_tilemap_bg1.w + (15 * 2) + (10 * 32 * 2) + 1                    ; $01D421 | Now set the Y register to repeat on the second row.
.else
    LDY #r_menu_tilemap_bg1.w + (15 * 2) + (12 * 32 * 2) + 1                    ; $01D421 | Now set the Y register to repeat on the second row.
.endif
+   LDA #%00000100.b                                                            ; $01D424 |\
    LDX #6.w                                                                    ; $01D426 | | Loop to set the palette on the 6 numbers to palette 1 to grey them
-   STA 0.w,Y                                                                   ; $01D429 | | out.
    INY                                                                         ; $01D42C | |
    INY                                                                         ; $01D42D | |
    INY                                                                         ; $01D42E | |
    INY                                                                         ; $01D42F | |
    DEX                                                                         ; $01D430 | |
    BNE -                                                                       ; $01D431 |/
    RTS                                                                         ; $01D433

.if FF4_VERSION != "JAPAN"
.if FF4_VERSION != "JAPAN_REV_1"
; _menu_set_custom_joypad ($01:D434)
;
; Transfers the configured custom joypad settings to the main custom joypad
; variables and initializes the joypad maps.
;
; NOTE: This routine exists as part of a larger routine in the Japanese version,
;       but in the USA version, it has been relocated and only certain parts
;       have survived. It also applies to the Easytype version.
_menu_set_custom_joypad:
    LDX r_config_joypad_confirm.w                                               ; $01D434 |\
    STX r_joypad_custom_confirm.w                                               ; $01D437 | | Transfer the joypad settings.
    LDX r_config_joypad_menu.w                                                  ; $01D43A | |
    STX r_joypad_custom_menu.w                                                  ; $01D43D | |
    LDA r_config_joypad_start.w                                                 ; $01D440 | |
    STA r_joypad_custom_start.w                                                 ; $01D443 |/
    JMP _initialize_joypad_maps                                                 ; $01D446 | Initialize the joypad maps.

; menu_custom_cursor_y_coordinate_data ($01:D449)
;
; For each value of the cursor index in the custom menu, determines the Y
; coordinate of the cursor. This is only applicable to the USA version.
menu_custom_cursor_y_coordinate_data:
.if FF4_VERSION != "JAPAN_EASYTYPE"
    .db  48                                                                     ; $01D449 | $00: Battle Speed
    .db  80                                                                     ; $01D44A | $01: Battle Message Speed
    .db 120                                                                     ; $01D44B | $02: Sound
    .db 160                                                                     ; $01D44C | $03: R
    .db 176                                                                     ; $01D44D | $04: G
    .db 192                                                                     ; $01D44E | $05: B
.endif
.endif
.endif

; _menu_spoils ($01:D44F)
;
; Main entry point for the spoils menu.
_menu_spoils:
    PHB                                                                         ; $01D44F |\ Preserve the data bank and direct registers.
    PHD                                                                         ; $01D450 |/
    JSR _menu_backup_vram_tiles                                                 ; $01D451 | Backup certain VRAM tiles that would be clobbered.
    JSR _menu_init                                                              ; $01D454 | Initialize the menu system.
    STZ r_menu_spoils_do_exchange_first.w                                       ; $01D457 | Reset the flag to indicate exchange should be done first.
    LDX <r_menu_zero                                                            ; $01D45A |\
    TXA                                                                         ; $01D45C | | Initialize the cursor coordinates to zero.
    STX r_menu_spoils_upper_cursor_coordinates.w                                ; $01D45D | |
    STX r_menu_spoils_lower_cursor_coordinates.w                                ; $01D460 | |
    STA r_menu_spoils_lower_cursor_first_row.w                                  ; $01D463 |/
    LDA #8.b                                                                    ; $01D466 |\ Initialize the count to eight.
    STA <r_menu_generic_tmp_count                                               ; $01D468 |/
    LDX <r_menu_zero                                                            ; $01D46A |\ Initialize the X and Y registers to zero.
    TXY                                                                         ; $01D46C |/
-   LDA r_battle_drops.w,X                                                      ; $01D46D | Load the next dropped item.
    BEQ ++                                                                      ; $01D470 |\
    CMP #ITEM_FIRST_ARROW.b                                                     ; $01D472 | | If the item is in the arrow range, set the ID and set the count to
    BCC +                                                                       ; $01D474 | | 10 in the spoils inventory.
    CMP #ITEM_LAST_ARROW.b + 1                                                  ; $01D476 | |
    BCS +                                                                       ; $01D478 | |
    STA r_menu_spoils_inventory.1.id.w,Y                                        ; $01D47A | |
    LDA #10.b                                                                   ; $01D47D | |
    STA r_menu_spoils_inventory.1.count.w,Y                                     ; $01D47F | |
    BRA +++                                                                     ; $01D482 |/
+   STA r_menu_spoils_inventory.1.id.w,Y                                        ; $01D484 |\
    LDA #$01.b                                                                  ; $01D487 | | For other items, set the ID and set the count to zero.
    STA r_menu_spoils_inventory.1.count.w,Y                                     ; $01D489 | |
    BRA +++                                                                     ; $01D48C |/
++  LDA #0.b                                                                    ; $01D48E |\
    STA r_menu_spoils_inventory.1.id.w,Y                                        ; $01D490 | | If there was no item, set both the ID and count to zero.
    STA r_menu_spoils_inventory.1.count.w,Y                                     ; $01D493 |/
+++ INY                                                                         ; $01D496 |\
    INY                                                                         ; $01D497 | | Increment the index registers.
    INX                                                                         ; $01D498 |/
    DEC <r_menu_generic_tmp_count                                               ; $01D499 |\ Loop until all eight potential items have been checked.
    BNE -                                                                       ; $01D49B |/
    JSR _menu_spoils_execute                                                    ; $01D49D | Execute the spoils menu input handler.
    JSR _menu_ppu_fade_out                                                      ; $01D4A0 | Fade the PPU out.
    STZ r_menu_inventory_highlight_key_items.w                                  ; $01D4A3 | Reset the flag to highlight key items.
    JSR _menu_restore_vram_tiles                                                ; $01D4A6 | Restore the backed up VRAM tiles.
    LDA #0.b                                                                    ; $01D4A9 |\ Set the high byte of the accumulator to zero.
    XBA                                                                         ; $01D4AB |/
    PLD                                                                         ; $01D4AC |\ Restore the direct and data bank registers.
    PLB                                                                         ; $01D4AD |/
    RTS                                                                         ; $01D4AE

; _menu_spoils_execute ($01:D4AF)
;
; Main input handler for the spoils menu. Unfortunately, this menu's control
; flow is a quintessential example of spaghetti code, so it may be difficult to
; follow. The core loop repeatedly allows the user to select a command, and if
; the command is exit, the code has to check that no key items are left behind.
; This core loop actually can occur in two different routines. There are a few
; core routines that are all connected to each other through JMP instructions,
; so, again, it can be difficult to follow.
_menu_spoils_execute:
    LDX #-32.w                                                                  ; $01D4AF |\ Set the BG1 vertical scroll offset to -32.
    STX <r_menu_scroll_bg1.vertical.value                                       ; $01D4B2 |/
    LDX #-120.w                                                                 ; $01D4B4 |\ Set the BG3 vertical scroll offset to -120.
    STX <r_menu_scroll_bg3.vertical.value                                       ; $01D4B7 |/
    JSR _menu_set_current_tilemap_bg2                                           ; $01D4B9 |\ Draw the title window and the command window to BG2.
    JSR _menu_spoils_draw_title_and_commands                                    ; $01D4BC |/
    JSR _menu_set_current_tilemap_bg1                                           ; $01D4BF | Set the current tilemap to BG1.
    LDX #ITEM_NONE.w + ((ITEM_FIRST_UNSELLABLE_KEY_ITEM - 1) << 8)              ; $01D4C2 |\ Set the enabled item range to everything except unsellable key
    STX r_menu_inventory_enabled_item_range.w                                   ; $01D4C5 |/ items.
    INC r_menu_inventory_highlight_key_items.w                                  ; $01D4C8 | Set the flag to highlight key items in the inventory.
    JSR _menu_spoils_draw_inventory                                             ; $01D4CB | Draw the spoils inventory to BG1.
    JSR _menu_set_current_tilemap_bg4                                           ; $01D4CE |\
    LDY #menu_window_spoils_spoil_inventory_data.w                              ; $01D4D1 | | Draw the spoils inventory window to BG4.
    JSR _menu_configure_and_draw_window                                         ; $01D4D4 |/
    JSR _menu_set_current_tilemap_bg3                                           ; $01D4D7 |\ Draw the main inventory to BG3.
    JSR _menu_inventory_draw_window                                             ; $01D4DA |/
    JSR _menu_copy_tilemaps_to_vram                                             ; $01D4DD | Copy the tilemaps to VRAM.
    JSR _menu_set_bg_scroll_proxy                                               ; $01D4E0 | Set the background scroll values.
    STZ <r_menu_spoils_exit_selected                                            ; $01D4E3 | Reset the exit selected flag.
    JSR _menu_ppu_fade_in                                                       ; $01D4E5 | Fade the PPU in.
-   JSR _menu_spoils_select_command                                             ; $01D4E8 | Execute the selection of a command.
    LDA <r_menu_spoils_exit_selected                                            ; $01D4EB |\
    BEQ +                                                                       ; $01D4ED | | If exit is selected, verify no key items remain. If they do,
    JSR _menu_spoils_check_for_key_items                                        ; $01D4EF | | repeatedly execute this loop. If exit is not selected, branch to
    BCS -                                                                       ; $01D4F2 | | execute the take all code.
    RTS                                                                         ; $01D4F4 |/
+   BRA _menu_spoils_take_all                                                   ; $01D4F5

; _menu_spoils_select_command ($01:D4F7)
;
; Part of the spoils menu, allows the player to select a main command. Returns
; when a command is selected. The command chosen is then reflected in $60, which
; is zero if "Take all" was selected and $FF if Exit was selected.
_menu_spoils_select_command:
    JSR _menu_set_current_tilemap_bg2                                           ; $01D4F7 |\
    LDY #menu_text_spoils_take_all_data.w                                       ; $01D4FA | | Draw the "Take all" text to BG2.
    JSR _menu_draw_text_indirect                                                ; $01D4FD |/
    JSR _menu_spoils_draw_command_cursor                                        ; $01D500 | Draw the command cursor.
    JSR _menu_wait_for_vblank_copy_oam_to_ppu                                   ; $01D503 | Wait for vblank and copy the OAM to the PPU.
    JSR _menu_copy_tilemap_to_vram_bg2_no_vblank                                ; $01D506 | Copy the BG2 tilemap to VRAM.
    JSR _menu_update_joypad_and_play_sound_effect                               ; $01D509 | Update the joypad values and play any associated sound effect.
    LDA <r_menu_joypad_repeat.hi                                                ; $01D50C |\
    AND #JOYPAD_H_LEFT.b | JOYPAD_H_RIGHT                                       ; $01D50E | | If either left or right is selected, toggle whether or not Exit is
    BEQ +                                                                       ; $01D510 | | selected.
    LDA <r_menu_spoils_exit_selected                                            ; $01D512 | |
    EOR #%11111111.b                                                            ; $01D514 | |
    STA <r_menu_spoils_exit_selected                                            ; $01D516 |/
+   LDA <r_menu_joypad_repeat.hi                                                ; $01D518 |\
    AND #JOYPAD_H_B.b                                                           ; $01D51A | | If B is pressed on the joypad and if Exit is the selected command,
    BEQ ++                                                                      ; $01D51C | | return. Otherwise, if B is pressed, select the Exit command, but
    LDA <r_menu_spoils_exit_selected                                            ; $01D51E | | otherwise continue.
    CMP #%11111111.b                                                            ; $01D520 | |
    BNE +                                                                       ; $01D522 | |
    RTS                                                                         ; $01D524 | |
+   LDA #%11111111.b                                                            ; $01D525 | |
    STA <r_menu_spoils_exit_selected                                            ; $01D527 |/
++  LDA <r_menu_joypad_repeat.lo                                                ; $01D529 |\
    AND #JOYPAD_L_A.b                                                           ; $01D52B | | If the A button is pressed, return.
    BEQ +                                                                       ; $01D52D | |
    RTS                                                                         ; $01D52F |/
+   LDA <r_menu_joypad_repeat.hi                                                ; $01D530 |\
    AND #JOYPAD_H_DOWN.b                                                        ; $01D532 | | If down is selected, reset the exit selected flag, draw the
    BEQ +                                                                       ; $01D534 | | command cursor, set the exchange flag, and then call the core
    STZ <r_menu_spoils_exit_selected                                            ; $01D536 | | spoils handler.
    JSR _menu_spoils_draw_command_cursor                                        ; $01D538 | |
    INC r_menu_spoils_do_exchange_first.w                                       ; $01D53B | |
    JMP _menu_spoils_main_loop                                                  ; $01D53E |/
+   JMP _menu_spoils_select_command                                             ; $01D541

; _menu_spoils_draw_command_cursor ($01:D544)
;
; Draws the command cursor in the spoils menu.
_menu_spoils_draw_command_cursor:
    LDA <r_menu_spoils_exit_selected                                            ; $01D544 |\
    BNE +                                                                       ; $01D546 | | Set the X coordinate to 88 if exit is not selected and to 184 if
.if FF4_REGION == "JAPAN"                                                       ;         | | it is. (The Japanese version uses 72 instead.)
    LDA #72.b                                                                   ; $01D548 | |
.else                                                                           ;         | |
    LDA #88.b                                                                   ; $01D548 | |
.endif                                                                          ;         | |
    BRA ++                                                                      ; $01D54A | |
+   LDA #184.b                                                                  ; $01D54C | |
++  STA <r_menu_draw_cursor_arg_coordinates.x                                   ; $01D54E |/
    LDA #14.b                                                                   ; $01D550 |\ Set the Y coordinate to 14.
    STA <r_menu_draw_cursor_arg_coordinates.y                                   ; $01D552 |/
    JMP _menu_draw_cursor_1                                                     ; $01D554 | Draw the cursor.

; _menu_spoils_take_all ($01:D557)
;
; Part of the spoils menu, attempts to execute the "Take all" command. If
; successful, will simply return. Otherwise, will jump to another portion of the
; spoils menu system. This routine should only be executed via a jump or branch
; instruction, and not via JSR. It is deeply intertwined with the rest of the
; spoils menu code.
_menu_spoils_take_all:
    LDY <r_menu_zero                                                            ; $01D557 | Initialize the Y register to zero.
    LDA #8.b                                                                    ; $01D559 |\ Initialize the count for the spoils inventory to 8.
    STA <r_menu_spoils_tmp_count                                                ; $01D55B |/
--  LDA r_menu_spoils_inventory.1.id.w,Y                                        ; $01D55D |\ Skip this spoils inventory spot if empty.
    BEQ ++                                                                      ; $01D560 |/
    LDA #48.b                                                                   ; $01D562 |\ Initialize the regular inventory count to 48.
    STA <r_menu_generic_tmp_count                                               ; $01D564 |/
    LDX <r_menu_zero                                                            ; $01D566 | Initialize the X register to zero.
-   LDA r_menu_spoils_inventory.1.id.w,Y                                        ; $01D568 |\
    CMP r_inventory.1.id.w,X                                                    ; $01D56B | | If the items in the two spots being compared are the same and if
    BNE +                                                                       ; $01D56E | | their total count is less than 100, update the count in the main
    LDA r_menu_spoils_inventory.1.count.w,Y                                     ; $01D570 | | inventory to the sum and zero the item from the spoils inventory.
    CLC                                                                         ; $01D573 | | Afterward, branch ahead to move on to the next item in the spoils
    ADC r_inventory.1.count.w,X                                                 ; $01D574 | | inventory.
    CMP #100.b                                                                  ; $01D577 | |
    BCS +                                                                       ; $01D579 | |
    STA r_inventory.1.count.w,X                                                 ; $01D57B | |
    LDA #0.b                                                                    ; $01D57E | |
    STA r_menu_spoils_inventory.1.id.w,Y                                        ; $01D580 | |
    STA r_menu_spoils_inventory.1.count.w,Y                                     ; $01D583 | |
    BRA ++                                                                      ; $01D586 |/
+   INX                                                                         ; $01D588 |\
    INX                                                                         ; $01D589 | | Otherwise, increment the X register, decrement the count, and loop
    DEC <r_menu_generic_tmp_count                                               ; $01D58A | | until all main inventory spots have been checked.
    BNE -                                                                       ; $01D58C |/
++  INY                                                                         ; $01D58E |\
    INY                                                                         ; $01D58F | | Increment the Y register, decrement the spoils count, and loop
    DEC <r_menu_spoils_tmp_count                                                ; $01D590 | | until all spoils inventory spots have been checked.
    BNE --                                                                      ; $01D592 |/
    LDA #8.b                                                                    ; $01D594 |\ Initialize the spoils count to 8.
    STA <r_menu_generic_tmp_count                                               ; $01D596 |/
    LDY <r_menu_zero                                                            ; $01D598 | Initialize the Y register to zero.
-   LDA r_menu_spoils_inventory.1.id.w,Y                                        ; $01D59A |\ If this spoils inventory slot is empty, branch forward to skip this
    BEQ +                                                                       ; $01D59D |/ slot.
    LDA #ITEM_NONE.b                                                            ; $01D59F |\
    PHY                                                                         ; $01D5A1 | | Scan the inventory for an empty spot.
    JSR _menu_find_available_inventory_slot                                     ; $01D5A2 | |
    PLY                                                                         ; $01D5A5 |/
    CMP #0.b                                                                    ; $01D5A6 |\
    BNE +                                                                       ; $01D5A8 | | If one was found, copy the item ID and count from the spoils
    REP #FLAG_P_ACCUMULATOR                                                     ; $01D5AA | | inventory to the main inventory. Then, reset the spoils inventory
    LDA r_menu_spoils_inventory.w,Y                                             ; $01D5AC | | to zero.
    STA r_inventory.w,X                                                         ; $01D5AF | |
    LDA <r_menu_zero                                                            ; $01D5B2 | |
    STA r_menu_spoils_inventory.1.id.w,Y                                        ; $01D5B4 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01D5B7 |/
+   INY                                                                         ; $01D5B9 |\
    INY                                                                         ; $01D5BA | | Increment the Y register, decrement the count, and loop until all
    DEC <r_menu_generic_tmp_count                                               ; $01D5BB | | spoils inventory slots have been checked.
    BNE -                                                                       ; $01D5BD |/
    LDY #8.w                                                                    ; $01D5BF |\
    LDX <r_menu_zero                                                            ; $01D5C2 | | Sum the total remaining count of items in the spoils inventory.
    TXA                                                                         ; $01D5C4 | |
-   CLC                                                                         ; $01D5C5 | |
    ADC r_menu_spoils_inventory.1.count.w,X                                     ; $01D5C6 | |
    INX                                                                         ; $01D5C9 | |
    INX                                                                         ; $01D5CA | |
    DEY                                                                         ; $01D5CB | |
    BNE -                                                                       ; $01D5CC |/
    JSR _menu_spoils_redraw_inventory                                           ; $01D5CE | Redraw the spoils and main inventories.
    CMP #0.b                                                                    ; $01D5D1 |\ If there were still items remaining, branch to execute the command
    BNE _menu_spoils_main_loop                                                  ; $01D5D3 |/ selection menu again.
    INC <r_menu_spoils_exit_selected                                            ; $01D5D5 | Reset the exit selected flag (from $FF to $00).
    JSR _menu_spoils_draw_command_cursor                                        ; $01D5D7 | Draw the command cursor.
    JSR _menu_wait_for_vblank_copy_oam_to_ppu                                   ; $01D5DA | Copy the OAM to PPU at the next vblank.
    JSR _menu_set_current_tilemap_bg2                                           ; $01D5DD |\ Set the current tilemap to BG2 and copy it to VRAM.
    JSR _menu_copy_tilemap_to_vram_bg2                                          ; $01D5E0 |/
    JMP _menu_wait_for_input                                                    ; $01D5E3 | Wait for input.

; _menu_spoils_redraw_inventory ($01:D5E6)
;
; In the spoils menu, redraws the spoils inventory and main inventory on BG1 and
; BG3, respectively. Preserves the value in the accumulator.
_menu_spoils_redraw_inventory:
    PHA                                                                         ; $01D5E6 | Preserve the value in the accumulator.
    JSR _menu_set_current_tilemap_bg1_and_initialize                            ; $01D5E7 | Set the current tilemap to BG1 and clear it.
    JSR _menu_spoils_draw_inventory                                             ; $01D5EA | Draw the spoils inventory to BG1.
    JSR _menu_set_current_tilemap_bg3                                           ; $01D5ED |\ Draw the main inventory to BG3.
    JSR _menu_inventory_draw_window                                             ; $01D5F0 |/
    JSR _menu_copy_tilemap_to_vram_bg1                                          ; $01D5F3 |\ Copy both BG1 and BG3 to VRAM.
    JSR _menu_copy_tilemap_to_vram_bg3                                          ; $01D5F6 |/
    PLA                                                                         ; $01D5F9 | Restore the value in the accumulator.
    RTS                                                                         ; $01D5FA

; _menu_spoils_main_loop ($01:D5FB)
;
; Part of the spoils menu, effectively serves as a main loop to repeatedly
; execute the command selection code until the spoils inventory no longer has
; any remaining key items.
_menu_spoils_main_loop:
    LDA r_menu_spoils_do_exchange_first.w                                       ; $01D5FB |\ Load the exchange first flag and then zero it out.
    STZ r_menu_spoils_do_exchange_first.w                                       ; $01D5FE |/
    BNE ++                                                                      ; $01D601 | If the flag was set, branch to execute the exchange code.
-   JSR _menu_spoils_select_command                                             ; $01D603 | Allow the player to select a command.
    LDA <r_menu_spoils_exit_selected                                            ; $01D606 |\
    BEQ +                                                                       ; $01D608 | | If exit is selected, double check for remaining key items. If any
    JSR _menu_spoils_check_for_key_items                                        ; $01D60A | | are found, repeat the loop. Otherwise, return.
    BCS -                                                                       ; $01D60D | |
    RTS                                                                         ; $01D60F |/
+   JMP _menu_spoils_take_all                                                   ; $01D610 | If exit was not selected, execute the "Take all" code.
++  JSR _menu_spoils_exchange                                                   ; $01D613 |\ Execute the exchange menu, and then branch to the main loop.
    BRA -                                                                       ; $01D616 |/

; _menu_spoils_exchange ($01:D618)
;
; Handler for the first portion of the exchange menu in the spoils menu.
_menu_spoils_exchange:
    JSR _menu_set_current_tilemap_bg2                                           ; $01D618 |\
    LDY #menu_text_spoils_exchange_data.w                                       ; $01D61B | | Draw the Exchange command text to BG2.
    JSR _menu_draw_text_indirect                                                ; $01D61E |/
    JSR _menu_copy_tilemap_to_vram_bg2                                          ; $01D621 | Copy the BG2 tilemap to VRAM.
@loop_start:
    LDA r_menu_spoils_upper_cursor_coordinates.y.w                              ; $01D624 |\
    ASL A                                                                       ; $01D627 | | Set the cursor Y pixel coordinate to the Y coordinate times 16
    ASL A                                                                       ; $01D628 | | plus 48.
    ASL A                                                                       ; $01D629 | |
    ASL A                                                                       ; $01D62A | |
    ADC #48.b                                                                   ; $01D62B | |
    STA <r_menu_spoils_tmp_word.hi                                              ; $01D62D |/
    LDA r_menu_spoils_upper_cursor_coordinates.x.w                              ; $01D62F |\
    BEQ +                                                                       ; $01D632 | | Set the cursor X pixel coordinate to 0 if the first column is
    LDA #112.b                                                                  ; $01D634 | | selected and 112 otherwise.
    BRA ++                                                                      ; $01D636 | |
+   LDA #0.b                                                                    ; $01D638 | |
++  STA <r_menu_spoils_tmp_word.lo                                              ; $01D63A |/
    LDX <r_menu_spoils_tmp_word                                                 ; $01D63C |\
    LDY #r_oam.2.w                                                              ; $01D63E | | Draw the cursor to the second OAM Entry.
    TDC                                                                         ; $01D641 | |
    JSR _menu_draw_cursor_direct                                                ; $01D642 |/
    JSR _menu_wait_for_vblank_copy_oam_to_ppu                                   ; $01D645 | Wait for vblank and copy the OAM to the PPU.
    JSR _menu_update_joypad_and_play_sound_effect                               ; $01D648 | Update the joypad and play a sound effect if appropriate.
    LDA <r_menu_joypad_repeat.hi                                                ; $01D64B |\
    AND #JOYPAD_H_B.b                                                           ; $01D64D | | If the B button is pressed, reset the exit selected flag and
    BEQ +                                                                       ; $01D64F | | erase the second cursor.
    STZ <r_menu_spoils_exit_selected                                            ; $01D651 | |
    LDY #r_oam.2.w                                                              ; $01D653 | |
    JMP _menu_erase_cursor_direct                                               ; $01D656 |/
+   LDA <r_menu_joypad_repeat.lo                                                ; $01D659 |\
    AND #JOYPAD_L_A.b                                                           ; $01D65B | | If the A button is pressed, call the routine to handle the
    BEQ +                                                                       ; $01D65D | | selection of the second item.
    JSR _menu_spoils_exchange_second_item                                       ; $01D65F |/
+   LDA <r_menu_joypad_repeat.hi                                                ; $01D662 |\
    AND #JOYPAD_H_RIGHT.b                                                       ; $01D664 | | If right is pressed on the d-pad, toggle the X coordinate between
    BEQ +                                                                       ; $01D666 | | 0 and 1. If the result is 0, branch ahead to simulate a down
    LDA r_menu_spoils_upper_cursor_coordinates.x.w                              ; $01D668 | | press.
    INC A                                                                       ; $01D66B | |
    AND #%00000001.b                                                            ; $01D66C | |
    STA r_menu_spoils_upper_cursor_coordinates.x.w                              ; $01D66E | |
    BEQ @down                                                                   ; $01D671 |/
+   LDA <r_menu_joypad_repeat.hi                                                ; $01D673 |\
    AND #JOYPAD_H_LEFT.b                                                        ; $01D675 | | If left is pressed on the d-pad, toggle the X coordinate between
    BEQ +                                                                       ; $01D677 | | 0 and 1. If the result is 1, branch ahead to simulate an up press.
    LDA r_menu_spoils_upper_cursor_coordinates.x.w                              ; $01D679 | |
    INC A                                                                       ; $01D67C | |
    AND #%00000001.b                                                            ; $01D67D | |
    STA r_menu_spoils_upper_cursor_coordinates.x.w                              ; $01D67F | |
    BNE ++                                                                      ; $01D682 |/
+   LDA <r_menu_joypad_repeat.hi                                                ; $01D684 |\
    AND #JOYPAD_H_UP.b                                                          ; $01D686 | | If up is pressed on the d-pad, decrement the Y coordinate. If the
    BEQ +                                                                       ; $01D688 | | result is positive, store the result.
++  LDA r_menu_spoils_upper_cursor_coordinates.y.w                              ; $01D68A | |
    DEC A                                                                       ; $01D68D | |
    BMI +                                                                       ; $01D68E | |
    STA r_menu_spoils_upper_cursor_coordinates.y.w                              ; $01D690 |/
+   LDA <r_menu_joypad_repeat.hi                                                ; $01D693 |\
    AND #JOYPAD_H_DOWN.b                                                        ; $01D695 | | If down is not pressed on the d-pad, branch to the next loop.
    BEQ +                                                                       ; $01D697 |/
@down:
    LDA r_menu_spoils_upper_cursor_coordinates.w                                ; $01D699 |\
    INC A                                                                       ; $01D69C | | Increment the Y coordinate. If the result is less than 4, store
    CMP #4.b                                                                    ; $01D69D | | the result.
    BEQ +                                                                       ; $01D69F | |
    STA r_menu_spoils_upper_cursor_coordinates.w                                ; $01D6A1 |/
+   JMP @loop_start                                                             ; $01D6A4

; _menu_spoils_exchange_second_item ($01:D6A7)
;
; Handler for the second part of the exchange portion of the spoils menu.
; Specifically, after one item has been selected, and the player is prompted to
; select another item from the main inventory.
_menu_spoils_exchange_second_item:
    LDA r_menu_spoils_lower_cursor_coordinates.y.w                              ; $01D6A7 |\
    ASL A                                                                       ; $01D6AA | | Set the pixel Y coordinate to 134 plus the cursor Y coordinate
    ASL A                                                                       ; $01D6AB | | times 16.
    ASL A                                                                       ; $01D6AC | |
    ASL A                                                                       ; $01D6AD | |
    ADC #134.b                                                                  ; $01D6AE | |
    STA <r_menu_generic_tmp_word.hi                                             ; $01D6B0 |/
    LDA r_menu_spoils_lower_cursor_coordinates.x.w                              ; $01D6B2 |\
    BEQ +                                                                       ; $01D6B5 | | Set the pixel X coordinate to 0 if the first column is selected
    LDA #112.b                                                                  ; $01D6B7 | | and 112 otherwise.
    BRA ++                                                                      ; $01D6B9 | |
+   LDA #0.b                                                                    ; $01D6BB | |
++  STA <r_menu_generic_tmp_word.lo                                             ; $01D6BD |/
    JSR _menu_draw_cursor_1                                                     ; $01D6BF | Draw the first cursor. NOTE: This overwrites the command cursor.
    JSR _menu_wait_for_vblank_copy_oam_to_ppu                                   ; $01D6C2 | Wait for vblank and copy the OAM to the PPU.
    JSR _menu_update_joypad_and_play_sound_effect                               ; $01D6C5 | Update the joypad values and play a sound effect if appropriate.
@check_input:
    LDA <r_menu_joypad_repeat.hi                                                ; $01D6C8 |\
    AND #JOYPAD_H_B.b                                                           ; $01D6CA | | If the B button is pressed, erase the first cursor and return.
    BEQ +                                                                       ; $01D6CC | | BUG: This does not restore the command cursor.
    JMP _menu_erase_cursor_1                                                    ; $01D6CE |/
+   LDA <r_menu_joypad_repeat.lo                                                ; $01D6D1 |\
    AND #JOYPAD_L_A.b                                                           ; $01D6D3 | | If the A button is pressed, erase the first cursor and attempt to
    BEQ +                                                                       ; $01D6D5 | | exchange the two selected items. Return afterward.
    JSR _menu_erase_cursor_1                                                    ; $01D6D7 | |
    JMP _menu_spoils_exchange_item                                              ; $01D6DA |/
+   LDA <r_menu_joypad_repeat.hi                                                ; $01D6DD |\
    AND #JOYPAD_H_RIGHT.b                                                       ; $01D6DF | | If the right button is pressed on the d-pad, increment the X
    BEQ +                                                                       ; $01D6E1 | | coordinate, and take the result mod 2. If the result is zero,
    LDA r_menu_spoils_lower_cursor_coordinates.x.w                              ; $01D6E3 | | branch to simulate a down press.
    INC A                                                                       ; $01D6E6 | |
    AND #%00000001.b                                                            ; $01D6E7 | |
    STA r_menu_spoils_lower_cursor_coordinates.x.w                              ; $01D6E9 | |
    BEQ @down                                                                   ; $01D6EC |/
+   LDA <r_menu_joypad_repeat.hi                                                ; $01D6EE |\
    AND #JOYPAD_H_LEFT.b                                                        ; $01D6F0 | | If the left button is pressed on the d-pad, increment the X
    BEQ +                                                                       ; $01D6F2 | | coordinate and take the result mod 2. If the result is 1, branch
    LDA r_menu_spoils_lower_cursor_coordinates.x.w                              ; $01D6F4 | | ahead to simulate an up press.
    INC A                                                                       ; $01D6F7 | |
    AND #%00000001.b                                                            ; $01D6F8 | |
    STA r_menu_spoils_lower_cursor_coordinates.x.w                              ; $01D6FA | |
    BNE ++                                                                      ; $01D6FD |/
+   LDA <r_menu_joypad_repeat.hi                                                ; $01D6FF |\
    AND #JOYPAD_H_UP.b                                                          ; $01D701 | | If up is not pressed on the d-pad, branch ahead to check down.
    BEQ @check_down                                                             ; $01D703 |/
++  LDA r_menu_spoils_lower_cursor_coordinates.y.w                              ; $01D705 |\
    DEC A                                                                       ; $01D708 | | Decrement the cursor Y coordinate, and if it's still positive,
    BPL +                                                                       ; $01D709 |/  branch to store the result.
    LDA r_menu_spoils_lower_cursor_first_row.w                                  ; $01D70B |\
    DEC A                                                                       ; $01D70E | | Decrement the first row. If the result is negative, branch to
    BMI @check_down                                                             ; $01D70F | | check down, as there's no further to go up. Otherwise, store the
    STA r_menu_spoils_lower_cursor_first_row.w                                  ; $01D711 |/  result.
    LDA #8.b                                                                    ; $01D714 |\
-   REP #FLAG_P_ACCUMULATOR                                                     ; $01D716 | | Decrement the BG3 vertical scroll register by two each frame until
    DEC <r_menu_scroll_bg3.vertical.value                                       ; $01D718 | | a total of 16 pixels have been scrolled.
    DEC <r_menu_scroll_bg3.vertical.value                                       ; $01D71A | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01D71C | |
    JSR _menu_set_bg_scroll_proxy_vblank                                        ; $01D71E | |
    DEC A                                                                       ; $01D721 | |
    BNE -                                                                       ; $01D722 |/
    JSR _menu_update_joypad_and_play_sound_effect                               ; $01D724 | Update the joypad and play a sound effect if appropriate.
    LDX <r_menu_joypad_pressed                                                  ; $01D727 |\ Copy the pressed joypad values into the repeat joypad values to
    STX <r_menu_joypad_repeat                                                   ; $01D729 |/ immediately recheck input.
    BRA @check_input                                                            ; $01D72B | Branch to check input again.
+   STA r_menu_spoils_lower_cursor_coordinates.y.w                              ; $01D72D | If the new coordinate was positive, store the result.
@check_down:
    LDA <r_menu_joypad_repeat.hi                                                ; $01D730 |\
    AND #JOYPAD_H_DOWN.b                                                        ; $01D732 | | If down is not pressed, branch to repeat the loop.
    BEQ @next                                                                   ; $01D734 |/
@down:
    LDA r_menu_spoils_lower_cursor_coordinates.y.w                              ; $01D736 |\
    INC A                                                                       ; $01D739 | | Increment the Y coordinate, and if it isn't 5, branch ahead to
    CMP #5.b                                                                    ; $01D73A | | store the updated value.
    BNE +                                                                       ; $01D73C |/
    LDA r_menu_spoils_lower_cursor_first_row.w                                  ; $01D73E |\
    INC A                                                                       ; $01D741 | | Increment the first row value, and if it reaches 20, branch to
    CMP #20.b                                                                   ; $01D742 | | the next loop, since there's no further to go down. Othewrise,
    BEQ @next                                                                   ; $01D744 | | store the updated value.
    STA r_menu_spoils_lower_cursor_first_row.w                                  ; $01D746 |/
    LDA #8.b                                                                    ; $01D749 |\
-   REP #FLAG_P_ACCUMULATOR                                                     ; $01D74B | | Increment the BG3 vertical scroll value by two pixels per frame
    INC <r_menu_scroll_bg3.vertical.value                                       ; $01D74D | | until 16 pixels have been scrolled.
    INC <r_menu_scroll_bg3.vertical.value                                       ; $01D74F | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01D751 | |
    JSR _menu_set_bg_scroll_proxy_vblank                                        ; $01D753 | |
    DEC A                                                                       ; $01D756 | |
    BNE -                                                                       ; $01D757 |/
    JSR _menu_update_joypad_and_play_sound_effect                               ; $01D759 | Update the joypad and play a sound effect if appropriate.
    LDX <r_menu_joypad_pressed                                                  ; $01D75C |\ Copy the pressed joypad values into the repeat joypad values to
    STX <r_menu_joypad_repeat                                                   ; $01D75E |/ immediately consider any pressed buttons.
    JMP @check_input                                                            ; $01D760 | Jump to immediately recheck input.
+   STA r_menu_spoils_lower_cursor_coordinates.y.w                              ; $01D763 | Store the updated Y coordinate if updated.
@next:
    JMP _menu_spoils_exchange_second_item                                       ; $01D766 | Jump to the beginning of the routine.

; _menu_spoils_exchange_item ($01:D769)
;
; In the spoils menu, handles exchanging the two items at the current
; coordinates.
_menu_spoils_exchange_item:
    LDA r_menu_spoils_upper_cursor_coordinates.y.w                              ; $01D769 |\
    ASL A                                                                       ; $01D76C | | Set the X register to the selected index in the spoils inventory
    ADC r_menu_spoils_upper_cursor_coordinates.x.w                              ; $01D76D | | by multiplying the Y coordinate by two, adding the X coordinate,
    ASL A                                                                       ; $01D770 | | and multiplying by two again.
    JSR _menu_transfer_a_to_x                                                   ; $01D771 |/
    LDA r_menu_spoils_lower_cursor_coordinates.y.w                              ; $01D774 |\
    CLC                                                                         ; $01D777 | | Set the Y register to the selected index in the main inventory by
    ADC r_menu_spoils_lower_cursor_first_row.w                                  ; $01D778 | | adding the Y coordinate and the first row, multiplying by two,
    ASL A                                                                       ; $01D77B | | adding the X coordinate, and multiplying by two again.
    ADC r_menu_spoils_lower_cursor_coordinates.x.w                              ; $01D77C | |
    ASL A                                                                       ; $01D77F | |
    STA <r_menu_generic_tmp_offset.lo                                           ; $01D780 | |
    LDY <r_menu_generic_tmp_offset                                              ; $01D782 |/
    LDA r_inventory.1.id.w,Y                                                    ; $01D784 |\
    CMP #ITEM_LEGEND.b                                                          ; $01D787 | | Skip doing anything if the selected item in the main inventory is
    BEQ ++                                                                      ; $01D789 | | the Legend, the Crystal or an unsellable key item.
    CMP #ITEM_CRYSTAL.b                                                         ; $01D78B | |
    BEQ ++                                                                      ; $01D78D | |
    CMP #ITEM_FIRST_UNSELLABLE_KEY_ITEM.b                                       ; $01D78F | |
    BCS ++                                                                      ; $01D791 |/
    LDA r_inventory.1.id.w,Y                                                    ; $01D793 |\
    CMP r_menu_spoils_inventory.1.id.w,X                                        ; $01D796 | | If the selected items in the two inventories are the same, attempt
    BNE +                                                                       ; $01D799 | | to add the counts together. If the result is less than 100, add
    LDA r_menu_spoils_inventory.1.count.w,X                                     ; $01D79B | | the spoils item into the main inventory. Otherwise, do nothing.
    CLC                                                                         ; $01D79E | | Either way, branch to the end.
    ADC r_inventory.1.count.w,Y                                                 ; $01D79F | |
    CMP #100.b                                                                  ; $01D7A2 | | NOTE: The Easytype version additionally zeroes out the id number
    BCS ++                                                                      ; $01D7A4 | |       to avoid leaving zero of that item in the spoils inventory.
    STA r_inventory.1.count.w,Y                                                 ; $01D7A6 | |
    STZ r_menu_spoils_inventory.1.count.w,X                                     ; $01D7A9 | |
.if FF4_VERSION == "JAPAN_EASYTYPE"                                             ;         | |
    STZ r_menu_spoils_inventory.1.id.w,X                                        ; $01D915 | |
.endif                                                                          ;         | |
    BRA ++                                                                      ; $01D7AC |/
+   REP #FLAG_P_ACCUMULATOR                                                     ; $01D7AE |\
    LDA r_inventory.w,Y                                                         ; $01D7B0 | | Otherwise, swap the two items and their counts.
    PHA                                                                         ; $01D7B3 | |
    LDA r_menu_spoils_inventory.w,X                                             ; $01D7B4 | |
    STA r_inventory.w,Y                                                         ; $01D7B7 | |
    PLA                                                                         ; $01D7BA | |
    STA r_menu_spoils_inventory.w,X                                             ; $01D7BB | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01D7BE |/
__menu_spoils_redraw_inventory:
++  JMP _menu_spoils_redraw_inventory                                           ; $01D7C0 | Jump to redraw the inventory and return.

; _unused_menu_spoils_reset_spoils_inventory_x ($01:D7C3)
;
; Given an offset to an item in the spoils inventory in the X register, resets
; that item by setting both its ID and count to zero.
_unused_menu_spoils_reset_spoils_inventory_x:
    REP #FLAG_P_ACCUMULATOR                                                     ; $01D7C3 |\
    LDA <r_menu_zero                                                            ; $01D7C5 | | Store a zero in the ID and count for the item referenced by the X
    STA r_menu_spoils_inventory.w,X                                             ; $01D7C7 | | register.
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01D7CA |/
    BRA __menu_spoils_redraw_inventory                                          ; $01D7CC | Branch to redraw the inventory.

; _menu_spoils_check_for_key_items ($01:D7CE)
;
; In the spoils menu, validates that the spoils inventory has no key items. If
; none are found, clears the carry flag and returns. Otherwise, displays a
; warning dialog, and falls through to the next routine which redraws the
; header and sets the carry flag.
_menu_spoils_check_for_key_items:
    LDX <r_menu_zero                                                            ; $01D7CE | Initialize the X register to zero.
-   LDA r_menu_spoils_inventory.1.id.w,X                                        ; $01D7D0 |\
    CMP #ITEM_LEGEND.b                                                          ; $01D7D3 | | Loop through the spoils inventory, hunting for any unsellable key
    BEQ +                                                                       ; $01D7D5 | | item or the Crystal or the Legend sword. If found, branch ahead.
    CMP #ITEM_CRYSTAL.b                                                         ; $01D7D7 | | If not found, clear the carry flag and return.
    BEQ +                                                                       ; $01D7D9 | |
    CMP #ITEM_FIRST_UNSELLABLE_KEY_ITEM.b                                       ; $01D7DB | |
    BCS +                                                                       ; $01D7DD | |
    INX                                                                         ; $01D7DF | |
    INX                                                                         ; $01D7E0 | |
    CPX #_sizeof_r_menu_spoils_inventory.w                                      ; $01D7E1 | |
    BNE -                                                                       ; $01D7E4 | |
    CLC                                                                         ; $01D7E6 | |
    RTS                                                                         ; $01D7E7 |/
+   JSR _menu_set_current_tilemap_bg2                                           ; $01D7E8 |\
    LDY #menu_window_important_items_remain_data.w                              ; $01D7EB | | Draw the untranslated "important items remain" dialog to BG2 and
    JSR _menu_draw_text_indirect_plus_window                                    ; $01D7EE | | copy it to VRAM.
    JSR _menu_copy_tilemap_to_vram_bg2                                          ; $01D7F1 |/
    JSR _play_sound_effect_error                                                ; $01D7F4 | Play the error sound effect.
    JSR _menu_wait_for_input                                                    ; $01D7F7 | Wait for input.
    JSR _menu_initialize_tilemap_bg2                                            ; $01D7FA | Initialize BG2 to clear the dialog box, then fall through.

; _menu_spoils_draw_title_and_commands ($01:D7FD)
;
; Draws the spoils menu title and commands. Expects the currently active
; background to be BG2. Sets the carry flag before returning, which is used in
; conjunction with the routine immediately preceding this one.
_menu_spoils_draw_title_and_commands:
    LDY #menu_window_spoils_command_data.w                                      ; $01D7FD |\ Draw the command menu window.
    JSR _menu_configure_and_draw_window                                         ; $01D800 |/
    LDY #menu_window_spoils_header_data.w                                       ; $01D803 |\ Draw the title window, the title text, and the command text.
    JSR _menu_draw_text_indirect_plus_window                                    ; $01D806 |/
    JSR _menu_copy_tilemap_to_vram_bg2                                          ; $01D809 | Copy the BG2 tilemap to VRAM.
    SEC                                                                         ; $01D80C | Set the carry flag.
    RTS                                                                         ; $01D80D

; menu_window_namingway_character_portrait_data ($01:D80E)
;
; For the Namingway menu, defines the tilemap offset and size for the window
; that displays the character portrait, when not using the Namingway layout.
menu_window_namingway_character_portrait_data:
    MENU_COORDINATES 7, 1                                                       ; $01D80E.D80F
    .db 4, 4                                                                    ; $01D810.D811

; menu_window_namingway_character_name_data ($01:D812)
;
; For the non-Namingway layout of the Namingway menu, defines the tilemap offset
; and size for the window that displays the character's name.
menu_window_namingway_character_name_data:
    MENU_COORDINATES 14, 1                                                      ; $01D812.D813
    .db 8, 4                                                                    ; $01D814.D815

; menu_window_namingway_character_sets_data ($01:D816)
;
; For the Namingway menu, defines the tilemap offset and size for the window
; that displays the available character sets.
menu_window_namingway_character_sets_data:
    MENU_COORDINATES 1, 8                                                       ; $01D816.D817
    .db 5, 17                                                                   ; $01D818.D819

; menu_window_namingway_characters_data ($01:D81A)
;
; Tilemap offset and size for the window in the Namingway menu that displays the
; characters available for using in a name.
menu_window_namingway_characters_data:
    MENU_COORDINATES 7, 8                                                       ; $01D81A.D81B
    .db 22, 17                                                                  ; $01D81C.D81D

; menu_window_party_details_data ($01:D81E)
;
; Tilemap offset and size for the window which contains the details of the
; current party, and is also used for the save/load screen.
menu_window_party_details_data:
    MENU_COORDINATES 0, 0                                                       ; $01D81E.D81F
    .db 22, 26                                                                  ; $01D820.D821

; menu_window_main_gp_data ($01:D822)
;
; Tilemap offset and size for the window which contains the party's GP total on
; the main menu.
menu_window_main_gp_data:
    MENU_COORDINATES 21, 23                                                     ; $01D822.D823
    .db 8, 3                                                                    ; $01D824.D825

; menu_window_main_time_data ($01:D826)
;
; Tilemap offset and size for the window that displays the game timer in the
; main menu.
menu_window_main_time_data:
    MENU_COORDINATES 22, 19                                                     ; $01D826.D827
    .db 7, 2                                                                    ; $01D828.D829

; menu_window_main_command_data ($01:D82A)
;
; Tilemap offset and size for the window that displays the commands available on
; the main menu. In addition, has the coordinates and text for all of the
; commands. The final command, "Save", has its own label as well, but also
; serves as part of this table.
menu_window_main_command_data:
    MENU_COORDINATES 22, 0                                                      ; $01D82A.D82B
    .db 7, 17                                                                   ; $01D82C.D82D
    MENU_COORDINATES 24, 1                                                      ; $01D82E.D82F
.if FF4_REGION == "JAPAN"
    .db $CA, $CB, $DC, $EA, 1                                                   ; $01DB73.DB77 | 
.else
    .asc "Item", 1                                                              ; $01D830.D834
.endif
    MENU_COORDINATES 24, 3                                                      ; $01D835.D836
.if FF4_REGION == "JAPAN"
    .db $A8, $A7, $8C, $FF, 1                                                   ; $01DB7A.DB7E | 
.else
    .asc "Magic", 1                                                             ; $01D837.D83C
.endif
    MENU_COORDINATES 24, 5                                                      ; $01D83D.D83E
.if FF4_REGION == "JAPAN"
    .db $98, $8C, $20, $FF, 1                                                   ; $01DB81.DB85 | 
.else
    .asc "Equip", 1                                                             ; $01D83F.D844
.endif
    MENU_COORDINATES 24, 7                                                      ; $01D845.D846
.if FF4_REGION == "JAPAN"
    .db $D6, $DC, $C2, $D9, $D6, 1                                              ; $01DB88.DB8D | 
.else
    .asc "Status", 1                                                            ; $01D847.D84D
.endif
    MENU_COORDINATES 24, 9                                                      ; $01D84E.D84F
.if FF4_REGION == "JAPAN"
    .db $9E, $B0, $20, $8F, $8D, 1                                              ; $01DB90.DB95 | 
.else
    .asc "Form", 1                                                              ; $01D850.D854
.endif
    MENU_COORDINATES 24, 11                                                     ; $01D855.D856
.if FF4_REGION == "JAPAN"
    .db $99, $8B, $92, $8B, 1                                                   ; $01DB98.DB9C | 
.else
    .asc "Change", 1                                                            ; $01D857.D85D
.endif
    MENU_COORDINATES 24, 13                                                     ; $01D85E.D85F
.if FF4_REGION == "JAPAN"
    .db $D3, $F6, $E5, $B8, $2B, 1                                              ; $01DB9F.DBA4 | 
.else
    .asc "Custom", 1                                                            ; $01D860.D866
.endif
    MENU_COORDINATES 24, 15                                                     ; $01D867.D868

; menu_text_save_data ($01:D869)
;
; Contains the "Save" text drawn to each save slot on the save menu.
menu_text_save_data:
.if FF4_REGION == "JAPAN"
    .db $D7, $C2, $3A, 0                                                        ; $01DBA7.DBAB | 
.else
    .asc "Save", 0                                                              ; $01D869.D86D
.endif

; menu_text_magic_title_data ($01:D86E)
;
; Coordinates and text to display Magic at 24, 3.
menu_text_magic_title_data:
    MENU_COORDINATES 24, 3                                                      ; $01D86E.D86F
.if FF4_REGION == "JAPAN"
    .db $A8, $A7, $8C, $FF, 0                                                   ; $01DBAD.DBB1 | 
.else
    .asc "Magic", 0                                                             ; $01D870.D875
.endif

; menu_text_swoon_data ($01:D876)
;
; Text for the Swoon text used in place of a character's class in the menu.
menu_text_swoon_data:
.if FF4_REGION == "JAPAN"
    .db $97, $B6, $9D, $8C, $A5, $A2, $8C, 0                                    ; $01DBB2.DBB9 | 
.else
    .asc "Swoon", 0                                                             ; $01D876.D87B
.endif

; menu_namingway_character_sets_data ($01:D87C)
;
; Defines the characters available in each character set in the Namingway
; screen. Note that there is only one character set in this version of the game:
; the "ABC" character set. The Japanese version also has hiragana and katakana.
menu_namingway_character_sets_data:
.if FF4_REGION == "JAPAN"
    .db $8A, $8B, $8C, $8D, $8E, $B0, $B1, $B2, $B3, $B4                        ; $01DBBA.DBC3 |  
    .db $8F, $90, $91, $92, $93, $10, $11, $12, $13, $14                        ; $01DBC4.DBCD |  
    .db $94, $95, $96, $97, $98, $15, $16, $17, $18, $19                        ; $01DBCE.DBD7 |  
    .db $99, $9A, $9B, $9C, $9D, $1A, $1B, $1C, $1D, $1E                        ; $01DBD8.DBE1 |  
    .db $9E, $9F, $A0, $A1, $A2, $1F, $20, $21, $22, $23                        ; $01DBE2.DBEB |  
    .db $A3, $A4, $A5, $A6, $A7, $24, $25, $26, $27, $28                        ; $01DBEC.DBF5 |  
    .db $A8, $A9, $AA, $AB, $AC, $7B, $7C, $7D, $7E, $7F                        ; $01DBF6.DBFF |  
    .db $AD, $AE, $AF, $B5, $B6, $00, $00, $00, $00, $00                        ; $01DC00.DC09 | 

    .db $CA, $CB, $CC, $CD, $CE, $F0, $F1, $F2, $F3, $F4                        ; $01DC0A.DC13 |  
    .db $CF, $D0, $D1, $D2, $D3, $29, $2A, $2B, $2C, $2D                        ; $01DC14.DC1D |  
    .db $D4, $D5, $D6, $D7, $D8, $2E, $2F, $30, $31, $32                        ; $01DC1E.DC27 |  
    .db $D9, $DA, $DB, $DC, $DD, $33, $34, $35, $36, $37                        ; $01DC28.DC31 |  
    .db $DE, $DF, $E0, $E1, $E2, $38, $39, $3A, $3B, $3C                        ; $01DC32.DC3B |  
    .db $E3, $E4, $E5, $E6, $E7, $3D, $3E, $3F, $40, $41                        ; $01DC3C.DC45 |  
    .db $E8, $E9, $EA, $EB, $EC, $B7, $B8, $BA, $BB, $BC                        ; $01DC46.DC4F |  
    .db $ED, $EE, $EF, $F5, $F6, $BD, $BE, $BF, $0F, $00                        ; $01DC50.DC59 |  
.endif

    .asc "ABCDE", "abcde"                                                       ; $01D87C.D885
    .asc "FGHIJ", "fghij"                                                       ; $01D886.D88F
    .asc "KLMNO", "klmno"                                                       ; $01D890.D899
    .asc "PQRST", "pqrst"                                                       ; $01D89A.D8A3
    .asc "UVWXY", "uvwxy"                                                       ; $01D8A4.D8AD
    .asc "Z0123", "z!?%/"                                                       ; $01D8AE.D8B7
    .asc "45678", ":", 0, 0, 0, 0                                               ; $01D8B8.D8C1
.if FF4_REGION == "JAPAN"
    .db $89, $B9, $C9, $C2, $C3, $00, $00, $00, $00, $00                        ; $01DCA0.DCA9
.else
    .asc "9'.-", $C3, 0, 0, 0, 0, 0                                             ; $01D8C2.D8CB
.endif

; menu_namingway_character_set_index_cursor_y_coordinate_data ($01:D8CC)
;
; For each possible character set index in the Namingway menu, determines the Y
; coordinate of the cursor when that index is selected.
menu_namingway_character_set_index_cursor_y_coordinate_data:
.if FF4_REGION == "JAPAN"
    .db  77                                                                     ; $01DBAA | $00: 
    .db  93                                                                     ; $01DBAB | $01: 
    .db 109                                                                     ; $01DBAC | $02: ABC
    .db 189                                                                     ; $01DBAD | $03: END
.else
    .db  77                                                                     ; $01D8CC | $00: ABC
    .db 189                                                                     ; $01D8CD | $01: END
.endif

; menu_text_namingway_character_sets_data ($01:D8CE)
;
; For the Namingway menu, contains the coordinates and text to display to
; display the available character sets (only "ABC" in the US version) and the
; "END" option. The Japanese version additionally has hiragana and katakana
; available.
menu_text_namingway_character_sets_data:
.if FF4_REGION == "JAPAN"
    MENU_COORDINATES 3, 9                                                       ; $01DCAE.DCAF
    .db $A4, $B0, $10, $9E, 1                                                   ; $01DCB0.DCB4 | 
    MENU_COORDINATES 3, 11                                                      ; $01DCB5.DCB6
    .db $CF, $D9, $CF, $DE, 1                                                   ; $01DCB7.DCBB | 
    MENU_COORDINATES 3, 13                                                      ; $01DCBC.DCBD
    .asc "ABC", 1                                                               ; $01DCBE.DCC1 | ABC
    MENU_COORDINATES 3, 23                                                      ; $01DCC2.DCC3
    .db $8E, $B5, $B1, 0                                                        ; $01DCC4.DCC7 | 
.else
    MENU_COORDINATES 3, 9                                                       ; $01D8CE.D8CF
    .asc "ABC", 1                                                               ; $01D8D0.D8D3
    MENU_COORDINATES 3, 23                                                      ; $01D8D4.D8D5
    .asc "END", 0                                                               ; $01D8D6.D8D9
.endif

; menu_namingway_character_sets_offset_data ($01:D8DA)
;
; For each character set index, determines the offset to the actual character
; set data. Note that only the first is used in this version of the game.
menu_namingway_character_sets_offset_data:
    .dw $0000                                                                   ; $01D8DA.D8DB | $00: ABC
    .dw $0050                                                                   ; $01D8DC.D8DD | $01: <unused>
    .dw $00A0                                                                   ; $01D8DE.D8DF | $02: <unused>

; menu_window_sell_inventory_data ($01:D8E0)
;
; Tilemap offset and size of the shop window that displays the shop inventory
; when making a purchase.
menu_window_sell_inventory_data:
    MENU_COORDINATES 1, 0                                                       ; $01D8E0.D8E1
    .db 27, 48                                                                  ; $01D8E2.D8E3

; menu_window_item_title_right_data ($01:D8E4)
;
; Tilemap offset and size for a window that is the same size as the item title
; window, but appears on the right side of the screen. Used as part of the
; transition while opening the item menu.
menu_window_item_title_right_data:
    MENU_COORDINATES 22, 0                                                      ; $01D8E4.D8E5
    .db 7, 3                                                                    ; $01D8E6.D8E7

; menu_window_item_description_data ($01:D8E8)
;
; Tilemap offset and size for the window that displays a description of the
; selected item in the item menu.
menu_window_item_description_data:
    MENU_COORDINATES 9, 0                                                       ; $01D8E8.D8E9
    .db 19, 3                                                                   ; $01D8EA.D8EB

; menu_window_item_message_data ($01:D8EC)
;
; Tilemap offset and size for the window displayed while using an item that
; gives a message to the player.
menu_window_item_message_data:
    MENU_COORDINATES 8, 10                                                      ; $01D8EC.D8ED
    .db 13, 2                                                                   ; $01D8EE.D8EF

; menu_text_item_message_no_need_data ($01:D8F0)
;
; "No need!" text that appears when attempting to use a Life potion on a living
; character.
menu_text_item_message_no_need_data:
.if FF4_REGION == "JAPAN"
    MENU_COORDINATES 9, 11                                                      ; $01DCDE.DCDF
    .db $98, $A2, $A4, $9B, $AF, $8C, $A3, $FF, $8A, $B1, $A8, $97, $B6, 0      ; $01DCE0.DCED |  
.else
    MENU_COORDINATES 12, 11                                                     ; $01D8F0.D8F1
    .asc "No need!", 0                                                          ; $01D8F2.D8FA
.endif

; menu_text_item_message_failed_data ($01:D8FB)
;
; "Failed......" text that appears when attempting to use a Cure potion on a
; swooned character.
menu_text_item_message_failed_data:
    MENU_COORDINATES 9, 11                                                      ; $01D8FB.D8FC
.if FF4_REGION == "JAPAN"
    .db $8C, $A8, $91, $8B, $8F, $9E, $8B, $AF, $8C, $1D, $96, 0                ; $01DCF0.DCFB | 
.else
    .asc "Failed", $C3, $C3, 0                                                  ; $01D8FD.D905
.endif

; menu_window_item_title_data ($01:D906)
;
; Tilemap offset, size and "Item" text for the title window displayed in the
; item menu.
menu_window_item_title_data:
    MENU_COORDINATES 1, 0                                                       ; $01D906.D907
    .db 7, 3                                                                    ; $01D908.D909
menu_text_item_data:
    MENU_COORDINATES 3, 1                                                       ; $01D90A.D90B
.if FF4_REGION == "JAPAN"
    .db $CA, $CB, $DC, $EA, 0                                                   ; $01DD02.DD05 | 
.else
    .asc "Item", 0                                                              ; $01D90C.D910
.endif

DATA_01D911:
    MENU_COORDINATES 10, 1                                                      ; $01D911.D912
.if FF4_REGION == "JAPAN"
    .db $49, $51, $7B, $8F, $8B, $A5, $91, $95, $A8, $96, 0                     ; $01DD09.DD13 | HP
.else
    .asc "Recover HP.", 0                                                       ; $01D913.D91E
.endif

; menu_text_item_whom_data ($01:D91F)
;
; "Whom?" text displayed in the item description window when using an item.
menu_text_item_whom_data:
    MENU_COORDINATES 10, 1                                                      ; $01D91F.D920
.if FF4_REGION == "JAPAN"
    .db $1A, $B3, $9F, $9B, $8F, $8B, $A8, $96, $8F, 0                          ; $01DD16.DD1F | 
.else
    .asc "Whom?", 0                                                             ; $01D921.D926
.endif

; menu_text_cannot_use_here_data ($01:D927)
;
; "Cannot use here" text displayed when attempting to use an item incorrectly.
menu_text_cannot_use_here_data:
    MENU_COORDINATES 10, 1                                                      ; $01D927.D928
.if FF4_REGION == "JAPAN"
    .db $93, $93, $1D, $A3, $9B, $8F, $8D, $A8, $97, $B6, 0                     ; $01DD22.DD2C | 
.else
    .asc "Cannot use here.", 0                                                  ; $01D929.D939
.endif

; menu_text_nothing_here_data ($01:D93A)
;
; Text displayed when the player selects an empty location in the inventory.
menu_text_nothing_here_data:
    MENU_COORDINATES 10, 1                                                      ; $01D93A.D93B
.if FF4_REGION == "JAPAN"
    .db $9E, $9F, $AC, $8A, $B1, $A8, $97, $B6, 0                               ; $01DD2F.DD37 | 
.else
    .asc "Nothing here.", 0                                                     ; $01D93C.D949
.endif

; menu_window_item_target_left_data ($01:D94A)
;
; Tilemap offset and size for the window which displays target choices when
; using an item. This version is on the left side of the screen.
menu_window_item_target_left_data:
    MENU_COORDINATES 1, 5                                                       ; $01D94A.D94B
    .db 14, 21                                                                  ; $01D94C.D94D

; menu_window_item_target_right_data ($01:D94E)
;
; Tilemap offset and size for the window which displays target choices when
; using an item. This version is on the right side of the screen.
menu_window_item_target_right_data:
    MENU_COORDINATES 14, 5                                                      ; $01D94E.D94F
    .db 14, 21                                                                  ; $01D950.D951

; menu_window_magic_cannot_use_data ($01:D952)
;
; Tilemap offset, size and text for the window displayed when attempting to
; access the magic menu for a character that cannot use magic.
menu_window_magic_cannot_use_data:
    MENU_COORDINATES 8, 8                                                       ; $01D952.D953
    .db 10, 3                                                                   ; $01D954.D955
    MENU_COORDINATES 9, 9                                                       ; $01D956.D957
.if FF4_REGION == "JAPAN"
    .db $A8, $A7, $8C, $A3, $9B, $8F, $8D, $A8, $97, $B6, 0                     ; $01DD46.DD50 | 
.else
    .asc "Cannot Use", 0                                                        ; $01D958.D962
.endif

; menu_window_magic_list_data ($01:D963)
;
; Tilemap offset and coordinates for the window that displays the spells in the
; magic menu.
menu_window_magic_list_data:
    MENU_COORDINATES 1, 8                                                       ; $01D963.D964
    .db 28, 17                                                                  ; $01D965.D966

; menu_window_magic_character_details_position_0_data ($01:D967)
;
; Tilemap offset and position for the character details for position 0 in the
; magic menu.
menu_window_magic_character_details_position_0_data:
    MENU_COORDINATES 1, 0                                                       ; $01D967.D968
    .db 19, 7                                                                   ; $01D969.D96A

; menu_window_magic_character_details_position_1_data ($01:D96B)
;
; Tilemap offset and position for the character details for position 0 in the
; magic menu.
menu_window_magic_character_details_position_1_data
    MENU_COORDINATES 1, 5                                                       ; $01D96B.D96C
    .db 19, 7                                                                   ; $01D96D.D96E

; menu_window_magic_character_details_position_2_data ($01:D96F)
;
; Tilemap offset and position for the character details for position 0 in the
; magic menu.
menu_window_magic_character_details_position_2_data
    MENU_COORDINATES 1, 10                                                      ; $01D96F.D970
    .db 19, 7                                                                   ; $01D971.D972

; menu_window_magic_character_details_position_3_data ($01:D973)
;
; Tilemap offset and position for the character details for position 0 in the
; magic menu.
menu_window_magic_character_details_position_3_data
    MENU_COORDINATES 1, 15                                                      ; $01D973.D974
    .db 19, 7                                                                   ; $01D975.D976

; menu_window_magic_character_details_position_4_data ($01:D977)
;
; Tilemap offset and position for the character details for position 0 in the
; magic menu.
menu_window_magic_character_details_position_4_data
    MENU_COORDINATES 1, 20                                                      ; $01D977.D978
    .db 19, 7                                                                   ; $01D979.D97A

; menu_window_magic_spell_list_selection_data ($01:D97B)
;
; Tilemap offset and size for the window that allows the player to select a
; spell list in the magic menu.
menu_window_magic_spell_list_selection_data:
    MENU_COORDINATES 22, 2                                                      ; $01D97B.D97C
    .db 7, 7                                                                    ; $01D97D.D97E

; menu_window_magic_target_selection_data ($01:D97F)
;
; Tilemap offset and size for the target selection window in the magic menu.
menu_window_magic_target_selection_data:
    MENU_COORDINATES 8, 0                                                       ; $01D97F.D980
    .db 21, 26                                                                  ; $01D981.D982

; menu_window_magic_whom_data ($01:D983)
;
; Tilemap offset and size for the window that displays the "Whom?" text in the
; magic menu.
menu_window_magic_whom_data:
    MENU_COORDINATES 1, 8                                                       ; $01D983.D984
    .db 7, 3                                                                    ; $01D985.D986

; menu_window_magic_details_data ($01:D987)
;
; Tilemap offset and size for the window for displaying the spell details when
; choosing a target in the magic menu.
menu_window_magic_details_data:
    MENU_COORDINATES 1, 0                                                       ; $01D987.D988
    .db 7, 7                                                                    ; $01D989.D98A

; menu_text_need_mp_data ($01:D98B)
;
; Text for the "Need MP" text in the magic menu. The _direct variant allows the
; caller to specify the coordinates directly.
menu_text_need_mp_data:
.if FF4_REGION == "JAPAN"
    MENU_COORDINATES 3, 4                                                       ; $01DD79.DD7A
menu_text_need_mp_direct_data;
    .db $95, $7F, $8C, $A4, $4E, $51, 0                                         ; $01DD7B.DD81 | MP
.else
    MENU_COORDINATES 2, 4                                                       ; $01D98B.D98C
menu_text_need_mp_direct_data:
    .asc "Need MP", 0                                                           ; $01D98D.D994
.endif

; menu_text_magic_whom_data ($01:D995)
;
; "Whom?" text displayed when choosing a target in the magic menu.
menu_text_magic_whom_data:
    MENU_COORDINATES 3, 10                                                      ; $01D995.D996
.if FF4_REGION == "JAPAN"
    .db $1A, $B3, $9F, $FF, $C4, $C5, 0                                         ; $01DD84.DD8A |  
.else
    .asc "Whom?", 0                                                             ; $01D997.D99C
.endif

; menu_window_equip_character_stats_position_offset_data ($01:D99D)
;
; For each character position, gives the offset to the window description for
; the transitional stats window for that position.
menu_window_equip_character_stats_position_offset_data:
    .addr menu_window_equip_character_stats_position_0_data                     ; $01D99D.D99E
    .addr menu_window_equip_character_stats_position_1_data                     ; $01D99F.D9A0
    .addr menu_window_equip_character_stats_position_2_data                     ; $01D9A1.D9A2
    .addr menu_window_equip_character_stats_position_3_data                     ; $01D9A3.D9A4
    .addr menu_window_equip_character_stats_position_4_data                     ; $01D9A5.D9A6

; menu_window_equip_character_stats_position_0_data ($01:D9A7)
;
; Tilemap offset and size for the character stats window used as a transition
; target when transitioning to the equip menu.
menu_window_equip_character_stats_position_0_data:
    MENU_COORDINATES 1, 0                                                       ; $01D9A7.D9A8
    .db 27, 11                                                                  ; $01D9A9.D9AA

; menu_window_equip_character_stats_position_1_data ($01:D9AB)
;
; Tilemap offset and size for the character stats window used as a transition
; target when transitioning to the equip menu.
menu_window_equip_character_stats_position_1_data:
    MENU_COORDINATES 1, 5                                                       ; $01D9AB.D9AC
    .db 27, 11                                                                  ; $01D9AD.D9AE

; menu_window_equip_character_stats_position_2_data ($01:D9AF)
;
; Tilemap offset and size for the character stats window used as a transition
; target when transitioning to the equip menu.
menu_window_equip_character_stats_position_2_data:
    MENU_COORDINATES 1, 10                                                      ; $01D9AF.D9B0
    .db 27, 11                                                                  ; $01D9B1.D9B2

; menu_window_equip_character_stats_position_3_data ($01:D9B3)
;
; Tilemap offset and size for the character stats window used as a transition
; target when transitioning to the equip menu.
menu_window_equip_character_stats_position_3_data:
    MENU_COORDINATES 1, 15                                                      ; $01D9B3.D9B4
    .db 27, 11                                                                  ; $01D9B5.D9B6

; menu_window_equip_character_stats_position_4_data ($01:D9B7)
;
; Tilemap offset and size for the character stats window used as a transition
; target when transitioning to the equip menu.
menu_window_equip_character_stats_position_4_data:
    MENU_COORDINATES 1, 20                                                      ; $01D9B7.D9B8
    .db 27, 11                                                                  ; $01D9B9.D9BA

; menu_window_equip_equipment_data ($01:D9BB)
;
; Tilemap offsize, size and text for the window that displays the character's
; current equipment in the equip screen.
menu_window_equip_equipment_data:
    MENU_COORDINATES 1, 0                                                       ; $01D9BB.D9BC
    .db 27, 11                                                                  ; $01D9BD.D9BE
.if FF4_REGION == "JAPAN"
    MENU_COORDINATES 14, 1                                                      ; $01DDAD.DDAE
    .db $A9, $11, $9C, 1                                                        ; $01DDAF.DDB2 | 
    MENU_COORDINATES 14, 3                                                      ; $01DDB3.DDB4
    .db $A4, $1A, $B1, $9C, 1                                                   ; $01DDB5.DDB9 | 
    MENU_COORDINATES 14, 5                                                      ; $01DDBA.DDBB
    .db $8A, $99, $A8, 1                                                        ; $01DDBC.DDBF | 
    MENU_COORDINATES 14, 7                                                      ; $01DDC0.DDC1
    .db $8F, $B0, $1A, 1                                                        ; $01DDC2.DDC5 | 
    MENU_COORDINATES 14, 9                                                      ; $01DDC6.DDC7
    .db $8C, $1D, 0                                                             ; $01DDC8.DDCA | 
.else
    MENU_COORDINATES 13, 1                                                      ; $01D9BF.D9C0
    .asc "RHand", 1                                                             ; $01D9C1.D9C6
    MENU_COORDINATES 13, 3                                                      ; $01D9C7.D9C8
    .asc "LHand", 1                                                             ; $01D9C9.D9CE
    MENU_COORDINATES 13, 5                                                      ; $01D9CF.D9D0
    .asc "Head", 1                                                              ; $01D9D1.D9D5
    MENU_COORDINATES 13, 7                                                      ; $01D9D6.D9D7
    .asc "Body", 1                                                              ; $01D9D8.D9DC
    MENU_COORDINATES 13, 9                                                      ; $01D9DD.D9DE
    .asc "Arms", 0                                                              ; $01D9DF.D9E3
.endif

DATA_01D9E4:
    MENU_COORDINATES 4, 5                                                       ; $01D9E4.D9E5
.if FF4_REGION == "JAPAN"
    .db $AC, $9A, $AC, $A2, $10, $8B, $7C, $24, $8B, $1D, $96, 0                ; $01DDCD.DDD8 | 
.else
    .asc "Items full.", 0                                                       ; $01D9E6.D9F1
.endif

; menu_window_two_handed_error_data ($01:D9F2)
;
; Tilemap offset and size for the window that displays the error message when
; attempting to incorrectly equip a two handed weapon.
;
; BUG: This window suffers from a bug that results in it only displaying the
;      first line of the message. The zeroes that terminate the first two lines
;      should be replaced with ones instead. The bug only affects the USA
;      version.
menu_window_two_handed_error_data:
    MENU_COORDINATES 9, 14                                                      ; $01D9F2.D9F3
    .db 11, 6                                                                   ; $01D9F4.D9F5
    MENU_COORDINATES 10, 15                                                     ; $01D9F6.D9F7
.if FF4_REGION == "JAPAN"
    .db $FF, $B1, $7F, $8C, $9C, $1D, $FF, $9B, $8F, $8C, 1                     ; $01DDDF.DDE9 |  
.else
    .asc " To equip", 0                                                         ; $01D9F8.DA01
.endif
    MENU_COORDINATES 12, 17                                                     ; $01DA02.DA03
.if FF4_REGION == "JAPAN"
    .db $CA, $CB, $DC, $EA, $1D, $96, 1                                         ; $01DDEC.DDF2 | 
.else
    .asc "with both", 0                                                         ; $01DA04.DA0D
.endif
    MENU_COORDINATES 10, 19                                                     ; $01DA0E.DA0F
.if FF4_REGION == "JAPAN"
    .db $A7, $8F, $A3, $98, $8C, $20, $1D, $90, $A8, $97, $B6, 0                ; $01DDF5.DE00 | 
.else
    .asc "hands.", 0                                                            ; $01DA10.DA16
.endif

; menu_window_status_data ($01:DA17)
;
; Tilemap offset and size for the main status window in the menu.
menu_window_status_data:
    MENU_COORDINATES 0, 1                                                       ; $01DA17.DA18
    .db 29, 24                                                                  ; $01DA18.DA1A

; menu_window_status_portrait_title_data ($01:DA1B)
;
; Tilemap offset and size for the window in the status menu that displays the
; character's portrait and the title of the menu.
menu_window_status_portrait_title_data:
    MENU_COORDINATES 18, 6                                                      ; $01DA1B.DA1C
    .db 11, 4                                                                   ; $01DA1D.DA1E

; menu_text_status_title_data ($01:DA1F)
;
; Coordinates and text for the "Status" title in the status menu.
menu_text_status_title_data:
    MENU_COORDINATES 24, 7                                                      ; $01DA1F.DA20
.if FF4_REGION == "JAPAN"
    .db $D6, $DC, $C2, $D9, $D6, 0                                              ; $01DE0B.DE10 | 
.else
    .asc "Status", 0                                                            ; $01DA21.DA27
.endif

; menu_text_status_text_data ($01:DA28)
;
; Contains the tilemap offset and text for most of the static text that appears
; in the status menu.
menu_text_status_text_data:
.if FF4_REGION == "JAPAN"
    MENU_COORDINATES 10, 4                                                      ; $01DE11.DE12
    .db $F3, $3B, $F2, 1                                                        ; $01DE13.DE16 | 
    MENU_COORDINATES 17, 6                                                      ; $01DE17.DE18
    .db $92, $8B, $92, $B6, $9A, 1                                              ; $01DE19.DE1E | 
    MENU_COORDINATES 3, 8                                                       ; $01DE1F.DE20
    .asc "HP", 1                                                                ; $01DE21.DE23 | HP
    MENU_COORDINATES 3, 10                                                      ; $01DE24.DE25
    .asc "MP", 1                                                                ; $01DE26.DE28 | MP
    MENU_COORDINATES 2, 13                                                      ; $01DE29.DE2A
    .db $CA, $39, $F1, $DC, $B8, $C2, 1                                         ; $01DE2B.DE31 | 
    MENU_COORDINATES 3, 15                                                      ; $01DE32.DE33
    .db $9A, $8F, $B0, 1                                                        ; $01DE34.DE37 | 
    MENU_COORDINATES 3, 17                                                      ; $01DE38.DE39
    .db $96, $1F, $AD, $94, 1                                                   ; $01DE3A.DE3E | 
    MENU_COORDINATES 3, 19                                                      ; $01DE3F.DE40
    .db $99, $8B, $B1, $7F, $91, 1                                              ; $01DE41.DE46 | 
    MENU_COORDINATES 3, 21                                                      ; $01DE47.DE48
    .db $9A, $97, $8B, 1                                                        ; $01DE49.DE4C | 
    MENU_COORDINATES 3, 23                                                      ; $01DE4D.DE4E
    .db $97, $8B, $95, $B6, 1                                                   ; $01DE4F.DE53 | 
    MENU_COORDINATES 13, 13                                                     ; $01DE54.DE55
    .db $93, $8C, $13, $90, 1                                                   ; $01DE56.DE5A | 
    MENU_COORDINATES 13, 15                                                     ; $01DE5B.DE5C
    .db $AB, $8B, $9A, $7E, $8C, $B1, $9B, 1                                    ; $01DE5D.DE64 | 
    MENU_COORDINATES 13, 17                                                     ; $01DE65.DE66
    .db $23, $8C, $11, $7F, 1                                                   ; $01DE67.DE6B | 
    MENU_COORDINATES 13, 19                                                     ; $01DE6C.DE6D
    .db $8F, $8B, $A4, $B1, $9B, 1                                              ; $01DE6E.DE73 | 
    MENU_COORDINATES 13, 21                                                     ; $01DE74.DE75
    .db $A8, $A7, $8C, $23, $8C, $11, $7F, 1                                    ; $01DE76.DE7D | 
    MENU_COORDINATES 13, 23                                                     ; $01DE7E.DE7F
    .db $A8, $A7, $8C, $8F, $8B, $A4, $B1, $9B, 1                               ; $01DE80.DE88 | 
    MENU_COORDINATES 23, 13                                                     ; $01DE89.DE8A
    .db $8F, $8B, 1                                                             ; $01DE8B.DE8D | 
    MENU_COORDINATES 23, 17                                                     ; $01DE8E.DE8F
    .db $8F, $8B, 1                                                             ; $01DE90.DE92 | 
    MENU_COORDINATES 23, 21                                                     ; $01DE93.DE94
    .db $8F, $8B, 0                                                             ; $01DE95.DE97 | 
.else
    MENU_COORDINATES 11, 4                                                      ; $01DA28.DA29
    .asc "Lv.", 1                                                               ; $01DA2A.DA2D
    MENU_COORDINATES 17, 6                                                      ; $01DA2E.DA2F
    .asc "Exp.", 1                                                              ; $01DA30.DA34
    MENU_COORDINATES 3, 8                                                       ; $01DA35.DA36
    .asc "HP", 1                                                                ; $01DA37.DA39
    MENU_COORDINATES 3, 10                                                      ; $01DA3A.DA3B
    .asc "MP", 1                                                                ; $01DA3C.DA3E
    MENU_COORDINATES 2, 13                                                      ; $01DA3F.DA40
    .asc "Ability", 1                                                           ; $01DA41.DA48
    MENU_COORDINATES 3, 15                                                      ; $01DA49.DA4A
    .asc "Str.", 1                                                              ; $01DA4B.DA4F
    MENU_COORDINATES 3, 17                                                      ; $01DA50.DA51
    .asc "Agil.", 1                                                             ; $01DA52.DA57
    MENU_COORDINATES 3, 19                                                      ; $01DA58.DA59
    .asc "Vit.", 1                                                              ; $01DA5A.DA5E
    MENU_COORDINATES 3, 21                                                      ; $01DA5F.DA60
    .asc "Wis.", 1                                                              ; $01DA61.DA65
    MENU_COORDINATES 3, 23                                                      ; $01DA66.DA67
    .asc "Will", 1                                                              ; $01DA68.DA6C
    MENU_COORDINATES 13, 13                                                     ; $01DA6D.DA6E
    .asc "Attack", 1                                                            ; $01DA6F.DA75
    MENU_COORDINATES 13, 15                                                     ; $01DA76.DA77
    .asc "Attack%", 1                                                           ; $01DA78.DA7F
    MENU_COORDINATES 13, 17                                                     ; $01DA80.DA81
    .asc "Defence", 1                                                           ; $01DA82.DA89
    MENU_COORDINATES 13, 19                                                     ; $01DA8A.DA8B
    .asc "Defence%", 1                                                          ; $01DA8C.DA94
    MENU_COORDINATES 13, 21                                                     ; $01DA95.DA96
    .asc "Mag Def", 1                                                           ; $01DA97.DA9E
    MENU_COORDINATES 13, 23                                                     ; $01DA9F.DAA0
    .asc "Mag Def%", 1                                                          ; $01DAA1.DAA9
    MENU_COORDINATES 23, 13                                                     ; $01DAAA.DAAB
    .asc "x", 1                                                                 ; $01DAAC.DAAD
    MENU_COORDINATES 23, 17                                                     ; $01DAAE.DAAF
    .asc "x", 1                                                                 ; $01DAB0.DAB1
    MENU_COORDINATES 23, 21                                                     ; $01DAB2.DAB3
    .asc "x", 0                                                                 ; $01DAB4.DAB5
.endif

; menu_text_status_for_level_up_data ($01:DAB6)
;
; Coordinates and text for the "For level up" text that displays in the status
; menu.
menu_text_status_for_level_up_data:
    MENU_COORDINATES 17, 9                                                      ; $01DAB6.DAB7
.if FF4_REGION == "JAPAN"
    .db $9B, $11, $A2, $F3, $3B, $F2, $A8, $1D, $FF, $8A, $9D, 0                ; $01DE9A.DEA5 |  
.else
    .asc "For level up", 0                                                      ; $01DAB8
.endif

; menu_window_shop_gp_data ($01:DAC5)
;
; Tilemap offset and size of the shop window that displays the party's GP.
menu_window_shop_gp_data:
    MENU_COORDINATES 17, 4                                                      ; $01DAC5.DAC6
    .db 11, 3                                                                   ; $01DAC7.DAC8

; menu_window_shop_buy_sell_exit_data ($01:DAC9)
;
; Tilemap offset and size of the shop window that displays the Buy, Sell and
; Exit options.
menu_window_shop_buy_sell_exit_data:
    MENU_COORDINATES 1, 4                                                       ; $01DAC9.DACA
    .db 15, 3                                                                   ; $01DACB.DACC

; menu_window_shop_name_data ($01:DACD)
;
; Tilemap offset and size of the shop window that displays the name of the shop.
menu_window_shop_name_data:
    MENU_COORDINATES 1, 0                                                       ; $01DACD.DACE
    .db 6, 2                                                                    ; $01DACF.DAD0

; menu_window_shop_greeting_data ($01:DAD1)
;
; Tilemap offset and size of the shop window that displays the greeting from the
; shopkeeper.
menu_window_shop_greeting_data:
    MENU_COORDINATES 8, 0                                                       ; $01DAD1.DAD2
    .db 20, 2                                                                   ; $01DAD3.DAD4

; menu_window_buy_inventory_data ($01:DAD5)
;
; Tilemap offset and size of the shop window that displays the shop inventory
; when making a purchase.
menu_window_buy_inventory_data
    MENU_COORDINATES 1, 8                                                       ; $01DAD5.DAD6
    .db 20, 17                                                                  ; $01DAD7.DAD8

; menu_window_shop_character_sprites_data ($01:DAD9)
;
; Tilemap offset and size of the shop window that displays the character
; sprites.
menu_window_shop_character_sprites_data:
    MENU_COORDINATES 22, 8                                                      ; $01DAD9.DADA
    .db 7, 11                                                                   ; $01DADB.DADC

; shop_name_data ($01:DADD)
;
; Names of the three types of shop. Each entry is theoretically eight bytes, but
; the last value must be a zero, and there is only room in the window for six
; characters, regardless. For the Japanese version, each entry is four
; characters, followed by a terminating zero.
shop_name_data:
.if FF4_REGION == "JAPAN"
    .db $21, $90, $AD, $FF, 0                                                   ; $01DEBE.DEC2 | 
    .db $23, $8C, $12, $AD, 0                                                   ; $01DEC3.DEC7 | 
    .db $1E, $8C, $12, $AD, 0                                                   ; $01DEC8.DECC | 
.else
    .asc "Weapon", 0, 0                                                         ; $01DADD.DAE4
    .asc "Armor ", 0, 0                                                         ; $01DAE5.DAEC
    .asc "Item  ", 0, 0                                                         ; $01DAED.DAF4
.endif

; menu_text_shop_greeting_buy_sell_exit_data ($01:DAF5)
;
; Provides the target offsets and characters to draw the shop greeting and the
; Buy/Sell/Exit options to the shop windows.
menu_text_shop_greeting_buy_sell_exit_data:
.if FF4_REGION == "JAPAN"
    MENU_COORDINATES 10, 1                                                      ; $01DECD.DECE
    .db $8B, $B0, $7C, $95, $7D, $8B, $C4, $FF, $1E, $B6, $9E, $14, $AF, $8C    ; $01DECF.DEDC |  
    .db $92, $B6, $1D, $C5, 1                                                   ; $01DEDD.DEE1
    MENU_COORDINATES 4, 5                                                       ; $01DEE2.DEE3
    .db $8F, $8C, $FF, $FF, $FF, $8C, $B2, $FF, $FF, $FF, $1D, $B2, 0           ; $01DEE4.DEF0 |       
.else
    MENU_COORDINATES 10, 1                                                      ; $01DAF5.DAF6
    .asc "May I help you?", 1                                                   ; $01DAF7.DB06
    MENU_COORDINATES 3, 5                                                       ; $01DB07.DB08
    .asc "Buy  Sell Exit", 0                                                    ; $01DB09.DB17
.endif

; menu_text_shop_which_one_quantity_data ($01:DB18)
;
; Provides the target offsets and characters to draw the "Which one?" and
; quantity selection text to the shop windows. Some code references the quantity
; portion directly.
menu_text_shop_which_one_quantity_data:
.if FF4_REGION == "JAPAN"
    MENU_COORDINATES 10, 1                                                      ; $01DEF1.DEF2
    .db $1E, $B3, $9F, $8B, $99, $95, $A8, $95, $7F, $8C, $C5, 1                ; $01DEF3.DEFE | 
.else
    MENU_COORDINATES 10, 1                                                      ; $01DB18.DB19
    .asc "Which one?", 1                                                        ; $01DB1A.DB24
.endif
menu_text_shop_quantity_data:
.if FF4_REGION == "JAPAN"
    MENU_COORDINATES 3, 5                                                       ; $01DEFF.DF00
    .db $8B, $91, $9B, $C5, $FF, $FF, $FF, $81, 0                               ; $01DF01.DF09 |    1
.else
    MENU_COORDINATES 3, 5                                                       ; $01DB25.DB26
    .asc "Qty.   1", 0                                                          ; $01DB27.DB2F
.endif

; menu_text_shop_party_gp_data ($01:DB30)
;
; Provides the target offset and characters to draw the "GP" text appearing in
; the shop screen. The _text_only variant only contains the text, and does not
; set the coordinates.
menu_text_shop_party_gp_data:
    MENU_COORDINATES 27, 5                                                      ; $01DB30.DB31
menu_text_shop_party_gp_text_only_data:
.if FF4_REGION == "JAPAN"
    .db $2A, $F2, 0                                                             ; $01DF0C.DF0E | 
.else
    .asc "GP", 0                                                                ; $01DB32.DB34
.endif

; menu_window_shop_full_inventory_data ($01:DB35)
;
; Data to draw the window that displays the message telling the player that
; their inventory is full when trying to make a purchase.
menu_window_shop_full_inventory_data:
    MENU_COORDINATES 1, 10                                                      ; $01DB35.DB36
    .db 20, 4                                                                   ; $01DB37.DB38
.if FF4_REGION == "JAPAN"
    MENU_COORDINATES 2, 11                                                      ; $01DF13.DF14
    .db $8E, $90, $7D, $91, $94, $B6, $FF, $AC, $9A, $AC, $A2, $10, $2D, $DA    ; $01DF15.DF22 |  
    .db $BD, $2D, $DA, $BD, $1A, $AF, 1                                         ; $01DF23.DF29
    MENU_COORDINATES 2, 13                                                      ; $01DF2A.DF2B
    .db $97, $8B, $B1, $95, $9E, $8B, $9D, $FF, $A3, $8B, $B6, $9E, $8B, $AF, 0 ; $01DF2C.DF3A |  
.else
    MENU_COORDINATES 2, 11                                                      ; $01DB39.DB3A
    .asc "Your bag is full.", 1                                                 ; $01DB3B.DB4C
    MENU_COORDINATES 2, 13                                                      ; $01DB4D.DB4E
    .asc "Sort it out first!", 0                                                ; $01DB4F.DB61
.endif

; menu_window_shop_not_enough_gp_data ($01:DB62)
;
; Data to draw the window that displays the message telling the player that they
; don't have enough GP for the purchase they tried to make.
menu_window_shop_not_enough_gp_data:
    MENU_COORDINATES 5, 10                                                      ; $01DB62.DB63
    .db 16, 4                                                                   ; $01DB64.DB65
    MENU_COORDINATES 6, 11                                                      ; $01DB66.DB67
.if FF4_REGION == "JAPAN"
    .db $8E, $90, $7D, $91, $94, $B6, $FF, $8E, $8F, $A1, $10, $99, $B1, $9E    ; $01DF41.DF4E |  
    .db $8B, $AF, 1                                                             ; $01DF4F.DF51
.else
    .asc "Not enough GP!", 1                                                    ; $01DB68.DB76
.endif
    MENU_COORDINATES 6, 13                                                      ; $01DB77.DB78
.if FF4_REGION == "JAPAN"
    .db $A4, $AD, $8F, $95, $A3, $FF, $93, $A8, $B1, $A8, $96, $9E, 0           ; $01DF54.DF60 |  
.else
    .asc "Well, good-bye.", 0                                                   ; $01DB79.DB88
.endif

; menu_window_shop_thank_you_data ($01:DB89)
;
; Data to draw the window that displays the thank you message after the player
; makes a purchase.
menu_window_shop_thank_you_data:
    MENU_COORDINATES 5, 10                                                      ; $01DB89.DB8A
    .db 11, 2                                                                   ; $01DB8B.DB8C
    MENU_COORDINATES 6, 11                                                      ; $01DB8D.DB8E
.if FF4_REGION == "JAPAN"
    .db $8A, $B1, $10, $9D, $8C, $14, $15, $8B, $A8, $95, $99, 0                ; $01DF67.DF72 | 
.else
    .asc "Thank you.", 0                                                        ; $01DB8F.DB99
.endif

; menu_window_shop_confirmation_data ($01:DB9A)
;
; Data to draw the window used to confirm a transaction in the shop menu.
menu_window_shop_confirmation_data:
    MENU_COORDINATES 9, 10                                                      ; $01DB9A.DB9B
.if FF4_REGION == "JAPAN"
    .db 11, 13                                                                  ; $01DF75.DF76
    MENU_COORDINATES 13, 13                                                     ; $01DF77.DF78
    .db $1D, $95, $99, $B0, 1                                                   ; $01DF79.DF7D | 
    MENU_COORDINATES 18, 15                                                     ; $01DF7E.DF7F
    .db $2A, $F2, $1D, 1                                                        ; $01DF80.DF83 | 
    MENU_COORDINATES 10, 17                                                     ; $01DF84.DF85
    .db $8E, $A4, $90, $9D, $B1, $8B, $99, $95, $A8, $96, $10, 1                ; $01DF86.DF91 | 
    MENU_COORDINATES 11, 19                                                     ; $01DF92.DF93
    .db $AF, $B4, $95, $8B, $1D, $96, $8F, $C5, 1                               ; $01DF94.DF9C | 
    MENU_COORDINATES 12, 21                                                     ; $01DF9D.DF9E
    .db $A3, $8B, $FF, $FF, $8B, $8B, $8D, 0                                    ; $01DF9F.DFA6 |   
.else
    .db 11, 11                                                                  ; $01DB9C.DB9D
    MENU_COORDINATES 12, 15                                                     ; $01DB9E.DB9F
    .asc "That's ", 1                                                           ; $01DBA0.DBA7
    MENU_COORDINATES 18, 17                                                     ; $01DBA8.DBA9
    .asc "GP.", 1                                                               ; $01DBAA.DBAD
    MENU_COORDINATES 12, 13                                                     ; $01DBAE.DBAF
    .asc "x", 1                                                                 ; $01DBB0.DBB1
    MENU_COORDINATES 12, 19                                                     ; $01DBB2.DBB3
    .asc "Yes  No", 0                                                           ; $01DBB4.DBBB
.endif

; menu_text_shop_sell_shopkeeper_data ($01:DBBC)
;
; This text is intended to be displayed in the shopkeeper dialog window when
; selling items at a shop.
;
; BUG: The routine that references this location uses the indirect mode, which
;      means the first two bytes here should actually be the coordinates to
;      draw at. Since these coordinates are omitted, the first two bytes are
;      interpreted as the coordinates instead, which is essentially garbage
;      data. (The end result is the tiles are sent to the end of BG2's tilemap
;      instead, but that part of the tilemap is never copied to VRAM).
menu_text_shop_sell_shopkeeper_data:
.if FF4_REGION == "JAPAN"
    .db $99, $8B, $9C, $8B, $A2, $AC, $A2, $A3, $FF, $8E, $A4, $90, $9D, $B1    ; $01DFA7.DFB4 |  
    .db $95, $A8, $96, $AF, 0                                                   ; $01DFB5.DFB9
.else
    .asc "I buy most things!", 0                                                ; $01DBBC.DBCE
.endif

; menu_text_shop_gp_overflow_data ($01:DBCF)
;
; This odd text is intended to be displayed if the price of an item in a shop
; exceeds the 9999999 limit. However, it's not implemented correctly, and since
; this text is unchanged from the Japanese version, it's possible that code was
; simply abandoned at some point, and instead, they made sure that no items
; exceeded 100k in price.
menu_text_shop_gp_overflow_data:
    .asc "EXPEND", 0                                                            ; $01DBCF.DBD5

; menu_window_save_slot_data ($01:DBD6)
;
; Contains tilemap offset and size for the window that displays the data about
; a save slot on the save screen.
menu_window_save_slot_data:
    MENU_COORDINATES 0, 0                                                       ; $01DBD6.DBD7
    .db 29, 5                                                                   ; $01DBD8.DBD9

; menu_window_save_new_game_data ($01:DBDA)
;
; Tilemap offset and size for the window that displays the new game text on the
; save menu.
menu_window_save_new_game_data:
    MENU_COORDINATES 0, 0                                                       ; $01DBDA.DBDB
    .db 16, 2                                                                   ; $01DBDC.DBDD

; menu_text_new_game_data ($01:DBDE)
;
; Text for the "New Game" option.
menu_text_new_game_data:
    MENU_COORDINATES 3, 1                                                       ; $01DBDE.DBDF
.if FF4_REGION == "JAPAN"
    .db $DF, $BE, $C2, $2C, $C2, $EA, 0                                         ; $01DFCB.DFD1 | 
.else
    .asc "New Game", 0                                                          ; $01DBE0.DBE8
.endif

DATA_01DBE9:
    MENU_COORDINATES 20, 1                                                      ; $01DBE9.DBEA
.if FF4_REGION == "JAPAN"
    .db $38, $DD, $F2, $D6, $3E, $C2, $37, 0                                    ; $01DFD4.DFDB | 
.else
    .asc "Battle Speed", 0                                                      ; $01DBEB.DBF7
.endif

; menu_window_save_confirm_data ($01:DBF8)
;
; Tilemap offset and size for the save confirmation dialog window.
menu_window_save_confirm_data:
    MENU_COORDINATES 22, 0                                                      ; $01DBF8.DBF9
    .db 7, 8                                                                    ; $01DBFA.DBFB

; menu_window_save_time_data ($01:DBFC)
;
; Tilemap offset and size for the window that displays the game time on the save
; details menu.
menu_window_save_time_data:
    MENU_COORDINATES 22, 16                                                     ; $01DBFC.DBFD
    .db 7, 5                                                                    ; $01DBFE.DBFF

; menu_window_save_gp_data ($01:DC00)
;
; Tilemap offset and size for the window that displays the party's GP when
; viewing save details.
menu_window_save_gp_data:
    MENU_COORDINATES 22, 23                                                     ; $01DC00.DC01
    .db 7, 3                                                                    ; $01DC02.DC03

; menu_text_load_confirm_data ($01:DC04)
;
; Text displayed in the confirmation dialog when loading a save.
menu_text_load_confirm_data:
    MENU_COORDINATES 23, 1                                                      ; $01DC04.DC05
.if FF4_REGION == "JAPAN"
    .db $93, $A2, $36, $C2, $D9, $1D, 1                                         ; $01DFEA.DFF0 | 
    MENU_COORDINATES 23, 3                                                      ; $01DFF1.DFF2
    .db $8B, $8B, $1D, $96, $8F, $C5, 0                                         ; $01DFF3.DFF9 | 
.else
    .asc "This", 1                                                              ; $01DC06.DC0A
    MENU_COORDINATES 24, 3                                                      ; $01DC0B.DC0C
    .asc "data?", 0                                                             ; $01DC0D.DC12
.endif

; menu_text_save_yes_no_data ($01:DC13)
;
; The Yes and No options when saving or loading the game.
menu_text_save_yes_no_data:
    MENU_COORDINATES 25, 5                                                      ; $01DC13.DC14
.if FF4_REGION == "JAPAN"
    .db $A3, $8B, 1                                                             ; $01DFFC.DFFE | 
.else
    .asc "Yes", 1                                                               ; $01DC15.DC18
.endif
    MENU_COORDINATES 25, 7                                                      ; $01DC19.DC1A
.if FF4_REGION == "JAPAN"
    .db $8B, $8B, $8D, 0                                                        ; $01E001.E004 | 
.else
    .asc "No", 0                                                                ; $01DC1B.DC1D
.endif

; menu_text_save_time_data ($01:DC1E)
;
; "Time" text displayed on a save details menu. The _direct_ variant points to
; just the text, without the coordinates.
menu_text_save_time_data:
    MENU_COORDINATES 23, 17                                                     ; $01DC1E.DC1F
menu_text_time_direct_data:
.if FF4_REGION == "JAPAN"
    .asc "TIME", 0                                                              ; $01E007.E00B
.else
    .asc "Time", 0                                                              ; $01DC20.DC24
.endif

; menu_text_empty_data ($01:DC25)
;
; The "Empty" text displayed on an empty save slot. The direct variant simply
; ignores the coordinates.
menu_text_empty_data:
    MENU_COORDINATES 8, 2                                                       ; $01DC25.DC26
menu_text_empty_direct_data:
.if FF4_REGION == "JAPAN"
    .asc "EMPTY", 0                                                             ; $01E00E.E013
.else
    .asc "Empty", 0                                                             ; $01DC27.DC2C
.endif

; menu_text_save_title_data ($01:DC2D)
;
; Tilemap offset and text for the "Save" title that appears on the save menu.
menu_text_save_title_data:
    MENU_COORDINATES 3, 1                                                       ; $01DC2D.DC2E
.if FF4_REGION == "JAPAN"
    .db $D7, $C2, $3A, 0                                                        ; $01E016.E019 | 
.else
    .asc "Save", 0                                                              ; $01DC2F.DC33
.endif

; menu_text_save_cancelled_data ($01:DC34)
;
; Tilemap offset and text for the "Cancelled." text that appears when canceling
; a save action.
menu_text_save_cancelled_data:
    MENU_COORDINATES 3, 1                                                       ; $01DC34.DC35
.if FF4_REGION == "JAPAN"
    .db $D7, $C2, $3A, $A3, $D0, $BD, $F6, $D7, $F2, $94, $B3, $A8, $95, $99, 0 ; $01E01C.E02A | 
.else
    .asc "Cancelled.", 0                                                        ; $01DC36.DC40
.endif

; menu_text_save_done_data ($01:DC41)
;
; Tilemap offset and text for the "Done!" text that appears when saving the
; game.
menu_text_save_done_data:
.if FF4_REGION == "JAPAN"
    MENU_COORDINATES 23, 11                                                     ; $01E02B.E02C
    .db $D7, $C2, $3A, $95, $A8, $95, $99, 0                                    ; $01E02D.E034 | 
.else
    MENU_COORDINATES 24, 11                                                     ; $01DC41.DC42
    .asc "Done!", 0                                                             ; $01DC43.DC48
.endif

; menu_text_save_confirm_data ($01:DC49)
;
; Text displayed in the confirmation window when saving.
menu_text_save_confirm_data:
.if FF4_REGION == "JAPAN"
    MENU_COORDINATES 23, 1                                                      ; $01E035.E036
    .db $A8, $8D, $A2, $36, $C2, $D9, $7B, 1                                    ; $01E037.E03E | 
    MENU_COORDINATES 23, 3                                                      ; $01E03F.E040
    .db $92, $95, $A8, $96, $8F, $C5, 0                                         ; $01E041.E047 | 
.else
    MENU_COORDINATES 23, 1                                                      ; $01DC49.DC4A
    .asc "Save", 0                                                              ; $01DC4B.DC4F | BUG: Because the final byte was set to a zero here, the second
    MENU_COORDINATES 23, 3                                                      ; $01DC50.DC51 |      line does not appear.
    .asc "here?", 0                                                             ; $01DC52.DC57
.endif

; menu_text_save_cancel_data ($01:DC58)
;
; Tilemap offset and text for the "Cancel" message that is intended to appear
; in the save menu.
menu_text_save_cancel_data:
    MENU_COORDINATES 25, 11                                                     ; $01DC58.DC59
.if FF4_REGION == "JAPAN"
    .db $D0, $BD, $F6, $D7, $F2, 0                                              ; $01E04A.E04F | 
.else
    .asc "Cancel", 0                                                            ; $01DC5A.DC60
.endif

; menu_window_save_done_data ($01:DC61)
;
; Tilemap offset and size for the window that displays the "Done!" text in the
; save menu.
menu_window_save_done_data:
    MENU_COORDINATES 22, 10                                                     ; $01DC61.DC62
    .db 7, 2                                                                    ; $01DC63.DC64

; menu_window_namingway_yes_no_data ($01:DC65)
;
; Tilemap offset and size of the window used to display the yes/no options in
; the Namingway screen. Additionally includes the starting dialog for the
; dialog window.
menu_window_namingway_yes_no_data:
    MENU_COORDINATES 1, 5                                                       ; $01DC65.DC66
    .db 13, 1                                                                   ; $01DC67.DC68
    MENU_COORDINATES 7, 1                                                       ; $01DC69.DC6A
.if FF4_REGION == "JAPAN"
    .db $E1, $E9, $F6, $2B, $CC, $BA, $CB, $FF, $B9, $8E, $9E, $A8, $8D, $A2    ; $01E05A.E067 |   
    .db $FF, $14, $A6, $B6, $93, $8C, $1D, $C5, $C9, 0                          ; $01E068.E071
.else
    .asc "Namingway:Change name?", 0                                            ; $01DC6B.DC81
.endif

; menu_text_namingway_whose_name_data ($01:DC82)
;
; Text for the "Whose name?" dialog for Namingway. This is famously misspelled
; as "Who's name?"
menu_text_namingway_whose_name_data:
    MENU_COORDINATES 7, 1                                                       ; $01DC82.DC83
.if FF4_REGION == "JAPAN"
    .db $B9, $1E, $9E, $99, $94, $A8, $10, $14, $A6, $B6, $93, $8C, $9E, $94    ; $01E074.E081 | 
    .db $8B, $A8, $96, $8F, $C5, $C9, 0                                         ; $01E082.E088
.else
    .asc "Who's name?", 0                                                       ; $01DC84.DC8F | BUG: This should be "Whose".
.endif

DATA_01E089:
.if FF4_REGION == "JAPAN"
    MENU_COORDINATES 7, 1                                                       ; $01E089.E08A
    .db $B9, $1D, $FF, $8A, $99, $B0, $95, $8B, $FF, $8E, $9E, $A8, $8D, $A3    ; $01E08B.E098 |   
    .db $C5, $C9, 0                                                             ; $01E099.E09B
    MENU_COORDINATES 7, 1                                                       ; $01E09C.E09D
    .db $B9, $1D, $FF, $AF, $B4, $95, $8B, $B6, $1D, $96, $A1, $C5, $C9, 0      ; $01E09E.E0AB |  
.else
    MENU_COORDINATES 7, 1                                                       ; $01DC90.DC91
    .asc "D", 0                                                                 ; $01DC92.DC93
    MENU_COORDINATES 7, 1                                                       ; $01DC94.DC95
    .asc "D", 0                                                                 ; $01DC96.DC97
.endif

; menu_text_namingway_yes_no_data ($01:DC98)
;
; Text to display in the yes/no window for the Namingway screen.
menu_text_namingway_yes_no_data:
.if FF4_REGION == "JAPAN"
    .db $8F, $8D, $B2, $FF, $FF, $FF, $8F, $8D, $9E, $8B, 0                     ; $01E0AC.E0B6 |    
.else
    .asc "Yes   No", 0                                                          ; $01DC98.DCA0
.endif

; menu_text_namingway_very_well_data ($01:DCA1)
;
; Coordinates and text for the "Very well." message that appears at the end of
; the Namingway menu.
menu_text_namingway_very_well_data:
    MENU_COORDINATES 7, 1                                                       ; $01DCA1.DCA2
.if FF4_REGION == "JAPAN"
    .db $B9, $98, $A2, $A7, $8C, $10, $AF, $B4, $95, $7E, $8C, $14, $15, $8B    ; $01E0B9.E0C6 | 
    .db $A8, $96, $9E, $C9, 0                                                   ; $01E0C7.E0CB
.else
    .asc "Very well.", 0                                                        ; $01DCA3.DCAD
.endif

; menu_window_namingway_dialog_data ($01:DCAE)
;
; Tilemap offset and size of the window to display the dialog of the Namingway
; screen.
menu_window_namingway_dialog_data:
    MENU_COORDINATES 6, 0                                                       ; $01DCAE.DCAF
    .db 23, 2                                                                   ; $01DCB0.DCB1

; menu_window_namingway_name_data ($01:DCB2)
;
; Tilemap offset and size of the window for the character names in the Namingway
; screen.
menu_window_namingway_name_data:
    MENU_COORDINATES 8, 4                                                       ; $01DCB2.DCB3
    .db 6, 2                                                                    ; $01DCB4.DCB5

; menu_window_big_chocobo_dialog_data ($01:DCB6)
;
; Tilemap offset and size of the window to display the Big Chocobo's dialog.
menu_window_big_chocobo_dialog_data:
    MENU_COORDINATES 6, 1                                                       ; $01DCB6.DCB7
    .db 20, 2                                                                   ; $01DCB8.DCB9

; menu_window_big_chocobo_inventory_data ($01:DCBA)
;
; Tilemap offset and size of the window to display the inventory in the Big
; Chocobo menu.
menu_window_big_chocobo_inventory_data:
    MENU_COORDINATES 1, 10                                                      ; $01DCBA.DCBB
    .db 27, 15                                                                  ; $01DCBC.DCBD

; menu_window_big_chocobo_command_menu_data ($01:DCBE)
;
; Tilemap offset, size and text for the Big Chocobo menu that shows the command
; menu. THe Japanese version also includes the name of the bird to draw in the
; uppermost window.
menu_window_big_chocobo_command_menu_data:
    MENU_COORDINATES 2, 6                                                       ; $01DCBE.DCBF
    .db 12, 2                                                                   ; $01DCC0.DCC1
.if FF4_REGION == "JAPAN"
    MENU_COORDINATES 7, 2                                                       ; $01E0E0.E0E1
    .db $1D, $21, $DA, $BF, $D3, $3C, 1                                         ; $01E0E2.E0E8 | 
    MENU_COORDINATES 4, 7                                                       ; $01E0E9.E0EA
    .db $8A, $17, $92, $B2, $FF, $FF, $A4, $90, $1A, $96, 0                     ; $01E0EB.E0F5 |   
.else
    MENU_COORDINATES 4, 7                                                       ; $01DCC2.DCC3
    .asc "Give  Take", 0                                                        ; $01DCC4.DCCE
.endif

; menu_text_big_chocobo_what_do_you_want_data ($01:DCCF)
;
; Text displayed in the Big Chocobo dialog box when called with a Carrot.
menu_text_big_chocobo_what_do_you_want_data:
.if FF4_REGION == "JAPAN"
    MENU_COORDINATES 13, 2                                                      ; $01E0F6.E0F7
    .db $B9, $AF, $C2, $8E, $FF, $9E, $B6, $8F, $AF, $8C, $8F, $C2, $8B, $C9, 0 ; $01E0F8.E106 |  
.else
    MENU_COORDINATES 7, 2                                                       ; $01DCCF.DCD0
    .asc "What do you want?", 0                                                 ; $01DCD1.DCE2
.endif

; menu_text_big_chocobo_did_you_call_me_data ($01:DCE3)
;
; Text displayed in the Big Chocobo dialog box when called by the Whistle.
menu_text_big_chocobo_did_you_call_me_data:
.if FF4_REGION == "JAPAN"
    MENU_COORDINATES 13, 2                                                      ; $01E107.E108
    .db $B9, $93, $B6, $9E, $9D, $93, $1D, $E5, $CD, $A5, $91, $9E, $AF, $C9, 0 ; $01E109.E117 | 
.else
    MENU_COORDINATES 7, 2                                                       ; $01DCE3.DCE4
    .asc "Did you call me?", 0                                                  ; $01DCE5.DCF5
.endif

; menu_text_big_chocobo_what_ll_you_give_me_data ($01:DCF6)
;
; Text displayed in the Big Chocobo dialog box when using the Give command.
menu_text_big_chocobo_what_ll_you_give_me_data:
.if FF4_REGION == "JAPAN"
    MENU_COORDINATES 13, 2                                                      ; $01E118.E119
    .db $FF, $B9, $9E, $9F, $7B, $91, $B3, $B2, $B6, $1A, $C2, $8B, $C9, $FF, 0 ; $01E11A.E128 | 
.else
    MENU_COORDINATES 7, 2                                                       ; $01DCF6.DCF7
    .asc "What'll you give me?", 0                                              ; $01DCF8.DD0C
.endif

; menu_text_big_chocobo_what_are_you_taking_data ($01:DD0D)
;
; Text displayed in the Big Chocobo dialog window when using the Take command.
menu_text_big_chocobo_what_are_you_taking_data:
.if FF4_REGION == "JAPAN"
    MENU_COORDINATES 13, 2                                                      ; $01E129.E12A
    .db $FF, $B9, $9E, $9F, $10, $A7, $95, $8B, $B6, $1A, $C2, $8B, $C9, $FF, 0 ; $01E12B.E139 | 
.else
    MENU_COORDINATES 7, 2                                                       ; $01DD0D.DD0E
    .asc "What are you taking?", 0                                              ; $01DD0F.DD23
.endif

; menu_text_big_chocobo_im_full_data ($01:DD24)
;
; Text displayed in the Big Chocobo menu if the Big Chocobo inventory is full.
menu_text_big_chocobo_im_full_data:
.if FF4_REGION == "JAPAN"
    MENU_COORDINATES 13, 2                                                      ; $01E13A.E13B
    .db $FF, $B9, $8C, $C2, $B6, $FF, $AC, $8C, $91, $8D, $9E, $8B, $C9, $FF, 0 ; $01E13C.E14A |  
.else
    MENU_COORDINATES 7, 2                                                       ; $01DD24.DD25
    .asc "I'm full!", 0                                                         ; $01DD26.DD2F
.endif

; menu_text_big_chocobo_clean_your_bag_data ($01:DD30)
;
; Text displayed in the Big Chocobo menu if the player's inventory is full.
menu_text_big_chocobo_clean_your_bag_data:
.if FF4_REGION == "JAPAN"
    MENU_COORDINATES 13, 2                                                      ; $01E14B.E14C
    .db $FF, $B9, $9F, $AC, $9B, $7B, $97, $8B, $B1, $95, $9E, $C2, $C9, $FF, 0 ; $01E14D.E15B | 
.else
    MENU_COORDINATES 7, 2                                                       ; $01DD30.DD31
    .asc "Clean your bag!     ", 0                                              ; $01DD32.DD46
.endif

; menu_window_custom_title_data ($01:DD47)
;
; Tilemap offset and size for the custom menu title window.
menu_window_custom_title_data:
.if FF4_REGION == "JAPAN"
    MENU_COORDINATES 10, 1                                                      ; $01E15C.E15D
    .db 7, 2                                                                    ; $01E15E.E15F
.else
    MENU_COORDINATES 9, 1                                                       ; $01DD47.DD48
    .db 10, 2                                                                   ; $01DD49.DD4A
.endif

; menu_text_customizer_data ($01:DD4B)
;
; Text for the title of the custom menu.
menu_text_customizer_data:
.if FF4_REGION == "JAPAN"
    MENU_COORDINATES 12, 2                                                      ; $01E160.E161
    .db $D3, $F6, $E5, $B8, $2B, 0                                              ; $01E162.E167 | 
.else
    MENU_COORDINATES 10, 2                                                      ; $01DD4B.DD4C
    .asc "Customizer", 0                                                        ; $01DD4D.DD57
.endif

; menu_window_custom_data ($01:DD58)
;
; Tilemap offset, size and most text strings for the Custom menu. The text for
; the word controller has its own label, as it's also used separately (in the
; Japanese version).
menu_window_custom_data:
.if FF4_REGION == "JAPAN"
    MENU_COORDINATES 2, 4                                                       ; $01E168.E169
.if FF4_EASYTYPE == 1
    .db 24, 16                                                                  ; $01DF94.DF95
.else
    .db 24, 20                                                                  ; $01E16A.E16B
.endif
    MENU_COORDINATES 5, 5                                                       ; $01E16C.E16D
    .db $38, $DD, $F2, $EC, $C2, $37, 1                                         ; $01E16E.E174 | 
    MENU_COORDINATES 15, 5                                                      ; $01E175.E176
    .db $CC, $CD, $CB, $DD, $FF, $FF, $FF, $CA, $D1, $DC, $B8, $3A, 1           ; $01E177.E183 |    
    MENU_COORDINATES 5, 7                                                       ; $01E184.E185
    .db $38, $DD, $F2, $D6, $3E, $C2, $37, 1                                    ; $01E186.E18D | 
    MENU_COORDINATES 5, 9                                                       ; $01E18E.E18F
    .db $38, $DD, $F2, $EB, $BC, $D7, $C2, $2F, 1                               ; $01E190.E198 | 
.if FF4_EASYTYPE == 1
    MENU_COORDINATES 5, 15                                                      ; $01E199.E19A
.else
    MENU_COORDINATES 5, 19                                                      ; $01E199.E19A
.endif
    .db $CC, $B8, $F6, $37, $CC, $CF, $F0, $C2, 1                               ; $01E19B.E1A3 | 
.if FF4_EASYTYPE != 1
    MENU_COORDINATES 15, 13                                                     ; $01E1A4.E1A5
    .db $E2, $C2, $E8, $F2, $FF, $FF, $FF, $CF, $D6, $D9, $EA, 1                ; $01E1A6.E1B1 |    
    MENU_COORDINATES 5, 17                                                      ; $01E1B2.E1B3
    .db $CF, $C2, $D8, $F2, $8B, $9A, 1                                         ; $01E1B4.E1BA | 
    MENU_COORDINATES 15, 17                                                     ; $01E1BB.E1BC
    .db $AC, $1E, $96, $FF, $FF, $FF, $FF, $90, $8E, $91, 1                     ; $01E1BD.E1C7 |     
.endif
    MENU_COORDINATES 5, 11                                                      ; $01E1C8.E1C9
    .db $D4, $CC, $F6, $37, 1                                                   ; $01E1CA.E1CE | 
    MENU_COORDINATES 15, 11                                                     ; $01E1CF.E1D0
    .db $D6, $DC, $F3, $CE, $FF, $FF, $FF, $EC, $E2, $F0, $F2, 1                ; $01E1D1.E1DC |    
    MENU_COORDINATES 15, 8                                                      ; $01E1DD.E1DE
    .db $A3, $AD, $8B, 1                                                        ; $01E1DF.E1E2 | 
    MENU_COORDINATES 23, 8                                                      ; $01E1E3.E1E4
    .db $8E, $98, $8B, 1                                                        ; $01E1E5.E1E8 | 
.if FF4_EASYTYPE == 1
    MENU_COORDINATES 15, 13                                                     ; $01E1E9.E1EA
.else
    MENU_COORDINATES 15, 15                                                     ; $01E1E9.E1EA
.endif
    .db $D5, $F6, $2B, $F2, $FF, $FF, $FF, $E8, $F2, $DA, 1                     ; $01E1EB.E1F5 |    
    MENU_COORDINATES 5, 13                                                      ; $01E1F6.E1F7
menu_text_controller_data:
    .db $D3, $F6, $DD, $F4, $C2, $F0, $C2, 0                                    ; $01E1F8.E1F9 | 
.else
    MENU_COORDINATES 2, 4                                                       ; $01DD58.DD59
    .db 24, 20                                                                  ; $01DD5A.DD5B
    MENU_COORDINATES 15, 6                                                      ; $01DD5C.DD5D
    .asc "Fast", 1                                                              ; $01DD5E.DD62
    MENU_COORDINATES 22, 6                                                      ; $01DD63.DD64
    .asc "Slow", 1                                                              ; $01DD65.DD69
    MENU_COORDINATES 15, 10                                                     ; $01DD6A.DD6B
    .asc "Fast", 1                                                              ; $01DD6C.DD70
    MENU_COORDINATES 22, 10                                                     ; $01DD71.DD72
    .asc "Slow", 1                                                              ; $01DD73.DD77
    MENU_COORDINATES 5, 5                                                       ; $01DD78.DD79
    .asc "Battle Speed", 1                                                      ; $01DD7A.DD86
    MENU_COORDINATES 5, 9                                                       ; $01DD87.DD88
    .asc "Battle Message", 1                                                    ; $01DD89.DD97
    MENU_COORDINATES 5, 17                                                      ; $01DD98.DD99
    .asc "Window Color", 1                                                      ; $01DD9A.DDA6
    MENU_COORDINATES 5, 14                                                      ; $01DDA7.DDA8
    .asc "Sound", 1                                                             ; $01DDA9.DDAE
    MENU_COORDINATES 15, 14                                                     ; $01DDAF.DDB0
    .asc "Stereo Mono", 0                                                       ; $01DDB1.DDBC
.endif

; menu_window_custom_joypad_data ($01:DDBD)
;
; Tilemap offset and size for the controller customization window only used in
;  the Japanese version. The data remains in the USA version, however.
menu_window_custom_joypad_data:
    MENU_COORDINATES 0, 7                                                       ; $01DDBD.DDBE
    .db 28, 12                                                                  ; $01DDBF.DDC0

.if FF4_REGION == "JAPAN"
; menu_text_custom_joypad_data ($01:E204)
;
; Tilemap location and text for all the labels used on the custom controller
; window in the Japanese version.
menu_text_custom_joypad_data:
    MENU_COORDINATES 11, 2                                                      ; $01E204.E205
    .db $CF, $D6, $D9, $E8, $CB, $2E, 1                                         ; $01E206.E20C | 
    MENU_COORDINATES 3, 8                                                       ; $01E20D.E20E
    .db $92, $7C, $9C, $8B, 1                                                   ; $01E20F.E213 | 
    MENU_COORDINATES 3, 10                                                      ; $01E214.E215
    .db $9A, $7E, $8C, $95, 1                                                   ; $01E216.E21A | 
    MENU_COORDINATES 3, 12                                                      ; $01E21B.E21C
    .db $EB, $DF, $BE, $C2, 1                                                   ; $01E21D.E221 | 
    MENU_COORDINATES 3, 14                                                      ; $01E222.E223
    .db $4D, $3C, $D9, $F6, $A3, 1                                              ; $01E224.E229 | L
    MENU_COORDINATES 3, 16                                                      ; $01E22A.E22B
    .asc "START", 1                                                             ; $01E22C.E231 | START
    MENU_COORDINATES 3, 18                                                      ; $01E232.E233
    .db $8E, $B5, $B1, 0                                                        ; $01E234.E237 | 

; menu_text_custom_joypad_l_start_options_data ($01:E238)
;
; Text for the options available for the L and Start buttons in the controller
; customization window. Only used in the Japanese version.
menu_text_custom_joypad_l_start_options_data:
    .db $AA, $95, $96, $B2, $FF, $92, $7C, $9C, $8B, $FF, $9A, $7E, $8C, $95    ; $01E238.E245 |    
    .db $FF, $EB, $DF, $BE, $C2, 0                                              ; $01E246.E24B

; menu_text_custom_joypad_confirm_cancel_menu_options_data ($01:E24C)
;
; Text for the options available for the confirm, cancel and menu options in the
; controller customization window. Only used in the Japanese version.
menu_text_custom_joypad_confirm_cancel_menu_options_data:
    .asc "A  B  X  Y  SELECT", 0                                                ; $01E24C.E25E
.endif

UNKNOWN_01DDC1:
    .db $02                                                                     ; $01DDC1
    .db $02                                                                     ; $01DDC2
    .db $1B                                                                     ; $01DDC3
    .db $06                                                                     ; $01DDC4

; menu_window_custom_joypad_selector_data ($01:DDC5)
;
; Tilemap offset, size and text for the title of the character joypad selector
; menu.
menu_window_custom_joypad_selector_data:
    MENU_COORDINATES 5, 7                                                       ; $01DDC5.DDC6
    .db 20, 11                                                                  ; $01DDC7.DDC8
.if FF4_REGION == "JAPAN"
    MENU_COORDINATES 11, 2                                                      ; $01E267.E268
    .db $3D, $BC, $37, $D7, $F3, $D1, $D9, 0                                    ; $01E269.E272 | 
.endif

; menu_window_spoils_command_data ($01:DDC9)
;
; Tilemap offset and size for the window containing the commands to choose from
; in the spoils menu.
menu_window_spoils_command_data:
    MENU_COORDINATES 8, 0                                                       ; $01DDC9.DDCA
    .db 20, 2                                                                   ; $01DDCB.DDCC

; menu_window_spoils_spoil_inventory_data ($01:DDCD)
;
; Tilemap offset and size for the window containing the spoils inventory in the
; spoils menu.
menu_window_spoils_spoil_inventory_data:
    MENU_COORDINATES 1, 3                                                       ; $01DDCD.DDCE
    .db 27, 10                                                                  ; $01DDCF.DDD0

; menu_window_spoils_header_data ($01:DDD1)
;
; Tilemap offset and size for the header window for the spoils menu, as well as
; the title text and the command text for the spoils menu. Some of the text
; additionally has its own labels.
menu_window_spoils_header_data:
.if FF4_REGION == "JAPAN"
    MENU_COORDINATES 1, 0                                                       ; $01E279.E27A
    .db 6, 2                                                                    ; $01E27B.E27C
    MENU_COORDINATES 3, 1                                                       ; $01E27D.E27E
    .db $8E, $99, $8F, $B0, 1                                                   ; $01E27F.E283 | 
    MENU_COORDINATES 25, 1                                                      ; $01E284.E285
    .db $8E, $B5, $B1, 1                                                        ; $01E286.E289 | 
menu_text_spoils_take_all_data:
    MENU_COORDINATES 11, 1                                                      ; $01E28A.E28B
    .db $96, $22, $9C, $AC, $7C, $9C, $8B, $91, 0                               ; $01E28C.E294 | 
.else
    MENU_COORDINATES 1, 0                                                       ; $01DDD1.DDD2
    .db 8, 2                                                                    ; $01DDD3.DDD4
    MENU_COORDINATES 2, 1                                                       ; $01DDD5.DDD6
    .asc "Treasure", 1                                                          ; $01DDD7.DDDF
    MENU_COORDINATES 25, 1                                                      ; $01DDE0.DDE1
    .asc "Exit", 1                                                              ; $01DDE2.DDE6
menu_text_spoils_take_all_data:
    MENU_COORDINATES 13, 1                                                      ; $01DDE7.DDE8
    .asc "Take all", 0                                                          ; $01DDE9.DDF1
.endif

; menu_text_spoils_exchange_data ($01:DDF2)
;
; Coordinate and text for the "Exchange" command in the spoils menu.
menu_text_spoils_exchange_data:
.if FF4_REGION == "JAPAN"
    MENU_COORDINATES 11, 1                                                      ; $01E295.E296
    .db $93, $8C, $8F, $B6, $FF, $FF, $FF, $FF, 0                               ; $01E297.E29F | 
.else
    MENU_COORDINATES 13, 1                                                      ; $01DDF2.DDF3
    .asc "Exchange", 0                                                          ; $01DDF4.DDFC
.endif

; menu_window_important_items_remain_data ($01:DDFD)
;
; Tilemap offset, size and text for the dialog that is shown when attempting to
; leave the spoils menu with a key item remaining in the spoils inventory.
;
; BUG: This message was not translated for the US release, so it appears as a
;      garbled mess. The decoding of the Japanese text is listed in the
;      comments.
menu_window_important_items_remain_data:
    MENU_COORDINATES 8, 10                                                      ; $01DDFD.DDFE
    .db 11, 4                                                                   ; $01DDFF.DE00
    MENU_COORDINATES 9, 11                                                      ; $01DE01.DE02
    .db $16, $7E, $8C, $AF, $8C, $9E, $CA, $CB, $DC, $EA, $10, 1                ; $01DE03.DE0E | 
    MENU_COORDINATES 10, 13                                                     ; $01DE0F.DE10
    .db $A2, $93, $7C, $9C, $8B, $A8, $96, $AF, 0                               ; $01DE11.DE19 | 

; menu_window_item_learned_data ($01:DE1A)
;
; Tilemap offset, size and "learned" text for the window that displays when
; using a summon teaching item.
menu_window_item_learned_data:
    MENU_COORDINATES 12, 9                                                      ; $01DE1A.DE1B
    .db 7, 6                                                                    ; $01DE1C.DE1D
.if FF4_REGION == "JAPAN"
    MENU_COORDINATES 19, 10                                                     ; $01E2C1.E2C2
    .db $A3, 1                                                                  ; $01E2C3.E2C4 | 
    MENU_COORDINATES 14, 14                                                     ; $01E2C5.E2C6
    .db $7B, $8E, $23, $8D, $99, 0                                              ; $01E2C7.E2CC | 
.else
    MENU_COORDINATES 13, 12                                                     ; $01DE1E.DE1F
    .asc "learned", 0                                                           ; $01DE20.DE27
.endif

; menu_text_numbers_1_6_data ($01:DE28)
;
; Text of the numbers from 1 to 6 used for battle speed and battle message
; speed in the custom menu.
menu_text_numbers_1_6_data:
    .asc "1 2 3 4 5 6", 0                                                       ; $01DE28.DE33

; menu_text_equip_handedness_data ($01:DE34)
;
; Text descriptions for the three possible handedness options for a character,
; plus a dummy entry for the unused $00 entry. The Japanese version has actual
; text for the $00 entry.
menu_text_equip_handedness_data:
.if FF4_REGION == "JAPAN"
    .db $21, $90, $AF, $8C, 0, 0, 0, 0                                          ; $01E2D9.E2E0 | $00: 
    .db $A4, $1A, $B1, $90, $90, 0, 0, 0                                        ; $01E2E1.E2E8 | $01: 
    .db $A9, $11, $90, $90, 0, 0, 0, 0                                          ; $01E2E9.E2F0 | $02: 
    .db $B1, $7F, $8C, $90, $90, 0, 0, 0                                        ; $01E2F1.E2F8 | $03: 
.else
    .asc "D", 0, 0, 0, 0, 0, 0, 0                                               ; $01DE34.DE3B | $00: <unused>
    .asc "L-Hand", 0, 0                                                         ; $01DE3C.DE43 | $01: Left
    .asc "R-Hand", 0, 0                                                         ; $01DE44.DE4B | $02: Right
    .asc "R/L both", 0                                                          ; $01DE4C.DE54 | $03: Both
.endif

UNUSED_01DE55:
.if FF4_REGION == "JAPAN"
.if FF4_EASYTYPE == 1
    .dsb $0202 $FF                                                              ; $01E2F9.E2FF
.else
    .dsb $0007 $FF                                                              ; $01E2F9.E2FF
.endif
.else
    .dsb $04AB $FF                                                              ; $01DE55.E2FF
.endif

; battle_animate_cast_effect_white_call ($01:E300)
;
; Given a spell visual effect number in the accumulator, animates that effect
; if the value is 1 or 2 (the white magic cast effect and the call magic cast
; effect, respectively).
battle_animate_cast_effect_white_call:
    CMP #SPELL_AUDIOVISUAL_CAST_WHITE.b                                         ; $01E300 |\
    BEQ +                                                                       ; $01E302 | | Return if the passed visual effect is anything other than the cast
    CMP #SPELL_AUDIOVISUAL_CAST_CALL.b                                          ; $01E304 | | effects for either white or call magic. Otherwise, branch to one
    BEQ ++                                                                      ; $01E306 | | section for white and another section for call.
    RTL                                                                         ; $01E308 |/
+   LDA #%00000111.b                                                            ; $01E309 |\
    STA r_battle_effect_cast_frame_mask.w                                       ; $01E30B | | If this is the white magic cast effect, set the frame mask to
    LDA #5.b                                                                    ; $01E30E | | update the animation frame every eight frames, set the animation
    STA r_battle_effect_cast_frame_limit.w                                      ; $01E310 | | frame limit to 5, set the radius limit to 20, set the offset to
    LDA #20.b                                                                   ; $01E313 | | zero (for the white magic effect), and to load $AE as the palette
    STA r_battle_effect_cast_radius_limit.w                                     ; $01E315 | | value, which will use the blue/white gradient for both palettes in
    STZ r_battle_effect_cast_offset.w                                           ; $01E318 | | the cycle and (pointlessly) cycle the palette every two frames.
    LDA #$AE.b                                                                  ; $01E31B | |
    BRA +                                                                       ; $01E31D |/
++  LDA #%00000011.b                                                            ; $01E31F |\
    STA r_battle_effect_cast_frame_mask.w                                       ; $01E321 | | If this is the call magic cast effect, set the frame mask to
    LDA #8.b                                                                    ; $01E324 | | update the animation frame every four frames, set the animation
    STA r_battle_effect_cast_frame_limit.w                                      ; $01E326 | | frame limit to 8, set the radius limit to 255 (instead limited by
    LDA #8.b                                                                    ; $01E329 | | frame), set the offset to eight (to use the call magic sprites),
    STA r_battle_effect_cast_offset.w                                           ; $01E32B | | and to load $9E as the palette value, which will use the green-red
    LDA #255.b                                                                  ; $01E32E | | gradient for both palettes in the cycle and (pointlessly) cycle
    STA r_battle_effect_cast_radius_limit.w                                     ; $01E330 | | the palette every two frames.
    LDA #$9E.b                                                                  ; $01E333 |/
+   JSL bank02.battle_effect_set_palette_or_flash                               ; $01E335 | Set the configured palette value.
    JSR _battle_reset_effect_oam_large                                          ; $01E339 | Reset the effect OAM to large sprites.
    JSL bank02.battle_effect_initialize_sine_indexes                            ; $01E33C | Initialize the sine indexes.
    TDC                                                                         ; $01E340 |\
    TAX                                                                         ; $01E341 | | Loop through the eight sine indexes, incrementing each by a
-   PHA                                                                         ; $01E342 | | multiple of 32, corresponding to the index. This results in the
    JSR _battle_effect_increment_sine_indexes                                   ; $01E343 | | eight values being evenly distributed throughout the sine data.
    PLA                                                                         ; $01E346 | |
    CLC                                                                         ; $01E347 | |
    ADC #32.b                                                                   ; $01E348 | |
    INX                                                                         ; $01E34A | |
    CPX #8.w                                                                    ; $01E34B | |
    BNE -                                                                       ; $01E34E |/
    TDC                                                                         ; $01E350 |\ Initialize the sine magnitude arrays to zero.
    JSL bank02.battle_effect_initialize_sine_magnitude                          ; $01E351 |/
    LDA r_battle_current_actor_slot.w                                           ; $01E355 |\
    ASL A                                                                       ; $01E358 | | Set the X register to the actor slot times two.
    TAX                                                                         ; $01E359 |/
    LDA r_battle_character_cursor_coordinates_copy_2.1.x.w,X                    ; $01E35A |\
    CLC                                                                         ; $01E35D | | Set the center X coordinate to the actor's cursor X coordinate
    ADC #16.b                                                                   ; $01E35E | | plus sixteen.
    STA r_battle_effect_cast_coordinates.x.w                                    ; $01E360 |/
    LDA r_battle_character_cursor_coordinates_copy_2.1.y.w,X                    ; $01E363 |\
    SEC                                                                         ; $01E366 | | Set the center Y coordinate to the actor's cursor Y coordinate
    SBC #8.b                                                                    ; $01E367 | | minus eight.
    STA r_battle_effect_cast_coordinates.y.w                                    ; $01E369 |/
    STZ r_battle_effect_cast_current_frame.w                                    ; $01E36C | Initialize the current animation frame to zero.
    STZ r_battle_effect_cast_frame_counter.w                                    ; $01E36F | Initialize the frame counter to zero.
    STZ r_battle_effect_cast_current_radius.w                                   ; $01E372 | Initialize the radius to zero.
--  JSR _battle_wait_next_frame_preserve_x_y                                    ; $01E375 | Wait for the next frame.
    JSR _battle_effect_cast_update_oam                                          ; $01E378 | Update the cast sprite OAM based on the current values.
    JSL bank02.battle_effect_check_palette_cycle                                ; $01E37B | Check and update the current palette cycling.
    LDA r_battle_effect_cast_current_radius.w                                   ; $01E37F |\
    CMP r_battle_effect_cast_radius_limit.w                                     ; $01E382 | | If the current radius is less than the radius limit, update the
    BEQ +                                                                       ; $01E385 | | sine magnitude with the current radius, and then increment the
    LDA r_battle_effect_cast_current_radius.w                                   ; $01E387 | | radius.
    JSL bank02.battle_effect_initialize_sine_magnitude                          ; $01E38A | |
    INC r_battle_effect_cast_current_radius.w                                   ; $01E38E |/
+   LDA r_battle_effect_cast_offset.w                                           ; $01E391 |\
    BNE +                                                                       ; $01E394 | | If the offset is set to zero (in other words, if the white magic
    TDC                                                                         ; $01E396 | | effect is the one being done), update the eight sine indexes by
    TAX                                                                         ; $01E397 | | adding four to each, to produce a slow revolution effect around
-   LDA #4.b                                                                    ; $01E398 | | the actor.
    JSR _battle_effect_increment_sine_indexes                                   ; $01E39A | |
    INX                                                                         ; $01E39D | |
    CPX #8.w                                                                    ; $01E39E | |
    BNE -                                                                       ; $01E3A1 |/
+   INC r_battle_effect_cast_frame_counter.w                                    ; $01E3A3 | Increment the frame counter.
    LDA r_battle_effect_cast_frame_counter.w                                    ; $01E3A6 |\
    AND r_battle_effect_cast_frame_mask.w                                       ; $01E3A9 | | If the frame counter, masked by the frame mask is zero, increment
    BNE +                                                                       ; $01E3AC | | the animation frame.
    INC r_battle_effect_cast_current_frame.w                                    ; $01E3AE |/
+   LDA r_battle_effect_cast_current_frame.w                                    ; $01E3B1 |\
    CMP r_battle_effect_cast_frame_limit.w                                      ; $01E3B4 | | Repeat the loop until the animation frame reaches the limit.
    BNE --                                                                      ; $01E3B7 |/
    JSR _battle_reset_effect_oam_large                                          ; $01E3B9 | Reset the effect OAM.
    RTL                                                                         ; $01E3BC

; _battle_effect_cast_update_oam ($01:E3BD)
;
; For the cast effect used by white magic and call magic, updates the sprites
; in OAM for the current frame.
_battle_effect_cast_update_oam:
    TDC                                                                         ; $01E3BD |\
    TAX                                                                         ; $01E3BE | | Initialize the X and Y registers to zero.
    TAY                                                                         ; $01E3BF |/
-   JSR _battle_effect_get_sine_value_2                                         ; $01E3C0 |\
    CLC                                                                         ; $01E3C3 | | Set the current X coordinate to the center X coordinate plus the
    ADC r_battle_effect_cast_coordinates.x.w                                    ; $01E3C4 | | current cosine value.
    STA <r_battle_generic_tmp_index_lo                                          ; $01E3C7 |/
    JSR _battle_effect_get_sine_value                                           ; $01E3C9 |\
    CLC                                                                         ; $01E3CC | | Set the current Y coordinate to the center Y coordinate plus the
    ADC r_battle_effect_cast_coordinates.y.w                                    ; $01E3CD | | current sine value.
    STA <r_battle_generic_tmp_index_2_lo                                        ; $01E3D0 |/
    PHX                                                                         ; $01E3D2 |\
    LDA r_battle_effect_cast_current_frame.w                                    ; $01E3D3 | | Load the flags and tile number from ROM based on the two arguments
    CLC                                                                         ; $01E3D6 | | and put them in the appropriate places.
    ADC r_battle_effect_cast_offset.w                                           ; $01E3D7 | |
    TAX                                                                         ; $01E3DA | |
    LDA bank0D.battle_effect_cast_oam_flags_data.l,X                            ; $01E3DB | |
    STA <r_battle_generic_tmp_index_3_lo                                        ; $01E3DF | |
    LDA bank0D.battle_effect_cast_oam_tile_data.l,X                             ; $01E3E1 | |
    PLX                                                                         ; $01E3E5 |/
    JSR _battle_set_effect_oam                                                  ; $01E3E6 | Set the OAM values for this sprite.
    INX                                                                         ; $01E3E9 |\
    CPX #8.w                                                                    ; $01E3EA | | Increment the X register and loop until all eight have been done.
    BNE -                                                                       ; $01E3ED |/
    RTS                                                                         ; $01E3EF

; _battle_set_effect_oam ($01:E3F0)
;
; Given a tile number in the accumulator, an index to the desired OAM entry in
; the Y register, an 8-bit X coordinate value in $00, an 8-bit Y coordinate
; value in $02, and the base tile flags in $04, sets the OAM entry (relative to
; the 17th entry) to the passed values.
_battle_set_effect_oam:
    STA r_oam.17.tile.w,Y                                                       ; $01E3F0 | Set the tile number to the value in the accumulator.
    LDA <r_battle_generic_tmp_index_2_lo                                        ; $01E3F3 |\ Set the Y coordinate to the passed value.
    STA r_oam.17.y.w,Y                                                          ; $01E3F5 |/
    LDA r_formation_back_attack_copy.w                                          ; $01E3F8 |\
    BNE +                                                                       ; $01E3FB | | If this is not a back attack, set the X coordinate to the passed
    LDA <r_battle_generic_tmp_index_lo                                          ; $01E3FD | | value and set load the unmodified flags into the accumulator
    STA r_oam.17.x.w,Y                                                          ; $01E3FF | | before branching forward.
    LDA <r_battle_generic_tmp_index_3_lo                                        ; $01E402 | |
    BRA ++                                                                      ; $01E404 |/
+   LDA <r_battle_generic_tmp_index_lo                                          ; $01E406 |\
    EOR #%11111111.b                                                            ; $01E408 | | If this is a back attack, set the X coordinate to the passed value
    SEC                                                                         ; $01E40A | | after flipping the bits and subtracting 16. Load the tile flags
    SBC #16.b                                                                   ; $01E40B | | into the accumulator, but toggle the horizontal flip bit.
    STA r_oam.17.x.w,Y                                                          ; $01E40D | |
    LDA <r_battle_generic_tmp_index_3_lo                                        ; $01E410 | |
    EOR #%01000000.b                                                            ; $01E412 |/
++  STA r_oam.17.flags.w,Y                                                      ; $01E414 | Set the loaded flags as the flags.
    INY                                                                         ; $01E417 |\
    INY                                                                         ; $01E418 | | Increment the Y register by four to move to the next entry.
    INY                                                                         ; $01E419 | |
    INY                                                                         ; $01E41A |/
    RTS                                                                         ; $01E41B

; _battle_reset_effect_oam_large ($01:E41C)
;
; Proxy function to call the battle_reset_effect_oam_large function bank $02.
_battle_reset_effect_oam_large:
    JSL bank02.battle_reset_effect_oam_large                                    ; $01E41C
    RTS                                                                         ; $01E420

; battle_effect_animate_dark_wave ($01:E421)
;
; Animates the actual attack phase of the Dark Wave attack, with the various
; sprites moving from the source to the target sides of the screen.
battle_effect_animate_dark_wave:
    LDA r_battle_current_action_details.target_flags.w                          ; $01E421 |\
    STA r_battle_play_audio_pan_monster.w                                       ; $01E424 | | Play the Dark Wave sound effect, panning it as appropriate to the
    LDA #AUDIO_EFFECT_DARK_WAVE.b                                               ; $01E427 | | target side.
    JSL bank02.battle_play_sound_effect                                         ; $01E429 |/
    JSL set_battle_flash_continuous_blue                                        ; $01E42D |\
    LDA #BATTLE_FLASH_MODE_PULSE.b                                              ; $01E431 | | Configure the flash mode to turn blue immediately, then pulse.
    STA r_battle_flash_mode.w                                                   ; $01E433 |/
    JSR _battle_reset_effect_oam_large                                          ; $01E436 | Reset the effect OAM to large sprites.
    TDC                                                                         ; $01E439 |\
    STA r_battle_effect_sine_index.w + 0                                        ; $01E43A | | Initialize the two sine indexes to 0 and 128, so one will go up
    LDA #128.b                                                                  ; $01E43D | | and the other will go down.
    STA r_battle_effect_sine_index.w + 1                                        ; $01E43F |/
    LDA #40.b                                                                   ; $01E442 |\
    STA r_battle_effect_sine_magnitude.w + 0                                    ; $01E444 | | Set the sine magnitude to 40.
    STA r_battle_effect_sine_magnitude.w + 1                                    ; $01E447 |/
    LDA r_battle_current_actor_slot.w                                           ; $01E44A |\
    ASL A                                                                       ; $01E44D | | Set the X register to the actor's coordinate offset.
    TAX                                                                         ; $01E44E |/
    LDA #72.b                                                                   ; $01E44F |\ Set the projectile target Y coordinate to 72 (roughly the middle of
    STA r_battle_effect_projectile_target_coordinates.y.w                       ; $01E451 |/ the field).
    LDA r_battle_current_action_details.actor_flags.w                           ; $01E454 |\ Branch ahead if the actor is a monster.
    BMI +                                                                       ; $01E457 |/
    STZ r_battle_effect_extra_tile_flags.w                                      ; $01E459 | Don't set any extra tile flags if the actor is a character.
    LDA r_battle_character_cursor_coordinates_copy_2.1.x.w,X                    ; $01E45C |\
    STA r_battle_effect_projectile_source_coordinates.x.w                       ; $01E45F | | Set the projectile source coordinates to the character's position,
    LDA r_battle_character_cursor_coordinates_copy_2.1.y.w,X                    ; $01E462 | | subtracting eight from the Y coordinate to center it.
    SEC                                                                         ; $01E465 | |
    SBC #8.b                                                                    ; $01E466 | |
    STA r_battle_effect_projectile_source_coordinates.y.w                       ; $01E468 |/
    STZ r_battle_effect_projectile_target_coordinates.x.w                       ; $01E46B | Set the target X coordinate to zero (monster side of the screen).
    BRA ++                                                                      ; $01E46E | Branch ahead to the common code.
+   LDA #%01000000.b                                                            ; $01E470 |\ If a monster actor, set extra flags to add the horizontal flip bit.
    STA r_battle_effect_extra_tile_flags.w                                      ; $01E472 |/
    LDA r_battle_monster_coordinates_center.1.x.w,X                             ; $01E475 |\
    STA r_battle_effect_projectile_source_coordinates.x.w                       ; $01E478 | | Set the source projectile coordinates to the monster's center
    LDA r_battle_monster_coordinates_center.1.y.w,X                             ; $01E47B | | coordinates, subtracting 12 from the Y coordinate.
    SEC                                                                         ; $01E47E | |
    SBC #12.b                                                                   ; $01E47F | |
    STA r_battle_effect_projectile_source_coordinates.y.w                       ; $01E481 |/
    LDA #248.b                                                                  ; $01E484 |\ Set the target X coordinate to the character side of the screen.
    STA r_battle_effect_projectile_target_coordinates.x.w                       ; $01E486 |/
++  LDA #8.b                                                                    ; $01E489 |\ Set the projectile horizontal rate to 8 pixels per frame.
    STA r_battle_effect_projectile_horizontal_rate.w                            ; $01E48B |/
    JSL bank02.battle_effect_projectile_initialize                              ; $01E48E | Initialize the projectile variables.
@start:
    JSR _battle_wait_next_frame_preserve_x_y                                    ; $01E492 | Wait for the next frame.
    JSR _battle_effect_dark_wave_shift_effect_oam                               ; $01E495 | Rotate the OAM to prepare for the next sprites.
    JSL bank02.battle_effect_projectile_update_coordinates                      ; $01E498 |\ Update the current projectile coordinates, and branch to the end if
    BCS +                                                                       ; $01E49C |/ the last frame has been reached.
    LDA r_battle_effect_projectile_coordinates.x.w                              ; $01E49E |\
    STA <r_battle_generic_tmp_index_lo                                          ; $01E4A1 | | Transfer the current projectile coordinates to two temporary
    LDA r_battle_effect_projectile_coordinates.y.w                              ; $01E4A3 | | variables.
    STA <r_battle_generic_tmp_index_2_lo                                        ; $01E4A6 |/
    TDC                                                                         ; $01E4A8 |\
    TAY                                                                         ; $01E4A9 | | Push a zero to the stack, and initialize Y to zero.
    PHY                                                                         ; $01E4AA |/
    LDA #$84.b                                                                  ; $01E4AB |\ Set the first OAM entry to tile $84.
    JSR _battle_effect_set_oam_entry                                            ; $01E4AD |/
    LDY #_sizeof_oam_sprite.w * 3                                               ; $01E4B0 |\
    PLX                                                                         ; $01E4B3 | | Set the fourth OAM entry to tile $84, except adjusting the Y
    LDA #$84.b                                                                  ; $01E4B4 | | coordinate based on the sine data.
    JSR _battle_effect_set_sine_adjusted_oam_entry                              ; $01E4B6 |/
    LDY #_sizeof_oam_sprite.w * 6                                               ; $01E4B9 |\
    LDX #1.w                                                                    ; $01E4BC | | Set the seventh OAM entry to tile $84, except adjusting the Y
    LDA #$84.b                                                                  ; $01E4BF | | coordinate based on the sine data.
    JSR _battle_effect_set_sine_adjusted_oam_entry                              ; $01E4C1 |/
    JMP @start                                                                  ; $01E4C4 | Loop back to the start.
+   JSL bank02.battle_effect_load_palette                                       ; $01E4C7 | Load the palette currently stored in $F457.
    STZ r_battle_flash_mode.w                                                   ; $01E4CB | Disable the flash effect.
    RTL                                                                         ; $01E4CE

; _battle_effect_set_sine_adjusted_oam_entry ($01:E4CF)
;
; Given an offset to an OAM entry in the Y register (relative to entry 16), a
; tile value in the accumulator, and a sine index offset in the X register,
; sets that OAM entry to the passed tile, while adjusting the current projectile
; Y coordinate based on the value of the sine.
_battle_effect_set_sine_adjusted_oam_entry:
    PHA                                                                         ; $01E4CF |\ Preserve the accumulator and the Y register.
    PHY                                                                         ; $01E4D0 |/
    LDA #16.b                                                                   ; $01E4D1 |\ Add 16 to the sine index value indicated by the X register.
    JSR _battle_effect_increment_sine_indexes                                   ; $01E4D3 |/
    JSR _battle_effect_get_sine_value                                           ; $01E4D6 | Get the current sine value for the index in the X register.
    CLC                                                                         ; $01E4D9 |\
    ADC r_battle_effect_projectile_coordinates.y.w                              ; $01E4DA | | Set the Y coordinate by adding the sine value to the base Y.
    STA <r_battle_generic_tmp_index_2_lo                                        ; $01E4DD |/
    PLY                                                                         ; $01E4DF |\ Restore the accumulator and Y register.
    PLA                                                                         ; $01E4E0 |/
    JMP _battle_effect_set_oam_entry                                            ; $01E4E1 | Set the OAM entry to the passed tile and adjusted coordinate.

; _battle_effect_dark_wave_shift_effect_oam ($01:E4E4)
;
; Shifts the OAM entries in slots 16 through 23 to spots 17 through 24, adding
; two to their tile numbers in the process.
_battle_effect_dark_wave_shift_effect_oam:
    LDY #_sizeof_oam_sprite.w * 7                                               ; $01E4E4 | Initialize the Y register to point to the eighth sprite.
    REP #FLAG_P_ACCUMULATOR                                                     ; $01E4E7 | Switch to 16-bit accumulator mode.
-   LDA r_oam.17.x.w,Y                                                          ; $01E4E9 |\
    STA r_oam.18.x.w,Y                                                          ; $01E4EC | | Copy the sprite in the current position to the next position,
    LDA r_oam.17.tile.w,Y                                                       ; $01E4EF | | adding 2 to the tile number in the process (to move to the next
    CLC                                                                         ; $01E4F2 | | sprite).
    ADC #2.w                                                                    ; $01E4F3 | |
    STA r_oam.18.tile.w,Y                                                       ; $01E4F6 |/
    DEY                                                                         ; $01E4F9 |\
    DEY                                                                         ; $01E4FA | | Decrement the Y register four times to move to the next OAM
    DEY                                                                         ; $01E4FB | | entry.
    DEY                                                                         ; $01E4FC |/
    CPY #-4.w                                                                   ; $01E4FD |\ Loop until all of the OAM entries have been updated.
    BNE -                                                                       ; $01E500 |/
    TDC                                                                         ; $01E502 |\ Switch back to 8-bit accumulator mode.
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01E503 |/
    RTS                                                                         ; $01E505

; _battle_effect_spell_white_set_oam_entry ($01:E506)
;
; Given an X coordinate in $00, a Y coordinate in $02, and the offset to the
; desired OAM entry (relative to entry 16) in the Y register, sets that OAM
; entry in the OAM mirror in RAM. Sets parameters and falls through to the next
; function.
_battle_effect_spell_white_set_oam_entry:
    STZ r_battle_effect_extra_tile_flags.w                                      ; $01E506
    LDA #$82.b                                                                  ; $01E509

; _battle_effect_set_oam_entry ($01:E50B)
;
; Given a tile number in the accumulator, an X coordinate in $00, a Y coordinate
; in $02, a set of flags to toggle in $F484, and the offset to the desired OAM
; entry (relative to entry 16) in the Y register, sets that OAM entry in the
; OAM mirror in RAM.
_battle_effect_set_oam_entry:
    STA r_oam.17.tile.w,Y                                                       ; $01E50B | Set the tile number to the value in the accumulator.
    LDA <r_battle_generic_tmp_index_2_lo                                        ; $01E50E |\ Set the Y coordinate to the value in $02.
    STA r_oam.17.y.w,Y                                                          ; $01E510 |/
    LDA r_formation_back_attack_copy.w                                          ; $01E513 |\
    BNE +                                                                       ; $01E516 | | If this is not a back attack, set the X coordinate to the value in
    LDA <r_battle_generic_tmp_index_lo                                          ; $01E518 | | $00 and set the tile flags to priority 3, palette 7, using the
    STA r_oam.17.x.w,Y                                                          ; $01E51A | | high name table.
    LDA #%00111111.b                                                            ; $01E51D | |
    BRA ++                                                                      ; $01E51F |/
+   LDA <r_battle_generic_tmp_index_lo                                          ; $01E521 |\
    EOR #%11111111.b                                                            ; $01E523 | | If it is a back attack, flip the X coordinate bits, and add the
    STA r_oam.17.x.w,Y                                                          ; $01E525 | | horizontal flip bit to the flags.
    LDA #%01111111.b                                                            ; $01E528 |/
++  EOR r_battle_effect_extra_tile_flags.w                                      ; $01E52A |\ Apply any extra flags using EOR (to potentially unset the
    STA r_oam.17.flags.w,Y                                                      ; $01E52D |/ horizontal flip bit) and then save to the flags variable.
    INY                                                                         ; $01E530 |\
    INY                                                                         ; $01E531 | | Increment the Y register by four to move to the next OAM entry.
    INY                                                                         ; $01E532 | |
    INY                                                                         ; $01E533 |/
    RTS                                                                         ; $01E534

; _battle_effect_spell_white_shift_and_mirror_oam ($01:E535)
;
; Shifts the OAM entries back one slot from indexes 16 through 33. Afterward,
; horizontally mirrors the entries from 16 through 31 to entries 32 through 47.
_battle_effect_spell_white_shift_and_mirror_oam:
    JSR _battle_shift_sixteen_effect_oam                                        ; $01E535 | Shift the entries back one spot.
    JMP _battle_mirror_sixteen_effect_oam                                       ; $01E538 | Mirror the first entries to the second set.

; _battle_shift_sixteen_effect_oam ($01:E53B)
;
; Shifts the OAM entries starting from index 16 through index 33. Each entry is
; shifted one index higher, with whatever having previously been in entry 33
; being discarded.
;
; NOTE: This is probably two indexes further than is actually desired, but since
;       another routine mirrors the sprites in 16-31 horizontally to 32-47, it
;       probably doesn't end up mattering much.
_battle_shift_sixteen_effect_oam:
    LDY #_sizeof_oam_sprite.w * 16                                              ; $01E53B | Initialize the Y register to 64.
    REP #FLAG_P_ACCUMULATOR                                                     ; $01E53E | Switch to 16-bit mode to reduce the number of instructions.
-   LDA r_oam.17.x.w,Y                                                          ; $01E540 |\ Transfer the X and Y coordinate from one sprite to the next sprite.
    STA r_oam.18.x.w,Y                                                          ; $01E543 |/
    LDA r_oam.17.tile.w,Y                                                       ; $01E546 |\ Repeat with the tile and flags.
    STA r_oam.18.tile.w,Y                                                       ; $01E549 |/
    DEY                                                                         ; $01E54C |\
    DEY                                                                         ; $01E54D | | Decrement the Y register by four to move to the next entry.
    DEY                                                                         ; $01E54E | |
    DEY                                                                         ; $01E54F |/
    CPY #-4.w                                                                   ; $01E550 |\ Loop until all of the sprites have been shifted.
    BNE -                                                                       ; $01E553 |/
    TDC                                                                         ; $01E555 |\ Return to 8-bit accumulator mode.
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01E556 |/
    RTS                                                                         ; $01E558

; _battle_mirror_sixteen_effect_oam ($01:E559)
;
; Mirrors the sixteen sprites in the OAM from index 16 to 31 to the slots at
; indexes 32 through 47. The X coordinate bits are flipped to roughly mirror it
; on screen.
_battle_mirror_sixteen_effect_oam:
    TDC                                                                         ; $01E559 |\ Initialize the Y register to zero.
    TAY                                                                         ; $01E55A |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $01E55B | Switch to 16-bit accumulator mode to work with two bytes at a time.
-   LDA r_oam.17.x.w,Y                                                          ; $01E55D |\
    EOR #$00FF.w                                                                ; $01E560 | | Transfer the X and Y coordinates, flipping the X bits.
    STA r_oam.33.x.w,Y                                                          ; $01E563 |/
    LDA r_oam.17.tile.w,Y                                                       ; $01E566 |\ Transfer the tile and tile flags.
    STA r_oam.33.tile.w,Y                                                       ; $01E569 |/
    INY                                                                         ; $01E56C |\
    INY                                                                         ; $01E56D | | increment the Y register by four to move to the next OAM entry.
    INY                                                                         ; $01E56E | |
    INY                                                                         ; $01E56F |/
    CPY #_sizeof_oam_sprite.w * 16                                              ; $01E570 |\ Loop until all sixteen sprites have been mirrored.
    BNE -                                                                       ; $01E573 |/
    TDC                                                                         ; $01E575 |\ Switch back to 8-bit accumulator mode.
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01E576 |/
    RTS                                                                         ; $01E578

; battle_animate_spell_white ($01:E579)
;
; Animates the White spell.
battle_animate_spell_white:
    JSR _battle_reset_effect_oam_large                                          ; $01E579 | Reset the effect OAM to large sprites.
    JSL bank02.battle_effect_initialize_sine_indexes                            ; $01E57C | Initialize the sine indexes.
    LDA #16.b                                                                   ; $01E580 |\
    STA r_battle_effect_sine_magnitude.w                                        ; $01E582 | | Initialize the sine magnitudes to 16.
    STA r_battle_effect_sine_magnitude_2.w                                      ; $01E585 |/
    TDC                                                                         ; $01E588 |\ Initialize the current X coordinate to zero.
    STA r_battle_effect_spell_white_coordinates.x.w                             ; $01E589 |/
    LDA #48.b                                                                   ; $01E58C |\ Initialize the current Y coordiante to 48.
    STA r_battle_effect_spell_white_coordinates.y.w                             ; $01E58E |/
    JSR _battle_play_sound_effect_spell                                         ; $01E591 | Play the sound effect for the spell.
    JSR _set_battle_flash_pulse_blue                                            ; $01E594 | Start a pulsing blue battle flash effect.
-   JSR _battle_wait_next_frame_preserve_x_y                                    ; $01E597 | Wait for the next frame.
    JSR _battle_effect_spell_white_shift_and_mirror_oam                         ; $01E59A | Shift the current OAM entries and create the mirrored entries.
    TDC                                                                         ; $01E59D |\
    TAX                                                                         ; $01E59E | | Set the Y coordinate to the current base Y coordinate plus the
    JSR _battle_effect_get_sine_value                                           ; $01E59F | | current sine value.
    CLC                                                                         ; $01E5A2 | |
    ADC r_battle_effect_spell_white_coordinates.y.w                             ; $01E5A3 | |
    STA <r_battle_generic_tmp_index_2_lo                                        ; $01E5A6 |/
    LDA r_battle_effect_spell_white_coordinates.x.w                             ; $01E5A8 |\ Set the X coordinate to the current base X coordinate.
    STA <r_battle_generic_tmp_index_lo                                          ; $01E5AB |/
    TDC                                                                         ; $01E5AD |\
    TAX                                                                         ; $01E5AE | | Increment the sine index by 32 (45 degrees).
    LDA #32.b                                                                   ; $01E5AF | |
    JSR _battle_effect_increment_sine_indexes                                   ; $01E5B1 |/
    LDY #0.w                                                                    ; $01E5B4 |\
    TDC                                                                         ; $01E5B7 | | Set the OAM entry in slot zero to the calculated coordinates.
    JSR _battle_effect_spell_white_set_oam_entry                                ; $01E5B8 |/
    DEC r_battle_effect_spell_white_coordinates.y.w                             ; $01E5BB |\ Decrement the Y coordinate by two.
    DEC r_battle_effect_spell_white_coordinates.y.w                             ; $01E5BE |/
    LDA r_battle_effect_spell_white_coordinates.x.w                             ; $01E5C1 |\
    SEC                                                                         ; $01E5C4 | | Subtract eight from the X coordinate.
    SBC #8.b                                                                    ; $01E5C5 | |
    STA r_battle_effect_spell_white_coordinates.x.w                             ; $01E5C7 |/
    CMP #128.b                                                                  ; $01E5CA |\ Loop until the X coordinate reaches 128.
    BNE -                                                                       ; $01E5CC |/
    LDA #192.b                                                                  ; $01E5CE |\
    STA r_battle_effect_sine_index.w                                            ; $01E5D0 | | Initialize the two sine indexes to 192 and 0.
    CLC                                                                         ; $01E5D3 | |
    ADC #64.b                                                                   ; $01E5D4 | |
    STA r_battle_effect_sine_index_2.w                                          ; $01E5D6 |/
    LDA #32.b                                                                   ; $01E5D9 |\
    STA r_battle_effect_sine_magnitude.w                                        ; $01E5DB | | Change the sine magnitude values to 32.
    STA r_battle_effect_sine_magnitude_2.w                                      ; $01E5DE |/
    LDA #128.b                                                                  ; $01E5E1 |\ Set the X coordinate explicitly to 128.
    STA r_battle_effect_spell_white_coordinates.x.w                             ; $01E5E3 |/
    LDA #8.b                                                                    ; $01E5E6 |\ Set the Y coordinate explicitly to 8.
    STA r_battle_effect_spell_white_coordinates.y.w                             ; $01E5E8 |/
-   JSR _battle_wait_next_frame_preserve_x_y                                    ; $01E5EB | Wait for the next frame.
    JSR _battle_effect_spell_white_shift_and_mirror_oam                         ; $01E5EE | Shift and mirror the OAM entries.
    TDC                                                                         ; $01E5F1 |\
    TAX                                                                         ; $01E5F2 | | Set the X coordinate for this sprite to the base X coordinate plus
    JSR _battle_effect_get_sine_value_2                                         ; $01E5F3 | | the current sine value.
    CLC                                                                         ; $01E5F6 | |
    ADC r_battle_effect_spell_white_coordinates.x.w                             ; $01E5F7 | |
    STA <r_battle_generic_tmp_index_lo                                          ; $01E5FA |/
    JSR _battle_effect_get_sine_value                                           ; $01E5FC |\
    CLC                                                                         ; $01E5FF | | Set the Y coordinate to the base Y coordinate plus the current
    ADC r_battle_effect_spell_white_coordinates.y.w                             ; $01E600 | | sine value.
    STA <r_battle_generic_tmp_index_2_lo                                        ; $01E603 |/
    TDC                                                                         ; $01E605 |\
    TAY                                                                         ; $01E606 | | Update the OAM entry.
    JSR _battle_effect_spell_white_set_oam_entry                                ; $01E607 |/
    TDC                                                                         ; $01E60A |\
    TAX                                                                         ; $01E60B | | Increment the sine indexes by 32 (45 degrees).
    LDA #32.b                                                                   ; $01E60C | |
    JSR _battle_effect_increment_sine_indexes                                   ; $01E60E |/
    LDA r_battle_effect_sine_magnitude.w                                        ; $01E611 |\
    CMP #8.b                                                                    ; $01E614 | | If the sine magnitude is less than eight, skip to the next code.
    BCC +                                                                       ; $01E616 |/
    TDC                                                                         ; $01E618 |\
    TAX                                                                         ; $01E619 | | Otherwise, subtract one from the sine magnitudes and branch back
    DEC A                                                                       ; $01E61A | | to the next iteration.
    JSR _battle_effect_increment_sine_magnitudes                                ; $01E61B | |
    JMP -                                                                       ; $01E61E |/
+   TDC                                                                         ; $01E621 |\ Set the X register to zero.
    TAX                                                                         ; $01E622 |/
    LDA r_battle_effect_spell_white_target.w                                    ; $01E623 |\ Transfer the target value to a temporary variable.
    STA <r_battle_generic_tmp_index_3_lo                                        ; $01E626 |/
-   ASL <r_battle_generic_tmp_index_3_lo                                        ; $01E628 |\ Skip this slot if not set in the target variable.
    BCC +++                                                                     ; $01E62A |/
    LDA r_battle_effect_spell_white_target_flags.w                              ; $01E62C |\
    BMI +                                                                       ; $01E62F | | If the target is a party member, load the coordinates from the
    LDA r_battle_character_cursor_coordinates_copy_2.1.x.w,X                    ; $01E631 | | character cursor coordinates.
    STA <r_battle_generic_tmp_index_lo                                          ; $01E634 | |
    LDA r_battle_character_cursor_coordinates_copy_2.1.y.w,X                    ; $01E636 | |
    BRA ++                                                                      ; $01E639 |/
+   LDA r_battle_monster_coordinates_center.1.x.w,X                             ; $01E63B |\
    STA <r_battle_generic_tmp_index_lo                                          ; $01E63E | | Otherwise, load the center monster coordinates.
    LDA r_battle_monster_coordinates_center.1.y.w,X                             ; $01E640 |/
++  STA <r_battle_generic_tmp_index_hi                                          ; $01E643 | Either way, save the second value as the Y coordinate.
    BRA +                                                                       ; $01E645 | Branch ahead to the next code.
+++ INX                                                                         ; $01E647 |\
    INX                                                                         ; $01E648 | | Loop through the slots until the target is found.
    CPX #16.w                                                                   ; $01E649 | |
    BNE -                                                                       ; $01E64C |/
+   LDA #8.b                                                                    ; $01E64E |\ Set the projectile source Y coordinate to 8.
    STA r_battle_effect_projectile_source_coordinates.y.w                       ; $01E650 |/
    LDA <r_battle_generic_tmp_index_lo                                          ; $01E653 |\
    CMP #128.b                                                                  ; $01E655 | | Set the projectile source X coordinates to 88 if the effect will
    BCC +                                                                       ; $01E657 | | be moving to the right, and to 168 if the effect will be moving to
    LDA #88.b                                                                   ; $01E659 | | the left.
    BRA ++                                                                      ; $01E65B | |
+   LDA #168.b                                                                  ; $01E65D | |
++  STA r_battle_effect_projectile_source_coordinates.x.w                       ; $01E65F |/
    LDX <r_battle_generic_tmp_index_lo                                          ; $01E662 |\ Set the projectile target coordinates to the previously loaded
    STX r_battle_effect_projectile_target_coordinates.x.w                       ; $01E664 |/ coordinates of the target.
    LDA #16.b                                                                   ; $01E667 |\ Set the projectile horizontal rate to 16 pixels per frame.
    STA r_battle_effect_projectile_horizontal_rate.w                            ; $01E669 |/
    JSL bank02.battle_effect_projectile_initialize                              ; $01E66C | Initialize the projectile variables.
-   JSR _battle_wait_next_frame_preserve_x_y                                    ; $01E670 | Wait for the next frame.
    JSR _battle_shift_sixteen_effect_oam                                        ; $01E673 | Shift the effect OAM.
    JSL bank02.battle_effect_projectile_update_coordinates                      ; $01E676 |\ Update the projectile coordinates and branch to the end if the
    BCS +                                                                       ; $01E67A |/ target has been reached.
    STZ <r_battle_generic_tmp_index_hi                                          ; $01E67C |\ Initialize the high bytes of the coordinates parameters to zero.
    STZ <r_battle_generic_tmp_index_2_hi                                        ; $01E67E |/
    LDA r_battle_effect_projectile_coordinates.x.w                              ; $01E680 |\
    SEC                                                                         ; $01E683 | | Set the target OAM X coordinate to the projectile X coordinate
    SBC #8.b                                                                    ; $01E684 | | minus eight.
    STA <r_battle_generic_tmp_index_lo                                          ; $01E686 |/
    LDA r_battle_effect_projectile_coordinates.y.w                              ; $01E688 |\
    SEC                                                                         ; $01E68B | | Set the target OAM Y coordinate to the projectile Y coordinate
    SBC #8.b                                                                    ; $01E68C | | minus eight.
    STA <r_battle_generic_tmp_index_2_lo                                        ; $01E68E |/
    TDC                                                                         ; $01E690 |\ Initialize the Y register to zero to set the lowest OAM entry.
    TAY                                                                         ; $01E691 |/
    JSR _battle_effect_spell_white_set_oam_entry                                ; $01E692 | Update the OAM entry with the provided coordinates.
    JMP -                                                                       ; $01E695 | Jump to repeat the loop.
+   STZ r_battle_flash_mode.w                                                   ; $01E698 | Unset the battle flash.
    RTL                                                                         ; $01E69B

; battle_effect_spell_animate_reeling ($01:E69C)
;
; If the current spell being animated causes damage and if the target is one or
; more party members, animate their reeling to the attack.
battle_effect_spell_animate_reeling:
    LDA r_battle_effect_spell_animate_reeling.w                                 ; $01E69C |\ Skip this function if reeling animation is not enabled.
    BEQ @done                                                                   ; $01E69F |/
    LDA r_battle_effect_spell_reeling_monster.w                                 ; $01E6A1 |\ If the monsters would be reeling, skip this function.
    BMI @done                                                                   ; $01E6A4 |/
    JSR _battle_reset_effect_oam_large                                          ; $01E6A6 | Reset the effect OAM to large sprites.
    STZ <r_battle_monster_effect_counter                                        ; $01E6A9 | Initialize the frame counter to zero.
    TDC                                                                         ; $01E6AB |\
    TAY                                                                         ; $01E6AC | | Back up the pose overrides for the five character slots.
-   LDA r_battle_character_pose.w,Y                                             ; $01E6AD | |
    STA r_battle_character_pose_backup.w,Y                                      ; $01E6B0 | |
    INY                                                                         ; $01E6B3 | |
    CPY #5.w                                                                    ; $01E6B4 | |
    BNE -                                                                       ; $01E6B7 |/
--  JSR _battle_wait_next_frame_preserve_x_y                                    ; $01E6B9 | Wait for the next frame.
    LDA r_battle_effect_spell_reeling_targets.w                                 ; $01E6BC |\ Copy the reeling targets into a temporary variable.
    STA <r_battle_generic_tmp_index_lo                                          ; $01E6BF |/
    TDC                                                                         ; $01E6C1 |\ Initialize the Y register to zero.
    TAY                                                                         ; $01E6C2 |/
-   ASL <r_battle_generic_tmp_index_lo                                          ; $01E6C3 |\ Skip this slot if not set as a reeling target.
    BCC +                                                                       ; $01E6C5 |/
    LDA #BATTLE_POSE_REELING.b                                                  ; $01E6C7 |\ Set the character's pose override to reeling.
    STA r_battle_character_pose.w,Y                                             ; $01E6C9 |/
    TYA                                                                         ; $01E6CC |\
    ASL A                                                                       ; $01E6CD | | Set the X register to the slot times sixteen to index the visual
    ASL A                                                                       ; $01E6CE | | properties data.
    ASL A                                                                       ; $01E6CF | |
    ASL A                                                                       ; $01E6D0 | |
    TAX                                                                         ; $01E6D1 |/
    LDA <r_battle_monster_effect_counter                                        ; $01E6D2 |\
    AND #%00000100.b                                                            ; $01E6D4 | | Set the character's X offset to alternate between 4 and 0 every
    EOR #%00000100.b                                                            ; $01E6D6 | | four frames.
    STA r_battle_character_visual_properties.1.x_offset.w,X                     ; $01E6D8 |/
+   INY                                                                         ; $01E6DB |\
    CPY #5.w                                                                    ; $01E6DC | | Loop until all five character slots are set.
    BNE -                                                                       ; $01E6DF |/
    INC <r_battle_monster_effect_counter                                        ; $01E6E1 |\
    LDA <r_battle_monster_effect_counter                                        ; $01E6E3 | | Increment the frame counter and loop until sixteen frames have
    CMP #16.b                                                                   ; $01E6E5 | | passed.
    BNE --                                                                      ; $01E6E7 |/
    TDC                                                                         ; $01E6E9 |\
    TAY                                                                         ; $01E6EA | | Restore the backed up pose override values for each character.
-   LDA r_battle_character_pose_backup.w,Y                                      ; $01E6EB | |
    STA r_battle_character_pose.w,Y                                             ; $01E6EE | |
    INY                                                                         ; $01E6F1 | |
    CPY #5.w                                                                    ; $01E6F2 | |
    BNE -                                                                       ; $01E6F5 |/
@done:
    RTL                                                                         ; $01E6F7

; _battle_effect_spell_fire3_splatter_update_oam ($01:E6F8)
;
; Given the current OAM offset (relative to the 17th entry) in the Y register,
; a base X coordinate in $00, an X offset in $01, a Y coordinate in $02, a Y
; offset in $03, a sine index in $04 and tile flags in $05, udpates that OAM
; entry for the Fire3 splatter effect.
_battle_effect_spell_fire3_splatter_update_oam:
    PHX                                                                         ; $01E6F8 | Preserve the value in the X register.
    LDA r_formation_back_attack_copy.w                                          ; $01E6F9 |\ Branch ahead to other code if not a back attack.
    BEQ +++                                                                     ; $01E6FC |/
    LDA <r_battle_effect_spell_fire3_tmp_x_offset                               ; $01E6FE |\
    CLC                                                                         ; $01E700 | | Add 15 to the X offset.
    ADC #15.b                                                                   ; $01E701 |/
    BPL +                                                                       ; $01E703 |\
    CLC                                                                         ; $01E705 | | If the result is negative (that is, if the offset is less than
    ADC <r_battle_effect_spell_fire3_tmp_x_coordinate                           ; $01E706 | | -15), add the X coordinate, and if the result does not exceed
    BCC @invisible                                                              ; $01E708 | | zero, branch to the inviisble code. Otherwise, to the visible.
    BRA ++                                                                      ; $01E70A |/
+   CLC                                                                         ; $01E70C |\
    ADC <r_battle_effect_spell_fire3_tmp_x_coordinate                           ; $01E70D | | Otherwise, branch to invisible if the sum crosses zero.
    BCS @invisible                                                              ; $01E70F |/
++  EOR #%11111111.b                                                            ; $01E711 |\ If visible, flip the bits and branch ahead.
    BRA @visible                                                                ; $01E713 |/
+++ LDA <r_battle_effect_spell_fire3_tmp_x_offset                               ; $01E715 |\
    BPL +                                                                       ; $01E717 | | If the battle is not a back attack, determine if the sum of the
    CLC                                                                         ; $01E719 | | X coordinate and X offset is invisible or invisible, and branch
    ADC <r_battle_effect_spell_fire3_tmp_x_coordinate                           ; $01E71A | | accordingly.
    BCC @invisible                                                              ; $01E71C | |
    BRA @visible                                                                ; $01E71E | |
+   CLC                                                                         ; $01E720 | |
    ADC <r_battle_effect_spell_fire3_tmp_x_coordinate                           ; $01E721 | |
    BCC @visible                                                                ; $01E723 |/
@invisible:
    LDA #240.b                                                                  ; $01E725 |\
    STA r_oam.17.x.w,Y                                                          ; $01E727 | | If determined to be invisible, set the coordinates to 240 and
    STA r_oam.17.y.w,Y                                                          ; $01E72A | | branch ahead to the end of the function.
    BRA @done                                                                   ; $01E72D |/
@visible:
    STA r_oam.17.x.w,Y                                                          ; $01E72F | If visible, save the calculated value as the X coordinate.
    LDA <r_battle_effect_spell_fire3_tmp_y_coordinate                           ; $01E732 |\
    CLC                                                                         ; $01E734 | | Set the Y coordinate to the sum of the Y coordinate and the Y
    ADC <r_battle_effect_spell_fire3_tmp_y_offset                               ; $01E735 | | offset.
    STA r_oam.17.y.w,Y                                                          ; $01E737 |/
    LDA <r_battle_effect_spell_fire3_tmp_x_sine_index                           ; $01E73A |\
    AND #%01100000.b                                                            ; $01E73C | | Set the X register to a value based on the X coordinate sine
    LSR A                                                                       ; $01E73E | | index, such that it changes every 32 increments, or every 45
    LSR A                                                                       ; $01E73F | | degrees.
    LSR A                                                                       ; $01E740 | |
    LSR A                                                                       ; $01E741 | |
    TAX                                                                         ; $01E742 |/
    LDA bank16.battle_effect_fire3_splatter_oam_tile_data.l + 0,X               ; $01E743 |\ Set the tile number based on the calculated index.
    STA r_oam.17.tile.w,Y                                                       ; $01E747 |/
    LDA bank16.battle_effect_fire3_splatter_oam_tile_data.l + 1,X               ; $01E74A |\
    EOR <r_battle_effect_spell_fire3_tmp_tile_flags                             ; $01E74E | | Set the tile flags based on the calculated index, making sure to
    PHA                                                                         ; $01E750 | | toggle the horizontal flip bit if this is a back attack.
    LDA r_formation_back_attack_copy.w                                          ; $01E751 | |
    BEQ +                                                                       ; $01E754 | |
    PLA                                                                         ; $01E756 | |
    EOR #%01000000.b                                                            ; $01E757 | |
    PHA                                                                         ; $01E759 | |
+   PLA                                                                         ; $01E75A | |
    STA r_oam.17.flags.w,Y                                                      ; $01E75B |/
@done:
    INY                                                                         ; $01E75E |\
    INY                                                                         ; $01E75F | | Increment the Y register by four to move to the next OAM entry.
    INY                                                                         ; $01E760 | |
    INY                                                                         ; $01E761 |/
    PLX                                                                         ; $01E762 | Restore the value in the X register.
    RTS                                                                         ; $01E763

; _battle_effect_spell_fire3_splatter_update_pair ($01:E764)
;
; Updates a pair of sprites for the Fire3 splatter effect. The base X coordinate
; for the center of the overall effect should be in $00, with the base Y
; coordinate in $02. The current OAM entry offset should be in the Y register.
; This will be automatically updated as the two sprites are written.
_battle_effect_spell_fire3_splatter_update_pair:
    LDA <r_battle_effect_spell_fire3_tmp_x_coordinate                           ; $01E764 |\ Preserve the initial value of the X coordinate.
    PHA                                                                         ; $01E766 |/
    LDA <r_battle_effect_spell_fire3_tmp_x_coordinate                           ; $01E767 |\
    SEC                                                                         ; $01E769 | | Subtract 16 from the X coordinate.
    SBC #16.b                                                                   ; $01E76A | |
    STA <r_battle_effect_spell_fire3_tmp_x_coordinate                           ; $01E76C |/
    JSR _battle_effect_get_sine_value_2                                         ; $01E76E |\ Set the X offset to the second sine value.
    STA <r_battle_effect_spell_fire3_tmp_x_offset                               ; $01E771 |/
    JSR _battle_effect_get_sine_value                                           ; $01E773 |\ Set the Y offset to the first sine value.
    STA <r_battle_effect_spell_fire3_tmp_y_offset                               ; $01E776 |/
    LDA r_battle_effect_sine_index_2.w,X                                        ; $01E778 |\ Set the X sine index so the current direction can be determined.
    STA <r_battle_effect_spell_fire3_tmp_x_sine_index                           ; $01E77B |/
    STZ <r_battle_effect_spell_fire3_tmp_tile_flags                             ; $01E77D | Clear the tile flags.
    JSR _battle_effect_spell_fire3_splatter_update_oam                          ; $01E77F | Update the OAM entry for this sprite.
    LDA <r_battle_effect_spell_fire3_tmp_x_coordinate                           ; $01E782 |\
    CLC                                                                         ; $01E784 | | Add 32 to the X coordinate to do the other side.
    ADC #32.b                                                                   ; $01E785 | |
    STA <r_battle_effect_spell_fire3_tmp_x_coordinate                           ; $01E787 |/
    LDA <r_battle_effect_spell_fire3_tmp_x_offset                               ; $01E789 |\
    EOR #%11111111.b                                                            ; $01E78B | | Flip the bits on the X offset to mirror the effect.
    STA <r_battle_effect_spell_fire3_tmp_x_offset                               ; $01E78D |/
    LDA #%01000000.b                                                            ; $01E78F |\ Set the horizontal flip bit on the tile flags.
    STA <r_battle_effect_spell_fire3_tmp_tile_flags                             ; $01E791 |/
    JSR _battle_effect_spell_fire3_splatter_update_oam                          ; $01E793 | Update the OAM entry for this next sprite.
    PLA                                                                         ; $01E796 |\ Restore the original value of the X coordinate.
    STA <r_battle_effect_spell_fire3_tmp_x_coordinate                           ; $01E797 |/
    RTS                                                                         ; $01E799

; battle_effect_spell_fire3_animate_splatter ($01:E79A)
;
; Given the target flags in $F13E and the target value in the accumulator,
; animates the splatter effect of the Fire3 spell.
battle_effect_spell_fire3_animate_splatter:
    STA r_battle_effect_spell_fire3_target.w                                    ; $01E79A | Save the passed value as the target value.
    JSR _battle_reset_effect_oam_large                                          ; $01E79D | Reset the effect OAM to large sprites.
    JSL bank02.battle_effect_initialize_sine_indexes                            ; $01E7A0 | Initialize eight sine indexes.
    TDC                                                                         ; $01E7A4 |\ Initialize the X register to zero.
    TAX                                                                         ; $01E7A5 |/
-   LDA bank16.battle_effect_fire3_splatter_vertical_sine_magnitude_data.l,X    ; $01E7A6 |\ Read the vertical sine magnitude from ROM.
    STA r_battle_effect_sine_magnitude.w,X                                      ; $01E7AA |/
    LDA bank16.battle_effect_fire3_splatter_horizontal_sine_magnitude_data.l,X  ; $01E7AD |\ Read the horizontal sine magnitude from ROM.
    STA r_battle_effect_sine_magnitude_2.w,X                                    ; $01E7B1 |/
    LDA #-4.b                                                                   ; $01E7B4 |\ Subtract four from the sine indexes for this index.
    JSR _battle_effect_increment_sine_indexes                                   ; $01E7B6 |/
    INX                                                                         ; $01E7B9 |\
    CPX #4.w                                                                    ; $01E7BA | | Loop until all four pairs have been initialized.
    BNE -                                                                       ; $01E7BD |/
@outer_start:
    JSR _battle_wait_next_frame_preserve_x_y                                    ; $01E7BF | Wait for the next frame.
    TDC                                                                         ; $01E7C2 |\
    TAY                                                                         ; $01E7C3 | | Initialize the X and Y registers to zero.
    TAX                                                                         ; $01E7C4 |/
    LDA r_battle_effect_spell_fire3_target.w                                    ; $01E7C5 |\ Transfer the target value to a temporary variable.
    STA <r_battle_effect_spell_fire3_tmp_target                                 ; $01E7C8 |/
@inner_start:
    ASL <r_battle_effect_spell_fire3_tmp_target                                 ; $01E7CA |\ Skip this slot if not a target.
    BCC +++                                                                     ; $01E7CC |/
    LDA r_battle_effect_spell_fire3_arg_target_flags.w                          ; $01E7CE |\
    BMI +                                                                       ; $01E7D1 | | If the target is a character, set the base X coordinate and load
    LDA r_battle_character_cursor_coordinates_copy_2.1.x.w,X                    ; $01E7D3 | | the Y coordinate from the character cursor coordinates. Add 16 to
    CLC                                                                         ; $01E7D6 | | the X coordinate.
    ADC #16.b                                                                   ; $01E7D7 | |
    STA <r_battle_effect_spell_fire3_tmp_x_coordinate                           ; $01E7D9 | |
    LDA r_battle_character_cursor_coordinates_copy_2.1.y.w,X                    ; $01E7DB | |
    BRA ++                                                                      ; $01E7DE |/
+   LDA r_battle_monster_coordinates_center.1.x.w,X                             ; $01E7E0 |\
    SEC                                                                         ; $01E7E3 | | If a monster, set the X coordinate to the monster center X
    SBC #12.b                                                                   ; $01E7E4 | | coordinate minus 12, and load the center Y coordinate into the
    STA <r_battle_effect_spell_fire3_tmp_x_coordinate                           ; $01E7E6 | | accumulator.
    LDA r_battle_monster_coordinates_center.1.y.w,X                             ; $01E7E8 |/
++  STA <r_battle_effect_spell_fire3_tmp_y_coordinate                           ; $01E7EB | Save the loaded value as the Y coordinate.
    PHX                                                                         ; $01E7ED |\
    LDX #0.w                                                                    ; $01E7EE | | Loop through the four pairs, updating their OAM entries.
-   JSR _battle_effect_spell_fire3_splatter_update_pair                         ; $01E7F1 | |
    INX                                                                         ; $01E7F4 | |
    CPX #4.w                                                                    ; $01E7F5 | |
    BNE -                                                                       ; $01E7F8 | |
    PLX                                                                         ; $01E7FA |/
+++ INX                                                                         ; $01E7FB |\
    INX                                                                         ; $01E7FC | | Increment the X register by two and loop until all eight slots
    CPX #16.w                                                                   ; $01E7FD | | have been processed.
    BNE @inner_start                                                            ; $01E800 |/
    TDC                                                                         ; $01E802 |\ Initialize the X register to zero.
    TAX                                                                         ; $01E803 |/
-   LDA battle_effect_spell_fire3_splatter_pair_sine_delta_data.l,X             ; $01E804 |\
    JSR _battle_effect_increment_sine_indexes                                   ; $01E808 | | Loop through the four pairs, updating the indexes by adding a
    INX                                                                         ; $01E80B | | value loaded from ROM.
    CPX #4.w                                                                    ; $01E80C | |
    BNE -                                                                       ; $01E80F |/
    LDA r_battle_effect_sine_index.w                                            ; $01E811 |\
    CMP #128.b                                                                  ; $01E814 | | Loop until the first sine index reaches 128.
    BCS @outer_start                                                            ; $01E816 |/
    RTL                                                                         ; $01E818

; battle_effect_spell_fire3_splatter_pair_sine_delta_data ($01:E819)
;
; For each pair of the Fire3 splatter effect, determines the value to add to the
; sine index each cycle.
battle_effect_spell_fire3_splatter_pair_sine_delta_data:
    .db -4                                                                      ; $01E819
    .db -3                                                                      ; $01E81A
    .db -4                                                                      ; $01E81B
    .db -3                                                                      ; $01E81C

; _battle_get_next_rng ($01:E81D)
;
; Increments the battle RNG index at $97 and then returns the associated value
; in the array at $1900.
_battle_get_next_rng:
    INC <r_battle_rng_index                                                     ; $01E81D | Increment the battle RNG index.
    LDA <r_battle_rng_index                                                     ; $01E81F |\
    TAY                                                                         ; $01E821 | | Load the next value in the RNG data.
    LDA r_prng_data.w,Y                                                         ; $01E822 |/
    RTS                                                                         ; $01E825

; battle_effect_fire3_update_coordinate_offsets ($01:E826)
;
; Given an 8-bit mask of sprite indexes to update in $04 (where bit zero
; corresponds to sprite zero), updates the coordinate offsets for that sprite in
; the array at $F459 to new values based on the base coordinate offsets and a
; randomly selected value.
battle_effect_fire3_update_coordinate_offsets:
    PHX                                                                         ; $01E826 | Preserve the value in the X register.
    TDC                                                                         ; $01E827 |\ Set the X register to zero.
    TAX                                                                         ; $01E828 |/
-   LSR <r_battle_effect_fire3_update_coordinate_offsets_arg                    ; $01E829 |\ Skip to the next iteration if the current sprite is not being
    BCC +                                                                       ; $01E82B |/ updated.
    JSR _battle_get_next_rng                                                    ; $01E82D |\
    AND #%00000111.b                                                            ; $01E830 | | Select a random value from 0 to 7 and add it to the base X
    CLC                                                                         ; $01E832 | | coordinate for this sprite index, saving it to a temporary
    ADC bank16.battle_effect_fire3_base_coordinate_offsets.l + 0,X              ; $01E833 | | variable.
    STA <r_battle_generic_tmp_index_lo                                          ; $01E837 |/
    JSR _battle_get_next_rng                                                    ; $01E839 |\
    AND #%00011111.b                                                            ; $01E83C | | Select random value from 0 to 31 and add it to the base Y
    ADC bank16.battle_effect_fire3_base_coordinate_offsets.l + 1,X              ; $01E83E | | coordinate for this sprite index.
    STA <r_battle_generic_tmp_index_hi                                          ; $01E842 |/
    LDA <r_battle_generic_tmp_index_lo                                          ; $01E844 |\
    SEC                                                                         ; $01E846 | | Set the X coordinate to the previously calculated value minus
    SBC #8.b                                                                    ; $01E847 | | eight.
    STA r_battle_effect_fire3_coordinate_offsets.1.x.w,X                        ; $01E849 |/
    LDA <r_battle_generic_tmp_index_hi                                          ; $01E84C |\
    SEC                                                                         ; $01E84E | | Set the Y coordinate to the previously calculated value minus
    SBC #8.b                                                                    ; $01E84F | | eight.
    STA r_battle_effect_fire3_coordinate_offsets.1.y.w,X                        ; $01E851 |/
+   INX                                                                         ; $01E854 |\
    INX                                                                         ; $01E855 | | Increment the X register by two and loop until all four sprites
    CPX #_sizeof_r_battle_effect_fire3_coordinate_offsets.w                     ; $01E856 | | have been checked.
    BNE -                                                                       ; $01E859 |/
    PLX                                                                         ; $01E85B | Restore the value of the X register.
    RTL                                                                         ; $01E85C

; battle_effect_fire3_update_sprites ($01:E85D)
;
; Updates the OAM coordinate offsets for the nine sprites used by the Fire3
; effect.
battle_effect_fire3_update_sprites:
    LDA r_battle_effect_fire3_frame_counter.w                                   ; $01E85D |\
    TAX                                                                         ; $01E860 | | Update the coordinate offsets for the sprite designated to be
    PHX                                                                         ; $01E861 | | updated on this frame.
    LDA bank13.battle_effect_fire3_frame_sprite_mask_data.l,X                   ; $01E862 | |
    STA <r_battle_effect_fire3_update_coordinate_offsets_arg                    ; $01E866 | |
    JSL battle_effect_fire3_update_coordinate_offsets.l                         ; $01E868 |/
    PLX                                                                         ; $01E86C |\
    PHX                                                                         ; $01E86D | | Set the X register to the current alignment data offset for this
    LDA bank16.battle_effect_fire3_sprite_alignment_offset_data.l,X             ; $01E86E | | frame.
    TAX                                                                         ; $01E872 |/
    TDC                                                                         ; $01E873 |\
    TAY                                                                         ; $01E874 | | Initially set the OAM coordinate offsets for the nine sprites to
-   LDA bank16.battle_effect_fire3_sprite_alignment_data.l,X                    ; $01E875 | | the values that will result in the three composite sprites being
    STA r_battle_effect_spell_oam_coordinate_offsets.w,Y                        ; $01E879 | | centered at the same location.
    INX                                                                         ; $01E87C | |
    INY                                                                         ; $01E87D | |
    CPY #18.w                                                                   ; $01E87E | |
    BNE -                                                                       ; $01E881 |/
    PLX                                                                         ; $01E883 |\
    LDA bank16.battle_effect_fire3_sprite_index_map_offset_data.l,X             ; $01E884 | | Set the X register to the offset to the sprite map location.
    TAX                                                                         ; $01E888 |/
    TDC                                                                         ; $01E889 |\ Set the Y register to zero.
    TAY                                                                         ; $01E88A |/
-   LDA bank16.battle_effect_fire3_sprite_index_map_data.l,X                    ; $01E88B |\
    ASL A                                                                       ; $01E88F | | Set the X register to the coordinate offset offset for the current
    PHX                                                                         ; $01E890 | | sprite.
    TAX                                                                         ; $01E891 |/
    LDA r_battle_effect_spell_oam_coordinate_offsets.1.x.w,Y                    ; $01E892 |\
    CLC                                                                         ; $01E895 | | Add the current X coordinate offset to the coordinate offset for
    ADC r_battle_effect_fire3_coordinate_offsets.1.x.w,X                        ; $01E896 | | this sprite.
    STA r_battle_effect_spell_oam_coordinate_offsets.1.x.w,Y                    ; $01E899 |/
    LDA r_battle_effect_spell_oam_coordinate_offsets.1.y.w,Y                    ; $01E89C |\
    CLC                                                                         ; $01E89F | | Repeat with the Y coordinate.
    ADC r_battle_effect_fire3_coordinate_offsets.1.y.w,X                        ; $01E8A0 | |
    STA r_battle_effect_spell_oam_coordinate_offsets.1.y.w,Y                    ; $01E8A3 |/
    PLX                                                                         ; $01E8A6 |\
    INX                                                                         ; $01E8A7 | | Increment the index registers and loop until all nine sprites have
    INY                                                                         ; $01E8A8 | | been updated.
    INY                                                                         ; $01E8A9 | |
    CPY #18.w                                                                   ; $01E8AA | |
    BNE -                                                                       ; $01E8AD |/
    INC r_battle_effect_fire3_frame_counter.w                                   ; $01E8AF |\
    LDA r_battle_effect_fire3_frame_counter.w                                   ; $01E8B2 | | Increment the frame counter and set it back to zero if it reaches
    CMP #9.b                                                                    ; $01E8B5 | | nine.
    BNE +                                                                       ; $01E8B7 | |
    STZ r_battle_effect_fire3_frame_counter.w                                   ; $01E8B9 |/
+   RTL                                                                         ; $01E8BC

; draw_battle_background ($01:E8BD)
;
; Draws the battle background to the battle tilemap area in RAM.
draw_battle_background:
    LDA r_battle_background.w                                                   ; $01E8BD |\
    AND #%00011111.b                                                            ; $01E8C0 | | Load the battle background and mask out all but the lower 5 bits.
    PHA                                                                         ; $01E8C2 |/
    ASL A                                                                       ; $01E8C3 |\
    ASL A                                                                       ; $01E8C4 | | Determine the X register by multiplying by 4.
    TAX                                                                         ; $01E8C5 |/
    LDA bank0D.battle_background_properties_data.l + 3,X                        ; $01E8C6 |\
    STA <r_draw_battle_background_base_arg_base_tile                            ; $01E8CA | | Draw the base of the background.
    LDA bank0D.battle_background_properties_data.l + 2,X                        ; $01E8CC | |
    JSR _draw_battle_background_base                                            ; $01E8D0 |/
    TDC                                                                         ; $01E8D3 |\ Reset the Y register to zero.
    TAY                                                                         ; $01E8D4 |/
    LDA bank0D.battle_background_properties_data.l + 0,X                        ; $01E8D5 |\
    PHX                                                                         ; $01E8D9 | | Draw the upper portion of the background.
    JSR _set_x_to_a_times_256                                                   ; $01E8DA | |
    JSR _draw_battle_background_section                                         ; $01E8DD |/
    PLX                                                                         ; $01E8E0 |\
    LDA bank0D.battle_background_properties_data.l + 1,X                        ; $01E8E1 | | If the additional section value is non-zero, draw the background
    BEQ +                                                                       ; $01E8E5 | | section to replace the first eight of the lower ten rows.
    JSR _set_x_to_a_times_256                                                   ; $01E8E7 | |
    JSR _draw_battle_background_section                                         ; $01E8EA |/
+   PLA                                                                         ; $01E8ED |\
    CMP #BATTLE_BACKGROUND_ZEROMUS.b                                            ; $01E8EE | | If the battle background is the Zeromus background, raise the
    BNE ++                                                                      ; $01E8F0 | | priority of the last four background rows (and an additional 13
    LDX #$0000.w                                                                ; $01E8F2 | | rows for some reason) so that the Zeromus sprite will appear
-   LDA r_battle_tilemap_data.w + (14 * 64) + 1,X                               ; $01E8F5 | | beneath them. (They are partially transparent.)
    ORA #%00100000.b                                                            ; $01E8F8 | |
    STA r_battle_tilemap_data.w + (14 * 64) + 1,X                               ; $01E8FA | |
    INX                                                                         ; $01E8FD | |
    INX                                                                         ; $01E8FE | |
    CPX #17 * 64.w                                                              ; $01E8FF | |
    BNE -                                                                       ; $01E902 |/
++  RTL                                                                         ; $01E904

; _set_x_to_a_times_256 ($01:E905)
;
; Sets the X register to the value in the accumulator times 256.
_set_x_to_a_times_256:
    STA <r_set_x_to_a_times_256_tmp_hi                                          ; $01E905 |\
    STZ <r_set_x_to_a_times_256_tmp_lo                                          ; $01E907 | | Set the high byte of X to the value in the accumulator.
    LDX <r_set_x_to_a_times_256_tmp                                             ; $01E909 |/
    RTS                                                                         ; $01E90B

; _draw_battle_background_base ($01:E90C)
;
; Sets the values in the battle tilemap data to draw the bottom 10 lines of the
; actual background. Takes a single parameter in $06, which is the base tile
; number.
_draw_battle_background_base:
    PHX                                                                         ; $01E90C | Preserve the value of the X register.
    REP #FLAG_P_ACCUMULATOR                                                     ; $01E90D |\
    ASL A                                                                       ; $01E90F | | Calculate the address to read from by starting with $16F880 and
    ASL A                                                                       ; $01E910 | | adding the value passed in the accumulator multiplied by 64.
    ASL A                                                                       ; $01E911 | |
    ASL A                                                                       ; $01E912 | |
    ASL A                                                                       ; $01E913 | |
    ASL A                                                                       ; $01E914 | |
    CLC                                                                         ; $01E915 | |
    ADC #bank16.battle_background_lower_tilemap_data.w                          ; $01E916 | |
    STA <r_draw_battle_background_base_ptr_lo                                   ; $01E919 | |
    TDC                                                                         ; $01E91B | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01E91C | |
    LDA #:bank16.battle_background_lower_tilemap_data.b                         ; $01E91E | |
    STA <r_draw_battle_background_base_ptr_hi                                   ; $01E920 |/
    TDC                                                                         ; $01E922 |\
    TAX                                                                         ; $01E923 | | Initialize the X and Y registers to zero.
    TAY                                                                         ; $01E924 |/
-   LDA [<r_draw_battle_background_base_ptr],Y                                  ; $01E925 |\ Read the next value and save it.
    STA <r_draw_battle_background_base_value                                    ; $01E927 |/
    AND #%10000000.b                                                            ; $01E929 |\ Set the vertical flip variable by isolating the vertical flip bit.
    STA <r_draw_battle_background_base_vflip                                    ; $01E92B |/
    LDA <r_draw_battle_background_base_value                                    ; $01E92D |\
    AND #%00111111.b                                                            ; $01E92F | | Set the low byte of the tilemap by taking the low six bits of the
    INC A                                                                       ; $01E931 | | value, incrementing by one and adding the value of the base tile.
    CLC                                                                         ; $01E932 | |
    ADC <r_draw_battle_background_base_arg_base_tile                            ; $01E933 | |
    STA r_battle_tilemap_data.w + 512,X                                         ; $01E935 |/
    INX                                                                         ; $01E938 | Increment the X register to write the next byte.
    LDA <r_draw_battle_background_base_value                                    ; $01E939 |\
    AND #%01000000.b                                                            ; $01E93B | | Initially set the high byte to the desired palette by shifting the
    LSR A                                                                       ; $01E93D | | palette bit to the correct location and then adding 4, which
    LSR A                                                                       ; $01E93E | | effectively adds one to the palette (palettes 1 and 2 are
    LSR A                                                                       ; $01E93F | | allocated for background use).
    LSR A                                                                       ; $01E940 | |
    CLC                                                                         ; $01E941 | |
    ADC #4.b                                                                    ; $01E942 |/
    ORA #%00000010.b                                                            ; $01E944 | Set the high two bits of the tile number to add $200.
    ORA <r_draw_battle_background_base_vflip                                    ; $01E946 | Set the vertical flip bit if appropriate.
    STA r_battle_tilemap_data.w + 512,X                                         ; $01E948 | Set the high byte.
    INX                                                                         ; $01E94B |\
    INY                                                                         ; $01E94C | | Increment the X and Y registers. Always take the Y register mod 64
    TYA                                                                         ; $01E94D | | so it wraps around every two lines. Loop until all 10 lines have
    AND #%00111111.b                                                            ; $01E94E | | been filled.
    TAY                                                                         ; $01E950 | |
    CPX #32 * 10 * 2.w                                                          ; $01E951 | |
    BNE -                                                                       ; $01E954 |/
    PLX                                                                         ; $01E956 | Restore the X register.
    RTS                                                                         ; $01E957

; _draw_battle_background_section ($01:E958)
;
; Draws a battle background section to the tilemap area in RAM. The target index
; in the tilemap data can be set with the Y register. The X register should be
; set to the correct index to begin reading the relevant tilemap data from ROM.
; (This is the section index times $100).
_draw_battle_background_section:
    LDA #0.b                                                                    ; $01E958 |\ Initialize the count to zero.
    STA <r_draw_battle_background_section_count                                 ; $01E95A |/
-   LDA bank16.battle_background_section_tilemap_data.l,X                       ; $01E95C |\ Load the next value.
    STA <r_draw_battle_background_section_value                                 ; $01E960 |/
    AND #%10000000.b                                                            ; $01E962 |\ Get the vertical flip bit.
    STA <r_draw_battle_background_section_vflip                                 ; $01E964 |/
    LDA <r_draw_battle_background_section_value                                 ; $01E966 |\
    AND #%00111111.b                                                            ; $01E968 | | Set the low eight bits of the tile number by taking the low six
    INC A                                                                       ; $01E96A | | bits of the value.
    STA r_battle_tilemap_data.w,Y                                               ; $01E96B |/
    INY                                                                         ; $01E96E | Increment the Y register to write the next byte.
    LDA <r_draw_battle_background_section_value                                 ; $01E96F |\
    AND #%01000000.b                                                            ; $01E971 | | Initialize the palette index to either 1 or 2 depending on the
    LSR A                                                                       ; $01E973 | | value of the palette bit.
    LSR A                                                                       ; $01E974 | |
    LSR A                                                                       ; $01E975 | |
    LSR A                                                                       ; $01E976 | |
    CLC                                                                         ; $01E977 | |
    ADC #4.b                                                                    ; $01E978 |/
    ORA #%00000010.b                                                            ; $01E97A |\ Set the vertical flip bit if appropriate.
    ORA <r_draw_battle_background_section_vflip                                 ; $01E97C |/
    STA r_battle_tilemap_data.w,Y                                               ; $01E97E | Set the second byte of the tilemap.
    INY                                                                         ; $01E981 |\
    INX                                                                         ; $01E982 | | Increment and repeat until 256 tiles have been set.
    DEC <r_draw_battle_background_section_count                                 ; $01E983 | |
    BNE -                                                                       ; $01E985 |/
    RTS                                                                         ; $01E987

; battle_update_monster_back_row ($01:E988)
;
; Loops through the monsters, determining whether each monster is in the back
; row or not. A monster is in the back row unless it's rightmost tile is
; directly above or below one of the columns of the rightmost monster. The data
; is set in an array at $35EB, which is set to $80 if the monster is in the back
; row, and zero otherwise.
battle_update_monster_back_row:
    TDC                                                                         ; $01E988 |\ Initialize the X register to zero.
    TAX                                                                         ; $01E989 |/
    LDA #%10000000.b                                                            ; $01E98A |\
-   STA r_battle_monsters_back_row.w,X                                          ; $01E98C | | Loop through the back row array, initially setting the back row
    INX                                                                         ; $01E98F | | bit for all monsters.
    CPX #_sizeof_r_battle_monsters_back_row.w                                   ; $01E990 | |
    BNE -                                                                       ; $01E993 |/
    TDC                                                                         ; $01E995 |\ Initialize the X register (and therefore the slot) to zero.
    TAX                                                                         ; $01E996 |/
-   LDA r_sorted_monsters_horizontal_reversed.w,X                               ; $01E997 | Load the ID of the next monster.
    TAY                                                                         ; $01E99A |\
    LDA r_monster_slot_to_id_index_pre_action.w,Y                               ; $01E99B | | Loop through the list of monsters until the first non-empty slot
    CMP #$FF.b                                                                  ; $01E99E | | is found (and therefore the rightmost monster).
    BNE +                                                                       ; $01E9A0 | |
    INX                                                                         ; $01E9A2 | |
    CPX #_sizeof_r_sorted_monsters_horizontal_reversed.w                        ; $01E9A3 | |
    BNE -                                                                       ; $01E9A6 |/
+   LDA r_sorted_monsters_horizontal_reversed.w,X                               ; $01E9A8 |\
    JSR _battle_get_monster_right_x                                             ; $01E9AB | | Determine the X coordinate of the monster, which leaves the left
    LDA <r_battle_generic_tmp_index_lo                                          ; $01E9AE | | X coordinate of the rightmost monster in $02.
    STA <r_battle_generic_tmp_index_2_lo                                        ; $01E9B0 |/
    TDC                                                                         ; $01E9B2 |\ Initialize the slot to zero once again.
    TAX                                                                         ; $01E9B3 |/
-   LDA r_monster_slot_to_id_index_pre_action.w,X                               ; $01E9B4 |\
    CMP #$FF.b                                                                  ; $01E9B7 | | Loop through the eight monsters. If the rightmost tile of the
    BEQ +                                                                       ; $01E9B9 | | monster has an X coordinate that is equal to or greater than the
    TXA                                                                         ; $01E9BB | | coordinate of the rightmost monster's leftmost tile, zero out the
    JSR _battle_get_monster_right_x                                             ; $01E9BC | | back row variable (and therefore put them in the front row).
    DEC A                                                                       ; $01E9BF | |
    CMP <r_battle_generic_tmp_index_2_lo                                        ; $01E9C0 | |
    BCC +                                                                       ; $01E9C2 | |
    TDC                                                                         ; $01E9C4 | |
    STA r_battle_monsters_back_row.w,X                                          ; $01E9C5 | |
+   INX                                                                         ; $01E9C8 | |
    CPX #_sizeof_r_monster_slot_to_id_index_pre_action.w                        ; $01E9C9 | |
    BNE -                                                                       ; $01E9CC |/
    RTL                                                                         ; $01E9CE

; _battle_play_sound_effect_spell ($01:E9CF)
;
; Proxy to call the battle_play_sound_effect_spell function in bank $02.
_battle_play_sound_effect_spell:
    JSL bank02.battle_play_sound_effect_spell                                   ; $01E9CF
    RTS                                                                         ; $01E9D3

; flip_battle_background_tilemap ($01:E9D4)
;
; Flips the portion of the battle tilemap area in RAM that would contain the
; actual background. (The first 18 rows.) The flipping is done horizontally. The
; tiles are relocated and the horizontal flip bits are toggled.
flip_battle_background_tilemap:
    LDX #r_battle_tilemap_data.w                                                ; $01E9D4 |\ Set the pointer to the battle tilemap area.
    STX <r_battle_generic_tmp_index                                             ; $01E9D7 |/
    LDX #18.w                                                                   ; $01E9D9 |\ Set the count to 18 rows, which covers the entire background.
    STX <r_flip_tilemap_rows_arg_rows                                           ; $01E9DC |/
    JMP flip_tilemap_rows                                                       ; $01E9DE | Jump to the flipping function.

; flip_battle_monster_tilemap ($01:E9E1)
;
; First, if $F411 is non-zero, this function shifts the monster tilemap to the
; left by that number of tiles. This is used during the EvilWall battle to
; produce the effect of it moving (by moving it left by a diminishing number
; of tiles).
;
; Afterward (or otherwise if the battle didn't need the shifting effect), it
; calls the flip tilemap function which will flip everything horizontally if
; the battle is a back attack.
;
; BUG: If the battle is a back attack and attempts to use the shifting feature,
;      it will not work as expected, but will instead overwrite RAM, because
;      the row count is not reset before falling through to the flipping
;      function. This will never occur in vanilla, because the only battles that
;      use the shifting effect (EvilWall and a dummied battle) are not back
;      attacks.
flip_battle_monster_tilemap:
    LDX #r_battle_tilemap_data.w                                                ; $01E9E1 |\ Set the pointer to the battle tilemap area.
    STX <r_battle_generic_tmp_index                                             ; $01E9E4 |/
    LDX #18.w                                                                   ; $01E9E6 |\ Set the count to 18 rows, which covers the entire useful area.
    STX <r_flip_tilemap_rows_arg_rows                                           ; $01E9E9 |/
    LDA r_battle_shift_monster_tilemap_columns.w                                ; $01E9EB |\ If the monster tilemap isn't going to be shifted to the left, make
    BEQ flip_tilemap_rows                                                       ; $01E9EE |/ sure the tilemap gets flipped instead (if appropriate).
    ASL A                                                                       ; $01E9F0 |\ Multiply the shift value by two and save it, since we need to move
    STA <r_battle_generic_tmp_count                                             ; $01E9F1 |/ two bytes for each tile.
    CLC                                                                         ; $01E9F3 |\
    ADC <r_battle_generic_tmp_index_lo                                          ; $01E9F4 | | Calculate the second index by taking the initial index and adding
    STA <r_battle_generic_tmp_index_3_lo                                        ; $01E9F6 | | the number of bytes of shift.
    LDA <r_battle_generic_tmp_index_hi                                          ; $01E9F8 | |
    ADC #0.b                                                                    ; $01E9FA | |
    STA <r_battle_generic_tmp_index_3_hi                                        ; $01E9FC |/
    LDA #64.b                                                                   ; $01E9FE |\
    SEC                                                                         ; $01EA00 | | Calculate the number of tiles to copy, by subtracting the shift
    SBC <r_battle_generic_tmp_count                                             ; $01EA01 | | value from 64, transfer it to the Y register, and store it back to
    TAY                                                                         ; $01EA03 | | memory.
    STY <r_battle_generic_tmp_count                                             ; $01EA04 |/
--  REP #FLAG_P_ACCUMULATOR                                                     ; $01EA06 |\
    TDC                                                                         ; $01EA08 | | Initialize the Y register to zero.
    TAY                                                                         ; $01EA09 |/
-   LDA (<r_battle_generic_tmp_index_3),Y                                       ; $01EA0A |\
    STA (<r_battle_generic_tmp_index),Y                                         ; $01EA0C | | Copy tiles from the second location to the first location until
    INY                                                                         ; $01EA0E | | the correct number have been copied.
    INY                                                                         ; $01EA0F | |
    CPY <r_battle_generic_tmp_count                                             ; $01EA10 | |
    BNE -                                                                       ; $01EA12 |/
    LDA #$2200.w                                                                ; $01EA14 |\
-   STA (<r_battle_generic_tmp_index),Y                                         ; $01EA17 | | Fill the remaining tiles in this row with blank tiles.
    INY                                                                         ; $01EA19 | |
    INY                                                                         ; $01EA1A | |
    CPY #64.w                                                                   ; $01EA1B | |
    BNE -                                                                       ; $01EA1E |/
    LDA <r_battle_generic_tmp_index_3                                           ; $01EA20 |\
    CLC                                                                         ; $01EA22 | | Add 64 to the two pointers to move to the next row.
    ADC #64.w                                                                   ; $01EA23 | |
    STA <r_battle_generic_tmp_index_3                                           ; $01EA26 | |
    LDA <r_battle_generic_tmp_index                                             ; $01EA28 | |
    CLC                                                                         ; $01EA2A | |
    ADC #64.w                                                                   ; $01EA2B | |
    STA <r_battle_generic_tmp_index                                             ; $01EA2E |/
    TDC                                                                         ; $01EA30 |\
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01EA31 | | Loop until the remaining rows have been processed, and then
    DEC <r_flip_tilemap_rows_arg_rows                                           ; $01EA33 | | fall through to the next function. BUG: It will not operate as
    BNE --                                                                      ; $01EA35 |/  expected if the battle is a back attack (never in vanilla).

; flip_tilemap_rows ($01:EA37)
;
; Flips a the rows of a tilemap in RAM at the 16-bit pointer in $00. The number
; of rows is specified in $02.
flip_tilemap_rows:
    LDA r_formation_back_attack_copy.w                                          ; $01EA37 |\ Skip this function if the battle is not a back attack.
    BEQ +                                                                       ; $01EA3A |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $01EA3C |\
--  TDC                                                                         ; $01EA3E | | Initialize the Y register to zero.
    TAY                                                                         ; $01EA3F |/
-   LDA (<r_battle_generic_tmp_index),Y                                         ; $01EA40 |\
    PHA                                                                         ; $01EA42 | | Push the 32 tile property words for the row to the stack.
    INY                                                                         ; $01EA43 | |
    INY                                                                         ; $01EA44 | |
    CPY #64.w                                                                   ; $01EA45 | |
    BNE -                                                                       ; $01EA48 |/
    TDC                                                                         ; $01EA4A |\ Zero out the Y register.
    TAY                                                                         ; $01EA4B |/
-   PLA                                                                         ; $01EA4C |\
    EOR #%01000000 << 8.w                                                       ; $01EA4D | | Replace the 32 tiles in the reverse order to flip the row. Also
    STA (<r_battle_generic_tmp_index),Y                                         ; $01EA50 | | flip the horizontal flip bit of each tile.
    INY                                                                         ; $01EA52 | |
    INY                                                                         ; $01EA53 | |
    CPY #64.w                                                                   ; $01EA54 | |
    BNE -                                                                       ; $01EA57 |/
    LDA <r_battle_generic_tmp_index                                             ; $01EA59 |\
    CLC                                                                         ; $01EA5B | | Add 64 to the pointer to move to the next row.
    ADC #64.w                                                                   ; $01EA5C | |
    STA <r_battle_generic_tmp_index                                             ; $01EA5F |/
    DEC <r_flip_tilemap_rows_arg_rows                                           ; $01EA61 |\ Loop until the row count reaches zero.
    BNE --                                                                      ; $01EA63 |/
    TDC                                                                         ; $01EA65 |\ Switch back to 8-bit accumulator.
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01EA66 |/
+   RTL                                                                         ; $01EA68

; _battle_get_monster_right_x ($01:EA69)
;
; Given a monster slot number in the accumulator, returns the X coordinate of
; that monster plus its width, in tiles. The value is returned in the
; accumulator. The left X coordinate will be left in $00.
_battle_get_monster_right_x:
    TAY                                                                         ; $01EA69 |\ Load the coordinate value for the monster in the given slot.
    LDA r_monster_coordinates.w,Y                                               ; $01EA6A |/
    LSR A                                                                       ; $01EA6D |\
    LSR A                                                                       ; $01EA6E | | Extract the X portion of the coordinate and save it to a local
    LSR A                                                                       ; $01EA6F | | variable.
    LSR A                                                                       ; $01EA70 | |
    STA <r_battle_generic_tmp_index_lo                                          ; $01EA71 |/
    TYA                                                                         ; $01EA73 |\
    ASL A                                                                       ; $01EA74 | | Multiply the Y register by two to index another data structure.
    TAY                                                                         ; $01EA75 |/
    LDA r_monster_size.1.width.w,Y                                              ; $01EA76 |\
    CLC                                                                         ; $01EA79 | | Add the monster's width to the X coordinate.
    ADC <r_battle_generic_tmp_index_lo                                          ; $01EA7A |/
    RTS                                                                         ; $01EA7C

; _math_divide_16bit ($01:EA7D)
;
; Divides the 16-bit value in $1C by the 16-bit value in $1E. The 16-bit result
; is returned in $20 and the remainder is returned in $22.
_math_divide_16bit:
    PHX                                                                         ; $01EA7D |\
    REP #FLAG_P_ACCUMULATOR                                                     ; $01EA7E | | Preserve the values of the X register and accumulator.
    PHA                                                                         ; $01EA80 |/
    STZ <r_math_divide_16bit_result                                             ; $01EA81 |\ Zero out the result and remainder values.
    STZ <r_math_divide_16bit_remainder                                          ; $01EA83 |/
    LDA <r_math_divide_16bit_arg_1                                              ; $01EA85 |\
    BEQ ++                                                                      ; $01EA87 | | If either operand is zero, return at this point.
    LDA <r_math_divide_16bit_arg_2                                              ; $01EA89 | |
    BEQ ++                                                                      ; $01EA8B |/
    LDX #16.w                                                                   ; $01EA8D | Loop through all sixteen bits.
-   ROL <r_math_divide_16bit_arg_1                                              ; $01EA90 |\
    ROL <r_math_divide_16bit_remainder                                          ; $01EA92 | | For each bit of the first operand, attempt to subtract the second
    SEC                                                                         ; $01EA94 | | operand. If successful, the set carry bit will rotate into the
    LDA <r_math_divide_16bit_remainder                                          ; $01EA95 | | result. Otherwise, the value is added back and a zero is rotated
    SBC <r_math_divide_16bit_arg_2                                              ; $01EA97 | | into the result. This effectively performs binary long division as
    STA <r_math_divide_16bit_remainder                                          ; $01EA99 | | you would do it on paper.
    BCS +                                                                       ; $01EA9B | |
    LDA <r_math_divide_16bit_remainder                                          ; $01EA9D | |
    ADC <r_math_divide_16bit_arg_2                                              ; $01EA9F | |
    STA <r_math_divide_16bit_remainder                                          ; $01EAA1 | |
    CLC                                                                         ; $01EAA3 | |
+   ROL <r_math_divide_16bit_result                                             ; $01EAA4 |/
    DEX                                                                         ; $01EAA6 |\ Loop until all sixteen bits have been processed.
    BNE -                                                                       ; $01EAA7 |/
++  PLA                                                                         ; $01EAA9 |\
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01EAAA | | Restore the values of the X register and accumulator.
    PLX                                                                         ; $01EAAC |/
    RTS                                                                         ; $01EAAD

; set_status_icon_count ($01:EAAE)
;
; Reads the current slot in $47 and for that character, sets the count status
; icon value in $F078, and puts the tile numbers for the first and second digit
; of the count timer in $F079 and $F07A.
set_status_icon_count:
    PHX                                                                         ; $01EAAE |\
    LDA <r_battle_draw_character_sprites_slot                                   ; $01EAAF | | Determine the offset into this character's timer data.
    TAX                                                                         ; $01EAB1 | |
    LDA bank0D.character_slot_to_timer_offset_data.l,X                          ; $01EAB2 | |
    TAX                                                                         ; $01EAB6 |/
    LDA r_battle_timers.1.count.value_lo.w,X                                    ; $01EAB7 |\
    TAX                                                                         ; $01EABA | | Read the timer value for the character's count timer and divide
    STX <r_math_divide_16bit_arg_1                                              ; $01EABB | | by 10 (to separate into two separate digits).
    LDX #10.w                                                                   ; $01EABD | |
    STX <r_math_divide_16bit_arg_2                                              ; $01EAC0 | |
    JSR _math_divide_16bit                                                      ; $01EAC2 |/
    LDA <r_math_divide_16bit_remainder                                          ; $01EAC5 |\
    CLC                                                                         ; $01EAC7 | | Set the value for the second digit by adding $70 (the tile number
    ADC #$70.b                                                                  ; $01EAC8 | | for 0) to the remainder.
    STA r_battle_draw_character_sprites_count_digit_2.w                         ; $01EACA |/
    LDA <r_math_divide_16bit_result                                             ; $01EACD |\
    CLC                                                                         ; $01EACF | | Set the value for the first digit by adding $70 (the tile number
    ADC #$70.b                                                                  ; $01EAD0 | | for 0) to the quotient.
    STA r_battle_draw_character_sprites_count_digit_1.w                         ; $01EAD2 |/
    PLX                                                                         ; $01EAD5 | Restore the value of the X register.
    LDA #BATTLE_POSE_CROUCHING.b                                                ; $01EAD6 |\ Set the character's pose to HP critical.
    STA r_battle_character_visual_properties.1.pose.w,X                         ; $01EAD8 |/
    LDA #SPRITE_STATUS_ICON_COUNT.b                                             ; $01EADB |\ Set the status icon to count.
    STA r_battle_draw_character_sprites_status_icon.w                           ; $01EADD |/
    RTL                                                                         ; $01EAE0

; battle_init_misc ($01:EAE1)
;
; Does some miscellaneous battle initialization, mostly related to initializing
; some data structures in memory, but also sets a few important variables.
battle_init_misc:
    LDA r_formation_back_attack.w                                               ; $01EAE1 |\ Copy the back attack variable into another location used for
    STA r_formation_back_attack_copy.w                                          ; $01EAE4 |/ animation.
    TDC                                                                         ; $01EAE7 |\
    LDX #r_battle_cgram_data.w                                                  ; $01EAE8 | | Zero out RAM from $7EED50 to $7EF4BB.
-   STA 0.w,X                                                                   ; $01EAEB | |
    INX                                                                         ; $01EAEE | |
    CPX #$F4BC.w                                                                ; $01EAEF | |
    BNE -                                                                       ; $01EAF2 |/
    LDX #$180C.w                                                                ; $01EAF4 |\
-   STA 0.w,X                                                                   ; $01EAF7 | | Zero out RAM from $7E180C to $7E1846.
    INX                                                                         ; $01EAFA | |
    CPX #$1847.w                                                                ; $01EAFB | |
    BNE -                                                                       ; $01EAFE |/
    TDC                                                                         ; $01EB00 |\
    TAX                                                                         ; $01EB01 | | Initialize various values to zero.
    STZ <r_battle_current_action.manual_pending                                 ; $01EB02 | |
    STZ <r_battle_draw_character_sprites_slot                                   ; $01EB04 | |
    STX <r_battle_current_actor_slot                                            ; $01EB06 | |
    STX <r_battle_menu_flags.1                                                  ; $01EB08 | |
    STX <r_battle_menu_flags.3                                                  ; $01EB0A | |
    STZ <r_battle_monster_effect_counter                                        ; $01EB0C | |
    STX <r_battle_menu_coordinates                                              ; $01EB0E | |
    STX <r_battle_menu_coordinates_backup                                       ; $01EB10 | |
    STZ <r_battle_menu_inventory_index                                          ; $01EB12 | |
    STZ <r_battle_current_slot_incapacitated                                    ; $01EB14 | |
    STX <r_battle_joypad_repeat                                                 ; $01EB16 | |
    STX <r_battle_joypad_pressed                                                ; $01EB18 |/
    STA r_battle_ppu_brightness.w                                               ; $01EB1A | Set the brightness variable to zero.
    STA r_battle_ppu_mosaic.w                                                   ; $01EB1D | Disable any mosaic effects.
    INC r_battle_status_icon_timers.1.active.w                                  ; $01EB20 |\
    INC r_battle_status_icon_timers.2.active.w                                  ; $01EB23 | | Enable the status icon timers for each character.
    INC r_battle_status_icon_timers.3.active.w                                  ; $01EB26 | |
    INC r_battle_status_icon_timers.4.active.w                                  ; $01EB29 | |
    INC r_battle_status_icon_timers.5.active.w                                  ; $01EB2C |/
-   STA r_battle_weapon_effect_index.w,X                                        ; $01EB2F |\
    INX                                                                         ; $01EB32 | | Initialize every fourth byte from $4F to $5E to zero.
    INX                                                                         ; $01EB33 | |
    INX                                                                         ; $01EB34 | |
    INX                                                                         ; $01EB35 | |
    CPX #16.w                                                                   ; $01EB36 | |
    BNE -                                                                       ; $01EB39 |/
    LDX r_battle_formation.w                                                    ; $01EB3B |\
    CPX #BATTLE_FORMATION_DUMMY.w                                               ; $01EB3E | | If the current battle formation is a dummied overworld battle or
    BNE +                                                                       ; $01EB41 | | the EvilWall battle, set the initial number of colums to shift the
    LDA #2.b                                                                    ; $01EB43 | | monster tilemap to the left.
    BRA ++                                                                      ; $01EB45 | |
+   CPX #BATTLE_FORMATION_EVILWALL.w                                            ; $01EB47 | |
    BNE +                                                                       ; $01EB4A | |
    LDA #18.b                                                                   ; $01EB4C | |
++  STA r_battle_shift_monster_tilemap_columns.w                                ; $01EB4E |/
+   INC r_unknown_f28b.w                                                        ; $01EB51 | TODO: Increment an unknown variable.
    TDC                                                                         ; $01EB54 |\
    TAX                                                                         ; $01EB55 | | Initialize each monster's variable tilemap index to $FF, which
-   LDA #$FF.b                                                                  ; $01EB56 | | indicates either none or that it hasn't been loaded.
    STA r_monster_variable_sprite_index.w,X                                     ; $01EB58 |/
    LDA #$80.b                                                                  ; $01EB5B |\
    STA r_battle_menu_cursor_coordinates.1.x.w,X                                ; $01EB5D | | Initialize the battle cursor coordinates values to $80. The high
    STA r_battle_target_cursor_coordinates.w,X                                  ; $01EB60 | | bit will be set later.
    INX                                                                         ; $01EB63 | |
    CPX #8.w                                                                    ; $01EB64 | |
    BNE -                                                                       ; $01EB67 |/
    LDA #$02.b                                                                  ; $01EB69 |\
    STA r_battle_needed_mp_data.w + 1                                           ; $01EB6B | | Initialize the high bytes of the needed MP tile data to start at
    STA r_battle_needed_mp_data.w + 3                                           ; $01EB6E | | character $200.
    STA r_battle_needed_mp_data.w + 5                                           ; $01EB71 |/
    LDX #$0101.w                                                                ; $01EB74 |\ Ensure the battle menu cursors are hidden by default.
    STX r_battle_menu_cursor_hidden.1.w                                         ; $01EB77 |/
    STX r_battle_hide_arrows.w                                                  ; $01EB7A | Hide the up/down arrows by default.
    STX r_battle_target_cursor_hidden.1.w                                       ; $01EB7D |\ Hide the battle target cursors.
    STX r_battle_target_cursor_hidden.3.w                                       ; $01EB80 |/
    INC r_battle_menu_selected_cursor_hidden.w                                  ; $01EB83 | Hide the selected cursor.
    TDC                                                                         ; $01EB86 |\
    TAX                                                                         ; $01EB87 | | Precompute the offsets for each 8x8 tile in the spell sprite tile
    REP #FLAG_P_ACCUMULATOR                                                     ; $01EB88 | | data.
    LDA #bank0C.battle_sprite_spell_tile_data.w                                 ; $01EB8A | |
-   STA r_battle_spell_tile_offsets.l,X                                         ; $01EB8D | |
    CLC                                                                         ; $01EB91 | |
    ADC #24.w                                                                   ; $01EB92 | |
    INX                                                                         ; $01EB95 | |
    INX                                                                         ; $01EB96 | |
    CPX #_sizeof_r_battle_spell_tile_offsets.w                                  ; $01EB97 | |
    BNE -                                                                       ; $01EB9A | |
    LDA #0.w                                                                    ; $01EB9C | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01EB9F |/
    TDC                                                                         ; $01EBA1 |\
    TAX                                                                         ; $01EBA2 | | Load the HDMA scroll deltas for the Zeromus battle background
-   LDA bank03.zeromus_background_scroll_delta_normal_data.l,X                  ; $01EBA3 | | while it is moving normally.
    STA r_battle_zeromus_background_scroll_delta.w,X                            ; $01EBA7 | |
    INX                                                                         ; $01EBAA | |
    CPX #_sizeof_r_battle_zeromus_background_scroll_delta.w                     ; $01EBAB | |
    BNE -                                                                       ; $01EBAE |/
    JSL bank03.battle_update_color_math                                         ; $01EBB0 | Update the battle color math settings.
    LDA #$18.b                                                                  ; $01EBB4 |\
    STA r_unknown_01dd.w                                                        ; $01EBB6 | | TODO: Set two unknown variables.
    LDA #$03.b                                                                  ; $01EBB9 | |
    STA r_unknown_01dc.w                                                        ; $01EBBB |/
    RTL                                                                         ; $01EBBE

; battle_initialize_pause_tilemap ($01:EBBF)
;
; Writes the word "PAUSE" onto the pause tilemap mirror.
battle_initialize_pause_tilemap:
    TDC                                                                         ; $01EBBF |\
    TAX                                                                         ; $01EBC0 | | Initialize the X and Y registers to zero.
    TAY                                                                         ; $01EBC1 |/
-   LDA bank16.pause_text_data.l,X                                              ; $01EBC2 |\ Copy the next byte and write it to the tilemap mirror.
    STA r_battle_tilemap_bg3_pause.w + 64 + 28,Y                                ; $01EBC6 |/
    INX                                                                         ; $01EBC9 |\
    INY                                                                         ; $01EBCA | | Increment the X and Y registers.
    INY                                                                         ; $01EBCB |/
    CPX #bank16._sizeof_pause_text_data.w                                       ; $01EBCC |\ Loop until all five tiles have been written.
    BNE -                                                                       ; $01EBCF |/
    RTL                                                                         ; $01EBD1

; battle_initialize_menu_hdma_data ($01:EBD2)
;
; Constructs the HDMA data used by the battle menus from $8092 through $8CB1.
; By pre-constructing this data, which contains complete data to render various
; menu elements at the correct location on the screen, menus can be opened or
; closed by copying this data from its primary location to the main BG2 (parry,
; change, and the needed MP display) or BG3 (all other menus) HDMA tables at
; $7992 through $8091.
battle_initialize_menu_hdma_data:
    TDC                                                                         ; $01EBD2 |\
    TAX                                                                         ; $01EBD3 | | Initialize the HDMA tables for BG1, BG2 and BG3 by copying the
-   LDA bank0D.battle_bg_hdma_table_data.l,X                                    ; $01EBD4 | | data from ROM.
    STA r_battle_bg1_hdma_table.w,X                                             ; $01EBD8 | |
    INX                                                                         ; $01EBDB | |
    CPX #21.w                                                                   ; $01EBDC | |
    BNE -                                                                       ; $01EBDF |/
    TDC                                                                         ; $01EBE1 |\
    TAX                                                                         ; $01EBE2 | | Initializes memory from $7612 to $8C31 with zeroes. The first part
-   STA r_battle_bg1_hdma_data.w,X                                              ; $01EBE3 | | of this is the HDMA data for BG1, BG2 and BG3. The remainder may or
    INX                                                                         ; $01EBE6 | | may not be anything. TODO: Is it anything?
    CPX #$1620.w                                                                ; $01EBE7 | |
    BNE -                                                                       ; $01EBEA |/
    TDC                                                                         ; $01EBEC |\
    TAX                                                                         ; $01EBED | | Initially set the BG3 HDMA data to always point to the same line,
    LDA #-2.b                                                                   ; $01EBEE | | which is blank.
-   STA r_battle_bg3_hdma_data.1.vertical_lo.w,X                                ; $01EBF0 | |
    DEC A                                                                       ; $01EBF3 | |
    INX                                                                         ; $01EBF4 | |
    INX                                                                         ; $01EBF5 | |
    INX                                                                         ; $01EBF6 | |
    INX                                                                         ; $01EBF7 | |
    CPX #_sizeof_scroll_hdma_data_entry.w * 224                                 ; $01EBF8 | |
    BNE -                                                                       ; $01EBFB |/
    LDX #_sizeof_scroll_hdma_data_entry.w * 140                                 ; $01EBFD |\
-   LDA r_battle_bg3_hdma_data.1.vertical_lo.w,X                                ; $01EC00 | | Copy those same values into the HDMA data for BG2 starting at line
    DEC A                                                                       ; $01EC03 | | 140 and ending at line 160, so those lines are blank on BG2.
    STA r_battle_bg2_hdma_data.1.vertical_lo.w,X                                ; $01EC04 | |
    INX                                                                         ; $01EC07 | |
    INX                                                                         ; $01EC08 | |
    INX                                                                         ; $01EC09 | |
    INX                                                                         ; $01EC0A | |
    CPX #_sizeof_scroll_hdma_data_entry.w * 160                                 ; $01EC0B | |
    BNE -                                                                       ; $01EC0E |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $01EC10 |\
    TDC                                                                         ; $01EC12 | | Initialize the X register to zero.
    TAX                                                                         ; $01EC13 |/
    LDA #371.w                                                                  ; $01EC14 | Initialize the scroll value to 371 (to shift the dialog to bottom).
    LDY #8.w                                                                    ; $01EC17 | Initialize the pixels to next line value to eight.
-   STA r_battle_menu_hdma_data_main.1.vertical.w,X                             ; $01EC1A | Set the current scroll value for the main HDMA data.
    PHA                                                                         ; $01EC1D |\
    CLC                                                                         ; $01EC1E | | Add 104 and use that value to set the command HDMA data (as that
    ADC #104.w                                                                  ; $01EC1F | | is 104 pixels lower on BG3).
    STA r_battle_menu_hdma_data_command.1.vertical.w,X                          ; $01EC22 |/
    CLC                                                                         ; $01EC25 |\
    ADC #240.w                                                                  ; $01EC26 | | Add 240 for the HP and status scroll data. (The actual data is 248
    STA r_battle_menu_hdma_data_hp_and_status.1.vertical.w,X                    ; $01EC29 |/  pixels lower, but this will render HP and status 8 pixels lower.)
    PLA                                                                         ; $01EC2C | Restore the current base scroll value to the accumulator.
    DEY                                                                         ; $01EC2D |\
    BNE +                                                                       ; $01EC2E | | Decrement the number of pixels until the next line, and if it
    CLC                                                                         ; $01EC30 | | reaches zero, reset it to 12 and add four to the current base
    ADC #4.w                                                                    ; $01EC31 | | scroll value.
    LDY #12.w                                                                   ; $01EC34 |/
+   CPX #_sizeof_scroll_hdma_data_entry.w * 68                                  ; $01EC37 |\
    BNE +                                                                       ; $01EC3A | | After the 68th line is set, add four to the scroll index to skip
    CLC                                                                         ; $01EC3C | | the rest of the last blank line.
    ADC #4.w                                                                    ; $01EC3D |/
+   INX                                                                         ; $01EC40 |\
    INX                                                                         ; $01EC41 | | Increment the X register by four to move to the next entry.
    INX                                                                         ; $01EC42 | |
    INX                                                                         ; $01EC43 |/
    CPX #_sizeof_scroll_hdma_data_entry.w * 76                                  ; $01EC44 |\ Loop until the entries for 76 lines have been set.
    BNE -                                                                       ; $01EC47 |/
    TDC                                                                         ; $01EC49 |\ Initialize the X register to zero.
    TAX                                                                         ; $01EC4A |/
    LDA #367.w                                                                  ; $01EC4B | Initialize the scroll value to 367 (to shift the dialog to bottom).
    LDY #8.w                                                                    ; $01EC4E | Initialize the pixels to next line counter to eight.
-   INC r_battle_menu_hdma_data_inventory.1.horizontal_hi.w,X                   ; $01EC51 | Increment the high horizontal byte to display the right side.
    STA r_battle_menu_hdma_data_inventory.1.vertical.w,X                        ; $01EC54 | Set the current scroll value as the vertical scroll for this line.
    DEY                                                                         ; $01EC57 |\
    BNE +                                                                       ; $01EC58 | | Decrement the pixels to next line counter, and if it reaches zero,
    CLC                                                                         ; $01EC5A | | add four to the scroll value and reset the counter to 12.
    ADC #4.w                                                                    ; $01EC5B | |
    LDY #12.w                                                                   ; $01EC5E |/
+   CPX #_sizeof_scroll_hdma_data_entry.w * 68                                  ; $01EC61 |\
    BNE +                                                                       ; $01EC64 | | If the 68th line has just been set, add 308 to the scroll value to
    CLC                                                                         ; $01EC66 | | reach the bottom of the inventory display.
    ADC #308.w                                                                  ; $01EC67 |/
+   INX                                                                         ; $01EC6A |\
    INX                                                                         ; $01EC6B | | Increment the X register by four to move to the next HDMA entry.
    INX                                                                         ; $01EC6C | |
    INX                                                                         ; $01EC6D |/
    CPX #_sizeof_scroll_hdma_data_entry.w * 76                                  ; $01EC6E |\ Loop until 76 lines have been set.
    BNE -                                                                       ; $01EC71 |/
    TDC                                                                         ; $01EC73 |\ Initialize the X register to zero.
    TAX                                                                         ; $01EC74 |/
    LDA #107.w                                                                  ; $01EC75 | Initialize the scroll value to 107.
    LDY #8.w                                                                    ; $01EC78 | Initialize the number of pixels until next line to eight.
-   STA r_battle_menu_hdma_data_hand_inventory.1.vertical.w,X                   ; $01EC7B | Set the current value as the vertical scroll for this line.
    DEY                                                                         ; $01EC7E |\
    BNE +                                                                       ; $01EC7F | | Decrement the number of pixels until the next line and if it
    CLC                                                                         ; $01EC81 | | zero, add four to the scroll value to skip the blank pixels and
    ADC #4.w                                                                    ; $01EC82 | | reset the count to 12.
    LDY #12.w                                                                   ; $01EC85 |/
+   CPX #_sizeof_scroll_hdma_data_entry.w * 34                                  ; $01EC88 |\
    BNE +                                                                       ; $01EC8B | | If the 34th line has just been set, add four to the scroll index
    CLC                                                                         ; $01EC8D | | to skip to the bottom border.
    ADC #4.w                                                                    ; $01EC8E |/
+   INX                                                                         ; $01EC91 |\
    INX                                                                         ; $01EC92 | | Increment the X register by four to move to the next HDMA entry.
    INX                                                                         ; $01EC93 | |
    INX                                                                         ; $01EC94 |/
    CPX #_sizeof_scroll_hdma_data_entry.w * 40                                  ; $01EC95 |\ Loop until 40 lines have been set.
    BNE -                                                                       ; $01EC98 |/
    TDC                                                                         ; $01EC9A |\ Initialize the X register to zero.
    TAX                                                                         ; $01EC9B |/
-   LDA r_battle_bg3_hdma_data.w + _sizeof_scroll_hdma_data_entry * 216,X       ; $01EC9C |\
    STA r_battle_menu_hdma_data_main.77.horizontal.w,X                          ; $01EC9F | | Copy the horizontal scroll value from the first four lines of the
    STA r_battle_menu_hdma_data_command.77.horizontal.w,X                       ; $01ECA2 | | last eight lines of the BG3 HDMA data to the last four lines of
    INX                                                                         ; $01ECA5 | | the main and command menu HDMA data.
    INX                                                                         ; $01ECA6 | |
    CPX #_sizeof_scroll_hdma_data_entry.w * 4                                   ; $01ECA7 | | NOTE: This may not actually be necessary, and seems pointless.
    BNE -                                                                       ; $01ECAA |/
    TDC                                                                         ; $01ECAC |\ Initialize the X register to zero.
    TAX                                                                         ; $01ECAD |/
-   LDA #257.w                                                                  ; $01ECAE |\ Set the horizontal scroll value to 257, to display the right half
    STA r_battle_menu_hdma_data_mp.1.horizontal.w,X                             ; $01ECB1 |/ side of BG2 and shift one pixel.
    INX                                                                         ; $01ECB4 |\
    INX                                                                         ; $01ECB5 | | Increment the X register by four to move to the next HDMA entry.
    INX                                                                         ; $01ECB6 | |
    INX                                                                         ; $01ECB7 |/
    CPX #_sizeof_scroll_hdma_data_entry.w * 64                                  ; $01ECB8 |\ Loop until 64 lines have been set.
    BNE -                                                                       ; $01ECBB |/
    TDC                                                                         ; $01ECBD |\ Initialize the X register to zero.
    TAX                                                                         ; $01ECBE |/
    LDA #83.w                                                                   ; $01ECBF | Initialize the scroll value to 83.
    LDY #8.w                                                                    ; $01ECC2 | Initalize the pixels until next line index to eight.
-   STA r_battle_menu_hdma_data_change_1.1.vertical.w,X                         ; $01ECC5 |\ Set the scroll value for the top Change and Parry to the current
    STA r_battle_menu_hdma_data_parry_1.1.vertical.w,X                          ; $01ECC8 |/ value.
    PHA                                                                         ; $01ECCB |\
    SEC                                                                         ; $01ECCC | | Subtract 12 and set the scroll value for the top middle Change and
    SBC #12.w                                                                   ; $01ECCD | | Parry. (This moves their display down 12 pixels.)
    STA r_battle_menu_hdma_data_change_2.1.vertical.w,X                         ; $01ECD0 | |
    STA r_battle_menu_hdma_data_parry_2.1.vertical.w,X                          ; $01ECD3 |/
    SEC                                                                         ; $01ECD6 |\
    SBC #12.w                                                                   ; $01ECD7 | | Subtract 12 and set the scroll value for the middle ones.
    STA r_battle_menu_hdma_data_change_3.1.vertical.w,X                         ; $01ECDA | |
    STA r_battle_menu_hdma_data_parry_3.1.vertical.w,X                          ; $01ECDD |/
    SEC                                                                         ; $01ECE0 |\
    SBC #12.w                                                                   ; $01ECE1 | | Subtract 12 and set the scroll value for the bottom middle ones.
    STA r_battle_menu_hdma_data_change_4.1.vertical.w,X                         ; $01ECE4 | |
    STA r_battle_menu_hdma_data_parry_4.1.vertical.w,X                          ; $01ECE7 |/
    SEC                                                                         ; $01ECEA |\
    SBC #12.w                                                                   ; $01ECEB | | Subtract 12 and set the scroll value for the bottom ones.
    STA r_battle_menu_hdma_data_change_5.1.vertical.w,X                         ; $01ECEE | |
    STA r_battle_menu_hdma_data_parry_5.1.vertical.w,X                          ; $01ECF1 |/
    PLA                                                                         ; $01ECF4 | Restore the original pre-subtraction value.
    DEY                                                                         ; $01ECF5 | Decrement the pixels until next line count.
    BNE +                                                                       ; $01ECF6 |\
    CLC                                                                         ; $01ECF8 | | If it reaches zero, add four to the scroll value.
    ADC #4.w                                                                    ; $01ECF9 |/
+   PHA                                                                         ; $01ECFC | Preserve the original scroll value.
    LDA #172.w                                                                  ; $01ECFD |\
    STA r_battle_menu_hdma_data_parry_1.1.horizontal.w,X                        ; $01ED00 | | Set the horizontal scroll value for Parry to 172.
    STA r_battle_menu_hdma_data_parry_2.1.horizontal.w,X                        ; $01ED03 | |
    STA r_battle_menu_hdma_data_parry_3.1.horizontal.w,X                        ; $01ED06 | |
    STA r_battle_menu_hdma_data_parry_4.1.horizontal.w,X                        ; $01ED09 | |
    STA r_battle_menu_hdma_data_parry_5.1.horizontal.w,X                        ; $01ED0C |/
.if FF4_REGION == "JAPAN"                                                       ;         |\
    LDA #444.w                                                                  ; $01ED0F | | Set the horizontal scroll value for Change to 428 (USA) or 444
.else                                                                           ;         | | (Japan).
    LDA #428.w                                                                  ; $01ED0F | |
.endif                                                                          ;         | |
    STA r_battle_menu_hdma_data_change_1.1.horizontal.w,X                       ; $01ED12 | |
    STA r_battle_menu_hdma_data_change_2.1.horizontal.w,X                       ; $01ED15 | |
    STA r_battle_menu_hdma_data_change_3.1.horizontal.w,X                       ; $01ED18 | |
    STA r_battle_menu_hdma_data_change_4.1.horizontal.w,X                       ; $01ED1B | |
    STA r_battle_menu_hdma_data_change_5.1.horizontal.w,X                       ; $01ED1E |/
    PLA                                                                         ; $01ED21 | Restore the scroll value used for the vertical values.
    INX                                                                         ; $01ED22 |\
    INX                                                                         ; $01ED23 | | Increment the X register by four to move to the next HDMA entry.
    INX                                                                         ; $01ED24 | |
    INX                                                                         ; $01ED25 |/
    CPX #_sizeof_scroll_hdma_data_entry.w * 28                                  ; $01ED26 |\ Loop until 28 lines have been set.
    BNE -                                                                       ; $01ED29 |/
    LDX #_sizeof_scroll_hdma_data_entry.w * 7                                   ; $01ED2B | Initialize the X register to point to the eighth line.
    LDY #4.w                                                                    ; $01ED2E | Initialize the pixels to next line count to four.
    LDA #308.w                                                                  ; $01ED31 | Initialize the scroll value to 308 to scroll to the alert box.
-   STA r_battle_bg3_hdma_data.1.vertical.w,X                                   ; $01ED34 | Save the current value as the BG3 scroll value for this line.
    DEY                                                                         ; $01ED37 |\
    BNE +                                                                       ; $01ED38 | | Decrement the pixels to next line counter and if it reaches zero,
    CLC                                                                         ; $01ED3A | | add four to the scroll value.
    ADC #4.w                                                                    ; $01ED3B |/
+   INX                                                                         ; $01ED3E |\
    INX                                                                         ; $01ED3F | | Increment the X register by four to move to the next HDMA entry.
    INX                                                                         ; $01ED40 | |
    INX                                                                         ; $01ED41 |/
    CPX #_sizeof_scroll_hdma_data_entry.w * 32                                  ; $01ED42 |\ Loop until the 32 lines of the alert box area are set.
    BNE -                                                                       ; $01ED45 |/
    TDC                                                                         ; $01ED47 |\
    TAX                                                                         ; $01ED48 | | Initialize 32 lines of HDMA data for the pause window. The scroll
-   LDA #256.w                                                                  ; $01ED49 | | values are set to scroll to the pause window's location in the
    STA r_battle_menu_hdma_data_pause.1.horizontal.w,X                          ; $01ED4C | | lower middle right of BG3.
    LDA #352.w                                                                  ; $01ED4F | |
    STA r_battle_menu_hdma_data_pause.1.vertical.w,X                            ; $01ED52 | |
    INX                                                                         ; $01ED55 | |
    INX                                                                         ; $01ED56 | |
    INX                                                                         ; $01ED57 | |
    INX                                                                         ; $01ED58 | |
    CPX #_sizeof_scroll_hdma_data_entry.w * 32                                  ; $01ED59 | |
    BNE -                                                                       ; $01ED5C |/
    TDC                                                                         ; $01ED5E |\ Return to 8-bit accumulator mode.
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01ED5F |/
    RTL                                                                         ; $01ED61

; battle_set_bg1_scroll_* ($01:ED62)
;
; During battle, updates the BG1 scroll values by updating the HDMA table
; associated with the changes to the scroll registers. The 16-bit horizontal
; scroll value is set in $F406 and the 16-bit vertical value is set in $F408.
; The _with_vertical_offset entry point additionally adds the 16-bit value at
; $2A to the vertical value.
battle_set_bg1_scroll_with_vertical_offset:
    PHX                                                                         ; $01ED62 | Preserve the value of the X register.
    REP #FLAG_P_ACCUMULATOR                                                     ; $01ED63 |\
    LDA r_battle_set_bg1_scroll_arg_vertical.w                                  ; $01ED65 | | Copy the vertical argument to a local variable, adding in the
    CLC                                                                         ; $01ED68 | | extra offset.
    ADC <r_battle_set_bg1_scroll_arg_vertical_offset                            ; $01ED69 | |
    STA <r_battle_generic_tmp_index_2                                           ; $01ED6B |/
    JMP _battle_set_bg1_scroll_common                                           ; $01ED6D | Jump to the common code.
battle_set_bg1_scroll:
    PHX                                                                         ; $01ED70 | Preserve the value of the X register.
    REP #FLAG_P_ACCUMULATOR                                                     ; $01ED71 |\
    LDA r_battle_set_bg1_scroll_arg_vertical.w                                  ; $01ED73 | | Copy the vertical argument to a local variable.
    STA <r_battle_generic_tmp_index_2                                           ; $01ED76 |/
_battle_set_bg1_scroll_common:
    LDA r_battle_set_bg1_scroll_arg_horizontal.w                                ; $01ED78 |\ Copy the horizontal argument to a local variable.
    STA <r_battle_generic_tmp_index                                             ; $01ED7B |/
    TDC                                                                         ; $01ED7D |\ Initialize the X register to zero.
    TAX                                                                         ; $01ED7E |/
-   LDA <r_battle_generic_tmp_index                                             ; $01ED7F |\
    STA r_battle_bg1_hdma_data.1.horizontal.w,X                                 ; $01ED81 | | Set the horizontal scroll values.
    STA r_battle_bg1_hdma_data.36.horizontal.w,X                                ; $01ED84 | |
    STA r_battle_bg1_hdma_data.71.horizontal.w,X                                ; $01ED87 | |
    STA r_battle_bg1_hdma_data.106.horizontal.w,X                               ; $01ED8A |/
    LDA <r_battle_generic_tmp_index_2                                           ; $01ED8D |\
    STA r_battle_bg1_hdma_data.1.vertical.w,X                                   ; $01ED8F | | Set the vertical scroll values.
    STA r_battle_bg1_hdma_data.36.vertical.w,X                                  ; $01ED92 | |
    STA r_battle_bg1_hdma_data.71.vertical.w,X                                  ; $01ED95 | |
    STA r_battle_bg1_hdma_data.106.vertical.w,X                                 ; $01ED98 |/
    INX                                                                         ; $01ED9B |\
    INX                                                                         ; $01ED9C | | Increment the index by four to move to the next entry.
    INX                                                                         ; $01ED9D | |
    INX                                                                         ; $01ED9E |/
    CPX #(35 * _sizeof_scroll_hdma_data_entry).w                                ; $01ED9F |\ Loop until all entries have been updated.
    BNE -                                                                       ; $01EDA2 |/
    TDC                                                                         ; $01EDA4 |\
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01EDA5 | | Restore the value of the X register.
    PLX                                                                         ; $01EDA7 |/
    RTL                                                                         ; $01EDA8

; _battle_effect_spell_exit_update_palette ($01:EDA9)
;
; Given a battle miscellaneous palette number in the accumulator, a target
; palette to write to in the X register, and the byte within that palette to
; update in the Y register, copies that byte from ROM to the specified palette
; both at the specified index and sixteen bytes later (to fill the second half
; of the palette, as the source palettes are only 8 colors each).
_battle_effect_spell_exit_update_palette:
    PHY                                                                         ; $01EDA9 | Preserve the value in the Y register.
    STY <r_battle_generic_tmp_index                                             ; $01EDAA | Save the current byte index in the Y register to a variable.
    REP #FLAG_P_ACCUMULATOR                                                     ; $01EDAC | Switch to 16-bit accumulator mode.
    ASL A                                                                       ; $01EDAE |\
    ASL A                                                                       ; $01EDAF | | Multiply the passed source palette number by sixteen, and save the
    ASL A                                                                       ; $01EDB0 | | result to a temporary variable (to index palette data in ROM).
    ASL A                                                                       ; $01EDB1 | |
    STA <r_math_multiply_8bit_result                                            ; $01EDB2 |/
    TXA                                                                         ; $01EDB4 |\
    ASL A                                                                       ; $01EDB5 | | Set the Y register to the passed target palette number in the X
    ASL A                                                                       ; $01EDB6 | | register times 32 plus the original value in the Y register, to
    ASL A                                                                       ; $01EDB7 | | point to the current byte to write.
    ASL A                                                                       ; $01EDB8 | |
    ASL A                                                                       ; $01EDB9 | |
    CLC                                                                         ; $01EDBA | |
    ADC <r_battle_generic_tmp_index                                             ; $01EDBB | |
    TAY                                                                         ; $01EDBD |/
    LDA <r_math_multiply_8bit_result                                            ; $01EDBE |\
    CLC                                                                         ; $01EDC0 | | Set the X register to the source palette offset plus the current
    ADC <r_battle_generic_tmp_index                                             ; $01EDC1 | | byte index.
    TAX                                                                         ; $01EDC3 |/
    TDC                                                                         ; $01EDC4 |\ Switch back to 8-bit accumulator mode.
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01EDC5 |/
    LDA bank0E.battle_palette_data.l,X                                          ; $01EDC7 |\
    STA r_battle_cgram_data.1.color1.w,Y                                        ; $01EDCB | | Copy the palette byte from ROM to the two parts of the palette.
    STA r_battle_cgram_data.1.color9.w,Y                                        ; $01EDCE |/
    PLY                                                                         ; $01EDD1 | Restore the original value of the Y register.
    RTS                                                                         ; $01EDD2

; battle_animate_exit_palette_change ($01:EDD3)
;
; Animates the rapid transition of the battle background and monster palettes to
; the brown palette used in the Exit animation.
;
; BUG: This function, for whatever reason, omits the third monster palette,
;      which means the monster in that slot retains its existing color until
;      replaced by a later function in the animation.
battle_animate_exit_palette_change:
    TDC                                                                         ; $01EDD3 |\ Initialize the Y register to zero.
    TAY                                                                         ; $01EDD4 |/
-   PHY                                                                         ; $01EDD5 |\
    JSR _battle_wait_next_frame_preserve_x_y                                    ; $01EDD6 | | Wait for the next frame.
    PLY                                                                         ; $01EDD9 |/
    LDX #1.w                                                                    ; $01EDDA |\
    LDA #BATTLE_MISC_PALETTE_EXIT_BACKGROUND.b                                  ; $01EDDD | | Copy the next byte from the background palette to palette 1.
    JSR _battle_effect_spell_exit_update_palette                                ; $01EDDF |/
    LDX #2.w                                                                    ; $01EDE2 |\
    LDA #BATTLE_MISC_PALETTE_EXIT_BACKGROUND.b                                  ; $01EDE5 | | Copy the next byte from the background palette to palette 2.
    JSR _battle_effect_spell_exit_update_palette                                ; $01EDE7 |/
    LDX #3.w                                                                    ; $01EDEA |\
    LDA #BATTLE_MISC_PALETTE_EXIT_MONSTER.b                                     ; $01EDED | | Copy the next byte from the monster palette to palette 3.
    JSR _battle_effect_spell_exit_update_palette                                ; $01EDEF |/
    LDX #4.w                                                                    ; $01EDF2 |\
    LDA #BATTLE_MISC_PALETTE_EXIT_MONSTER.b                                     ; $01EDF5 | | Copy the next byte from the monster palette to palette 4.
    JSR _battle_effect_spell_exit_update_palette                                ; $01EDF7 |/
    LDX #6.w                                                                    ; $01EDFA |\
    LDA #BATTLE_MISC_PALETTE_EXIT_MONSTER.b                                     ; $01EDFD | | Copy the next byte from the monster palette to palette 6.
    JSR _battle_effect_spell_exit_update_palette                                ; $01EDFF |/
    INY                                                                         ; $01EE02 |\
    CPY #16.w                                                                   ; $01EE03 | | Loop until all eight colors have been completely updated.
    BNE -                                                                       ; $01EE06 |/
    RTL                                                                         ; $01EE08

; _battle_wait_next_frame_preserve_x_y ($01:EE09)
;
; Proxy function to call the same function in bank $02.
_battle_wait_next_frame_preserve_x_y:
    JSL bank02.battle_wait_next_frame_preserve_x_y                              ; $01EE09 | Call the function.
    RTS                                                                         ; $01EE0D

; monster_spell_audiovisual_dispatch ($01:EE0E)
;
; Proxy function to call the local function from another bank.
monster_spell_audiovisual_dispatch:
    JSR _monster_spell_audiovisual_dispatch                                     ; $01EE0E | Call the function.
    RTL                                                                         ; $01EE11

; _monster_spell_audiovisual_dispatch ($01:EE12)
;
; Given a monster spell value in the accumulator, dispatches to the correct
; handler for that spell. The spell ID should range from $A9 to $BF.
_monster_spell_audiovisual_dispatch:
    SEC                                                                         ; $01EE12 |\
    SBC #MONSTER_COMMAND_AUDIOVISUAL_BASE.b                                     ; $01EE13 | | Subtract the base value, multiply by two, and transfer to the X
    ASL A                                                                       ; $01EE15 | | register.
    TAX                                                                         ; $01EE16 |/
    LDA monster_spell_audiovisual_pointer_data.l + 0,X                          ; $01EE17 |\
    STA <r_battle_generic_tmp_ptr_2_addr_lo                                     ; $01EE1B | | Load the associated pointer and jump to it.
    LDA monster_spell_audiovisual_pointer_data.l + 1,X                          ; $01EE1D | |
    STA <r_battle_generic_tmp_ptr_2_addr_hi                                     ; $01EE21 | |
    JMP (r_battle_generic_tmp_ptr_2_addr.w)                                     ; $01EE23 |/

; monster_spell_audiovisual_pointer_data ($01:EE26)
;
; For monster spells ranging from $A9 to $BF, provides a pointer to the handler
; for the audiovisual portion of the spell.
monster_spell_audiovisual_pointer_data:
    .addr _monster_spell_audiovisual_noop                                       ; $01EE26.EE27 | $A9: Dummy
    .addr _monster_spell_audiovisual_noop                                       ; $01EE28.EE29 | $AA: Dummy
    .addr _battle_reset_monster_variable_sprites                                ; $01EE2A.EE2B | $AB: Recover
    .addr _battle_reset_monster_variable_sprites                                ; $01EE2C.EE2D | $AC: Remedy
    .addr _monster_spell_audiovisual_next_monster_strobe                        ; $01EE2E.EE2F | $AD: Dummy (transition to next monster)
    .addr _monster_spell_audiovisual_noop                                       ; $01EE30.EE31 | $AE: Dummy (?)
    .addr _monster_spell_audiovisual_evilwall_advance                           ; $01EE32.EE33 | $AF: Dummy (advances EvilWall)
    .addr _monster_spell_audiovisual_clear_caller_status                        ; $01EE34.EE35 | $B0: <unnamed> (clears Caller statuses)
    .addr _monster_spell_audiovisual_activate_caller                            ; $01EE36.EE37 | $B1: <unnamed> (activates Caller in battle)
    .addr _monster_spell_audiovisual_hide_monsters_and_apparitions              ; $01EE38.EE39 | $B2: <unnamed> (hides monsters and apparitions)
    .addr _monster_spell_audiovisual_show_character_apparition_anna             ; $01EE3A.EE3B | $B3: <unnamed> (shows Anna apparition)
    .addr _monster_spell_audiovisual_show_character_apparition_edward_tellah    ; $01EE3C.EE3D | $B4: <unnamed> (shows Edward/Tellah apparitions)
    .addr _monster_spell_audiovisual_show_character_apparition_palom_porom      ; $01EE3E.EE3F | $B5: <unnamed> (shows Palom/Porom apparitions)
    .addr _monster_spell_audiovisual_show_character_apparition_yang_cid         ; $01EE40.EE41 | $B6: <unnamed> (shows Yang/Cid apparitions)
    .addr _monster_spell_audiovisual_show_character_apparition_fusoya_golbez    ; $01EE42.EE43 | $B7: <unnamed> (shows FuSoYa/Golbez apparitions)
    .addr _battle_character_apparitions_hide                                    ; $01EE44.EE45 | $B8: <unnamed> (hides character apparitions)
    .addr _monster_spell_audiovisual_noop                                       ; $01EE46.EE47 | $B9
    .addr _monster_spell_audiovisual_noop                                       ; $01EE48.EE49 | $BA
    .addr _monster_spell_audiovisual_zeromus_shake                              ; $01EE4A.EE4B | $BB: <unnamed> (monsters shake and rumble)
    .addr _monster_spell_audiovisual_noop                                       ; $01EE4C.EE4D | $BC
    .addr _monster_spell_audiovisual_noop                                       ; $01EE4E.EE4F | $BD
    .addr _monster_spell_audiovisual_noop                                       ; $01EE50.EE51 | $BE
    .addr _monster_spell_audiovisual_chime_and_flash                            ; $01EE52.EE53 | $BF: <unnamed> (chime and flash)

; _monster_spell_audiovisual_chime_and_flash ($01:EE54)
;
; Handles a monster spell that plays a chime sound effect and flashes the
; screen.
_monster_spell_audiovisual_chime_and_flash:
    JSL bank03.battle_effect_chime_and_flash                                    ; $01EE54 | Call the chime and flash function.
    RTS                                                                         ; $01EE58

; _monster_spell_audiovisual_evilwall_advance ($01:EE59)
;
; Handles the EvilWall advancement action by decreasing the tilemap shift value
; and playing the EvilWall sound effect (which is actually the large door
; sound effect).
_monster_spell_audiovisual_evilwall_advance:
    LDA r_battle_shift_monster_tilemap_columns.w                                ; $01EE59 |\ If the column shift is already zero, do nothing and return.
    BEQ +                                                                       ; $01EE5C |/
    DEC r_battle_shift_monster_tilemap_columns.w                                ; $01EE5E | Decrement the column shift.
    JSL bank02.battle_animate_monster_transition_if_status                      ; $01EE61 | Animate a status-related transition if appropriate.
    LDA #AUDIO_EFFECT_LARGE_DOOR.b                                              ; $01EE65 |\ Play the large door sound effect.
    JSL bank02.battle_play_sound_effect                                         ; $01EE67 |/
+   RTS                                                                         ; $01EE6B

; _monster_spell_audiovisual_zeromus_shake ($01:EE6C)
;
; Handles the Zeromus shaking animation and sound effect.
_monster_spell_audiovisual_zeromus_shake:
    LDA #AUDIO_EFFECT_RUMBLE.b                                                  ; $01EE6C |\ Begin playing the rumble sound effect.
    JSL bank02.battle_play_sound_effect                                         ; $01EE6E |/
    LDX #64.w                                                                   ; $01EE72 | Initialize the X register to 64.
-   PHX                                                                         ; $01EE75 |\
    JSR _battle_wait_next_frame_preserve_x_y                                    ; $01EE76 | | Loop through the shaking effect for 64 frames.
    JSL bank02.battle_update_shake_scroll                                       ; $01EE79 | |
    PLX                                                                         ; $01EE7D | |
    DEX                                                                         ; $01EE7E | |
    BNE -                                                                       ; $01EE7F |/
    JSL bank02.battle_reset_bg1_bg2_horizontal_scroll                           ; $01EE81 | Reset the horizontal scroll to zero.
    TDC                                                                         ; $01EE85 |\ Stop playing the sound effect.
    JSL bank02.battle_play_sound_effect.l                                       ; $01EE86 |/
    RTS                                                                         ; $01EE8A

; _set_battle_flash_pulse_* ($01:EE8B)
;
; Based on the entry point, configures a pulse flash effect during battle with
; a particular color.
_set_battle_flash_pulse_red:
    LDA #%00100000.b                                                            ; $01EE8B |\ Set the color to red and branch to the actual code.
    BRA _set_battle_flash_pulse_finalize                                        ; $01EE8D |/
_set_battle_flash_pulse_blue:
    LDA #%10000000.b                                                            ; $01EE8F |\ Set the color to blue and branch to the actual code.
    BRA _set_battle_flash_pulse_finalize                                        ; $01EE91 |/
_set_battle_flash_pulse_white:
    LDA #%11100000.b                                                            ; $01EE93 | Set the color to white and fall through.
_set_battle_flash_pulse_finalize:
    STA r_battle_flash_color.w                                                  ; $01EE95 | Set the flash color to the value in the accumulator.
    STZ r_battle_flash_blue_intensity.w                                         ; $01EE98 |\
    STZ r_battle_flash_red_intensity.w                                          ; $01EE9B | | Initialize the intensity of all colors to zero, to start at black.
    STZ r_battle_flash_green_intensity.w                                        ; $01EE9E |/
    LDA #BATTLE_FLASH_MODE_PULSE.b                                              ; $01EEA1 |\ Set the flash mode to pulse.
    STA r_battle_flash_mode.w                                                   ; $01EEA3 |/
    STZ r_battle_flash_counter.w                                                ; $01EEA6 |\ Initialize the flash counter and phase both to zero.
    STZ r_battle_flash_phase.w                                                  ; $01EEA9 |/
    RTS                                                                         ; $01EEAC

; set_battle_flash_continuous_* ($01:EEAD)
;
; Based on the entry point, configures a continuous flash effect during battle
; with a particular color.
set_battle_flash_continuous_magenta:
    LDA #%10100000.b                                                            ; $01EEAD |\ Set the color to magenta and branch to the actual code.
    BRA _set_battle_flash_continuous_finalize                                   ; $01EEAF |/
set_battle_flash_continuous_cyan:
    LDA #%11000000.b                                                            ; $01EEB1 |\ Set the color to cyan and branch to the actual code.
    BRA _set_battle_flash_continuous_finalize                                   ; $01EEB3 |/
set_battle_flash_continuous_yellow:
    LDA #%01100000.b                                                            ; $01EEB5 |\ Set the color to yellow and branch to the actual code.
    BRA _set_battle_flash_continuous_finalize                                   ; $01EEB7 |/
set_battle_flash_continuous_red:
    LDA #%00100000.b                                                            ; $01EEB9 |\ Set the color to red and branch to the actual code.
    BRA _set_battle_flash_continuous_finalize                                   ; $01EEBB |/
set_battle_flash_continuous_green:
    LDA #%01000000.b                                                            ; $01EEBD |\ Set the color to green and branch to the actual code.
    BRA _set_battle_flash_continuous_finalize                                   ; $01EEBF |/
set_battle_flash_continuous_blue:
    LDA #%10000000.b                                                            ; $01EEC1 |\ Set the color to blue and branch to the actual code.
    BRA _set_battle_flash_continuous_finalize                                   ; $01EEC3 |/
set_battle_flash_continuous_white:
    LDA #%11100000.b                                                            ; $01EEC5 | Set the color to white and fall through.
_set_battle_flash_continuous_finalize:
    STA r_battle_flash_color.w                                                  ; $01EEC7 | Set the flash color to the value in the accumulator.
    LDA #31.b                                                                   ; $01EECA |\
    STA r_battle_flash_blue_intensity.w                                         ; $01EECC | | Set the initial intensity for all three colors to maximum.
    STA r_battle_flash_red_intensity.w                                          ; $01EECF | |
    STA r_battle_flash_green_intensity.w                                        ; $01EED2 |/
    LDA #BATTLE_FLASH_MODE_CONTINUOUS.b                                         ; $01EED5 |\ Enable a continuous flash effect.
    STA r_battle_flash_mode.w                                                   ; $01EED7 |/ TODO: Is this what it actually does?
    STZ r_battle_flash_counter.w                                                ; $01EEDA |\ Set both the flash counter and phase to zero.
    STZ r_battle_flash_phase.w                                                  ; $01EEDD |/
    RTL                                                                         ; $01EEE0

; _monster_spell_audiovisual_next_monster_strobe ($01:EEE1)
;
; Resets the variable monster sprites, loads the monster tilemaps, plays a
; transformation sound effect, and animates a transition using the strobe
; transition effect.
_monster_spell_audiovisual_next_monster_strobe:
    JSR _battle_reset_monster_variable_sprites                                  ; $01EEE1 | Reset the variable sprites for the monsters.
    JSL bank02.battle_load_monster_tilemaps                                     ; $01EEE4 | Load the tilemaps for the monsters.
    JSL flip_battle_monster_tilemap                                             ; $01EEE8 | Flip the monster tilemap if necessary.
    LDA #AUDIO_EFFECT_MONSTER_TRANSFORM.b                                       ; $01EEEC |\ Play a monster transformation sound effect.
    JSL bank02.battle_play_sound_effect                                         ; $01EEEE |/
    LDA #MONSTER_TRANSITION_STROBE.b                                            ; $01EEF2 |\ Transition between the monsters using the strobe transition.
    JSL bank02.battle_script_audiovisual_transition_fixed_type                  ; $01EEF4 |/
    RTS                                                                         ; $01EEF8

; _battle_reset_monster_variable_sprites ($01:EEF9)
;
; Resets the variable sprite indexes for all eight monster slots to $FF, which
; will cause them to be reloaded from ROM if applicable.
_battle_reset_monster_variable_sprites:
    TDC                                                                         ; $01EEF9 |\ Initialize the X register to zero
    TAX                                                                         ; $01EEFA |/
    DEC A                                                                       ; $01EEFB | Initialize the accumulator to $FF.
-   STA r_monster_variable_sprite_index.w,X                                     ; $01EEFC |\
    INX                                                                         ; $01EEFF | | Reset the variable sprite indexes for each monster slot to $FF,
    CPX #8.w                                                                    ; $01EF00 | | which will cause them to be reloaded from ROM.
    BNE -                                                                       ; $01EF03 |/
    RTS                                                                         ; $01EF05

; _monster_spell_audiovisual_noop ($01:EF06)
;
; Handles a monster spell that has no audiovisual component.
_monster_spell_audiovisual_noop:
    RTS                                                                         ; $01EF06

; _battle_get_caller_slot ($01:EF07)
;
; Returns the slot number of the Caller in the Y register. If no Caller is in
; the party, it will return zero (which means it's impossible to distinguish
; no Caller from a Caller in slot zero). In addition, the X register will
; contain the offset to that slot's battle stat record.
_battle_get_caller_slot:
    TDC                                                                         ; $01EF07 |\ Initialize the Y register to zero.
    TAY                                                                         ; $01EF08 |/
-   TYA                                                                         ; $01EF09 |\ Transfer the Y register to the X register.
    TAX                                                                         ; $01EF0A |/
    JSL bank02.multiply_x_by_128                                                ; $01EF0B | Multiply the value in the X register by 128.
    LDA r_character_battle.1.sprite_class.w,X                                   ; $01EF0F |\
    AND #%00001111.b                                                            ; $01EF12 | | If this slot has a Caller in it, skip to the end (which leaves the
    CMP #CLASS_CALLER.b                                                         ; $01EF14 | | caller slot in the Y register).
    BEQ +                                                                       ; $01EF16 |/
    INY                                                                         ; $01EF18 |\
    CPY #5.w                                                                    ; $01EF19 | | Increment Y and loop until all character slots are checked.
    BNE -                                                                       ; $01EF1C |/
    TDC                                                                         ; $01EF1E |\ If a Caller wasn't found, set the Y register to zero.
    TAY                                                                         ; $01EF1F |/
+   RTS                                                                         ; $01EF20

; _monster_spell_audiovisual_activate_caller ($01:EF21)
;
; Activates the caller in the party by having her enter from the right. Also
; pointlessly animates some things you can't see because she's invisible during.
; Used in the Golbez battle to display Rydia.
_monster_spell_audiovisual_activate_caller:
    JSR _battle_load_character_targeting_two_monsters_action_details            ; $01EF21 | Load the temporary action details from ROM.
    LDA r_battle_current_actor_slot.w                                           ; $01EF24 |\ Preserve the existing actor slot.
    PHA                                                                         ; $01EF27 |/
    LDA r_battle_caller_slot.w                                                  ; $01EF28 |\ Set the actor slot to the caller slot.
    STA r_battle_current_actor_slot.w                                           ; $01EF2B |/
    JSL bank02.battle_character_special_pose_exit_right                         ; $01EF2E | Have the caller exit to the right.
    JSR _battle_get_caller_slot                                                 ; $01EF32 | Set the Y register to the caller slot.
    TDC                                                                         ; $01EF35 |\ Unset the invisibility flag for this character.
    STA r_battle_character_slot_invisible.w,Y                                   ; $01EF36 |/
    LDA r_character_battle.1.id.w,X                                             ; $01EF39 |\ Load the character ID and push it for now.
    PHA                                                                         ; $01EF3C |/
    TYA                                                                         ; $01EF3D |\
    ASL A                                                                       ; $01EF3E | | Set the X register to the slot number times four.
    ASL A                                                                       ; $01EF3F | |
    ASL A                                                                       ; $01EF40 | |
    ASL A                                                                       ; $01EF41 | |
    TAX                                                                         ; $01EF42 |/
    PLA                                                                         ; $01EF43 |\ Set the character ID in the visual properties.
    STA r_battle_character_visual_properties.1.id.w,X                           ; $01EF44 |/
    JSL bank02.battle_character_enter_from_right                                ; $01EF47 | Animate the character entering from the right.
    PLA                                                                         ; $01EF4B |\ Restore the original actor slot.
    STA r_battle_current_actor_slot.w                                           ; $01EF4C |/
    JSR _battle_restore_current_action_details                                  ; $01EF4F | Restore the original action details.
    RTS                                                                         ; $01EF52

; _monster_spell_audiovisual_clear_caller_status ($01:EF53)
;
; If there is a caller in the party, clears out all four status bytes of that
; character slot. If there is no caller, instead clears out the statuses of the
; character in slot zero.
_monster_spell_audiovisual_clear_caller_status:
    JSR _battle_get_caller_slot                                                 ; $01EF53 | Get the slot and offset for the caller in the party.
    TDC                                                                         ; $01EF56 |\
    STA r_character_battle.1.status_1.w,X                                       ; $01EF57 | | Clear out the status variables for that slot, removing any
    STA r_character_battle.1.status_2.w,X                                       ; $01EF5A | | statuses the character may have.
    STA r_character_battle.1.status_3.w,X                                       ; $01EF5D | |
    STA r_character_battle.1.status_4.w,X                                       ; $01EF60 |/
    TYA                                                                         ; $01EF63 |\ Save the caller slot number for later.
    STA r_battle_caller_slot.w                                                  ; $01EF64 |/
    INC r_battle_caller_ready.w                                                 ; $01EF67 | Flag that the caller is ready so Mist will be animated.
    RTS                                                                         ; $01EF6A

; _battle_load_character_targeting_two_monsters_action_details ($01:EF6B)
;
; Backs up the action details in $34C2 to $F476 and replaces it with data
; loaded from ROM that describes the character in slot zero targeting the
; monsters in slots zero and one.
_battle_load_character_targeting_two_monsters_action_details:
    TDC                                                                         ; $01EF6B |\ Initialize the X register to zero.
    TAX                                                                         ; $01EF6C |/
-   LDA r_battle_current_action_details.w,X                                     ; $01EF6D |\ Copy the existing action details to the backup array.
    STA r_battle_current_action_details_backup.w,X                              ; $01EF70 |/
    LDA action_details_character_targeting_two_monsters_data.l,X                ; $01EF73 |\ Copy values from ROM to the action details array that describes the
    STA r_battle_current_action_details.w,X                                     ; $01EF77 |/ character in slot zero targeting monsters in slots zero and one.
    INX                                                                         ; $01EF7A |\
    CPX #_sizeof_action_details.w                                               ; $01EF7B | | Loop through all eight bytes.
    BNE -                                                                       ; $01EF7E |/
    RTS                                                                         ; $01EF80

; _battle_restore_current_action_details ($01:EF81)
;
; Restores the current action details at $34C2 from the backup at $F476.
_battle_restore_current_action_details:
    TDC                                                                         ; $01EF81 |\ Initialize the X register to zero.
    TAX                                                                         ; $01EF82 |/
-   LDA r_battle_current_action_details_backup.w,X                              ; $01EF83 |\ Copy the value from the backup to the main register.
    STA r_battle_current_action_details.w,X                                     ; $01EF86 |/
    INX                                                                         ; $01EF89 |\
    CPX #_sizeof_action_details.w                                               ; $01EF8A | | Loop until all eight bytes have been restored.
    BNE -                                                                       ; $01EF8D |/
    RTS                                                                         ; $01EF8F

; battle_animate_mist_golbez ($01:EF90)
;
; Animates the Mist attack on Golbez and the Shadow dragon.
battle_animate_mist_golbez:
    LDA #MONSTER_COMMAND_CALL.b                                                 ; $01EF90 |\
    STA r_battle_script_audiovisual.w + 0                                       ; $01EF92 | | Set an audiovisual script to call Mist.
    LDA #SPELL_CALL_MIST.b                                                      ; $01EF95 | |
    STA r_battle_script_audiovisual.w + 1                                       ; $01EF97 | |
    LDA #MONSTER_COMMAND_END.b                                                  ; $01EF9A | |
    STA r_battle_script_audiovisual.w + 2                                       ; $01EF9C |/
    JSR _battle_load_character_targeting_two_monsters_action_details            ; $01EF9F | Load the action details to target two monsters.
    INC r_battle_caller_ready.w                                                 ; $01EFA2 | Flag that the caller is ready.
    LDA r_battle_caller_slot.w                                                  ; $01EFA5 |\ Set the actor to the caller slot.
    STA r_battle_current_action_details.actor.w                                 ; $01EFA8 |/
    JSL bank02.battle_update_audiovisual                                        ; $01EFAB | Animate the audiovisual script.
    JSR _battle_restore_current_action_details                                  ; $01EFAF | Restore any action deatils.
    RTL                                                                         ; $01EFB2

; action_details_character_target_two_monsters_data ($01:EFB3)
;
; Contains data to put in the action details array at $34C2 which has the
; character in slot zero targeting monsters in slots zero and one.
action_details_character_targeting_two_monsters_data:
    .db $00, $00, $80, $C0, $00, $00, $00, $00                                  ; $01EFB3.EFBA

; _battle_character_apparitions_hide ($01:EFBB)
;
; Hides any character apparitions, including animating the disappearance.
_battle_character_apparitions_hide:
    STZ r_battle_draw_character_apparitions.w                                   ; $01EFBB |\ Disable any apparition drawing.
    STZ r_battle_draw_both_character_apparitions.w                              ; $01EFBE |/
    JMP _battle_character_apparitions_animate_switch                            ; $01EFC1 | Animate the switch to the current state.

; _battle_character_apparitions_animate_and_increment_both ($01:EFC4)
;
; Strange function that calls the function animate the switch to the current
; state regarding character apparitions, and then increments the flag that
; causes both apparitions to be drawn.
_battle_character_apparitions_animate_and_increment_both:
    JSR _battle_character_apparitions_animate_switch                            ; $01EFC4 | Animate the switch to the current state.
    INC r_battle_draw_both_character_apparitions.w                              ; $01EFC7 | Enable the drawing of both apparitions.
    RTS                                                                         ; $01EFCA

; _battle_character_apparitions_animate_switch ($01:EFCB)
;
; This function loads the current tilemap for the monsters (including any
; enabled apparitions) and then animates a strobe effect to switch between them.
; It's actually very generic and not apparition specific, but is used for
; apparitions.
_battle_character_apparitions_animate_switch:
    JSL bank02.battle_load_monster_tilemaps                                     ; $01EFCB | Draw the monster and apparition tilemaps.
    JSL flip_battle_monster_tilemap                                             ; $01EFCF | Flip the monster tilemap if necessary.
    STZ r_battle_monster_special_transition.w                                   ; $01EFD3 | Don't use any special transition effect.
    JSL bank02.battle_character_apparition_animate_strobe                       ; $01EFD6 | Animate a strobing transition between the old and new tilemaps.
    RTS                                                                         ; $01EFDA

; _monster_spell_audiovisual_hide_monsters_and_apparitions ($01:EFDB)
;
; Hides both monsters and apparitions from the battlefield. This appears to be
; unused.
_monster_spell_audiovisual_hide_monsters_and_apparitions
    INC r_battle_disable_monster_drawing.w                                      ; $01EFDB | Disable the drawing of monsters.
    JMP _battle_character_apparitions_hide                                      ; $01EFDE | Hide the apparitions (and monsters).

; _monster_spell_audiovisual_show_character_apparition_anna ($01:EFE1)
;
; Shows the Anna character apparition.
;
; NOTE: This function strangely calls itself twice, incrementing the flag to
;       draw both apparitions to keep track of which pass it's on. The second
;       pass effectively does nothing but cause a 96 frame delay. This isn't
;       necessarily a bug, but there would have been simpler ways to achieve
;       that if it was the intended result.
_monster_spell_audiovisual_show_character_apparition_anna:
    JSR +                                                                       ; $01EFE1 | Execute the second half of this function twice.
+   INC r_battle_draw_character_apparitions.w                                   ; $01EFE4 | Set the flag to draw character apparitions.
    LDA r_battle_draw_both_character_apparitions.w                              ; $01EFE7 |\
    BNE +                                                                       ; $01EFEA | | Load the apparition set if this is the first pass.
    LDA #APPARITION_SET_ANNA.b                                                  ; $01EFEC | |
    JSR _battle_load_character_apparition_set                                   ; $01EFEE |/
+   JMP _battle_character_apparitions_animate_and_increment_both                ; $01EFF1 | Animate the change.

; _monster_spell_audiovisual_show_character_apparition_edward_tellah ($01:EFF4)
;
; Shows the Edward and Tellah apparition set.
_monster_spell_audiovisual_show_character_apparition_edward_tellah:
    INC r_battle_draw_character_apparitions.w                                   ; $01EFF4 | Set the flag to draw character apparitions.
    LDA #APPARITION_SET_EDWARD_TELLAH.b                                         ; $01EFF7 |\ Load the Edward/Tellah apparition set.
    JSR _battle_load_character_apparition_set                                   ; $01EFF9 |/
    INC r_battle_draw_both_character_apparitions.w                              ; $01EFFC | Set the flag to draw both apparitions.
    JMP _battle_character_apparitions_animate_and_increment_both                ; $01EFFF | Animate the apparition appearance.

; _monster_spell_audiovisual_show_character_apparition_palom_porom ($01:F002)
;
; Shows the Palom and Porom apparition set.
_monster_spell_audiovisual_show_character_apparition_palom_porom:
    INC r_battle_draw_character_apparitions.w                                   ; $01F002 | Set the flag to draw character apparitions.
    LDA #APPARITION_SET_PALOM_POROM.b                                           ; $01F005 |\ Load the Palom/Porom apparition set.
    JSR _battle_load_character_apparition_set                                   ; $01F007 |/
    INC r_battle_draw_both_character_apparitions.w                              ; $01F00A | Set the flag to draw both apparitions.
    JMP _battle_character_apparitions_animate_and_increment_both                ; $01F00D | Animate the apparition appearance.

; _monster_spell_audiovisual_show_character_apparition_yang_cid ($01:F010)
;
; Shows the Yang and Cid apparition set.
_monster_spell_audiovisual_show_character_apparition_yang_cid:
    INC r_battle_draw_character_apparitions.w                                   ; $01F010 | Set the flag to draw character apparitions.
    LDA #APPARITION_SET_YANG_CID.b                                              ; $01F013 |\ Load the Yang/Cid apparition set.
    JSR _battle_load_character_apparition_set                                   ; $01F015 |/
    INC r_battle_draw_both_character_apparitions.w                              ; $01F018 | Set the flag to draw both apparitions.
    JMP _battle_character_apparitions_animate_and_increment_both                ; $01F01B | Animate the apparition appearance.

; _monster_spell_audiovisual_show_character_apparition_fusoya_golbez ($01:F01E)
;
; Enables party ATB and shows the FuSoYa and Golbez apparition set.
_monster_spell_audiovisual_show_character_apparition_fusoya_golbez:
    INC r_battle_zeromus_enable_party_atb.w                                     ; $01F01E | Set the flag that enables the party ATB.
    INC r_battle_draw_character_apparitions.w                                   ; $01F021 | Set the flag to draw character apparitions.
    LDA #APPARITION_SET_FUSOYA_GOLBEZ.b                                         ; $01F024 |\ Load the FuSoYa/Golbez apparition set.
    JSR _battle_load_character_apparition_set                                   ; $01F026 |/
    INC r_battle_draw_both_character_apparitions.w                              ; $01F029 | Set the flag to draw both apparitions.
    JMP _battle_character_apparitions_animate_and_increment_both                ; $01F02C | Animate the apparition appearance.

; battle_draw_character_apparitions ($01:F02F)
;
; If $F44C is non-zero, draws at least one character apparition on the left-hand
; side of the battlefield. If $F41A is set, both will be drawn, otherwise, only
; the first one will be drawn. The first one is drawn at the coordinates passed
; in a single byte at $F421 (4 bits per coordinate, with the X coordinate being
; 6 higher than passed), and the second one is drawn at the coordinates passed
; in $F422. The correct tiles are assumed to already be loaded at $280 through
; $28F. The results are drawn to the battle tilemap area in RAM, but no transfer
; to VRAM is done.
battle_draw_character_apparitions:
    LDA r_battle_draw_character_apparitions.w                                   ; $01F02F |\ Skip this function if no character apparitions are to be drawn.
    BEQ ++                                                                      ; $01F032 |/
    LDA r_battle_draw_both_character_apparitions.w                              ; $01F034 |\
    BEQ +                                                                       ; $01F037 | | If configured, draw the second character apparition. The tiles
    LDA r_battle_character_apparitions.coordinates.2.w                          ; $01F039 | | are assumed to be in VRAM starting at tile $288. The palette will
    JSR _get_battle_tilemap_address                                             ; $01F03C | | be palette 5, which is the palette used by the third monster
    LDA #%01110110.b                                                            ; $01F03F | | type.
    STA <r_battle_load_reversed_character_tilemap_flags                         ; $01F041 | |
    LDA #$88.b                                                                  ; $01F043 | |
    JSR _battle_load_reversed_character_tilemap                                 ; $01F045 |/
+   LDA r_battle_character_apparitions.coordinates.1.w                          ; $01F048 |\
    JSR _get_battle_tilemap_address                                             ; $01F04B | | Draw the first character apparition. This one is assumed to start
    LDA #%01110010.b                                                            ; $01F04E | | at tile $280, and uses palette 4, which is used by the second
    STA <r_battle_load_reversed_character_tilemap_flags                         ; $01F050 | | monster type.
    LDA #$80.b                                                                  ; $01F052 | |
    JSR _battle_load_reversed_character_tilemap                                 ; $01F054 |/
++  RTL                                                                         ; $01F057

; get_battle_tilemap_address ($01:F058)
;
; Given a one byte coordinate in the accumulator, in the format %XXXXYYYY where
; X is the X coordinate and Y is the Y coordinate, this function returns the
; corresponding address in the battle tilemap area in RAM. Note that the X
; coordinate will have six added to it, while the Y coordinate will be used
; directly. The result is returned in the X register.
_get_battle_tilemap_address:
    PHA                                                                         ; $01F058 | Preserve the value of the accumulator.
    AND #%00001111.b                                                            ; $01F059 |\
    STA <r_math_multiply_8bit_arg_1                                             ; $01F05B | | Extract the lower four bits and multiply by 64 to determine the
    LDA #64.b                                                                   ; $01F05D | | vertical offset.
    STA <r_math_multiply_8bit_arg_2                                             ; $01F05F | |
    JSL bank02.math_multiply_8bit                                               ; $01F061 |/
    PLA                                                                         ; $01F065 |\
    LSR A                                                                       ; $01F066 | | Restore the accumulator and shift right by four to determine the
    LSR A                                                                       ; $01F067 | | base X value.
    LSR A                                                                       ; $01F068 | |
    LSR A                                                                       ; $01F069 |/
    CLC                                                                         ; $01F06A |\ Add 6 to the base value.
    ADC #6.b                                                                    ; $01F06B |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $01F06D |\
    ASL A                                                                       ; $01F06F | | Multiply the resulting value by 2 (as each tile is two bytes),
    CLC                                                                         ; $01F070 | | add the vertical offset, and then add in the base address to the
    ADC <r_math_multiply_8bit_result                                            ; $01F071 | | tilemap data. Finally, transfer the value to the X register.
    CLC                                                                         ; $01F073 | |
    ADC #r_battle_tilemap_data.w                                                ; $01F074 | |
    TAX                                                                         ; $01F077 | |
    TDC                                                                         ; $01F078 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01F079 |/
    RTS                                                                         ; $01F07B

; _battle_load_reversed_character_tilemap
;
; Given a destination address in the X register and a base tile number in the
; accumulator, writes the base tile and the five tiles in a 2x3 grid, with the
; lower number of each pair occuring on the right side. The purpose is to draw
; the character sprites that appear as ghosts or apparitions during the WaterHag
; and Zeromus battles.
_battle_load_reversed_character_tilemap:
    STX <r_battle_generic_tmp_index                                             ; $01F07C | Write the value in the X register to the index.
    LDY #0.w                                                                    ; $01F07E |\ Write the first row to the tilemap.
    JSR _battle_load_reversed_character_tilemap_row                             ; $01F081 |/
    LDY #64.w                                                                   ; $01F084 |\ Write the second row to the tilemap.
    JSR _battle_load_reversed_character_tilemap_row                             ; $01F087 |/
    LDY #128.w                                                                  ; $01F08A |\ Write the third row in the tilemap.
    JMP _battle_load_reversed_character_tilemap_row                             ; $01F08D |/

; _battle_load_reversed_character_tilemap_row ($01:F090)
;
; Given a tile number in the accumulator, a 16-bit destination address in $00,
; an offset within that destination in the Y register, and tile flags in $02,
; writes the passed tile number and the next tile number in reversed order at
; the given location, also writing the flags.
_battle_load_reversed_character_tilemap_row:
    PHA                                                                         ; $01F090 | Preserve the initial value of the accumulator.
    INC A                                                                       ; $01F091 |\
    STA (<r_battle_generic_tmp_index),Y                                         ; $01F092 | | Increment the tile number and store it to the destination.
    INY                                                                         ; $01F094 |/
    LDA <r_battle_load_reversed_character_tilemap_flags                         ; $01F095 |\
    STA (<r_battle_generic_tmp_index),Y                                         ; $01F097 | | Load the tile flags and store them to the destination.
    INY                                                                         ; $01F099 |/
    PLA                                                                         ; $01F09A |\ Restore the original tile number and preserve it once again.
    PHA                                                                         ; $01F09B |/
    STA (<r_battle_generic_tmp_index),Y                                         ; $01F09C |\ Store the original tile to the destination.
    INY                                                                         ; $01F09E |/
    LDA <r_battle_load_reversed_character_tilemap_flags                         ; $01F09F |\ Once again store the tile flags.
    STA (<r_battle_generic_tmp_index),Y                                         ; $01F0A1 |/
    PLA                                                                         ; $01F0A3 |
    INC A                                                                       ; $01F0A4 |\ Increment the tile number by two for the next row.
    INC A                                                                       ; $01F0A5 |/
    RTS                                                                         ; $01F0A6

; _battle_load_character_apparition_set ($01:F0A7)
;
; Loads an apparition set from ROM into RAM and loads the graphical data for the
; set into VRAM. The set number is passed in the accumulator.
_battle_load_character_apparition_set:
    ASL A                                                                       ; $01F0A7 |\
    ASL A                                                                       ; $01F0A8 | | Multiply the passed value by 8 and transfer it to the X register
    ASL A                                                                       ; $01F0A9 | | to index the apparition data.
    TAX                                                                         ; $01F0AA |/
    TDC                                                                         ; $01F0AB |\ Initialize the Y register to zero.
    TAY                                                                         ; $01F0AC |/
-   LDA bank0D.battle_character_apparition_data.l,X                             ; $01F0AD |\
    STA r_battle_character_apparitions.w,Y                                      ; $01F0B1 | | Copy the apparition data for this index from ROM into RAM.
    INX                                                                         ; $01F0B4 | |
    INY                                                                         ; $01F0B5 | |
    CPY #_sizeof_apparition_set.w                                               ; $01F0B6 | |
    BNE -                                                                       ; $01F0B9 |/
    LDX #256.w                                                                  ; $01F0BB |\
    STX <r_battle_copy_to_vram_arg_bytes                                        ; $01F0BE | | Copy 8 tiles worth of the sprite set for the first apparition from
    LDX r_battle_character_apparitions.pointers.1.w                             ; $01F0C0 | | ROM to VRAM.
    LDY #$4800.w                                                                ; $01F0C3 | |
    LDA #:bank1A.battle_sprite_character_cecil_dknight_data.b                   ; $01F0C6 | |
    JSL bank02.battle_copy_to_vram                                              ; $01F0C8 |/
    LDX #256.w                                                                  ; $01F0CC |\
    STX <r_battle_copy_to_vram_arg_bytes                                        ; $01F0CF | | Repeat with the second apparition, to a different VRAM address.
    LDX r_battle_character_apparitions.pointers.2.w                             ; $01F0D1 | |
    LDY #$4880.w                                                                ; $01F0D4 | |
    LDA #:bank1A.battle_sprite_character_cecil_dknight_data.b                   ; $01F0D7 | |
    JSL bank02.battle_copy_to_vram                                              ; $01F0D9 |/
    LDA r_battle_character_apparitions.palettes.1.w                             ; $01F0DD |\
    LDX #4.w                                                                    ; $01F0E0 | | Load the first palette into palette 4.
    JSL bank02.battle_load_character_palette                                    ; $01F0E3 |/
    LDA r_battle_character_apparitions.palettes.2.w                             ; $01F0E7 |\
    LDX #5.w                                                                    ; $01F0EA | | Load the second palette into palettte 5.
    JSL bank02.battle_load_character_palette                                    ; $01F0ED |/
    RTS                                                                         ; $01F0F1

; battle_load_monster_weapon_sprite ($01:F0F2)
;
; Loads a sprite for a weapon used by a monster represented by a character
; sprite. The index is passed in $F410. The only useful values seem to be 0 and
; 1.
battle_load_monster_weapon_sprite:
    LDA r_battle_load_monster_weapon_sprite_arg_unused.w                        ; $01F0F2 |\ NOTE: This code serves no purpose whatsoever. Presumably something
    BNE +                                                                       ; $01F0F5 |/       from development that ended up unused.
+   LDA r_battle_load_monster_weapon_sprite_arg_index.w                         ; $01F0F7 |\
    ASL A                                                                       ; $01F0FA | | Calculate the offset into the data by multiplying the index by
    ASL A                                                                       ; $01F0FB | | eight.
    ASL A                                                                       ; $01F0FC | |
    TAX                                                                         ; $01F0FD |/
    TDC                                                                         ; $01F0FE |\ Initialize the Y register to zero.
    TAY                                                                         ; $01F0FF |/
-   LDA bank0D.battle_monster_character_weapon_sprite_data.l,X                  ; $01F100 |\
    STA r_battle_weapon_sprite_properties.w,Y                                   ; $01F104 | | Copy the data from ROM to RAM.
    INX                                                                         ; $01F107 | |
    INY                                                                         ; $01F108 | |
    CPY #_sizeof_r_battle_weapon_sprite_properties.w                            ; $01F109 | |
    BNE -                                                                       ; $01F10C |/
    INC r_battle_weapon_sprite_visible.w                                        ; $01F10E | Flag the weapon sprite as visible.
    RTL                                                                         ; $01F111

; battle_finalize_nmi ($01:F112)
;
; Does various miscellaneous battle updates, including drawing any alternate
; party sprite, setting of action poses, changing the music, setting or
; resetting the running flag, and incrementing the RNG index.
battle_finalize_nmi:
    JSR _battle_draw_alternate_party_sprite                                     ; $01F112 | Draw any configured alternate party sprite.
    JSL bank03.battle_update_zeromus_background_scroll                          ; $01F115 | Update the scrolling of the Zeromus background.
    LDA r_battle_action_pose_pending.w                                          ; $01F119 |\
    BEQ +                                                                       ; $01F11C | | If there is a pending action pose, load the correct new pose from
    LDA r_battle_action_pose_slot.w                                             ; $01F11E | | ROM and set the character's pose.
    TAY                                                                         ; $01F121 | |
    LDA r_battle_action_pose_command.w                                          ; $01F122 | |
    TAX                                                                         ; $01F125 | |
    LDA bank16.battle_command_initial_pose_data.l,X                             ; $01F126 | |
    STA r_battle_character_pose.w,Y                                             ; $01F12A |/
    STA r_battle_character_pose_backup.w,Y                                      ; $01F12D | Additionally store the pose in the backup location.
    STZ r_battle_action_pose_pending.w                                          ; $01F130 | Reset the pending flag.
+   LDA r_battle_song_change_pending.w                                          ; $01F133 |\
    BEQ +                                                                       ; $01F136 | | If a song change is pending, set the track and mode accordingly
    LDA r_battle_song_change_track.w                                            ; $01F138 | | and call the function to play audio.
    STA r_play_audio_arg_track.w                                                ; $01F13B | |
    LDA #AUDIO_MODE_NORMAL.b                                                    ; $01F13E | |
    STA r_play_audio_arg_mode.w                                                 ; $01F140 | |
    JSL bank04.play_audio                                                       ; $01F143 | |
    STZ r_battle_song_change_pending.w                                          ; $01F147 |/
+   LDA r_battle_play_audio_special_mode.w                                      ; $01F14A |\
    BEQ +                                                                       ; $01F14D | | TODO: Sets a new mode and calls the play audio routine.
    STA r_play_audio_arg_mode.w                                                 ; $01F14F | |       Understanding the usefulness of this may have to wait until
    JSL bank04.play_audio                                                       ; $01F152 | |       the sound code itself is disassembled.
    STZ r_battle_play_audio_special_mode.w                                      ; $01F156 |/
+   LDA r_battle_play_audio_mode.w                                              ; $01F159 |\
    BEQ ++                                                                      ; $01F15C | | If an audio effect has been configured, copy the values into the
    LDX r_battle_play_audio_mode.w                                              ; $01F15E | | audio routine's argument locations.
    STX r_play_audio_arg_mode.w                                                 ; $01F161 | |
    LDX r_battle_play_audio_pan.w                                               ; $01F164 | |
    STX r_play_audio_arg_pan.w                                                  ; $01F167 |/
    LDA r_formation_back_attack_copy.w                                          ; $01F16A |\
    BEQ +                                                                       ; $01F16D | | If this is a back attack, flip the bits of the pan value to move
    LDA r_play_audio_arg_pan.w                                                  ; $01F16F | | it to the other side.
    EOR #%11111111.b                                                            ; $01F172 | |
    STA r_play_audio_arg_pan.w                                                  ; $01F174 |/
+   JSL bank04.play_audio                                                       ; $01F177 |\ Play the actual audio and zero out the mode variable to indicate it
    STZ r_battle_play_audio_mode.w                                              ; $01F17B |/ has been processed.
++  STZ r_battle_running.w                                                      ; $01F17E |\
    LDA r_battle_party_victory.w                                                ; $01F181 | | If the current battle is not an auto-battle and if the party has
    ORA r_battle_auto.w                                                         ; $01F184 | | not already won, set the running flag if the L and R buttons are
    BNE +                                                                       ; $01F187 | | currently pressed. Otherwise, reset it.
    LDA reg_cpu_stdcntrl1l.l                                                    ; $01F189 | |
    ORA reg_cpu_stdcntrl2l.l                                                    ; $01F18D | |
    AND #(JOYPAD_L_L | JOYPAD_L_R).b                                            ; $01F191 | |
    CMP #(JOYPAD_L_L | JOYPAD_L_R).b                                            ; $01F193 | |
    BNE +                                                                       ; $01F195 | |
    INC r_battle_running.w                                                      ; $01F197 |/
+   STZ r_battle_nmi_status.w                                                   ; $01F19A | Reset the NMI status flag to indicate the NMI is complete.
    STZ r_battle_nmi_lock.w                                                     ; $01F19D | Unset the NMI lock flag.
    INC <r_battle_rng_index                                                     ; $01F1A0 | Increment the battle RNG index.
    RTL                                                                         ; $01F1A2

; battle_animate_land_monster($01:F1A3)
;
; Animates the process of a monster that is using the Jump command landing.
battle_animate_land_monster:
    LDA r_battle_effect_target_slot.w                                           ; $01F1A3 |\
    ASL A                                                                       ; $01F1A6 | | Set the X register to the target slot times two.
    TAX                                                                         ; $01F1A7 |/
    LDA r_battle_character_cursor_coordinates_copy_2.1.x.w,X                    ; $01F1A8 |\
    AND #%11111000.b                                                            ; $01F1AB | | Set the projectile source X coordinate to the target X coordinate
    STA r_battle_effect_projectile_source_coordinates.x.w                       ; $01F1AD | | truncated to a multiple of eight. Save the value additionally in a
    TAY                                                                         ; $01F1B0 | | temporary variable.
    STY <r_battle_generic_tmp_index                                             ; $01F1B1 |/
    STY r_battle_animate_land_unused_1.w                                        ; $01F1B3 | TODO: Store the value in $F133. Does this serve a purpose?
    LDA r_battle_character_cursor_coordinates_copy_2.1.y.w,X                    ; $01F1B6 |\
    AND #%11111000.b                                                            ; $01F1B9 | | Repeat the same procedure for the Y coordinate, also storing it in
    STA r_battle_effect_projectile_source_coordinates.y.w                       ; $01F1BB | | a temporary variable as well as a TODO variable.
    TAY                                                                         ; $01F1BE | |
    STY r_battle_animate_land_unused_2.w                                        ; $01F1BF | |
    STY <r_battle_generic_tmp_index_2                                           ; $01F1C2 |/
    LSR A                                                                       ; $01F1C4 |\
    LSR A                                                                       ; $01F1C5 | | Set the frame counter to the total vertical distance divided by
    LSR A                                                                       ; $01F1C6 | | eight.
    STA r_battle_animate_land_tmp_frame_counter.w                               ; $01F1C7 |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $01F1CA |\
    LDA #40.w                                                                   ; $01F1CC | | Set the BG1 horizontal scroll value to 40 (which would align the
    SEC                                                                         ; $01F1CF | | monster on the left side of the screen) minus the X coordinate
    SBC <r_battle_generic_tmp_index                                             ; $01F1D0 | | (which moves it to the X coordinate of the target) and minus the Y
    SEC                                                                         ; $01F1D2 | | coordinate (which adds the jumping distance).
    SBC <r_battle_generic_tmp_index_2                                           ; $01F1D3 | |
    STA r_battle_set_bg1_scroll_arg_horizontal.w                                ; $01F1D5 |/
    LDA #80.w                                                                   ; $01F1D8 |\
    STA r_battle_set_bg1_scroll_arg_vertical.w                                  ; $01F1DB | | Set the BG1 vertical scroll argument to 80 (top of the screen).
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01F1DE |/
    JSL battle_set_bg1_scroll                                                   ; $01F1E0 | Set the current BG1 scroll values.
-   JSR _battle_wait_next_frame_preserve_x_y                                    ; $01F1E4 | Wait for the next frame.
    REP #FLAG_P_ACCUMULATOR                                                     ; $01F1E7 |\
    LDA r_battle_set_bg1_scroll_arg_horizontal.w                                ; $01F1E9 | | Add eight to the horizontal scroll value and subtract eight from
    CLC                                                                         ; $01F1EC | | the vertical scroll value (results in the monster apparently
    ADC #8.w                                                                    ; $01F1ED | | moving down and to the left).
    STA r_battle_set_bg1_scroll_arg_horizontal.w                                ; $01F1F0 | |
    LDA r_battle_set_bg1_scroll_arg_vertical.w                                  ; $01F1F3 | |
    SEC                                                                         ; $01F1F6 | |
    SBC #8.w                                                                    ; $01F1F7 | |
    STA r_battle_set_bg1_scroll_arg_vertical.w                                  ; $01F1FA | |
    TDC                                                                         ; $01F1FD | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01F1FE |/
    JSL battle_set_bg1_scroll                                                   ; $01F200 | Update the scroll to the new values.
    DEC r_battle_animate_land_tmp_frame_counter.w                               ; $01F204 |\ Decrement the frame counter and loop back to the next frame.
    BNE -                                                                       ; $01F207 |/
    LDA #56.b                                                                   ; $01F209 |\
    STA r_battle_effect_projectile_target_coordinates.x.w                       ; $01F20B | | Set the projectile target coordinates to 56, 80, which will reset
    LDA #80.b                                                                   ; $01F20E | | the monster to its default position.
    STA r_battle_effect_projectile_target_coordinates.y.w                       ; $01F210 |/
    LDA #8.b                                                                    ; $01F213 |\ Set the projectile horizontal rate to eight pixels per frame.
    STA r_battle_effect_projectile_horizontal_rate.w                            ; $01F215 |/
    JSL bank02.battle_effect_projectile_initialize                              ; $01F218 | Initialize the projectile variables.
    JSL bank02.battle_weapon_effect_boomerang_initialize                        ; $01F21C | Initialize the boomerang effect variables.
    LDA #AUDIO_EFFECT_DART_HIT.b                                                ; $01F220 |\ Play the Dart hit sound effect.
    JSL bank02.battle_play_sound_effect                                         ; $01F222 |/
@start:
    JSR _battle_wait_next_frame_preserve_x_y                                    ; $01F226 | Wait for the next frame.
    JSL bank02.battle_effect_projectile_update_coordinates                      ; $01F229 | Update the projectile coordinates.
    JSL bank02.battle_weapon_effect_boomerang_calculate_vertical_offset         ; $01F22D | Calculate the boomerang vertical offset (returned in $2B).
    LDA <r_battle_set_bg1_scroll_arg_vertical_offset_hi                         ; $01F231 |\
    STA <r_battle_set_bg1_scroll_arg_vertical_offset_lo                         ; $01F233 | | Extend the result (returned in $2B) to sixteen bits.
    LDA <r_battle_set_bg1_scroll_arg_vertical_offset_hi                         ; $01F235 | |
    BMI +                                                                       ; $01F237 | |
    STZ <r_battle_set_bg1_scroll_arg_vertical_offset_hi                         ; $01F239 | |
    BRA ++                                                                      ; $01F23B | |
+   LDA #$FF.b                                                                  ; $01F23D | |
    STA <r_battle_set_bg1_scroll_arg_vertical_offset_hi                         ; $01F23F |/
++  REP #FLAG_P_ACCUMULATOR                                                     ; $01F241 |\
    LDA r_battle_set_bg1_scroll_arg_horizontal.w                                ; $01F243 | | Add eight to the horizontal scroll argument, and subtract the
    CLC                                                                         ; $01F246 | | moved Y distance from the vertical scroll argument.
    ADC #8.w                                                                    ; $01F247 | |
    STA r_battle_set_bg1_scroll_arg_horizontal.w                                ; $01F24A | |
    LDA r_battle_set_bg1_scroll_arg_vertical.w                                  ; $01F24D | |
    SEC                                                                         ; $01F250 | |
    SBC r_battle_effect_projectile_y_counter.w                                  ; $01F251 | |
    STA r_battle_set_bg1_scroll_arg_vertical.w                                  ; $01F254 | |
    TDC                                                                         ; $01F257 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01F258 |/
    LDA r_battle_set_bg1_scroll_arg_horizontal.w                                ; $01F25A |\ If the horizontal scroll has reached zero, branch to the end.
    BEQ +                                                                       ; $01F25D |/
    JSL bank01.battle_set_bg1_scroll_with_vertical_offset                       ; $01F25F |\ Otherwise, update the scroll values and return to the start of the
    JMP @start                                                                  ; $01F263 |/ loop.
+   LDX #0.w                                                                    ; $01F266 |\
    STX r_battle_set_bg1_scroll_arg_horizontal.w                                ; $01F269 | | Explicitly set the scroll values to zero.
    STX r_battle_set_bg1_scroll_arg_vertical.w                                  ; $01F26C | |
    JSL battle_set_bg1_scroll                                                   ; $01F26F |/
    RTL                                                                         ; $01F273

; battle_animate_monster_kick_forward ($01:F274)
;
; Animates the forward portion of the Kick command when used by a monster.
battle_animate_monster_kick_forward:
    TDC                                                                         ; $01F274 |\
    TAX                                                                         ; $01F275 | | Initialize the scroll values to zero.
    STX r_battle_set_bg1_scroll_arg_horizontal.w                                ; $01F276 | |
    STX r_battle_set_bg1_scroll_arg_vertical.w                                  ; $01F279 |/
-   JSR _battle_wait_next_frame_preserve_x_y                                    ; $01F27C | Wait for the next frame.
    JSL battle_set_bg1_scroll                                                   ; $01F27F | Set the current background scroll values.
    REP #FLAG_P_ACCUMULATOR                                                     ; $01F283 |\
    LDA r_battle_set_bg1_scroll_arg_horizontal.w                                ; $01F285 | | Subtract eight from the horizontal scroll value to make the
    SEC                                                                         ; $01F288 | | monster appear to move right.
    SBC #8.w                                                                    ; $01F289 | |
    STA r_battle_set_bg1_scroll_arg_horizontal.w                                ; $01F28C | | BUG: This doesn't apply to vanilla, but if the Karate encounter is
    TDC                                                                         ; $01F28F | |      a back attack, subtracting the value is wrong.
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01F290 |/
    INX                                                                         ; $01F292 |\
    CPX #20.w                                                                   ; $01F293 | | Loop twenty times (only nineteen updated entries get set).
    BNE -                                                                       ; $01F296 |/
    RTL                                                                         ; $01F298

; battle_animate_monster_kick_reverse ($01:F299)
;
; Animates the reverse portion of the Kick command when used by a monster.
battle_animate_monster_kick_reverse:
    TDC                                                                         ; $01F299 |\ Initialize the X register to zero.
    TAX                                                                         ; $01F29A |/
-   JSR _battle_wait_next_frame_preserve_x_y                                    ; $01F29B | Wait for the next frame.
    JSL battle_set_bg1_scroll                                                   ; $01F29E | Set the current background scroll values.
    REP #FLAG_P_ACCUMULATOR                                                     ; $01F2A2 |\
    LDA r_battle_set_bg1_scroll_arg_horizontal.w                                ; $01F2A4 | | Add eight to the horizontal scroll value to make the monster
    CLC                                                                         ; $01F2A7 | | appear to move left.
    ADC #8.w                                                                    ; $01F2A8 | |
    STA r_battle_set_bg1_scroll_arg_horizontal.w                                ; $01F2AB | | BUG: As with the above, this is technically wrong in a back
    TDC                                                                         ; $01F2AE | |      attack (that doesn't occur in vanilla).
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01F2AF |/
    INX                                                                         ; $01F2B1 |\
    CPX #21.w                                                                   ; $01F2B2 | | Loop 21 times to get the value back to zero.
    BNE -                                                                       ; $01F2B5 |/
    RTL                                                                         ; $01F2B7

; battle_load_monster_character_sprite_tilemap ($01:F2B8)
;
; Given a pose number in $F404 and tile flags in $07, loads a character
; sprite tilemap and stores it at the 16-bit offset stored in $04. Additionally,
; if the value at $F40E is non-zero, the horizontal flip bit will be toggled.
; The base tile for the tilemap should be passed in $06.
;
; TODO: Determine if this is exclusive to monster use. There's no reason it has
; to be, but early tests have cast doubt about this being used for characters
; proper.
battle_load_monster_character_sprite_tilemap:
    LDA r_battle_load_monster_character_reverse.w                               ; $01F2B8 |\
    BEQ +                                                                       ; $01F2BB | | Set the horizontal flip bit in the tile flags if the reverse flag
    LDA <r_battle_load_monster_tilemaps_flags                                   ; $01F2BD | | is set.
    EOR #%01000000.b                                                            ; $01F2BF | |
    STA <r_battle_load_monster_tilemaps_flags                                   ; $01F2C1 |/
+   LDA r_battle_load_monster_character_sprite_tilemap_pose.w                   ; $01F2C3 |\
    ASL A                                                                       ; $01F2C6 | | Set the X register to the desired pose times two.
    TAX                                                                         ; $01F2C7 |/
    LDA bank0D.battle_character_pose_tilemap_offset_data.l + 0,X                ; $01F2C8 |\
    STA <r_battle_generic_tmp_index_lo                                          ; $01F2CC | | Load the pointer to the desired tilemap data.
    LDA bank0D.battle_character_pose_tilemap_offset_data.l + 1,X                ; $01F2CE | |
    STA <r_battle_generic_tmp_index_hi                                          ; $01F2D2 | |
    LDA #:bank0D.battle_character_pose_tilemap_offset_data.b                    ; $01F2D4 | |
    STA <r_battle_generic_tmp_index_bank                                        ; $01F2D6 |/
    LDY #0.w                                                                    ; $01F2D8 |\ Read the first row of the tilemap.
    JSR _battle_load_monster_character_sprite_tilemap_row                       ; $01F2DB |/
    LDY #64.w                                                                   ; $01F2DE |\ Read the second row of the tilemap.
    JSR _battle_load_monster_character_sprite_tilemap_row                       ; $01F2E1 |/
    LDY #128.w                                                                  ; $01F2E4 |\ Read the third row of the tilemap.
    JSR _battle_load_monster_character_sprite_tilemap_row                       ; $01F2E7 |/
    RTL                                                                         ; $01F2EA

; _battle_load_monster_character_sprite_tilemap_row ($01:F2EB)
;
; Given the 24-bit address of character sprite tilemap data in $00, loads three
; tiles, and stores them plus the base tile in $06 and stores the result at the
; 16-bit address in $04, indexed by the value in the Y register. Additionally
; stores the flags passed in $07 in the flags bytes.
;
; TODO: Is this used generically to load character sprites in all situations, or
;       only when used as monsters?
_battle_load_monster_character_sprite_tilemap_row:
    LDX #3.w                                                                    ; $01F2EB | Initialize the X register to 3, as there are 3 tiles to load.
-   LDA [<r_battle_generic_tmp_index]                                           ; $01F2EE | Load the next byte.
    CMP #$FF.b                                                                  ; $01F2F0 |\
    BNE +                                                                       ; $01F2F2 | | If the value is $FF, store a zero tile to the tilemap and set the
    TDC                                                                         ; $01F2F4 | | flags to be priority 1 and the base tile to $200.
    STA (<r_battle_load_monster_tilemaps_offset),Y                              ; $01F2F5 | |
    INY                                                                         ; $01F2F7 | |
    LDA #%00100010.b                                                            ; $01F2F8 | |
    JMP ++                                                                      ; $01F2FA |/
+   CLC                                                                         ; $01F2FD |\
    ADC <r_battle_load_monster_tilemaps_base_tile                               ; $01F2FE | | Set the tile number to the read value plus the base tile.
    STA (<r_battle_load_monster_tilemaps_offset),Y                              ; $01F300 | |
    INY                                                                         ; $01F302 |/
    LDA <r_battle_load_monster_tilemaps_flags                                   ; $01F303 |\
++  STA (<r_battle_load_monster_tilemaps_offset),Y                              ; $01F305 | | Set the flags to the set flags value.
    INY                                                                         ; $01F307 |/
    PHX                                                                         ; $01F308 |\
    LDX <r_battle_generic_tmp_index                                             ; $01F309 | | Increment the index to move to the next value.
    INX                                                                         ; $01F30B | |
    STX <r_battle_generic_tmp_index                                             ; $01F30C | |
    PLX                                                                         ; $01F30E |/
    DEX                                                                         ; $01F30F |\ Decrement the index and loop until all three tiles have been loaded.
    BNE -                                                                       ; $01F310 |/
    RTS                                                                         ; $01F312

; battle_alternate_party_sprite_update_forward_strike ($01:F313)
;
; Proxy function to call _battle_alternate_party_sprite_update_forward_strike
; from another bank.
battle_alternate_party_sprite_update_forward_strike:
    JSR _battle_alternate_party_sprite_update_forward_strike                    ; $01F313
    RTL                                                                         ; $01F316

; _battle_animate_call_flashing_monster ($01:F317)
;
; Animates a summoned monster briefly flashing.
_battle_animate_call_flashing_monster:
    STZ <r_battle_monster_effect_counter                                        ; $01F317 | Initialize the monster effect counter to zero.
-   JSR _battle_wait_next_frame_preserve_x_y                                    ; $01F319 | Wait for the next frame.
    LDA <r_battle_monster_effect_counter                                        ; $01F31C |\
    AND #%00000100.b                                                            ; $01F31E | | Set the alternate party sprite tile flags to use priority 3 and
    LSR A                                                                       ; $01F320 | | to alternate between palettes 2 and 4 every four frames, using the
    LSR A                                                                       ; $01F321 | | low name table.
    BNE +                                                                       ; $01F322 | |
    LDA #%00110100.b                                                            ; $01F324 | |
    JMP ++                                                                      ; $01F326 | |
+   LDA #%00111000.b                                                            ; $01F329 | |
++  STA r_battle_alternate_party_sprite_tile_flags.w                            ; $01F32B |/
    INC <r_battle_monster_effect_counter                                        ; $01F32E | Increment the effect counter.
    LDA <r_battle_monster_effect_counter                                        ; $01F330 |\
    CMP #16.b                                                                   ; $01F332 | | Loop until the effect counter reaches 16.
    BNE -                                                                       ; $01F334 |/
    LDA #%00111000.b                                                            ; $01F336 |\ Set the final tile flags to use priority 3 and palette 4.
    STA r_battle_alternate_party_sprite_tile_flags.w                            ; $01F338 |/
    RTS                                                                         ; $01F33B

; _battle_alternate_party_sprite_update_forward_strike ($01:F33C)
;
; Moves the alternate party sprite to the left by eight pixels, and then updates
; the invisible columns based on its current position.
_battle_alternate_party_sprite_update_forward_strike
    PHX                                                                         ; $01F33C | Preserve the value in the X register.
    LDA r_battle_alternate_party_sprite_coordinates.x.w                         ; $01F33D |\
    SEC                                                                         ; $01F340 | | Subtract 8 from the alternate party sprite's X coordinate.
    SBC #8.b                                                                    ; $01F341 | |
    STA r_battle_alternate_party_sprite_coordinates.x.w                         ; $01F343 |/
    BNE +                                                                       ; $01F346 |\ If the X coordinate reaches zero, increment the invisibility index
    INC r_battle_alternate_party_sprite_invisible_column_index.w                ; $01F348 |/ to begin the column hiding process.
+   LDA r_battle_alternate_party_sprite_invisible_column_index.w                ; $01F34B |\ Skip the remainder unless the invisibility index is not zero.
    BEQ +                                                                       ; $01F34E |/
    LDA r_battle_alternate_party_sprite_invisible_columns.w                     ; $01F350 |\
    CMP #%11111111.b                                                            ; $01F353 | | If all columns are already invisible, skip to the end.
    BEQ +                                                                       ; $01F355 |/
    LDA r_battle_alternate_party_sprite_invisible_column_index.w                ; $01F357 |\
    TAX                                                                         ; $01F35A | | Read the correct invisible columns for this index and set the
    LDA bank0D.battle_alternate_party_sprite_invisible_columns_data.l,X         ; $01F35B | | value.
    STA r_battle_alternate_party_sprite_invisible_columns.w                     ; $01F35F |/
    INC r_battle_alternate_party_sprite_invisible_column_index.w                ; $01F362 | Increment the invisibility index for next time.
+   PLX                                                                         ; $01F365 | Restore the value in the X register.
    RTS                                                                         ; $01F366

; _battle_animate_sixteen_hits ($01:F367)
;
; Animates sixteen hits on the target monster by calling a function in bank $02
; to do such.
_battle_animate_sixteen_hits:
    LDA #$20.b                                                                  ; $01F367 |\ Set the base OAM index to 32.
    STA r_battle_effect_sprites_base_oam_index.w                                ; $01F369 |/ NOTE: This is useless, since it's overwritten very quickly.
    JSL bank02.battle_animate_sixteen_hits                                      ; $01F36C | Animate sixteen hits on the target monster.
    RTS                                                                         ; $01F370

; battle_animate_call_imp ($01:F371)
;
; Animates the Imp summoned monster hitting its target.
battle_animate_call_imp:
    JSR _battle_alternate_party_sprite_move_forward                             ; $01F371 | Animate the monster moving forward 16 pixels.
    JSR _battle_animate_call_flashing_monster                                   ; $01F374 | Animate the monster flashing briefly.
    JSR _battle_play_sound_effect_spell                                         ; $01F377 | Play the configured sound effect.
    JSR _battle_animate_sixteen_hits                                            ; $01F37A | Animate sixteen hits hitting the target.
    JSR _battle_alternate_party_sprite_move_backward                            ; $01F37D | Animate the monster moving backward 16 pixels.
    RTL                                                                         ; $01F380

; battle_animate_call_bomb_initial ($01:F381)
;
; Animates the first part of the Bomb summoned monster's attack. Moves it
; forward and animates it flashing.
battle_animate_call_bomb_initial:
    JSR _battle_alternate_party_sprite_move_forward                             ; $01F381 | Animate the monster moving forward 16 pixels.
    JSR _battle_animate_call_flashing_monster                                   ; $01F384 | Animate the monster flashing briefly.
    RTL                                                                         ; $01F387

; battle_animate_call_chocobo_kick ($01:F388)
;
; Animates the portion of the Chocobo spell effect that involves it hitting the
; enemy. The Chocobo is assumed to already be placed at the location where it
; will attack.
battle_animate_call_chocobo_kick:
    INC r_battle_alternate_party_sprite_auto_animate.w                          ; $01F388 | Activate auto-animation of the alternate party sprite.
    JSR _battle_play_sound_effect_spell                                         ; $01F38B | Play the configured sound effect.
    JSR _battle_animate_sixteen_hits                                            ; $01F38E | Animate sixteen hits.
    STZ r_battle_alternate_party_sprite_frame_counter.w                         ; $01F391 | Reset the frame back to the default.
    STZ r_battle_alternate_party_sprite_auto_animate.w                          ; $01F394 | Disable auto-animation.
    RTL                                                                         ; $01F397

; _battle_wait_x_frames ($01:F398)
;
; Waits for the number of frames provided in the X register.
_battle_wait_x_frames:
-   JSR _battle_wait_next_frame_preserve_x_y                                    ; $01F398 | Wait for the next frame.
    DEX                                                                         ; $01F39B |\ Loop until the X register reaches zero.
    BNE -                                                                       ; $01F39C |/
    RTS                                                                         ; $01F39E

; _battle_animate_call_asura ($01:F39F)
;
; Animates the Asura spell.
_battle_animate_call_asura:
    INC r_battle_alternate_party_sprite_auto_animate.w                          ; $01F39F | Enable auto-animation of the alternate party sprite.
    LDX #32.w                                                                   ; $01F3A2 |\ Wait for 32 to frames to animate the rotating heads for a short
    JSR _battle_wait_x_frames                                                   ; $01F3A5 |/ time.
    STZ r_battle_alternate_party_sprite_frame_counter.w                         ; $01F3A8 |\ Disable auto-animation and return to the base frame.
    STZ r_battle_alternate_party_sprite_auto_animate.w                          ; $01F3AB |/
    LDX #8.w                                                                    ; $01F3AE |\ Wait for eight frames.
    JSR _battle_wait_x_frames                                                   ; $01F3B1 |/
    RTS                                                                         ; $01F3B4

; battle_animate_call_asura ($01:F3B5)
;
; Proxy function to call _battle_animate_call_asura from another bank.
battle_animate_call_asura:
    JSR _battle_animate_call_asura                                              ; $01F3B5
    RTL                                                                         ; $01F3B8

; battle_animate_spell_demolish ($01:F3B9)
;
; Animates the Demolish spell.
battle_animate_spell_demolish:
    JSR _battle_reset_effect_oam_large                                          ; $01F3B9 | Reset the effect OAM to large sprites.
    JSR _battle_play_sound_effect_spell                                         ; $01F3BC | Play the sound effect for the spell.
    STZ <r_battle_generic_tmp_index_lo                                          ; $01F3BF | Initialize the first temporary index to zero.
    LDA #64.b                                                                   ; $01F3C1 |\ Initialize the second temporary index to 64, which will be 90
    STA <r_battle_generic_tmp_index_2_lo                                        ; $01F3C3 |/ degrees out of phase.
    TDC                                                                         ; $01F3C5 |\ Initialize the X register to zero.
    TAX                                                                         ; $01F3C6 |/
-   LDA <r_battle_generic_tmp_index_lo                                          ; $01F3C7 |\ Set the current sine index to the current first value.
    STA r_battle_effect_sine_index.w + 0,X                                      ; $01F3C9 |/
    CLC                                                                         ; $01F3CC |\
    ADC #16.b                                                                   ; $01F3CD | | Add 16 to the value for next time (22.5 degrees).
    STA <r_battle_generic_tmp_index_lo                                          ; $01F3CF |/
    PHA                                                                         ; $01F3D1 | Preserve the updated value.
    LDA <r_battle_generic_tmp_index_2_lo                                        ; $01F3D2 |\ Set the current cosine index to the current second value.
    STA r_battle_effect_sine_index_2.w + 0,X                                    ; $01F3D4 |/
    CLC                                                                         ; $01F3D7 |\
    ADC #16.b                                                                   ; $01F3D8 | | Add 16 to the value for next time (22.5 degrees).
    STA <r_battle_generic_tmp_index_2_lo                                        ; $01F3DA |/
    CLC                                                                         ; $01F3DC |\
    ADC #112.b                                                                  ; $01F3DD | | Add 128 to set the current 90-degree phased value.
    STA r_battle_effect_sine_index_2.w + 4,X                                    ; $01F3DF |/
    PLA                                                                         ; $01F3E2 |\
    CLC                                                                         ; $01F3E3 | | Pull the sine value, add 128, and use that to set the current 90-
    ADC #112.b                                                                  ; $01F3E4 | | degree phased value for the sine.
    STA r_battle_effect_sine_index.w + 4,X                                      ; $01F3E6 |/
    LDA #24.b                                                                   ; $01F3E9 |\
    STA r_battle_effect_sine_magnitude.w + 0,X                                  ; $01F3EB | | Initialize the initial magnitude to 24 for all values.
    STA r_battle_effect_sine_magnitude.w + 4,X                                  ; $01F3EE | |
    STA r_battle_effect_sine_magnitude_2.w + 0,X                                ; $01F3F1 | |
    STA r_battle_effect_sine_magnitude_2.w + 4,X                                ; $01F3F4 |/
    INX                                                                         ; $01F3F7 |\
    CPX #4.w                                                                    ; $01F3F8 | | Loop until all of the entries have been set.
    BNE -                                                                       ; $01F3FB |/
    LDA r_battle_effect_target_slot.w                                           ; $01F3FD |\
    ASL A                                                                       ; $01F400 | | Set the X register to the target slot times two.
    TAX                                                                         ; $01F401 |/
    LDA r_battle_current_action_details.target_flags.w                          ; $01F402 |\
    BMI +                                                                       ; $01F405 | | If the target is a character, set the center coordinates based on
    LDA r_battle_character_cursor_coordinates_copy_2.1.x.w,X                    ; $01F407 | | the cursor coordinates for the character. Add 24 to the X
    CLC                                                                         ; $01F40A | | coordinate and use the Y coordinate directly.
    ADC #24.b                                                                   ; $01F40B | |
    STA r_battle_effect_demolish_center_coordinates.x.w                         ; $01F40D | |
    LDA r_battle_character_cursor_coordinates_copy_2.1.y.w,X                    ; $01F410 | |
    STA r_battle_effect_demolish_center_coordinates.y.w                         ; $01F413 | |
    BRA ++                                                                      ; $01F416 |/
+   LDA r_battle_monster_coordinates_center.1.x.w,X                             ; $01F418 |\
    STA r_battle_effect_demolish_center_coordinates.x.w                         ; $01F41B | | If the target is a monster, use the monster's center coordinates.
    LDA r_battle_monster_coordinates_center.1.y.w,X                             ; $01F41E | |
    STA r_battle_effect_demolish_center_coordinates.y.w                         ; $01F421 |/
++  LDA r_battle_effect_demolish_center_coordinates.x.w                         ; $01F424 |\
    SEC                                                                         ; $01F427 | | Subtract eight from both of the coordinates to center the 16x16
    SBC #8.b                                                                    ; $01F428 | | sprite.
    STA r_battle_effect_demolish_center_coordinates.x.w                         ; $01F42A | |
    LDA r_battle_effect_demolish_center_coordinates.y.w                         ; $01F42D | |
    SEC                                                                         ; $01F430 | |
    SBC #8.b                                                                    ; $01F431 | |
    STA r_battle_effect_demolish_center_coordinates.y.w                         ; $01F433 |/
--  LDX #4.w                                                                    ; $01F436 |\ Wait for four frames.
    JSR _battle_wait_x_frames                                                   ; $01F439 |/
    TDC                                                                         ; $01F43C |\ Initialize the X register (the sprite number) to zero.
    TAX                                                                         ; $01F43D |/
-   JSR _battle_effect_get_sine_value_2                                         ; $01F43E |\ Set the X coordinate to the cosine value.
    STA r_battle_effect_demolish_sprite_coordinates_x.w,X                       ; $01F441 |/
    JSR _battle_effect_get_sine_value                                           ; $01F444 |\ Set the Y coordinate to the sine value.
    STA r_battle_effect_demolish_sprite_coordinates_y.w,X                       ; $01F447 |/
    LDA #-16.b                                                                  ; $01F44A |\ Subtract 16 from each of the sine indexes (to move 22.5 degrees
    JSR _battle_effect_increment_sine_indexes                                   ; $01F44C |/ counterclockwise).
    INX                                                                         ; $01F44F |\
    CPX #8.w                                                                    ; $01F450 | | Increment the X register and loop until all 8 sprites are done.
    BNE -                                                                       ; $01F453 |/
    JSR _battle_effect_spell_demolish_update_oam                                ; $01F455 | Update the OAM entries.
    JSR _battle_effect_spell_demolish_update_sine_magnitudes                    ; $01F458 | Update the sine magnitudes.
    LDA r_battle_effect_sine_magnitude.w                                        ; $01F45B |\ Loop until the magnitude for the head sprite reaches zero.
    BNE --                                                                      ; $01F45E |/
    RTL                                                                         ; $01F460

; _battle_effect_spell_demolish_update_sine_magnitudes ($01:F461)
;
; Decrements the sine magnitudes for the sprites used in the Demolish spell
; effect.
_battle_effect_spell_demolish_update_sine_magnitudes:
    TDC                                                                         ; $01F461 |\ Initialize the X register to zero.
    TAX                                                                         ; $01F462 |/
-   LDA r_battle_effect_sine_magnitude.w + 0,X                                  ; $01F463 |\
    STA r_battle_effect_sine_magnitude.w + 1,X                                  ; $01F466 | | Copy the magnitudes for the head sprites to the tail sprites.
    LDA r_battle_effect_sine_magnitude_2.w + 0,X                                ; $01F469 | |
    STA r_battle_effect_sine_magnitude_2.w + 1,X                                ; $01F46C | |
    LDA r_battle_effect_sine_magnitude.w + 4,X                                  ; $01F46F | |
    STA r_battle_effect_sine_magnitude.w + 5,X                                  ; $01F472 | |
    LDA r_battle_effect_sine_magnitude_2.w + 4,X                                ; $01F475 | |
    STA r_battle_effect_sine_magnitude_2.w + 5,X                                ; $01F478 |/
    INX                                                                         ; $01F47B |\
    CPX #3.w                                                                    ; $01F47C | | Loop until the magnitudes have been entirely updated.
    BNE -                                                                       ; $01F47F |/
    DEC r_battle_effect_sine_magnitude.w + 0                                    ; $01F481 |\
    DEC r_battle_effect_sine_magnitude.w + 4                                    ; $01F484 | | Decrement the head magnitudes.
    DEC r_battle_effect_sine_magnitude_2.w + 0                                  ; $01F487 | |
    DEC r_battle_effect_sine_magnitude_2.w + 4                                  ; $01F48A |/
    RTS                                                                         ; $01F48D

; _battle_effect_spell_demolish_update_oam ($01:F48E)
;
; Updates the OAM entries for the Demolish spell.
_battle_effect_spell_demolish_update_oam:
    TDC                                                                         ; $01F48E |\
    TAX                                                                         ; $01F48F | | Initialize the X and Y registers to zero.
    TAY                                                                         ; $01F490 |/
-   LDA r_battle_effect_demolish_sprite_coordinates_x.w,X                       ; $01F491 |\
    CLC                                                                         ; $01F494 | | Set the OAM entry X coordinate to the center X coordinate plus the
    ADC r_battle_effect_demolish_center_coordinates.x.w                         ; $01F495 | | individual sprite X coordinate.
    STA r_oam.17.x.w,Y                                                          ; $01F498 |/
    LDA r_battle_effect_demolish_sprite_coordinates_y.w,X                       ; $01F49B |\
    CLC                                                                         ; $01F49E | | Set the OAM entry Y coordinate to the center Y coordinate plus the
    ADC r_battle_effect_demolish_center_coordinates.y.w                         ; $01F49F | | individual sprite Y coordinate.
    STA r_oam.17.y.w,Y                                                          ; $01F4A2 |/
    LDA bank0D.battle_effect_demolish_oam_tile_data.l,X                         ; $01F4A5 |\ Read the tile number from ROM for this sprite.
    STA r_oam.17.tile.w,Y                                                       ; $01F4A9 |/
    LDA r_formation_back_attack_copy.w                                          ; $01F4AC |\
    BEQ +                                                                       ; $01F4AF | | If this is a back attack, calculate the X coordinate by adding the
    LDA r_battle_effect_demolish_sprite_coordinates_x.w,X                       ; $01F4B1 | | center coordinate to the sprite coordinate, flipping the bits, and
    CLC                                                                         ; $01F4B4 | | subtracting 16. Additionally, load the intended tile flags into
    ADC r_battle_effect_demolish_center_coordinates.x.w                         ; $01F4B5 | | the accumulator, which includes the horizontal flip bit.
    EOR #%11111111.b                                                            ; $01F4B8 | |
    SEC                                                                         ; $01F4BA | | NOTE: This completely overwrites any previousl calculated X
    SBC #16.b                                                                   ; $01F4BB | |       coordinate, which makes the original calculation a waste.
    STA r_oam.17.x.w,Y                                                          ; $01F4BD | |       Even if not a back attack, it gets recalculated below.
    LDA #%01111111.b                                                            ; $01F4C0 | |
    BRA ++                                                                      ; $01F4C2 |/
+   LDA r_battle_effect_demolish_sprite_coordinates_x.w,X                       ; $01F4C4 |\
    CLC                                                                         ; $01F4C7 | | If not a back attack, calculate the X coordinate to the sum of the
    ADC r_battle_effect_demolish_center_coordinates.x.w                         ; $01F4C8 | | center X coordinate and the sprite X coordinate, and load the
    STA r_oam.17.x.w,Y                                                          ; $01F4CB | | standard tile flags into the accumulator.
    LDA #%00111111.b                                                            ; $01F4CE |/
++  STA r_oam.17.flags.w,Y                                                      ; $01F4D0 | Set the flags to the loaded value.
    INY                                                                         ; $01F4D3 |\
    INY                                                                         ; $01F4D4 | | Increment the Y register by four to move to the next OAM entry.
    INY                                                                         ; $01F4D5 | |
    INY                                                                         ; $01F4D6 |/
    INX                                                                         ; $01F4D7 | Increment the X register to move to the next sprite.
    CPX #8.w                                                                    ; $01F4D8 |\ Loop until all eight sprites have been updated.
    BNE -                                                                       ; $01F4DB |/
    RTS                                                                         ; $01F4DD

; battle_animate_drain ($01:F4DE)
;
; Animates the Drain spell effect.
battle_animate_drain:
    JSR _battle_reset_effect_oam_large                                          ; $01F4DE | Reset the effect OAM to large sprites.
    JSR _battle_play_sound_effect_spell                                         ; $01F4E1 | Play the configured sound effect for the spell.
    LDA #$84.b                                                                  ; $01F4E4 |\ Set the base tile number to $84.
    STA r_battle_effect_particle_base_tile_number.w                             ; $01F4E6 |/
    LDA #112.b                                                                  ; $01F4E9 |\
    STA <r_battle_effect_init_sine_full_arg_magnitude_sine                      ; $01F4EB | | Initialize the sine/cosine arrays, passing a magnitude of 112.
    STA <r_battle_effect_init_sine_full_arg_magnitude_cosine                    ; $01F4ED | |
    JSR _battle_effect_init_sine_full                                           ; $01F4EF |/
    LDA #4.b                                                                    ; $01F4F2 |\
    STA r_battle_animate_drain_convergence_arg_delta.w                          ; $01F4F4 | | Set both the convergence delta and limit to four.
    STA r_battle_animate_drain_convergence_arg_limit.w                          ; $01F4F7 |/
    JSR _battle_animate_drain_convergence                                       ; $01F4FA | Animate the convergence effect.
    LDA r_formation_back_attack_copy.w                                          ; $01F4FD |\
    BEQ +                                                                       ; $01F500 | | Set a temporary variable to either eight (if a back attack) or
    LDA #8.b                                                                    ; $01F502 | | -8 (if not a back attack).
    BRA ++                                                                      ; $01F504 | |
+   LDA #-8.b                                                                   ; $01F506 | |
++  STA <r_battle_generic_tmp_index_2_lo                                        ; $01F508 |/
    LDA r_battle_effect_target_slot.w                                           ; $01F50A |\
    ASL A                                                                       ; $01F50D | | Set the Y register to the target slot times two.
    TAY                                                                         ; $01F50E |/
    LDA r_battle_current_action_details.actor_flags.w                           ; $01F50F |\ Branch to separate code if the actor is a character.
    BPL +                                                                       ; $01F512 |/
    LDA r_battle_character_cursor_coordinates_copy_2.1.x.w,Y                    ; $01F514 |\
    CLC                                                                         ; $01F517 | | Set the projectile source X coordinate to the character cursor X
    ADC #24.b                                                                   ; $01F518 | | coordinate plus 24 plus the previously calculated value.
    ADC <r_battle_generic_tmp_index_2_lo                                        ; $01F51A | |
    STA r_battle_effect_projectile_source_coordinates.x.w                       ; $01F51C |/
    LDA r_battle_character_cursor_coordinates_copy_2.1.y.w,Y                    ; $01F51F |\
    SEC                                                                         ; $01F522 | | Set the projectile source Y coordinate to the character cursor Y
    SBC #8.b                                                                    ; $01F523 | | coordinate minus eight.
    STA r_battle_effect_projectile_source_coordinates.y.w                       ; $01F525 |/
    BRA ++                                                                      ; $01F528 | Branch ahead past the next block.
+   LDA r_battle_monster_coordinates_center.1.x.w,Y                             ; $01F52A |\
    CLC                                                                         ; $01F52D | | If the actor is a character, set the coordinates instead assuming
    ADC <r_battle_generic_tmp_index_2_lo                                        ; $01F52E | | the target is a monster.
    STA r_battle_effect_projectile_source_coordinates.x.w                       ; $01F530 | |
    LDA r_battle_monster_coordinates_center.1.y.w,Y                             ; $01F533 | |
    SEC                                                                         ; $01F536 | |
    SBC #8.b                                                                    ; $01F537 | |
    STA r_battle_effect_projectile_source_coordinates.y.w                       ; $01F539 |/
++  LDA r_battle_current_actor_slot.w                                           ; $01F53C |\
    ASL A                                                                       ; $01F53F | | Set the Y register to the actor slot times two.
    TAY                                                                         ; $01F540 |/
    LDA r_battle_current_action_details.target_flags.w                          ; $01F541 |\
    BPL +                                                                       ; $01F544 | | Set the projectile target coordinates identically to how the
    LDA r_battle_character_cursor_coordinates_copy_2.1.x.w,Y                    ; $01F546 | | source coordinates were set, except using the actor's coordinates
    CLC                                                                         ; $01F549 | | instead of the spell target's.
    ADC #24.b                                                                   ; $01F54A | |
    STA r_battle_effect_projectile_target_coordinates.x.w                       ; $01F54C | | NOTE: Both this code and the above code oddly determine whether
    LDA r_battle_character_cursor_coordinates_copy_2.1.y.w,Y                    ; $01F54F | |       the subject is a character or monster by checking the flags
    SEC                                                                         ; $01F552 | |       of the opposite class. (That is, to check if the actor is a
    SBC #8.b                                                                    ; $01F553 | |       monster, it checks the target flags.) Later code explicitly
    STA r_battle_effect_projectile_target_coordinates.y.w                       ; $01F555 | |       prevents the code from doing anything if the actor and
    BRA ++                                                                      ; $01F558 | |       target are on the same side, but there wouldn't have been
+   LDA r_battle_monster_coordinates_center.1.x.w,Y                             ; $01F55A | |       any disadvantage to simply checking the normal way.
    CLC                                                                         ; $01F55D | |
    ADC <r_battle_generic_tmp_index_2_lo                                        ; $01F55E | |
    STA r_battle_effect_projectile_target_coordinates.x.w                       ; $01F560 | |
    LDA r_battle_monster_coordinates_center.1.y.w,Y                             ; $01F563 | |
    SEC                                                                         ; $01F566 | |
    SBC #8.b                                                                    ; $01F567 | |
    STA r_battle_effect_projectile_target_coordinates.y.w                       ; $01F569 |/
++  LDA #16.b                                                                   ; $01F56C |\ Set the horizontal rate to sixteen pixels per frame.
    STA r_battle_effect_projectile_horizontal_rate.w                            ; $01F56E |/
    JSL bank02.battle_effect_projectile_initialize                              ; $01F571 | Initialize the projectile variables.
    INC r_battle_effect_particle_custom_coordinates.w                           ; $01F575 | Set the flag to use custom coordinates for the particle sprites.
    LDA r_battle_current_action_details.actor_flags.w                           ; $01F578 |\
    AND #BATTLE_ACTION_DETAILS_ACTOR_FLAG_MONSTER.b                             ; $01F57B | | Skip the remainder of the code if the actor and target are on the
    STA <r_battle_generic_tmp_index_lo                                          ; $01F57D | | same side of the battlefield.
    LDA r_battle_current_action_details.target_flags.w                          ; $01F57F | |
    AND #BATTLE_ACTION_DETAILS_TARGET_FLAG_MONSTER.b                            ; $01F582 | |
    CMP <r_battle_generic_tmp_index_lo                                          ; $01F584 | |
    BEQ +                                                                       ; $01F586 |/
-   JSL bank02.battle_effect_projectile_update_coordinates                      ; $01F588 |\ Update the current projectile coordinates and return if the last
    BCS +                                                                       ; $01F58C |/ update has completed.
    LDX r_battle_effect_projectile_coordinates.w                                ; $01F58E |\ Set the particle coordinates to the calculated projectile
    STX r_battle_effect_particle_coordinates.w                                  ; $01F591 |/ coordinates.
    JSR _battle_effect_spell_drain_update_and_rotate                            ; $01F594 | Update the particle sprites.
    BRA -                                                                       ; $01F597 | Continue looping.
+   RTL                                                                         ; $01F599

; battle_animate_nuke_particles ($01:F59A)
;
; Animates the particle effect of the Nuke spell.
battle_animate_nuke_particles:
    JSR _battle_reset_effect_oam_large                                          ; $01F59A | Reset the effect OAM to large sprites.
    TDC                                                                         ; $01F59D |\ Initialize the X register to zero.
    TAX                                                                         ; $01F59E |/
    DEC A                                                                       ; $01F59F |\ Set the base tile number to $FF to enable individual tile numbers
    STA r_battle_effect_particle_base_tile_number.w                             ; $01F5A0 |/ for each sprite.
-   LDA r_prng_data.w,X                                                         ; $01F5A3 |\
    JSR _battle_animate_nuke_initialize_sine                                    ; $01F5A6 | | Loop through the 64 sprites, initially setting them as visible and
    TDC                                                                         ; $01F5A9 | | initializing their sine indexes and magnitudes to random values.
    STA r_battle_effect_particle_sprite_invisible.w,X                           ; $01F5AA | |
    INX                                                                         ; $01F5AD | |
    CPX #$0040.w                                                                ; $01F5AE | |
    BNE -                                                                       ; $01F5B1 |/
    JSR _set_battle_flash_pulse_red                                             ; $01F5B3 | Set a pulsing red battle flash effect.
    LDX #24.w                                                                   ; $01F5B6 | Initialize the X register to 24.
@start:
    PHX                                                                         ; $01F5B9 | Preserve the value in the X register.
    STZ r_battle_effect_particle_custom_coordinates.w                           ; $01F5BA | Disable the use of custom coordinates for the particle effect.
    TDC                                                                         ; $01F5BD |\ Initialize the Y register to zero.
    TAY                                                                         ; $01F5BE |/
-   LDA r_battle_effect_sine_magnitude.w,Y                                      ; $01F5BF |\
    LSR A                                                                       ; $01F5C2 | | Set the tile number for this sprite by taking the magnitude,
    LSR A                                                                       ; $01F5C3 | | dividing by 32, taking the result mod 4, and then indexing a table
    LSR A                                                                       ; $01F5C4 | | of tile numbers.
    LSR A                                                                       ; $01F5C5 | |
    LSR A                                                                       ; $01F5C6 | |
    AND #%00000011.b                                                            ; $01F5C7 | |
    TAX                                                                         ; $01F5C9 | |
    LDA bank0D.battle_effect_spell_nuke_oam_tile_data.l,X                       ; $01F5CA | |
    STA r_battle_effect_particle_sprite_tile_number.w,Y                         ; $01F5CE |/
    INY                                                                         ; $01F5D1 |\
    CPY #64.w                                                                   ; $01F5D2 | | Loop until all 64 sprites have been set.
    BNE -                                                                       ; $01F5D5 |/
    LDA #64.b                                                                   ; $01F5D7 |\ Update the particle sprites, indicating that there are 64 of them,
    JSR _battle_effect_particle_update_custom_count                             ; $01F5D9 |/ rather than the default of eight.
    TDC                                                                         ; $01F5DC |\ Initialize the X register to zero.
    TAX                                                                         ; $01F5DD |/
-   LDA r_battle_effect_particle_sprite_invisible.w,X                           ; $01F5DE |\ If the sprite is already invisible, skip this next block.
    BNE +                                                                       ; $01F5E1 |/
    LDA r_battle_effect_sine_magnitude.w,X                                      ; $01F5E3 |\
    SEC                                                                         ; $01F5E6 | | Subtract eight from the two magnitudes.
    SBC #8.b                                                                    ; $01F5E7 | |
    STA r_battle_effect_sine_magnitude.w,X                                      ; $01F5E9 | |
    STA r_battle_effect_sine_magnitude_2.w,X                                    ; $01F5EC |/
    CMP #16.b                                                                   ; $01F5EF |\
    BCS +                                                                       ; $01F5F1 | | If the magnitude is lower than 16, set the invisibility flag.
    LDA #1.b                                                                    ; $01F5F3 | |
    STA r_battle_effect_particle_sprite_invisible.w,X                           ; $01F5F5 |/
+   INX                                                                         ; $01F5F8 |\
    CPX #64.w                                                                   ; $01F5F9 | | Loop until all 64 sprites have been updated.
    BNE -                                                                       ; $01F5FC |/
    PLX                                                                         ; $01F5FE |\
    CPX #9.w                                                                    ; $01F5FF | | If the X register is exactly nine, set the battle flash to be
    BNE +                                                                       ; $01F602 | | continuous rather than pulsing.
    JSL set_battle_flash_continuous_red                                         ; $01F604 |/
+   DEX                                                                         ; $01F608 |\ Decrement the X register and loop until it reaches zero.
    BNE @start                                                                  ; $01F609 |/
    STZ r_battle_flash_mode.w                                                   ; $01F60B | Disable the battle flash effect.
    RTL                                                                         ; $01F60E

; _battle_animate_nuke_initialize_sine ($01:F60F)
;
; Given a sprite index in the X register and a magnitude in the accumulator,
; initializes the sine indexes and magnitudes for that sprite. Note that the
; indexes are determined by using the provided magnitude as an index to the PRNG
; data, so every magnitude will always produce the same value. The magnitude
; itself is truncated to the nearest multiple of four before being set as the
; magnitude (but not before being used as the PRNG index).
_battle_animate_nuke_initialize_sine:
    PHA                                                                         ; $01F60F |\
    TAY                                                                         ; $01F610 | | Set the first sine index for the index passed in the X register to
    LDA r_prng_data.w,Y                                                         ; $01F611 | | a random value determined by the value passed in the accumulator.
    STA r_battle_effect_sine_index.w,X                                          ; $01F614 | | Set the second sine index to that value plus 64, to serve as a
    CLC                                                                         ; $01F617 | | cosine.
    ADC #64.b                                                                   ; $01F618 | |
    STA r_battle_effect_sine_index_2.w,X                                        ; $01F61A | |
    PLA                                                                         ; $01F61D |/
    AND #%11111100.b                                                            ; $01F61E |\
    STA r_battle_effect_sine_magnitude.w,X                                      ; $01F620 | | Set the two magnitudes to the parameter, truncated to a multiple
    STA r_battle_effect_sine_magnitude_2.w,X                                    ; $01F623 |/  of four.
    RTS                                                                         ; $01F626

; _battle_effect_init_sine_full ($01:F627)
;
; Given an 8-bit sine magnitude in $04 and an 8-bit cosine magnitude in $06,
; initializes the entire set of 64-byte arrays relating to sine calculations.
; The two index arrays are initialized out of phase with each other by 90
; degrees, allowing the first to serve as a sine function and the second to
; serve as a cosine function. The arrays themselves are initialized in 45 degree
; increments, resulting in eight unique values, that repeat a total of eight
; times.
_battle_effect_init_sine_full:
    STZ r_battle_effect_particle_custom_coordinates.w                           ; $01F627 | Disable the use of custom coordinates in the particle effect.
    TDC                                                                         ; $01F62A |\ Initialize the X register to zero.
    TAX                                                                         ; $01F62B |/
    STZ <r_battle_generic_tmp_index_lo                                          ; $01F62C | Initialize the first sine index value to zero.
    LDA #64.b                                                                   ; $01F62E |\ Initialize the second sine index value to 64, which allows it to
    STA <r_battle_generic_tmp_index_2_lo                                        ; $01F630 |/ serve as cosine.
-   LDA <r_battle_generic_tmp_index_lo                                          ; $01F632 |\
    STA r_battle_effect_sine_index.w,X                                          ; $01F634 | | Set the next sine index to the current value and add 32 to prepare
    CLC                                                                         ; $01F637 | | for the next index.
    ADC #32.b                                                                   ; $01F638 | |
    STA <r_battle_generic_tmp_index_lo                                          ; $01F63A |/
    LDA <r_battle_generic_tmp_index_2_lo                                        ; $01F63C |\
    STA r_battle_effect_sine_index_2.w,X                                        ; $01F63E | | Set the next cosine index to the current value and add 32 to
    CLC                                                                         ; $01F641 | | prepare for the next index.
    ADC #32.b                                                                   ; $01F642 | |
    STA <r_battle_generic_tmp_index_2_lo                                        ; $01F644 |/
    LDA <r_battle_effect_init_sine_full_arg_magnitude_sine                      ; $01F646 |\
    STA r_battle_effect_sine_magnitude.w,X                                      ; $01F648 | | Set the two magnitudes to the passed values.
    LDA <r_battle_effect_init_sine_full_arg_magnitude_cosine                    ; $01F64B | |
    STA r_battle_effect_sine_magnitude_2.w,X                                    ; $01F64D |/
    INX                                                                         ; $01F650 |\
    CPX #_sizeof_r_battle_effect_sine_index.w                                   ; $01F651 | | Loop until all 64 bytes have been written.
    BNE -                                                                       ; $01F654 |/
    RTS                                                                         ; $01F656

UNUSED_CODE_01F657:
--  JSR _battle_effect_particle_update                                          ; $01F657
    TDC                                                                         ; $01F65A
    TAX                                                                         ; $01F65B
-   LDA #8.b                                                                    ; $01F65C
    JSR _battle_effect_increment_sine_indexes                                   ; $01F65E
    LDA r_battle_animate_drain_convergence_arg_delta.w                          ; $01F661
    JSR _battle_effect_increment_sine_magnitudes                                ; $01F664
    INX                                                                         ; $01F667
    CPX #8.w                                                                    ; $01F668
    BNE -                                                                       ; $01F66B
    LDA r_battle_effect_sine_magnitude.w                                        ; $01F66D
    CMP r_battle_animate_drain_convergence_arg_limit.w                          ; $01F670
    BNE --                                                                      ; $01F673
    RTS                                                                         ; $01F675

; _battle_animate_drain_convergence ($01:F676)
;
; Animates the convergence of the eight particle sprites from their initial
; spread out positions to the target position. Includes a relatively quick
; rotation effect of one cycle per 32 frames.
_battle_animate_drain_convergence:
--  JSR _battle_effect_particle_update                                          ; $01F676 | Update the particle sprites.
    TDC                                                                         ; $01F679 |\ Initialize the X register to zero.
    TAX                                                                         ; $01F67A |/
-   LDA #8.b                                                                    ; $01F67B |\ Add eight to the sine indexes to rotate the sprites by 1/32nd of a
    JSR _battle_effect_increment_sine_indexes                                   ; $01F67D |/ circle.
    LDA r_battle_effect_sine_magnitude.w,X                                      ; $01F680 |\
    BEQ +                                                                       ; $01F683 | | Subtract the delta value from the first magnitude.
    SEC                                                                         ; $01F685 | |
    SBC r_battle_animate_drain_convergence_arg_delta.w                          ; $01F686 | |
    STA r_battle_effect_sine_magnitude.w,X                                      ; $01F689 |/
+   LDA r_battle_effect_sine_magnitude_2.w,X                                    ; $01F68C |\
    BEQ +                                                                       ; $01F68F | | Subtract the delta value from the second magnitude.
    SEC                                                                         ; $01F691 | |
    SBC r_battle_animate_drain_convergence_arg_delta.w                          ; $01F692 | |
    STA r_battle_effect_sine_magnitude_2.w,X                                    ; $01F695 |/
+   INX                                                                         ; $01F698 |\
    CPX #8.w                                                                    ; $01F699 | | Loop until all eight entries have been updated.
    BNE -                                                                       ; $01F69C |/
    LDA r_battle_effect_sine_magnitude_2.w                                      ; $01F69E |\
    CMP r_battle_animate_drain_convergence_arg_limit.w                          ; $01F6A1 | | Repeat until the second sine magnitude reaches the passed limit.
    BNE --                                                                      ; $01F6A4 |/
    RTS                                                                         ; $01F6A6

; _battle_effect_spell_drain_update_and_rotate ($01:F6A7)
;
; Updates the current locations of the particle effect sprites and then updates
; the sine indexes to rotate their position in the next cycle.
_battle_effect_spell_drain_update_and_rotate:
    JSR _battle_effect_particle_update                                          ; $01F6A7 | Update the particle effect sprites.
    TDC                                                                         ; $01F6AA |\
    TAX                                                                         ; $01F6AB | | Update the first sixteen sine indexes, incrementing each by eight.
-   LDA #8.b                                                                    ; $01F6AC | | This will result in a full circle movement in 32 cycles.
    JSR _battle_effect_increment_sine_indexes                                   ; $01F6AE | |
    INX                                                                         ; $01F6B1 | |
    CPX #16.w                                                                   ; $01F6B2 | |
    BNE -                                                                       ; $01F6B5 |/
    RTS                                                                         ; $01F6B7

; _battle_effect_particle_update ($01:F6B8)
;
; Updates the current location of the particle effect sprites. The _custom_count
; variant allows you to specify the number of sprites. Otherwise, a default of
; eight is assumed.
_battle_effect_particle_update:
    LDA #8.b                                                                    ; $01F6B8 | Load eight into the accumulator.
_battle_effect_particle_update_custom_count:
    STA r_battle_effect_particle_sprite_count_lo.w                              ; $01F6BA |\ Set the particle sprite count to the loaded value.
    STZ r_battle_effect_particle_sprite_count_hi.w                              ; $01F6BD |/
    JSR _battle_wait_next_frame_preserve_x_y                                    ; $01F6C0 | Wait for the next frame.
    TDC                                                                         ; $01F6C3 |\
    TAX                                                                         ; $01F6C4 | | Initialize the sprite coordinates for the sprites to the cosine
-   JSR _battle_effect_get_sine_value_2                                         ; $01F6C5 | | and sine of each index.
    STA r_battle_effect_particle_sprite_coordinates_x.w,X                       ; $01F6C8 | |
    JSR _battle_effect_get_sine_value                                           ; $01F6CB | |
    STA r_battle_effect_particle_sprite_coordinates_y.w,X                       ; $01F6CE | |
    INX                                                                         ; $01F6D1 | |
    CPX r_battle_effect_particle_sprite_count.w                                 ; $01F6D2 | |
    BNE -                                                                       ; $01F6D5 |/
    TDC                                                                         ; $01F6D7 |\
    TAX                                                                         ; $01F6D8 | | TODO: Store a zero in a location that isn't used again?
    STX <r_battle_generic_tmp_index_3                                           ; $01F6D9 |/
    LDX #_sizeof_oam_sprite.w * 16                                              ; $01F6DB |\ Initialize the current OAM offset to entry 16.
    STX <r_battle_effect_particle_update_arg_oam_offset                         ; $01F6DE |/
    LDA r_formation_back_attack_copy.w                                          ; $01F6E0 |\
    BEQ +                                                                       ; $01F6E3 | | Set a temporary variable to either eight if this is a back attack
    LDA #8.b                                                                    ; $01F6E5 | | or -8 if not.
    BRA ++                                                                      ; $01F6E7 | |
+   LDA #-8.b                                                                   ; $01F6E9 | |
++  STA <r_battle_generic_tmp_index_2_lo                                        ; $01F6EB |/
    LDA r_battle_effect_particle_custom_coordinates.w                           ; $01F6ED |\
    BEQ +                                                                       ; $01F6F0 | | If the use of custom coordinates is enabled, load the custom
    LDX r_battle_effect_particle_coordinates.w                                  ; $01F6F2 | | coordinates, update the sprites using those coordinates, and
    STX <r_battle_effect_particle_update_arg_coordinates                        ; $01F6F5 | | return.
    JMP _battle_effect_particle_update_oam                                      ; $01F6F7 |/
+   LDA r_battle_current_action_details.target_flags.w                          ; $01F6FA |\ Otherwise, check if the target is a monster and branch accordingly.
    BMI @monster                                                                ; $01F6FD |/
    TDC                                                                         ; $01F6FF |\ Initialize the X register to zero.
    TAX                                                                         ; $01F700 |/
    LDA r_battle_current_action_details.target.w                                ; $01F701 |\ Store the targets value into a temporary variable.
    STA <r_battle_effect_particle_tmp                                           ; $01F704 |/
-   ASL <r_battle_effect_particle_tmp                                           ; $01F706 |\ If this slot is not set in the target variable, skip this slot.
    BCC +                                                                       ; $01F708 |/
    LDA r_character_slot_if_active.w,X                                          ; $01F70A |\
    CMP #$FF.b                                                                  ; $01F70D | | Skip this slot if the character is not active.
    BEQ +                                                                       ; $01F70F |/
    TXA                                                                         ; $01F711 |\
    ASL A                                                                       ; $01F712 | | Set the X coordinate to the character cursor X coordinate plus 24
    TAY                                                                         ; $01F713 | | plus the previously calculated offset.
    LDA r_battle_character_cursor_coordinates_copy_2.1.x.w,Y                    ; $01F714 | |
    CLC                                                                         ; $01F717 | |
    ADC #24.b                                                                   ; $01F718 | |
    ADC <r_battle_generic_tmp_index_2_lo                                        ; $01F71A | |
    STA <r_battle_effect_particle_update_arg_coordinates.x                      ; $01F71C |/
    LDA r_battle_character_cursor_coordinates_copy_2.1.y.w,Y                    ; $01F71E |\
    SEC                                                                         ; $01F721 | | Set the Y coordinate to the character cursor Y coordinate minus 8.
    SBC #8.b                                                                    ; $01F722 | |
    STA <r_battle_effect_particle_update_arg_coordinates.y                      ; $01F724 |/
    JSR _battle_effect_particle_update_oam                                      ; $01F726 | Update the OAM entries.
+   INX                                                                         ; $01F729 |\
    CPX #5.w                                                                    ; $01F72A | | Loop through all five character slots and return.
    BNE -                                                                       ; $01F72D | |
    RTS                                                                         ; $01F72F |/
@monster:
    TDC                                                                         ; $01F730 |\ Initialize the X register to zero.
    TAX                                                                         ; $01F731 |/
    LDA r_battle_current_action_details.target.w                                ; $01F732 |\ Save the target value to a temporary variable.
    STA <r_battle_effect_particle_tmp                                           ; $01F735 |/
-   ASL <r_battle_effect_particle_tmp                                           ; $01F737 |\ Skip this monster slot if not set in the target variable.
    BCC +                                                                       ; $01F739 |/
    LDA r_monster_slot_to_id_index_pre_action.w,X                               ; $01F73B |\
    CMP #$FF.b                                                                  ; $01F73E | | Skip this slot if there was no monster prior to the action.
    BEQ +                                                                       ; $01F740 |/
    TXA                                                                         ; $01F742 |\
    ASL A                                                                       ; $01F743 | | Set the X coordinate to the monster's center X coordinate
    TAY                                                                         ; $01F744 | | plus the previously calculated offset.
    LDA r_battle_monster_coordinates_center.1.x.w,Y                             ; $01F745 | |
    CLC                                                                         ; $01F748 | |
    ADC <r_battle_generic_tmp_index_2_lo                                        ; $01F749 | |
    STA <r_battle_effect_particle_update_arg_coordinates.x                      ; $01F74B |/
    LDA r_battle_monster_coordinates_center.1.y.w,Y                             ; $01F74D |\
    SEC                                                                         ; $01F750 | | Set the Y coordinate to the monster's center Y coordinate minus
    SBC #8.b                                                                    ; $01F751 | | eight.
    STA <r_battle_effect_particle_update_arg_coordinates.y                      ; $01F753 |/
    JSR _battle_effect_particle_update_oam                                      ; $01F755 | Update the OAM entries.
+   INX                                                                         ; $01F758 |\
    CPX #8.w                                                                    ; $01F759 | | Loop until all eight monsters are checked.
    BNE -                                                                       ; $01F75C |/
    RTS                                                                         ; $01F75E

; _battle_effect_particle_update_oam ($01:F75F)
;
; Handles updating the sprite OAM entries for the battle particle spell effect.
_battle_effect_particle_update_oam:
    INC r_battle_disable_oam_update.w                                           ; $01F75F | Disable automatic transfers to the OAM.
    PHX                                                                         ; $01F762 | Preserve the value of the X register.
    TDC                                                                         ; $01F763 |\ Initialize the X register to zero.
    TAX                                                                         ; $01F764 |/
    LDY <r_battle_effect_particle_update_arg_oam_offset                         ; $01F765 | Set the Y register to the passed OAM offset.
@start:
    LDA r_battle_effect_particle_sprite_coordinates_x.w,X                       ; $01F767 |\
    BMI +                                                                       ; $01F76A | | Set the X coordinate for the current OAM entry. The sprite
    CLC                                                                         ; $01F76C | | specific offset is added to the center X coordinate. If the carry
    ADC <r_battle_effect_particle_update_arg_coordinates.x                      ; $01F76D | | flag is set such that the ultimate coordinate is off-screen,
    BCS ++                                                                      ; $01F76F | | to the off-screen code. Otherwise, set the loaded value as the
    BRA +++                                                                     ; $01F771 | | coordinate.
+   CLC                                                                         ; $01F773 | |
    ADC <r_battle_effect_particle_update_arg_coordinates.x                      ; $01F774 | |
    BCS +++                                                                     ; $01F776 | |
++  BRA @offscreen                                                              ; $01F778 | |
+++ STA r_oam.1.x.w,Y                                                           ; $01F77A |/
    LDA r_battle_effect_particle_sprite_coordinates_y.w,X                       ; $01F77D |\
    BMI +                                                                       ; $01F780 | | Repeat with the Y coordinate, which has an additional restriction
    CLC                                                                         ; $01F782 | | of needing to be less than 128. This code doesn't set the actual
    ADC <r_battle_effect_particle_update_arg_coordinates.y                      ; $01F783 | | value in the OAM, but merely loads it into the accumulator.
    BCS ++                                                                      ; $01F785 | |
    BRA +++                                                                     ; $01F787 | |
+   CLC                                                                         ; $01F789 | |
    ADC <r_battle_effect_particle_update_arg_coordinates.y                      ; $01F78A | |
    BCS +++                                                                     ; $01F78C | |
++  BRA @offscreen                                                              ; $01F78E | |
+++ CMP #128.b                                                                  ; $01F790 | |
    BCC +                                                                       ; $01F792 |/
@offscreen:
    LDA #240.b                                                                  ; $01F794 |\
    STA r_oam.1.x.w,Y                                                           ; $01F796 | | If off-screen, set the X and Y coordinates both to 240.
    STA r_oam.1.y.w,Y                                                           ; $01F799 | |
    BRA ++                                                                      ; $01F79C |/
+   STA r_oam.1.y.w,Y                                                           ; $01F79E | Otherwise, set the loaded Y coordinate as the sprite Y coordinate.
++  LDA r_battle_effect_particle_base_tile_number.w                             ; $01F7A1 |\
    CMP #$FF.b                                                                  ; $01F7A4 | | If the passed base tile number is $FF, then each sprite has its
    BNE ++                                                                      ; $01F7A6 | | own designated tile number. If the sprite has been flagged as
    LDA r_battle_effect_particle_sprite_invisible.w,X                           ; $01F7A8 | | invisible, set its coordinates to 240. Otherwise, load its
    BEQ +                                                                       ; $01F7AB | | specific tile number into the accumulator and branch to the
    LDA #240.b                                                                  ; $01F7AD | | setting code.
    STA r_oam.1.x.w,Y                                                           ; $01F7AF | |
    STA r_oam.1.y.w,Y                                                           ; $01F7B2 | |
    BRA @next                                                                   ; $01F7B5 | |
+   LDA r_battle_effect_particle_sprite_tile_number.w,X                         ; $01F7B7 | |
    BRA +                                                                       ; $01F7BA |/
++  TXA                                                                         ; $01F7BC |\
    AND #%00000001.b                                                            ; $01F7BD | | Otherwise, load the base tile number plus either zero or one
    ASL A                                                                       ; $01F7BF | | depending on the current sprite index (alternate each index).
    CLC                                                                         ; $01F7C0 | |
    ADC r_battle_effect_particle_base_tile_number.w                             ; $01F7C1 |/
+   STA r_oam.1.tile.w,Y                                                        ; $01F7C4 | Either way, store the value as the sprite tile number.
    LDA r_formation_back_attack_copy.w                                          ; $01F7C7 |\
    BEQ +                                                                       ; $01F7CA | | If this is a back attack, flip the bits on the X coordinate to
    LDA r_oam.1.x.w,Y                                                           ; $01F7CC | | move it to the other side.
    EOR #%11111111.b                                                            ; $01F7CF | |
    STA r_oam.1.x.w,Y                                                           ; $01F7D1 |/
    LDA #%01111111.b                                                            ; $01F7D4 |\
    STA r_oam.1.flags.w,Y                                                       ; $01F7D6 | | Set the OAM flags for palette 7, priority 3, and the high name
    BRA @next                                                                   ; $01F7D9 | | table. If this is a back attack, additionally set the horizontal
+   LDA #%00111111.b                                                            ; $01F7DB | | flip bit.
    STA r_oam.1.flags.w,Y                                                       ; $01F7DD |/
@next:
    INX                                                                         ; $01F7E0 | Increment the X register by one to move to the next sprite.
    INY                                                                         ; $01F7E1 |\
    INY                                                                         ; $01F7E2 | | Increment the Y register by four to move to the next OAM entry.
    INY                                                                         ; $01F7E3 | |
    INY                                                                         ; $01F7E4 |/
    CPX r_battle_effect_particle_sprite_count.w                                 ; $01F7E5 |\
    BEQ +                                                                       ; $01F7E8 | | Loop until the number of requested sprites have been updated.
    JMP @start                                                                  ; $01F7EA |/
+   STY <r_battle_effect_particle_update_arg_oam_offset                         ; $01F7ED | Store the updated OAM offset.
    PLX                                                                         ; $01F7EF | Restore the value of the X register.
    STZ r_battle_disable_oam_update.w                                           ; $01F7F0 | Enable automatic transfer of OAM data to the OAM.
    RTS                                                                         ; $01F7F3

; battle_animate_call_with_spell ($01:F7F4)
;
; Animates a Call spell that uses another spell (e.g. Stone) as part of its
; effect. The alternate party sprite is advanced forward, flashes, the inner
; spell is animated, and then the sprite moves backward.
battle_animate_call_with_spell:
    JSR _battle_alternate_party_sprite_move_forward                             ; $01F7F4 | Animate the alternate party sprite moving forward.
    JSR _battle_animate_call_flashing_monster                                   ; $01F7F7 | Animate the alternate party sprite flashing.
    TDC                                                                         ; $01F7FA |\ Animate a standard fixed spell effect to animate the internal
    JSL bank02.battle_effect_spell_animate_internal                             ; $01F7FB |/ spell.
    JSR _battle_alternate_party_sprite_move_backward                            ; $01F7FF | Animate the alternate party sprite moving backward.
    RTL                                                                         ; $01F802

; battle_animate_reaction ($01:F803)
;
; Animates the Reaction spell, which explodes all on-screen monsters in
; sequence.
battle_animate_reaction:
    LDA #SPELL_VISUAL_EFFECT_HANDLER_EXPLODE_ACTING.b                           ; $01F803 |\ Animate the actor exploding.
    JSL bank02.battle_effect_spell_animate_internal                             ; $01F805 |/
    TDC                                                                         ; $01F809 |\ Set the X register to zero.
    TAX                                                                         ; $01F80A |/
-   LDA r_monster_slot_to_id_index_pre_action.w,X                               ; $01F80B |\
    CMP #$FF.b                                                                  ; $01F80E | | Skip this monster slot if empty.
    BEQ +                                                                       ; $01F810 |/
    TXA                                                                         ; $01F812 |\
    STA r_battle_current_action_details.actor.w                                 ; $01F813 | | Pretend this slot is the actor and animate the exploding actor
    STA r_battle_current_actor_slot.w                                           ; $01F816 | | effect again.
    PHX                                                                         ; $01F819 | |
    LDA #SPELL_VISUAL_EFFECT_HANDLER_EXPLODE_ACTING.b                           ; $01F81A | |
    JSL bank02.battle_effect_spell_animate_internal                             ; $01F81C |/
    PLX                                                                         ; $01F820 |\
+   INX                                                                         ; $01F821 | | Loop until all eight slots have been potentially animated.
    CPX #8.w                                                                    ; $01F822 | |
    BNE -                                                                       ; $01F825 |/
    RTL                                                                         ; $01F827

; _battle_effect_expanded_sprite_update_oam ($01:F828)
;
; Updates the OAM entries for the expanded effect sprites. This is possibly only
; used for Shiva.

; NOTE: This appears to only be used for Shiva. The expanded part of the refers
;       to the fact that it uses 72 OAM entries instead of a restricted number.
_battle_effect_expanded_sprite_update_oam:
    TDC                                                                         ; $01F828 |\ Initialize the X register to zero.
    TAX                                                                         ; $01F829 |/
    LDY #_sizeof_oam_sprite.w * 16                                              ; $01F82A | Initialize the Y register to point to the 17th OAM entry.
@start:
    LDA r_battle_effect_expanded_sprite_visible.w,X                             ; $01F82D |\
    BNE +                                                                       ; $01F830 | | If this sprite is not flagged as visible, set its coordinates to
    LDA #240.b                                                                  ; $01F832 | | 240 and branch to skip to the next iteration.
    STA r_oam.1.x.w,Y                                                           ; $01F834 | |
    STA r_oam.1.y.w,Y                                                           ; $01F837 | |
    JMP @next                                                                   ; $01F83A |/
+   LDA r_formation_back_attack_copy.w                                          ; $01F83D |\
    BEQ +                                                                       ; $01F840 | | If this is a back attack, set the X coordinate to the configured
    LDA r_battle_effect_expanded_sprite_coordinates_x.w,X                       ; $01F842 | | coordinate, adding the sine offset, but flip the bits and subtract
    CLC                                                                         ; $01F845 | | eight first. Set the flags to use priority 3, palette 7, high name
    ADC r_battle_effect_expanded_sprite_sine_offset.w,X                         ; $01F846 | | table, and set the horizontal flip bit.
    EOR #%11111111.b                                                            ; $01F849 | |
    SEC                                                                         ; $01F84B | |
    SBC #8.b                                                                    ; $01F84C | |
    STA r_oam.1.x.w,Y                                                           ; $01F84E | |
    LDA #%01111111.b                                                            ; $01F851 | |
    STA r_oam.1.flags.w,Y                                                       ; $01F853 | |
    JMP ++                                                                      ; $01F856 |/
+   LDA r_battle_effect_expanded_sprite_coordinates_x.w,X                       ; $01F859 |\
    CLC                                                                         ; $01F85C | | Otherwise, set the X coordinate to the configured X coordinate
    ADC r_battle_effect_expanded_sprite_sine_offset.w,X                         ; $01F85D | | plus the sine offset, and set the flags as above, except without
    STA r_oam.1.x.w,Y                                                           ; $01F860 | | setting the horizontal flip bit.
    LDA #%00111111.b                                                            ; $01F863 | |
    STA r_oam.1.flags.w,Y                                                       ; $01F865 |/
++  LDA r_battle_effect_expanded_sprite_coordinates_y.w,X                       ; $01F868 |\ Set the Y coordinate to the configured value.
    STA r_oam.1.y.w,Y                                                           ; $01F86B |/
@next:
    LDA r_battle_frame_counter.w                                                ; $01F86E |\
    AND #%00000010.b                                                            ; $01F871 | | Set the tile number to either $9C or $9E, depending on the current
    CLC                                                                         ; $01F873 | | value of the frame counter. The value alternates every two frames.
    ADC #$9C.b                                                                  ; $01F874 | |
    STA r_oam.1.tile.w,Y                                                        ; $01F876 |/
    INX                                                                         ; $01F879 | Increment the X register to move to the next sprite.
    INY                                                                         ; $01F87A |\
    INY                                                                         ; $01F87B | | Increment the Y register by four to move to the next OAM entry.
    INY                                                                         ; $01F87C | |
    INY                                                                         ; $01F87D |/
    CPX #_sizeof_r_battle_effect_expanded_sprite_coordinates_x.w                ; $01F87E |\ Loop until all 72 sprites have been updated.
    BNE @start                                                                  ; $01F881 |/
    RTS                                                                         ; $01F883

; battle_animate_call_shiva ($01:F884)
;
; Animates the Shiva spell effect.
battle_animate_call_shiva:
    JSR _battle_alternate_party_sprite_move_forward                             ; $01F884 | Animate Shiva moving forward by 16 frames.
    JSR _battle_play_sound_effect_spell                                         ; $01F887 | Play the appropriate sound effect.
    LDA #8.b                                                                    ; $01F88A |\ Set the sprite frame counter to eight to display the second frame.
    STA r_battle_alternate_party_sprite_frame_counter.w                         ; $01F88C |/
    JSL bank02.battle_reset_effect_oam                                          ; $01F88F | Reset the effect OAM to small sprites.
    TDC                                                                         ; $01F893 |\ Initialize the X register to zero.
    TAX                                                                         ; $01F894 |/
    STZ <r_battle_generic_tmp_index_lo                                          ; $01F895 | Initialize a temporary variable to zero.
    STZ <r_battle_generic_tmp_index_2_lo                                        ; $01F897 | Initialize another temporary variable to zero.
-   LDA r_prng_data.w,X                                                         ; $01F899 |\ Set the X coordinate to the next random value.
    STA r_battle_effect_expanded_sprite_coordinates_x.w,X                       ; $01F89C |/
    LDA <r_battle_generic_tmp_index_2_lo                                        ; $01F89F |\ Set the Y coordinate to the current temporary value.
    STA r_battle_effect_expanded_sprite_coordinates_y.w,X                       ; $01F8A1 |/
    CLC                                                                         ; $01F8A4 |\
    ADC #8.b                                                                    ; $01F8A5 | | Add eight to the temporary value.
    STA <r_battle_generic_tmp_index_2_lo                                        ; $01F8A7 |/
    CMP #136.b                                                                  ; $01F8A9 |\
    BNE +                                                                       ; $01F8AB | | If the temporary value reaches 136, reset it back to zero.
    STZ <r_battle_generic_tmp_index_2_lo                                        ; $01F8AD |/
+   TDC                                                                         ; $01F8AF |\ Initialize the sine offset to zero.
    STA r_battle_effect_expanded_sprite_sine_offset.w,X                         ; $01F8B0 |/
    STA r_battle_effect_expanded_sprite_visible.w,X                             ; $01F8B3 | Initially make the sprite not visible.
    LDA r_prng_data.w,X                                                         ; $01F8B6 |\ Set the sine index to the next random value.
    STA r_battle_effect_expanded_sprite_sine_index.w,X                          ; $01F8B9 |/
    INX                                                                         ; $01F8BC |\
    CPX #_sizeof_r_battle_effect_expanded_sprite_coordinates_x.w                ; $01F8BD | | Loop until all 72 sprites have been initialized.
    BNE -                                                                       ; $01F8C0 |/
    JSR _set_battle_flash_pulse_blue                                            ; $01F8C2 | Start a blue pulsing flash effect.
    LDX #128.w                                                                  ; $01F8C5 | Initialize the X register to 128.
@start:
    PHX                                                                         ; $01F8C8 | Preserve the current value of the X register.
    JSR _battle_wait_next_frame_preserve_x_y                                    ; $01F8C9 | Wait for the next frame.
    JSR _battle_effect_expanded_sprite_update_oam                               ; $01F8CC | Update the OAM with the current coordinates.
    TDC                                                                         ; $01F8CF |\ Initialize the X register to zero.
    TAX                                                                         ; $01F8D0 |/
-   LDA r_prng_data.w,X                                                         ; $01F8D1 |\
    AND #%00000010.b                                                            ; $01F8D4 | | Set a temporary variable randomly to either 2 or 4.
    CLC                                                                         ; $01F8D6 | |
    ADC #2.b                                                                    ; $01F8D7 | |
    STA <r_battle_generic_tmp_index_lo                                          ; $01F8D9 |/
    LDA r_battle_effect_expanded_sprite_coordinates_y.w,X                       ; $01F8DB |\
    CLC                                                                         ; $01F8DE | | Add the value to the Y coordinate for this sprite. If the value is
    ADC <r_battle_generic_tmp_index_lo                                          ; $01F8DF | | 136 or greater, increment the visibility flag for this sprite and
    CMP #136.b                                                                  ; $01F8E1 | | load zero into the accumulator.
    BCC +                                                                       ; $01F8E3 | |
    INC r_battle_effect_expanded_sprite_visible.w,X                             ; $01F8E5 | |
    TDC                                                                         ; $01F8E8 |/
+   STA r_battle_effect_expanded_sprite_coordinates_y.w,X                       ; $01F8E9 | Store either the updated coordinate or zero as determined above.
    INX                                                                         ; $01F8EC |\
    CPX #_sizeof_r_battle_effect_expanded_sprite_coordinates_x.w                ; $01F8ED | | Loop until all 72 sprites have been updated.
    BNE -                                                                       ; $01F8F0 |/
    TDC                                                                         ; $01F8F2 |\ Initialize the X register to zero.
    TAX                                                                         ; $01F8F3 |/
-   LDA #24.b                                                                   ; $01F8F4 |\ Set the desired sine magnitude to 12 (the value will be halved).
    STA <r_math_multiply_8bit_arg_2                                             ; $01F8F6 |/
    STX <r_battle_generic_tmp_index                                             ; $01F8F8 | Save the value in the X register to a temporary variable.
    LDA r_battle_effect_expanded_sprite_sine_index.w,X                          ; $01F8FA |\
    CLC                                                                         ; $01F8FD | | Add eight to the sine index, which will result in a full cycle
    ADC #8.b                                                                    ; $01F8FE | | after 32 updates.
    STA r_battle_effect_expanded_sprite_sine_index.w,X                          ; $01F900 |/
    JSL bank02.battle_get_scaled_sine_value                                     ; $01F903 | Get the scaled sine value.
    LDX <r_battle_generic_tmp_index                                             ; $01F907 | Set the X register to the saved value.
    STA r_battle_effect_expanded_sprite_sine_offset.w,X                         ; $01F909 | Set the sine offset to the calculated value.
    INX                                                                         ; $01F90C |\
    CPX #_sizeof_r_battle_effect_expanded_sprite_coordinates_x.w                ; $01F90D | | Loop through all 72 sprites.
    BNE -                                                                       ; $01F910 |/
    TDC                                                                         ; $01F912 |\ Initialize the X register to zero.
    TAX                                                                         ; $01F913 |/
-   LDA r_prng_data.w,X                                                         ; $01F914 |\
    AND #%00001111.b                                                            ; $01F917 | | Set a temporary variable to a random value mod 16.
    STA <r_battle_generic_tmp_index_lo                                          ; $01F919 |/
    LDA r_battle_effect_expanded_sprite_coordinates_x.w + 0,X                   ; $01F91B |\
    SEC                                                                         ; $01F91E | | Subtract the value from the sprite's X coordinate.
    SBC <r_battle_generic_tmp_index_lo                                          ; $01F91F | |
    STA r_battle_effect_expanded_sprite_coordinates_x.w + 0,X                   ; $01F921 |/
    LDA r_battle_effect_expanded_sprite_coordinates_x.w + 36,X                  ; $01F924 |\
    SEC                                                                         ; $01F927 | | Subtract four instead from the sprite in the other half of the
    SBC #4.b                                                                    ; $01F928 | | list.
    STA r_battle_effect_expanded_sprite_coordinates_x.w + 36,X                  ; $01F92A |/
    INX                                                                         ; $01F92D |\
    CPX #_sizeof_r_battle_effect_expanded_sprite_coordinates_x.w / 2            ; $01F92E | | Loop through all 72 sprites (in 36 pairs).
    BNE -                                                                       ; $01F931 |/
    PLX                                                                         ; $01F933 | Restore the remaining number of cycles to the X register.
    DEX                                                                         ; $01F934 |\ Loop until it reaches zero.
    BNE @start                                                                  ; $01F935 |/
    STZ r_battle_flash_mode.w                                                   ; $01F937 | Disable the battle flash.
    JSL bank02.battle_reset_effect_oam                                          ; $01F93A | Reset the effect OAM.
    JSR _battle_alternate_party_sprite_move_backward                            ; $01F93E | Animate Shiva moving backward 16 pixels.
    RTL                                                                         ; $01F941

; battle_animate_call_indra ($01:F942)
;
; Animates the Indra spell effect.
battle_animate_call_indra:
    JSR _battle_alternate_party_sprite_move_forward                             ; $01F942 | Animate the alternate party sprite moving forward.
    LDA #8.b                                                                    ; $01F945 |\ Set the alternate party sprite frame counter to eight to change the
    STA r_battle_alternate_party_sprite_frame_counter.w                         ; $01F947 |/ frame.
    TDC                                                                         ; $01F94A |\ Animate a standard fixed spell effect.
    JSL bank02.battle_effect_spell_animate_internal                             ; $01F94B |/
    JSR _battle_alternate_party_sprite_move_backward                            ; $01F94F | Animate the alternate party sprite moving backward.
    RTL                                                                         ; $01F952

; battle_animate_call_titan ($01:F953)
;
; Animates the Titan spell effect.
battle_animate_call_titan:
    JSR _battle_alternate_party_sprite_move_forward                             ; $01F953 | Animate Titan moving forward.
    LDA #8.b                                                                    ; $01F956 |\ Set the frame counter to eight to switch to the next frame.
    STA r_battle_alternate_party_sprite_frame_counter.w                         ; $01F958 |/
    LDA #SPELL_VISUAL_EFFECT_HANDLER_QUAKE.b                                    ; $01F95B |\ Animate the Quake effect.
    JSL bank02.battle_effect_spell_animate_internal                             ; $01F95D |/
    JSR _battle_alternate_party_sprite_move_backward                            ; $01F961 | Animate Titan moving backward.
    RTL                                                                         ; $01F964

; _battle_effect_get_sine_value ($01:F965)
;
; Given an index to the sine magnitude array at $F1B3 in the X register,
; returns the current sine value in the accumulator.
_battle_effect_get_sine_value:
    PHX                                                                         ; $01F965 | Preserve the value in the X register.
    LDA r_battle_effect_sine_magnitude.w,X                                      ; $01F966 |\
    ASL A                                                                       ; $01F969 | | Double the sine magnitude, as the sine data only goes to $7F.
    STA <r_math_multiply_8bit_arg_2                                             ; $01F96A |/
    LDA r_battle_effect_sine_index.w,X                                          ; $01F96C | Load the current sine index.
    JSL bank02.battle_get_scaled_sine_value                                     ; $01F96F | Get the scaled sine value.
    PLX                                                                         ; $01F973 | Restore the value in the X register.
    RTS                                                                         ; $01F974

; _battle_effect_get_sine_value_2 ($01:F975)
;
; Given an index to the second sine magnitude array at $F1F3 in the X register,
; returns the current second sine value in the accumulator.
_battle_effect_get_sine_value_2:
    PHX                                                                         ; $01F975 | Preserve the value in the X register.
    LDA r_battle_effect_sine_magnitude_2.w,X                                    ; $01F976 |\
    ASL A                                                                       ; $01F979 | | Double the sine magnitude, as the sine data only goes to $7F.
    STA <r_math_multiply_8bit_arg_2                                             ; $01F97A |/
    LDA r_battle_effect_sine_index_2.w,X                                        ; $01F97C | Load the current sine index.
    JSL bank02.battle_get_scaled_sine_value                                     ; $01F97F | Get the scaled sine value.
    PLX                                                                         ; $01F983 | Restore the value in the X register.
    RTS                                                                         ; $01F984

; _battle_effect_increment_sine_magnitudes ($01:F985)
;
; Given a value in the accumulator and an index in the X register, updates that
; index in the sine magnitude arrays by adding the passed value.
_battle_effect_increment_sine_magnitudes:
    PHA                                                                         ; $01F985 |\
    CLC                                                                         ; $01F986 | | Update the second sine magnitude array, adding the passed value.
    ADC r_battle_effect_sine_magnitude_2.w,X                                    ; $01F987 | |
    STA r_battle_effect_sine_magnitude_2.w,X                                    ; $01F98A | |
    PLA                                                                         ; $01F98D |/
    CLC                                                                         ; $01F98E |\
    ADC r_battle_effect_sine_magnitude.w,X                                      ; $01F98F | | Update the sine magnitude array, adding the passed value.
    STA r_battle_effect_sine_magnitude.w,X                                      ; $01F992 |/
    RTS                                                                         ; $01F995

; _battle_effect_increment_sine_indexes ($01:F996)
;
; Given a value in the accumulator and an index in the X register, updates that
; index in the sine index arrays by adding the passed value.
_battle_effect_increment_sine_indexes:
    PHA                                                                         ; $01F996 |\
    CLC                                                                         ; $01F997 | | Update the second sine index array, adding the passed value.
    ADC r_battle_effect_sine_index_2.w,X                                        ; $01F998 | |
    STA r_battle_effect_sine_index_2.w,X                                        ; $01F99B | |
    PLA                                                                         ; $01F99E |/
    CLC                                                                         ; $01F99F |\
    ADC r_battle_effect_sine_index.w,X                                          ; $01F9A0 | | Update the sine index array, adding the passed value.
    STA r_battle_effect_sine_index.w,X                                          ; $01F9A3 |/
    RTS                                                                         ; $01F9A6

; _battle_effect_mist_update_oam ($01:F9A7)
;
; Loops through 64 sprites used for the mist effect, and updates their entries
; in the OAM.
_battle_effect_mist_update_oam:
    TDC                                                                         ; $01F9A7 |\
    TAX                                                                         ; $01F9A8 | | Initialize the X and Y registers to zero.
    TAY                                                                         ; $01F9A9 |/
-   LDA r_battle_effect_mist_sprite_active.w,X                                  ; $01F9AA |\ Branch to the invisible code if the sprite is not yet active.
    BEQ +                                                                       ; $01F9AD |/
    LDA r_battle_effect_mist_sprite_complete.w,X                                ; $01F9AF |\ Branch to the invisible code if the sprite is complete.
    BNE +                                                                       ; $01F9B2 |/
    JSR _battle_effect_get_sine_value_2                                         ; $01F9B4 |\
    CLC                                                                         ; $01F9B7 | | Set the X coordinate to the sprite's base X coordinate plus the
    ADC r_battle_effect_mist_sprite_coordinate_x.w,X                            ; $01F9B8 | | sine value.
    STA <r_battle_generic_tmp_index_lo                                          ; $01F9BB |/
    JSR _battle_effect_get_sine_value                                           ; $01F9BD |\
    CLC                                                                         ; $01F9C0 | | Set the Y coordinate to 72 plus the current sine value.
    ADC #72.b                                                                   ; $01F9C1 | |
    STA <r_battle_generic_tmp_index_2_lo                                        ; $01F9C3 |/
    LDA <r_battle_generic_tmp_index_lo                                          ; $01F9C5 |\
    CMP #224.b                                                                  ; $01F9C7 | | If the X coordinate is 224 or greater, set the complete flag.
    BCC ++                                                                      ; $01F9C9 | |
    LDA #1.b                                                                    ; $01F9CB | |
    STA r_battle_effect_mist_sprite_complete.w,X                                ; $01F9CD |/
+   LDA #240.b                                                                  ; $01F9D0 |\
    STA <r_battle_generic_tmp_index_lo                                          ; $01F9D2 | | If not yet active or if complete, set the coordinates to 240.
    STA <r_battle_generic_tmp_index_2_lo                                        ; $01F9D4 |/
++  LDA r_battle_frame_counter.w                                                ; $01F9D6 |\
    AND #%00000010.b                                                            ; $01F9D9 | | Calculate the tile number to be either $8C or $8E, alternating
    CLC                                                                         ; $01F9DB | | every two frames.
    ADC #$8C.b                                                                  ; $01F9DC |/
    STZ r_battle_effect_extra_tile_flags.w                                      ; $01F9DE | Don't set any additional tile flags.
    JSR _battle_effect_set_oam_entry                                            ; $01F9E1 | Set the OAM entry for this sprite.
    INX                                                                         ; $01F9E4 |\
    CPX #_sizeof_r_battle_effect_mist_sprite_coordinate_x.w                     ; $01F9E5 | | Loop until all 64 sprites have been updated.
    BNE -                                                                       ; $01F9E8 |/
    RTS                                                                         ; $01F9EA

; battle_animate_call_mist ($01:F9EB)
;
; Animates the Mist spell effect.
battle_animate_call_mist:
    JSR _battle_alternate_party_sprite_move_forward                             ; $01F9EB | Animate Mist moving forward 16 pixels.
    TDC                                                                         ; $01F9EE |\ Initialize the X register to zero.
    TAX                                                                         ; $01F9EF |/
-   LDA r_prng_data.w,X                                                         ; $01F9F0 |\ Initialize the Y coordinate sine index to a random value.
    STA r_battle_effect_sine_index.w,X                                          ; $01F9F3 |/
    CLC                                                                         ; $01F9F6 |\
    ADC #64.b                                                                   ; $01F9F7 | | Initialize the X cooridnate sine index to the value plus 64.
    STA r_battle_effect_sine_index_2.w,X                                        ; $01F9F9 |/
    STZ r_battle_effect_sine_magnitude.w,X                                      ; $01F9FC | Initialize the Y coordinate sine magnitude to zero.
    LDA #8.b                                                                    ; $01F9FF |\ Initialize the X coordinate sine magnitude to eight.
    STA r_battle_effect_sine_magnitude_2.w,X                                    ; $01FA01 |/
    LDA #152.b                                                                  ; $01FA04 |\ Set the initial X coordinate for all sprites to 152.
    STA r_battle_effect_mist_sprite_coordinate_x.w,X                            ; $01FA06 |/
    STZ r_battle_effect_mist_sprite_complete.w,X                                ; $01FA09 |\ Set both the complete and active flags to zero.
    STZ r_battle_effect_mist_sprite_active.w,X                                  ; $01FA0C |/
    INX                                                                         ; $01FA0F |\
    CPX #_sizeof_r_battle_effect_mist_sprite_coordinate_x.w                     ; $01FA10 | | Loop until all 64 sprites are initialized.
    BNE -                                                                       ; $01FA13 |/
    JSR _battle_reset_effect_oam_large                                          ; $01FA15 | Reset the effect OAM to large sprites.
    JSR _set_battle_flash_pulse_white                                           ; $01FA18 | Set a white pulsing flash effect.
    JSR _battle_play_sound_effect_spell                                         ; $01FA1B | Play the sound effect for the spell.
@start:
    JSR _battle_wait_next_frame_preserve_x_y                                    ; $01FA1E | Wait for the next frame.
    JSR _battle_effect_mist_update_oam                                          ; $01FA21 | Update the OAM to match the current sprites.
    LDA r_battle_effect_mist_sprite_coordinate_x.w                              ; $01FA24 |\
    SEC                                                                         ; $01FA27 | | Subtract 6 from the X coordinate of the first sprite.
    SBC #6.b                                                                    ; $01FA28 | |
    STA r_battle_effect_mist_sprite_coordinate_x.w                              ; $01FA2A |/
    LDA #1.b                                                                    ; $01FA2D |\ Flag the first sprite as active.
    STA r_battle_effect_mist_sprite_active.w                                    ; $01FA2F |/
    TDC                                                                         ; $01FA32 |\
    TAX                                                                         ; $01FA33 | | Increment the sine indexes by 16 each, which will result in a full
-   LDA #16.b                                                                   ; $01FA34 | | cycle after 16 cycles.
    JSR _battle_effect_increment_sine_indexes                                   ; $01FA36 | |
    INX                                                                         ; $01FA39 | |
    CPX #_sizeof_r_battle_effect_mist_sprite_coordinate_x.w                     ; $01FA3A | |
    BNE -                                                                       ; $01FA3D |/
    LDA r_battle_effect_sine_magnitude.w                                        ; $01FA3F |\
    CLC                                                                         ; $01FA42 | | Increment the Y coordinate sine magnitude of the first sprite by
    ADC #2.b                                                                    ; $01FA43 | | two.
    STA r_battle_effect_sine_magnitude.w                                        ; $01FA45 |/
    LDX #_sizeof_r_battle_effect_mist_sprite_coordinate_x.w - 2                 ; $01FA48 | Initialize the X register to the number of sprites minus two.
-   LDA r_battle_effect_mist_sprite_coordinate_x.w + 0,X                        ; $01FA4B |\ Transfer the coordinate from one sprite to the next (effectively
    STA r_battle_effect_mist_sprite_coordinate_x.w + 1,X                        ; $01FA4E |/ subtracts six from each sprite that's active).
    LDA r_battle_effect_mist_sprite_active.w + 0,X                              ; $01FA51 |\ Transfer the active flag from each sprite to the next (effectively
    STA r_battle_effect_mist_sprite_active.w + 1,X                              ; $01FA54 |/ activates one sprite per frame).
    LDA r_battle_effect_sine_magnitude.w + 0,X                                  ; $01FA57 |\
    STA r_battle_effect_sine_magnitude.w + 1,X                                  ; $01FA5A | | Transfer the sine magnitudes as well.
    LDA r_battle_effect_sine_magnitude_2.w + 0,X                                ; $01FA5D | |
    STA r_battle_effect_sine_magnitude_2.w + 1,X                                ; $01FA60 |/
    DEX                                                                         ; $01FA63 |\
    CPX #-1.w                                                                   ; $01FA64 | | Loop until the values for all sprites have been updated.
    BNE -                                                                       ; $01FA67 |/
    TDC                                                                         ; $01FA69 |\
    TAX                                                                         ; $01FA6A | | Loop until all 64 sprites are complete.
-   LDA r_battle_effect_mist_sprite_complete.w,X                                ; $01FA6B | |
    BEQ @start                                                                  ; $01FA6E | |
    INX                                                                         ; $01FA70 | |
    CPX #_sizeof_r_battle_effect_mist_sprite_coordinate_x.w                     ; $01FA71 | |
    BNE -                                                                       ; $01FA74 |/
    STZ r_battle_flash_mode.w                                                   ; $01FA76 | Unset the flash mode.
    JSR _battle_alternate_party_sprite_move_backward                            ; $01FA79 | Animate the sprite moving backward 16 pixels.
    RTL                                                                         ; $01FA7C

; battle_do_nothing_but_return ($01:FA7D)
;
; This routine does nothing but return long. Based on where it's called, it was
; presumably somehow originally related to either the Stone spell or the Jinn
; Call spell. In any case, it does nothing now.
battle_do_nothing_but_return:
    RTL                                                                         ; $01FA7D

; battle_animate_call_sylph_initial ($01:FA7E)
;
; Animates the first part of the Sylph spell, where the Sylphs fly briefly
; before beginning their attack.
battle_animate_call_sylph_initial:
    STZ r_battle_alternate_party_sprite_frame_counter.w                         ; $01FA7E | Set the frame counter to zero to use the first frame of the sprite.
    STZ r_battle_play_audio_pan_monster.w                                       ; $01FA81 |\ Play the spell sound effect, panned to the party.
    JSR _battle_play_sound_effect_spell                                         ; $01FA84 |/
    LDX #120.w                                                                  ; $01FA87 | Initialize the X register to 120.
-   JSR _battle_wait_next_frame_preserve_x_y                                    ; $01FA8A | Wait for the next frame.
    LDA r_battle_alternate_party_sprite_frame_counter.w                         ; $01FA8D |\
    INC A                                                                       ; $01FA90 | | Increment the frame counter and take it mod 16. The sprite will
    AND #%00001111.b                                                            ; $01FA91 | | thus alternate between two frames.
    STA r_battle_alternate_party_sprite_frame_counter.w                         ; $01FA93 |/
    DEX                                                                         ; $01FA96 |\ Decrement the X register and loop until it reaches zero.
    BNE -                                                                       ; $01FA97 |/
    LDA #16.b                                                                   ; $01FA99 |\ Set the frame counter to 16, to move to the third frame.
    STA r_battle_alternate_party_sprite_frame_counter.w                         ; $01FA9B |/
    RTL                                                                         ; $01FA9E

; battle_animate_call_odin ($01:FA9F)
;
; Animates the Odin spell.
battle_animate_call_odin:
    JSR _battle_play_sound_effect_spell                                         ; $01FA9F | Play the sound effect for the spell.
    INC r_battle_alternate_party_sprite_auto_animate.w                          ; $01FAA2 | Enable auto-animation for the sprite.
    LDX #18.w                                                                   ; $01FAA5 |\ Wait 18 frames.
    JSR _battle_wait_x_frames                                                   ; $01FAA8 |/
    STZ r_battle_alternate_party_sprite_auto_animate.w                          ; $01FAAB | Disable auto-animation.
    LDX #32.w                                                                   ; $01FAAE |\
-   JSR _battle_wait_next_frame_preserve_x_y                                    ; $01FAB1 | | Loop through 32 frames, moving the sprite left 8 pixels each time.
    JSR _battle_alternate_party_sprite_update_forward_strike                    ; $01FAB4 | |
    DEX                                                                         ; $01FAB7 | |
    BNE -                                                                       ; $01FAB8 |/
    LDA #%01100010.b                                                            ; $01FABA |\ Set the BG1 tilemap address to $6000 and the size to 32x64.
    STA reg_ppu_bg1sc.l                                                         ; $01FABC |/
    TDC                                                                         ; $01FAC0 |\
    STA r_battle_effect_sine_index.w + 0                                        ; $01FAC1 | | Initialize the two sine indexes to 0 and 128 (180 degrees out of
    LDA #$80.b                                                                  ; $01FAC4 | | phase).
    STA r_battle_effect_sine_index.w + 1                                        ; $01FAC6 |/
--  JSR _battle_wait_next_frame_preserve_x_y                                    ; $01FAC9 | Wait for the next frame.
    LDA r_battle_effect_sine_index.w + 0                                        ; $01FACC |\
    CMP #16.b                                                                   ; $01FACF | | If the first index is 16 or greater, set color addition on the sub
    BCC +                                                                       ; $01FAD1 | | screen, set BG2 as the sub screen, set color math to 1/2 mode on
    LDA #%00000010.b                                                            ; $01FAD3 | | only BG1, and then fade the monster palettes by one step.
    STA reg_ppu_cgswsel.l                                                       ; $01FAD5 | |
    STA reg_ppu_ts.l                                                            ; $01FAD9 | | BUG: This would nominally have resulted in the monsters fading
    LDA #%01000001.b                                                            ; $01FADD | |      into the background, rather than to black. Unfortunately, the
    STA reg_ppu_cgadsub.l                                                       ; $01FADF | |      registers are overwritten by other code in various places,
    JSL bank02.battle_fade_monster_palettes                                     ; $01FAE3 |/       either directly or via HDMA.
+   STZ <r_battle_generic_tmp_index_2_lo                                        ; $01FAE7 | Initialize the line number parameter to zero.
    LDA #(144 / 48).b                                                           ; $01FAE9 |\ Initialize the counter to three, to cover 144 lines in total.
    STA <r_battle_generic_tmp_count                                             ; $01FAEB |/
-   LDA r_battle_effect_sine_index.w + 0                                        ; $01FAED |\ Set the HDMA for 24 lines using the first sine index.
    JSL bank02.battle_effect_update_odin_scroll_hdma                            ; $01FAF0 |/
    LDA r_battle_effect_sine_index.w + 1                                        ; $01FAF4 |\ Set the HDMA for the next 24 lines using the second sine index (to
    JSL bank02.battle_effect_update_odin_scroll_hdma                            ; $01FAF7 |/ go the opposite way).
    DEC <r_battle_generic_tmp_count                                             ; $01FAFB |\ Decrement the counter and loop until the 144 lines have been set.
    BNE -                                                                       ; $01FAFD |/
    INC r_battle_effect_sine_index.w + 0                                        ; $01FAFF |\
    INC r_battle_effect_sine_index.w + 1                                        ; $01FB02 | | Increment the sine indexes and loop until the first one reaches
    LDA r_battle_effect_sine_index.w + 0                                        ; $01FB05 | | 64.
    CMP #64.b                                                                   ; $01FB08 | |
    BNE --                                                                      ; $01FB0A |/
    LDA #%00011110.b                                                            ; $01FB0C |\ Set BG2, BG3, BG4 and sprites as the main screen.
    STA reg_ppu_tm.l                                                            ; $01FB0E |/
    INC r_battle_monster_effect_audio_pending.w                                 ; $01FB12 | Flag that effect audio is pending.
    RTL                                                                         ; $01FB15

; _battle_effect_wave_initialize_* ($01:FB16)
;
; Initializes the variables used by the Wave spell effect. One variant does the
; necessary initialization for a left-to-right effect that starts in the middle
; of the screen, and the _mirrored variant does the initialization for a right-
; to-left version that starts off the right edge of the screen.
_battle_effect_wave_initialize_standard:
    STZ r_battle_effect_wave_mirror.w                                           ; $01FB16 | Do not mirror the effect.
    BRA _battle_effect_wave_initialize_common                                   ; $01FB19 | Branch to the main code.
_battle_effect_wave_initialize_mirrored:
    LDA #1.b                                                                    ; $01FB1B |\ Set the flag to mirror the effect.
    STA r_battle_effect_wave_mirror.w                                           ; $01FB1D |/
_battle_effect_wave_initialize_common:
    TDC                                                                         ; $01FB20 |\
    TAX                                                                         ; $01FB21 | | Initialize the X and Y registers to zero.
    TAY                                                                         ; $01FB22 |/
--  LDA bank0D.battle_effect_wave_oam_tile_data.l,X                             ; $01FB23 |\ Copy the next byte and save it as the tile number for the current
    STA r_oam.17.tile.w,Y                                                       ; $01FB27 |/ sprite.
    INX                                                                         ; $01FB2A |\
    CPX #bank0D._sizeof_battle_effect_wave_oam_tile_data.w                      ; $01FB2B | | Increment the X register, and if the value reaches the size of the
    BNE +                                                                       ; $01FB2E | | source data, reset the register to zero to start from the
    TDC                                                                         ; $01FB30 | | beginning.
    TAX                                                                         ; $01FB31 |/
+   LDA r_formation_back_attack_copy.w                                          ; $01FB32 |\
    BEQ +                                                                       ; $01FB35 | | Set the OAM flags for the sprite. If the back attack flag and the
    LDA r_battle_effect_wave_mirror.w                                           ; $01FB37 | | mirror flag have the same value, toggle the horizontal flip bit
    BEQ ++                                                                      ; $01FB3A | | on the sprites. Otherwise, keep them as it is. The result is that
-   LDA #%01111111.b                                                            ; $01FB3C | | in a normal battle with the mirror flag unset, the effect will
    BRA +++                                                                     ; $01FB3E | | move from left to right. Toggling either one will result in the
+   LDA r_battle_effect_wave_mirror.w                                           ; $01FB40 | | effect being mirrored, but toggling both will keep the original
    BEQ -                                                                       ; $01FB43 | | direction. (The source data in ROM moves right to left.)
++  LDA #%00111111.b                                                            ; $01FB45 | |
+++ STA r_oam.17.flags.w,Y                                                      ; $01FB47 |/
    INY                                                                         ; $01FB4A |\
    INY                                                                         ; $01FB4B | | Increment the Y register by four to move to the next OAM entry.
    INY                                                                         ; $01FB4C | |
    INY                                                                         ; $01FB4D |/
    CPY #_sizeof_oam_sprite.w * 72                                              ; $01FB4E |\ Loop until all 72 effect sprites have been initialized.
    BNE --                                                                      ; $01FB51 |/
    TDC                                                                         ; $01FB53 |\
    TAX                                                                         ; $01FB54 | | Initialize the X and Y registers to zero.
    TAY                                                                         ; $01FB55 |/
-   LDA bank0D.battle_effect_wave_oam_coordinate_data.l + coordinates.x,X       ; $01FB56 |\
    STA r_battle_effect_wave_coordinates_x.1.lo.w,Y                             ; $01FB5A | | Initialize the X and Y coordinates of each sprite to the correct
    LDA bank0D.battle_effect_wave_oam_coordinate_data.l + coordinates.y,X       ; $01FB5D | | values for each sprite in the group.
    STA r_battle_effect_wave_coordinates_y.1.lo.w,Y                             ; $01FB61 |/
    TDC                                                                         ; $01FB64 |\ Initialize the second Y coordinate for each sprite to zero.
    STA r_battle_effect_wave_coordinates_y.1.hi.w,Y                             ; $01FB65 |/
    INX                                                                         ; $01FB68 |\
    INX                                                                         ; $01FB69 | | Increment the X register twice and loop until all 12 sprites in
    CPX #_sizeof_coordinates.w * 12                                             ; $01FB6A | | the group have been set.
    BNE +                                                                       ; $01FB6D |/
    TDC                                                                         ; $01FB6F |\ Initialize the X register to zero.
    TAX                                                                         ; $01FB70 |/
+   LDA r_battle_effect_wave_mirror.w                                           ; $01FB71 |\
    STA r_battle_effect_wave_coordinates_x.1.hi.w,Y                             ; $01FB74 | | For each sprite, set the high byte of the X coordinate to the
    INY                                                                         ; $01FB77 | | value of the mirror flag (effectively adding 256 if the effect is
    INY                                                                         ; $01FB78 | | being mirrored).
    CPY #_sizeof_word.w * 72                                                    ; $01FB79 | |
    BNE -                                                                       ; $01FB7C |/
    TDC                                                                         ; $01FB7E |\
    TAX                                                                         ; $01FB7F | | Initialize the X and Y registers to zero.
    TAY                                                                         ; $01FB80 |/
--  LDA #12.b                                                                   ; $01FB81 |\ Initialize the tile counter to 12.
    STA <r_battle_generic_tmp_index_2_lo                                        ; $01FB83 |/
-   LDA r_battle_effect_wave_mirror.w                                           ; $01FB85 |\
    BNE +                                                                       ; $01FB88 | | Load the base X coordinate for the current group and save it to a
    LDA bank0D.battle_effect_wave_group_standard_x_coordinate_data.l,X          ; $01FB8A | | temporary variable.
    BRA ++                                                                      ; $01FB8E | |
+   LDA bank0D.battle_effect_wave_group_mirrored_x_coordinate_data.l,X          ; $01FB90 | | NOTE: There are only five sets of data in the ROM.
++  STA <r_battle_generic_tmp_index_lo                                          ; $01FB94 |/
    LDA r_battle_effect_wave_coordinates_x.1.lo.w,Y                             ; $01FB96 |\
    CLC                                                                         ; $01FB99 | | Add the value to the previous calculated X coordinate for the
    ADC <r_battle_generic_tmp_index_lo                                          ; $01FB9A | | sprite.
    STA r_battle_effect_wave_coordinates_x.1.lo.w,Y                             ; $01FB9C |/
    LDA bank0D.battle_effect_wave_group_y_coordinate_data.l,X                   ; $01FB9F |\
    STA <r_battle_generic_tmp_index_lo                                          ; $01FBA3 | | Read the base Y coordinate for this group from ROM and add it to
    LDA r_battle_effect_wave_coordinates_y.1.lo.w,Y                             ; $01FBA5 | | the Y coordinate for the current sprite.
    CLC                                                                         ; $01FBA8 | |
    ADC <r_battle_generic_tmp_index_lo                                          ; $01FBA9 | |
    STA r_battle_effect_wave_coordinates_y.1.lo.w,Y                             ; $01FBAB |/
    INY                                                                         ; $01FBAE |\
    INY                                                                         ; $01FBAF | | Increment the Y register by two to move to the next sprite,
    DEC <r_battle_generic_tmp_index_2_lo                                        ; $01FBB0 | | decrement the tile counter, and loop until all 12 are complete.
    BNE -                                                                       ; $01FBB2 |/
    INX                                                                         ; $01FBB4 |\
    CPX #6.w                                                                    ; $01FBB5 | | Loop until all six groups have been set.
    BNE --                                                                      ; $01FBB8 |/
    TDC                                                                         ; $01FBBA |\
    TAX                                                                         ; $01FBBB | | Initialize the frame counter for each group to a random value.
-   LDA r_prng_data.l & $FFFF,X                                                 ; $01FBBC | |
    STA r_battle_effect_wave_group_frame_counter.w,X                            ; $01FBC0 | |
    INX                                                                         ; $01FBC3 | |
    CPX #6.w                                                                    ; $01FBC4 | |
    BNE -                                                                       ; $01FBC7 |/
    JSL bank02.battle_effect_initialize_sine_indexes                            ; $01FBC9 | Initialize the sine indexes.
    TDC                                                                         ; $01FBCD |\ Initialize the X register to zero.
    TAX                                                                         ; $01FBCE |/
-   LDA r_prng_data.w,X                                                         ; $01FBCF |\
    AND #%00000111.b                                                            ; $01FBD2 | | Set the current sine magnitude to a random value from 4 to 11.
    CLC                                                                         ; $01FBD4 | |
    ADC #4.b                                                                    ; $01FBD5 | |
    STA r_battle_effect_sine_magnitude.w,X                                      ; $01FBD7 | |
    STA r_battle_effect_sine_magnitude_2.w,X                                    ; $01FBDA |/
    TXA                                                                         ; $01FBDD |\
    ASL A                                                                       ; $01FBDE | | Increment the sine index by the current index times 32, which will
    ASL A                                                                       ; $01FBDF | | result in a full cycle in eight entries.
    ASL A                                                                       ; $01FBE0 | |
    ASL A                                                                       ; $01FBE1 | |
    ASL A                                                                       ; $01FBE2 | |
    JSR _battle_effect_increment_sine_indexes                                   ; $01FBE3 |/
    INX                                                                         ; $01FBE6 |\
    CPX #8.w                                                                    ; $01FBE7 | | Loop until all eight entries are complete.
    BNE -                                                                       ; $01FBEA |/
    STZ r_battle_effect_sine_magnitude.w                                        ; $01FBEC |\ Set the sine magnitudes for the first entry to zero.
    STZ r_battle_effect_sine_magnitude_2.w                                      ; $01FBEF |/
    RTS                                                                         ; $01FBF2

; _battle_effect_wave_update_oam ($01:FBF3)
;
; Updates the OAM for the current frame of the Wave spell effect.
_battle_effect_wave_update_oam:
    LDA r_battle_frame_counter.w                                                ; $01FBF3 |\
    TAX                                                                         ; $01FBF6 | | Load a random value depending on the current battle frame counter,
    LDA r_prng_data.w + 1,X                                                     ; $01FBF7 | | take the result mod 4, and save that to a temporary variable.
    AND #%00000011.b                                                            ; $01FBFA | |
    STA <r_battle_generic_tmp_index_hi                                          ; $01FBFC |/
    TDC                                                                         ; $01FBFE |\
    TAX                                                                         ; $01FBFF | | Initialize the X and Y registers to zero.
    TAY                                                                         ; $01FC00 |/
--  LDA r_formation_back_attack_copy.w                                          ; $01FC01 |\
    BEQ +                                                                       ; $01FC04 | | Transfer the X coordinate for the current sprite to the OAM. If
    LDA r_battle_effect_wave_mirror.w                                           ; $01FC06 | | the back attack flag and the mirror flag have the same value, the
    BEQ ++                                                                      ; $01FC09 | | X coordinate has its bits flipped. Otherwise, it's copied
-   LDA r_battle_effect_wave_coordinates_x.1.lo.w,X                             ; $01FC0B | | directly. (The default action is to flip, as the data in ROM is
    EOR #%11111111.b                                                            ; $01FC0E | | opposite of what is considered normal.)
    STA r_oam.17.x.w,Y                                                          ; $01FC10 | |
    BRA +++                                                                     ; $01FC13 | |
+   LDA r_battle_effect_wave_mirror.w                                           ; $01FC15 | |
    BEQ -                                                                       ; $01FC18 | |
++  LDA r_battle_effect_wave_coordinates_x.1.lo.w,X                             ; $01FC1A | |
    STA r_oam.17.x.w,Y                                                          ; $01FC1D |/
+++ LDA r_battle_effect_wave_coordinates_y.1.lo.w,X                             ; $01FC20 |\
    CLC                                                                         ; $01FC23 | | Add the two Y coordinates together, add the previously calculated
    ADC <r_battle_generic_tmp_index_hi                                          ; $01FC24 | | random value, and set that as the sprite's Y coordinate.
    ADC r_battle_effect_wave_coordinates_y.1.hi.w,X                             ; $01FC26 | |
    STA r_oam.17.y.w,Y                                                          ; $01FC29 |/
    INX                                                                         ; $01FC2C |\ Increment the X register by two to move to the next sprite.
    INX                                                                         ; $01FC2D |/
    INY                                                                         ; $01FC2E |\
    INY                                                                         ; $01FC2F | | Increment the Y register by four to move to the next OAM entry.
    INY                                                                         ; $01FC30 | |
    INY                                                                         ; $01FC31 |/
    CPX #120.w                                                                  ; $01FC32 |\ Loop until the first five groups of tiles have been transferred to
    BNE --                                                                      ; $01FC35 |/ the OAM.
    TDC                                                                         ; $01FC37 |\ Initialize the Y register to zero.
    TAY                                                                         ; $01FC38 |/
-   TYA                                                                         ; $01FC39 |\
    LSR A                                                                       ; $01FC3A | | Set the X register to the current sprite divided by four (to
    LSR A                                                                       ; $01FC3B | | index the high OAM bytes).
    LSR A                                                                       ; $01FC3C | |
    TAX                                                                         ; $01FC3D |/
    LDA r_battle_effect_wave_coordinates_x.1.hi.w,Y                             ; $01FC3E |\
    LSR A                                                                       ; $01FC41 | | For this sprite, set the high X coordinate bit if the coordinate
    ROR r_oam_hi.w + 4,X                                                        ; $01FC42 | | is 256 or greater, and always set the sprite size bit, to use
    SEC                                                                         ; $01FC45 | | 16x16 sprites.
    ROR r_oam_hi.w + 4,X                                                        ; $01FC46 |/
    INY                                                                         ; $01FC49 |\
    INY                                                                         ; $01FC4A | | Increment the Y register and loop until all 120 sprites are
    CPY #120.w                                                                  ; $01FC4B | | updated.
    BNE -                                                                       ; $01FC4E |/
    RTS                                                                         ; $01FC50

; _battle_effect_wave_update_coordinates ($01:FC51)
;
; Handles updating the coordinates each frame for the Wave spell effect.
_battle_effect_wave_update_coordinates:
    TDC                                                                         ; $01FC51 |\ Initialize the Y register (the current group number) to zero.
    TAY                                                                         ; $01FC52 |/
@start:
    LDA r_battle_effect_wave_group_frame_counter.w,Y                            ; $01FC53 |\
    AND #%00000100.b                                                            ; $01FC56 | | Initialize a temporary variable to either 1 or 5, depending on the
    INC A                                                                       ; $01FC58 | | current value of the frame counter. It will alternate every four
    STA <r_battle_generic_tmp_index_2_lo                                        ; $01FC59 | | frames.
    STZ <r_battle_generic_tmp_index_2_hi                                        ; $01FC5B |/
    TYA                                                                         ; $01FC5D |\
    TAX                                                                         ; $01FC5E | | Set the X register to the offset within the coordinates for the
    LDA bank0D.battle_effect_wave_group_coordinate_offset_data.l,X              ; $01FC5F | | first tile of this group.
    TAX                                                                         ; $01FC63 |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $01FC64 |\
    LDA #12.w                                                                   ; $01FC66 | | Loop through the 12 sprites for this group, decrementing the X
    STA <r_battle_generic_tmp_index                                             ; $01FC69 | | coordinate the number of times specified by the previously
--  LDA <r_battle_generic_tmp_index_2                                           ; $01FC6B | | calculated value (either 1 or 5).
    STA <r_battle_generic_tmp_index_3                                           ; $01FC6D | |
-   DEC r_battle_effect_wave_coordinates_x.w,X                                  ; $01FC6F | |
    DEC <r_battle_generic_tmp_index_3                                           ; $01FC72 | |
    BNE -                                                                       ; $01FC74 | |
    INX                                                                         ; $01FC76 | |
    INX                                                                         ; $01FC77 | |
    DEC <r_battle_generic_tmp_index                                             ; $01FC78 | |
    BNE --                                                                      ; $01FC7A | |
    TDC                                                                         ; $01FC7C | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01FC7D |/
    TYA                                                                         ; $01FC7F |\ Transfer the current group number to the X register.
    TAX                                                                         ; $01FC80 |/
    LDA #2.b                                                                    ; $01FC81 |\ Increment the sine indexes by two.
    JSR _battle_effect_increment_sine_indexes                                   ; $01FC83 |/
    LDA r_battle_effect_sine_index.w,X                                          ; $01FC86 |\
    ORA #%10000000.b                                                            ; $01FC89 | | Set the high bit of the sine index. NOTE: Pretty much useless.
    STA r_battle_effect_sine_index.w,X                                          ; $01FC8B |/
    JSR _battle_effect_get_sine_value                                           ; $01FC8E | Get the corresponding sine value.
    PHA                                                                         ; $01FC91 | Preserve that sine value on the stack.
    TYA                                                                         ; $01FC92 |\
    TAX                                                                         ; $01FC93 | | Set the X register to the offset to the coordinates data for this
    LDA bank0D.battle_effect_wave_group_coordinate_offset_data.l,X              ; $01FC94 | | group.
    TAX                                                                         ; $01FC98 |/
    LDA #12.b                                                                   ; $01FC99 |\ Initialize the counter to 12.
    STA <r_battle_generic_tmp_index_lo                                          ; $01FC9B |/
    PLA                                                                         ; $01FC9D | Restore the sine value to the accumulator.
-   STA r_battle_effect_wave_coordinates_y.1.hi.w,X                             ; $01FC9E | Set that value as the second Y coordinate for the sprite.
    INX                                                                         ; $01FCA1 |\
    INX                                                                         ; $01FCA2 | | Loop until all 12 sprites have had the second Y coordinate set.
    DEC <r_battle_generic_tmp_index_lo                                          ; $01FCA3 | |
    BNE -                                                                       ; $01FCA5 |/
    LDA r_battle_effect_wave_group_frame_counter.w,Y                            ; $01FCA7 |\
    INC A                                                                       ; $01FCAA | | Increment the frame counter for this group.
    STA r_battle_effect_wave_group_frame_counter.w,Y                            ; $01FCAB |/
    INY                                                                         ; $01FCAE |\
    CPY #6.w                                                                    ; $01FCAF | | Loop until all six groups have been updated.
    BNE @start                                                                  ; $01FCB2 |/
    RTS                                                                         ; $01FCB4

; battle_do_nothing_but_return_2 ($01:FCB5)
;
; Does nothing but return. Called as a handler for a spell, so it may be an
; artifact from incomplete development.
battle_do_nothing_but_return_2:
    RTL                                                                         ; $01FCB5

; battle_animate_odin ($01:FCB6)
;
; Animates the Odin attack (when Odin attacks the party).
battle_animate_odin:
    TDC                                                                         ; $01FCB6 |\
    TAX                                                                         ; $01FCB7 | | Set the initial BG1 scroll values both to zero.
    STX r_battle_set_bg1_scroll_arg_horizontal.w                                ; $01FCB8 | |
    STX r_battle_set_bg1_scroll_arg_vertical.w                                  ; $01FCBB |/
    LDA #AUDIO_EFFECT_ODIN.b                                                    ; $01FCBE |\ Play the Odin sound effect.
    JSL bank02.battle_play_sound_effect                                         ; $01FCC0 |/
-   JSR _battle_wait_next_frame_preserve_x_y                                    ; $01FCC4 | Wait for the next frame.
    JSL battle_set_bg1_scroll                                                   ; $01FCC7 | Set the BG1 scroll to the current values.
    REP #FLAG_P_ACCUMULATOR                                                     ; $01FCCB |\
    LDA r_battle_set_bg1_scroll_arg_horizontal.w                                ; $01FCCD | | Subtract eight from the horizontal scroll value (to make Odin
    SEC                                                                         ; $01FCD0 | | appear to move right).
    SBC #8.w                                                                    ; $01FCD1 | |
    STA r_battle_set_bg1_scroll_arg_horizontal.w                                ; $01FCD4 | |
    TAX                                                                         ; $01FCD7 | |
    TDC                                                                         ; $01FCD8 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01FCD9 |/
    CPX #-88.w                                                                  ; $01FCDB |\ Repeat until the horizontal scroll reaches -88.
    BNE -                                                                       ; $01FCDE |/
    JSL battle_set_bg1_scroll                                                   ; $01FCE0 | Set the scroll values to the final values.
    LDA #VARIABLE_SPRITE_ODIN_ATTACKING.b                                       ; $01FCE4 |\ Switch to the sprite of Odin attacking.
    JSL bank02.battle_load_monster_variable_sprite_to_bg1_left                  ; $01FCE6 |/
    LDX #16.w                                                                   ; $01FCEA |\ Wait 16 frames.
    JSR _battle_wait_x_frames                                                   ; $01FCED |/
    LDA #VARIABLE_SPRITE_ODIN.b                                                 ; $01FCF0 |\ Switch to the sprite of regular Odin.
    JSL bank02.battle_load_monster_variable_sprite_to_bg1_left                  ; $01FCF2 |/
    LDX r_battle_current_action_details.target_flags.w                          ; $01FCF6 |\ Transfer the action target flags and targets to the reeling target
    STX r_battle_effect_spell_reeling_monster.w                                 ; $01FCF9 |/ flags and targets.
    JSL bank01.battle_effect_spell_animate_reeling                              ; $01FCFC | Animate the reeling effect.
    STZ r_battle_effect_spell_animate_reeling.w                                 ; $01FD00 | Unset the reeling animation flag.
-   JSR _battle_wait_next_frame_preserve_x_y                                    ; $01FD03 | Wait for the next frame.
    JSL battle_set_bg1_scroll                                                   ; $01FD06 | Update the scroll registers to the current values.
    REP #FLAG_P_ACCUMULATOR                                                     ; $01FD0A |\
    LDA r_battle_set_bg1_scroll_arg_horizontal.w                                ; $01FD0C | | Add eight to the horizontal scroll value to make Odin appear to
    CLC                                                                         ; $01FD0F | | move left.
    ADC #8.w                                                                    ; $01FD10 | |
    STA r_battle_set_bg1_scroll_arg_horizontal.w                                ; $01FD13 | |
    PHA                                                                         ; $01FD16 | |
    TDC                                                                         ; $01FD17 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $01FD18 |/
    PLX                                                                         ; $01FD1A |\ Loop until Odin returns to the original position.
    BNE -                                                                       ; $01FD1B |/
    JSL battle_set_bg1_scroll                                                   ; $01FD1D | Set the final scroll value.
    RTL                                                                         ; $01FD21

; battle_animate_wave ($01:FD22)
;
; Animates the Wave effect in the standard left-to-right direction, starting in
; the middle of the screen, used when monsters attack the party.
battle_animate_wave:
    JSR _battle_play_sound_effect_spell                                         ; $01FD22 | Play the sound effect for the effect.
    JSR _battle_reset_effect_oam_large                                          ; $01FD25 | Reset the effect OAM to large sprites.
    JSR _battle_effect_wave_initialize_standard                                 ; $01FD28 | Initialize the wave effect in the left-to-right direction.
    JSR _battle_effect_wave_update_coordinates                                  ; $01FD2B | Update the initial coordinates.
    LDX #64.w                                                                   ; $01FD2E | Initialize the X register to 64.
-   PHX                                                                         ; $01FD31 | Preserve the current value of the X register.
    JSR _battle_wait_next_frame_preserve_x_y                                    ; $01FD32 | Wait for the next frame.
    INC r_battle_disable_oam_update.w                                           ; $01FD35 | Disable automatic OAM transfers.
    JSR _battle_effect_wave_update_coordinates                                  ; $01FD38 | Update the current coordinates.
    JSR _battle_effect_wave_update_oam                                          ; $01FD3B | Update the OAM with the new coordinates.
    STZ r_battle_disable_oam_update.w                                           ; $01FD3E | Re-enable OAM transfers.
    PLX                                                                         ; $01FD41 | Restore the value in the X register.
    DEX                                                                         ; $01FD42 |\ Decrement the X register and loop until all 64 frames have
    BNE -                                                                       ; $01FD43 |/ finished.
    LDX r_battle_current_action_details.target_flags.w                          ; $01FD45 |\ Set the reeling monster flag and targets to the action monster flag
    STX r_battle_effect_spell_reeling_monster.w                                 ; $01FD48 |/ and targets.
    JSL battle_effect_spell_animate_reeling                                     ; $01FD4B | Animate the reeling effect.
    STZ r_battle_effect_spell_animate_reeling.w                                 ; $01FD4F | Unset the reeling animation flag.
    RTL                                                                         ; $01FD52

; battle_animate_call_leviatan_wave ($01:FD53)
;
; Animates the wave effect used by Leviatan when used as a Call spell.
battle_animate_call_leviatan_wave:
    JSR _battle_play_sound_effect_spell                                         ; $01FD53 | Play the sound effect for the effect.
    JSR _battle_reset_effect_oam_large                                          ; $01FD56 | Reset the effect OAM to large sprites.
    JSR _battle_effect_wave_initialize_mirrored                                 ; $01FD59 | Initialize the wave effect in the right-to-left direction.
    JSR _battle_effect_wave_update_coordinates                                  ; $01FD5C | Update the initial coordinates.
    JSR _set_battle_flash_pulse_blue                                            ; $01FD5F | Set a blue pulsing battle flash.
    LDX #128.w                                                                  ; $01FD62 | Initialize the X register to 128.
-   PHX                                                                         ; $01FD65 | Preserve the current value of the X register.
    JSR _battle_wait_next_frame_preserve_x_y                                    ; $01FD66 | Wait for the next frame.
    INC r_battle_disable_oam_update.w                                           ; $01FD69 | Disable automatic OAM transfers.
    JSR _battle_effect_wave_update_coordinates                                  ; $01FD6C | Update the current coordinates.
    JSR _battle_effect_wave_update_oam                                          ; $01FD6F | Update the OAM with the new coordinates.
    STZ r_battle_disable_oam_update.w                                           ; $01FD72 | Re-enable automatic OAM transfers.
    JSL bank02.battle_update_shake_scroll                                       ; $01FD75 | Update the shaking effect for the current frame.
    PLX                                                                         ; $01FD79 | Restore the value of the X register.
    DEX                                                                         ; $01FD7A |\ Loop until all 128 frames have passed.
    BNE -                                                                       ; $01FD7B |/
    JSR _battle_reset_effect_oam_large                                          ; $01FD7D | Reset the effect OAM.
    STZ r_battle_flash_mode.w                                                   ; $01FD80 | Disable the battle flash.
    JSL bank02.battle_reset_bg1_bg2_horizontal_scroll                           ; $01FD83 | Reset the scroll registers to default.
    RTL                                                                         ; $01FD87

; battle_animate_call_bahamut ($01:FD88)
;
; Animates the Bahamut spell.
battle_animate_call_bahamut:
    LDX #32.w                                                                   ; $01FD88 |\ Wait for 32 frames.
    JSR _battle_wait_x_frames                                                   ; $01FD8B |/
    LDA #8.b                                                                    ; $01FD8E |\ Set the frame counter to eight to switch to the other Bahamut
    STA r_battle_alternate_party_sprite_frame_counter.w                         ; $01FD90 |/ sprite.
    JSR _battle_reset_effect_oam_large                                          ; $01FD93 | Reset the effect OAM.
    JSR _battle_play_sound_effect_spell                                         ; $01FD96 | Play the sound effect for the spell.
    JSL bank03.battle_animate_bahamut_sprites                                   ; $01FD99 | Animate the explosions.
    JSR _battle_reset_effect_oam_large                                          ; $01FD9D | Reset the effect OAM.
    RTL                                                                         ; $01FDA0

; _battle_alternate_party_sprite_move_forward ($01:FDA1)
;
; Moves the X coordinate of the alternate party sprite to the left by sixteen,
; over the course of eight frames.
_battle_alternate_party_sprite_move_forward:
    LDX #8.w                                                                    ; $01FDA1 | Initialize the X register to eight.
-   JSR _battle_wait_next_frame_preserve_x_y                                    ; $01FDA4 | Wait for the next frame.
    DEC r_battle_alternate_party_sprite_coordinates.x.w                         ; $01FDA7 |\ Decrement the alternate party sprite X coordinate by two.
    DEC r_battle_alternate_party_sprite_coordinates.x.w                         ; $01FDAA |/
    DEX                                                                         ; $01FDAD |\ Decrement the X register and loop until it reaches zero.
    BNE -                                                                       ; $01FDAE |/
    RTS                                                                         ; $01FDB0

; _battle_alternate_party_sprite_move_backward ($01:FDB1)
;
; Moves the X coordinate of the alternate party sprite to the right by sixteen,
; over the course of eight frames.
_battle_alternate_party_sprite_move_backward:
    LDX #8.w                                                                    ; $01FDB1 | Initialize the X register to eight.
-   JSR _battle_wait_next_frame_preserve_x_y                                    ; $01FDB4 | Wait for the next frame.
    INC r_battle_alternate_party_sprite_coordinates.x.w                         ; $01FDB7 |\ Increment the alternate party sprite X coordinate by two.
    INC r_battle_alternate_party_sprite_coordinates.x.w                         ; $01FDBA |/
    DEX                                                                         ; $01FDBD |\ Decrement the X register and loop until it reaches zero.
    BNE -                                                                       ; $01FDBE |/
    RTS                                                                         ; $01FDC0

; _unused_battle_move_alternate_party_sprite_left ($01:FDC1)
;
; Animates the alternate party sprite moving left by 16 pixels, at a rate of 2
; pixels per frame.
_unused_battle_move_alternate_party_sprite_left:
    LDX #8.w                                                                    ; $01FDC1 | Initialize the X register to eight.
-   JSR _battle_wait_next_frame_preserve_x_y                                    ; $01FDC4 | Wait for the next frame.
    DEC r_battle_alternate_party_sprite_coordinates.x.w                         ; $01FDC7 |\ Decrement the alternate party sprite X coordinate by two.
    DEC r_battle_alternate_party_sprite_coordinates.x.w                         ; $01FDCA |/
    LDA r_battle_alternate_party_sprite_frame_counter.w                         ; $01FDCD |\
    CLC                                                                         ; $01FDD0 | | Add four to the frame counter.
    ADC #4.b                                                                    ; $01FDD1 | |
    STA r_battle_alternate_party_sprite_frame_counter.w                         ; $01FDD3 |/
    DEX                                                                         ; $01FDD6 |\ Loop until the X register reaches zero.
    BNE -                                                                       ; $01FDD7 |/
    STZ r_battle_alternate_party_sprite_frame_counter.w                         ; $01FDD9 | Reset the frame counter to zero.
    RTS                                                                         ; $01FDDC

; _unused_battle_move_alternate_party_sprite_right ($01:FDDD)
;
; Unused function to animate the alternate party sprite moving right by 16
; pixels at a rate of 2 per frame.
_unused_battle_move_alternate_party_sprite_right:
    LDX #8.w                                                                    ; $01FDDD | Initialize the X register to eight.
-   JSR _battle_wait_next_frame_preserve_x_y                                    ; $01FDE0 | Wait for the next frame.
    INC r_battle_alternate_party_sprite_coordinates.x.w                         ; $01FDE3 |\ Increment the alternate party sprite X coordinate by two.
    INC r_battle_alternate_party_sprite_coordinates.x.w                         ; $01FDE6 |/
    LDA r_battle_alternate_party_sprite_frame_counter.w                         ; $01FDE9 |\
    CLC                                                                         ; $01FDEC | | Add four to the frame counter.
    ADC #4.b                                                                    ; $01FDED | |
    STA r_battle_alternate_party_sprite_frame_counter.w                         ; $01FDEF |/
    DEX                                                                         ; $01FDF2 |\ Decrement the X register and loop until it reaches zero.
    BNE -                                                                       ; $01FDF3 |/
    STZ r_battle_alternate_party_sprite_frame_counter.w                         ; $01FDF5 | Reset the frame counter to zero.
    RTS                                                                         ; $01FDF8

; _battle_draw_alternate_party_sprite ($01:FDF9)
;
; If an alternate party sprite has been configured (used by the Call spells to
; display the summoned monster), this routine draws that sprite. The variables
; to configure its behavior are largely contained from $F320 to $F330.
_battle_draw_alternate_party_sprite:
    LDA r_battle_alternate_party_sprite_mode.w                                  ; $01FDF9 |\
    BEQ +                                                                       ; $01FDFC | | Skip this function if the alternate party sprite mode is either
    CMP #ALTERNATE_PARTY_SPRITE_MODE_INVISIBLE.b                                ; $01FDFE | | disabled or set to invisible.
    BNE ++                                                                      ; $01FE00 | |
+   RTS                                                                         ; $01FE02 |/
++  LDX #(88 / 4).w                                                             ; $01FE03 |\
    LDA #%10101010.b                                                            ; $01FE06 | | Loop through the high OAM table for OAM entries 88 through 127 and
-   STA r_oam_hi.w,X                                                            ; $01FE08 | | set those bytes to use a base tile number of 0 and to use 16x16
    INX                                                                         ; $01FE0B | | sprites.
    CPX #_sizeof_r_oam_hi.w                                                     ; $01FE0C | |
    BNE -                                                                       ; $01FE0F |/
    LDA r_battle_alternate_party_sprite_auto_animate.w                          ; $01FE11 |\
    BEQ +                                                                       ; $01FE14 | | Increment the frame counter if automatic animation is enabled.
    INC r_battle_alternate_party_sprite_frame_counter.w                         ; $01FE16 |/
+   LDA r_battle_alternate_party_sprite_frame_counter.w                         ; $01FE19 |\
    LSR A                                                                       ; $01FE1C | | Take the frame counter divided by eight, mod 4, and save that as
    LSR A                                                                       ; $01FE1D | | the current frame index. (The result is that the frame index will
    LSR A                                                                       ; $01FE1E | | change every eight times the frame counter is incremented.)
    AND #%00000011.b                                                            ; $01FE1F | |
    STA <r_battle_alternate_party_sprite_tmp_frame_index                        ; $01FE21 |/
    LDA r_battle_alternate_party_sprite_index.w                                 ; $01FE23 |\
    ASL A                                                                       ; $01FE26 | | Multiply the sprite index times four (as each sprite has four
    ASL A                                                                       ; $01FE27 | | frames) and then add the frame index to determine the offset to
    CLC                                                                         ; $01FE28 | | the frame. Load the frame number and save it.
    ADC <r_battle_alternate_party_sprite_tmp_frame_index                        ; $01FE29 | |
    TAX                                                                         ; $01FE2B | |
    LDA bank13.battle_call_sprite_frame_data.l,X                                ; $01FE2C | |
    STA r_battle_alternate_party_sprite_frame_index.w                           ; $01FE30 |/
    TDC                                                                         ; $01FE33 |\
    TAX                                                                         ; $01FE34 | | Initialize the coordinate offsets to zero.
    STX r_battle_alternate_party_sprite_coordinate_offsets.w                    ; $01FE35 |/
    LDA r_battle_alternate_party_sprite_sine_offsets_enabled.w                  ; $01FE38 |\ Skip this next block if sine offsets are not enabled.
    BEQ +                                                                       ; $01FE3B |/
    LDA r_battle_effect_sine_magnitude.w                                        ; $01FE3D |\
    ASL A                                                                       ; $01FE40 | | Set the sine value argument to set the given magnitude.
    STA <r_math_multiply_8bit_reg_arg_2                                         ; $01FE41 |/
    LDA r_battle_effect_sine_index.w                                            ; $01FE43 |\
    CLC                                                                         ; $01FE46 | | Increment the sine index by the sine offset speed.
    ADC r_battle_alternate_party_sprite_sine_offsets_speed.w                    ; $01FE47 | |
    STA r_battle_effect_sine_index.w                                            ; $01FE4A |/
    JSL bank02.get_sine_value                                                   ; $01FE4D |\ Read the sine value and use that to set the Y offset.
    STA r_battle_alternate_party_sprite_coordinate_offsets.y.w                  ; $01FE51 |/
    LDA r_battle_effect_sine_magnitude_2.w                                      ; $01FE54 |\
    ASL A                                                                       ; $01FE57 | | Set the sine value argument to set the given magnitude.
    STA <r_math_multiply_8bit_reg_arg_2                                         ; $01FE58 |/
    LDA r_battle_effect_sine_index_2.w                                          ; $01FE5A |\
    CLC                                                                         ; $01FE5D | | Increment the cosine index by the sine offset speed.
    ADC r_battle_alternate_party_sprite_sine_offsets_speed.w                    ; $01FE5E | |
    STA r_battle_effect_sine_index_2.w                                          ; $01FE61 |/
    JSL bank02.get_sine_value                                                   ; $01FE64 |\ Read the cosine value and use that to set the X offset.
    STA r_battle_alternate_party_sprite_coordinate_offsets.x.w                  ; $01FE68 |/
+   LDA r_battle_alternate_party_sprite_frame_index.w                           ; $01FE6B |\
    ASL A                                                                       ; $01FE6E | | Load the pointer to the actual tile data for the chosen frame.
    TAX                                                                         ; $01FE6F | |
    LDA bank0D.battle_sprite_call_frame_offset_data.l + 0,X                     ; $01FE70 | |
    STA <r_battle_effect_spell_frame_data_ptr_addr_lo                           ; $01FE74 | |
    LDA bank0D.battle_sprite_call_frame_offset_data.l + 1,X                     ; $01FE76 | |
    STA <r_battle_effect_spell_frame_data_ptr_addr_hi                           ; $01FE7A | |
    LDA #:bank0D.battle_sprite_call_frame_offset_data.b                         ; $01FE7C | |
    STA <r_battle_effect_spell_frame_data_ptr_bank                              ; $01FE7E |/
    LDA r_battle_alternate_party_sprite_coordinates.y.w                         ; $01FE80 |\
    CLC                                                                         ; $01FE83 | | Set the Y coordinate to the sprite Y coordinate plus any
    ADC r_battle_alternate_party_sprite_coordinate_offsets.y.w                  ; $01FE84 | | calculated Y coordinate offset.
    STA <r_battle_alternate_party_sprite_tmp_coordinates.y                      ; $01FE87 |/
    LDA r_battle_alternate_party_sprite_size.height.w                           ; $01FE89 |\ Transfer the height to a temporary variable.
    STA <r_battle_alternate_party_sprite_tmp_size.height.b                      ; $01FE8C |/
    STZ <r_battle_alternate_party_sprite_next_arg_blanks                        ; $01FE8E | Initialize the number of blanks to zero.
    LDY #_sizeof_oam_sprite.w * 88                                              ; $01FE90 | Initialize the Y register to the offset to OAM entry 88.
@outer_start:
    LDA r_battle_alternate_party_sprite_size.width.w                            ; $01FE93 |\ Transfer the width to a temporary variable.
    STA <r_battle_alternate_party_sprite_tmp_size.width.b                       ; $01FE96 |/
    LDA r_battle_alternate_party_sprite_coordinates.x.w                         ; $01FE98 |\
    CLC                                                                         ; $01FE9B | | Set the X coordinate to the sprite X coordinate plus any
    ADC r_battle_alternate_party_sprite_coordinate_offsets.x.w                  ; $01FE9C | | calculated X coordinate offset.
    STA <r_battle_alternate_party_sprite_tmp_coordinates.x.b                    ; $01FE9F |/
    LDA r_battle_alternate_party_sprite_invisible_columns.w                     ; $01FEA1 |\ Transfer the invisible columns mask to a temporary variable.
    STA r_battle_alternate_party_sprite_tmp_invisible_columns.w                 ; $01FEA4 |/
@inner_start:
    JSL bank03.battle_alternate_party_sprite_get_next_tile                      ; $01FEA7 | Read the next tile number.
    BCC @next                                                                   ; $01FEAB | Skip this tile if this tile is meant to be blank.
    STA r_oam.1.tile.w,Y                                                        ; $01FEAD | Save the tile number as the tile for this sprite.
    ASL r_battle_alternate_party_sprite_tmp_invisible_columns.w                 ; $01FEB0 |\ If this column is set to be invisible, skip this tile.
    BCS @next                                                                   ; $01FEB3 |/
    LDA r_formation_back_attack_copy.w                                          ; $01FEB5 |\
    BNE +                                                                       ; $01FEB8 | | If this is not a back attack, set the X coordinate directly, but
    LDA <r_battle_alternate_party_sprite_tmp_coordinates.x                      ; $01FEBA | | toggle the horizontal flip bit on the tile flags (as the sprite is
    STA r_oam.1.x.w,Y                                                           ; $01FEBC | | being reversed from how it typically appears as a monster).
    LDA <r_battle_alternate_party_sprite_next_result_flags                      ; $01FEBF | |
    EOR #%01000000.b                                                            ; $01FEC1 | |
    STA r_oam.1.flags.w,Y                                                       ; $01FEC3 | |
    JMP ++                                                                      ; $01FEC6 |/
+   LDA <r_battle_alternate_party_sprite_tmp_coordinates.x                      ; $01FEC9 |\
    EOR #%11111111.b                                                            ; $01FECB | | Otherwise, if it is a back attack, flip the bits on the X
    SEC                                                                         ; $01FECD | | coordinate and subtract 16 to mirror to the other side. Leave the
    SBC #16.b                                                                   ; $01FECE | | tile flags as is.
    STA r_oam.1.x.w,Y                                                           ; $01FED0 | |
    LDA <r_battle_alternate_party_sprite_next_result_flags                      ; $01FED3 | |
    STA r_oam.1.flags.w,Y                                                       ; $01FED5 |/
++  LDA <r_battle_alternate_party_sprite_tmp_coordinates.y                      ; $01FED8 |\ Set the Y coordinate to the calculated Y coordinate.
    STA r_oam.1.y.w,Y                                                           ; $01FEDA |/
    INY                                                                         ; $01FEDD |\
    INY                                                                         ; $01FEDE | | Increment the Y register by four to move to the next OAM entry.
    INY                                                                         ; $01FEDF | |
    INY                                                                         ; $01FEE0 |/
@next:
    LDA <r_battle_alternate_party_sprite_tmp_coordinates.x                      ; $01FEE1 |\
    CLC                                                                         ; $01FEE3 | | Add sixteen to the X coordinate to move to the next tile.
    ADC #16.b                                                                   ; $01FEE4 | |
    STA <r_battle_alternate_party_sprite_tmp_coordinates.x                      ; $01FEE6 |/
    DEC <r_battle_alternate_party_sprite_tmp_size.width                         ; $01FEE8 |\ Decrement the width and loop until it reaches zero.
    BNE @inner_start                                                            ; $01FEEA |/
    LDA <r_battle_alternate_party_sprite_tmp_coordinates.y                      ; $01FEEC |\
    CLC                                                                         ; $01FEEE | | Add sixteen to the Y coordinate to move to the next row.
    ADC #16.b                                                                   ; $01FEEF | |
    STA <r_battle_alternate_party_sprite_tmp_coordinates.y                      ; $01FEF1 |/
    DEC <r_battle_alternate_party_sprite_tmp_size.height                        ; $01FEF3 |\ Decrement the height and loop until it reaches zero.
    BNE @outer_start                                                            ; $01FEF5 |/
    RTS                                                                         ; $01FEF7

; battle_effect_spell_rotating_pair_update_offsets ($01:FEF8)
;
; Updates the current OAM offsets for a pair of vertically stacked 32x32
; sprites in the frame that rotate around the target with a gradually decreasing
; radius. (Used at least for Cure4.)
battle_effect_spell_rotating_pair_update_offsets:
    TDC                                                                         ; $01FEF8 |\
    TAY                                                                         ; $01FEF9 | | Initialize the X and Y registers to zero.
    TAX                                                                         ; $01FEFA |/
-   PHX                                                                         ; $01FEFB |\ Preserve the current X register value (the coordinate index) and
    TYA                                                                         ; $01FEFC |/ set the X register to the sine index instead.
    TAX                                                                         ; $01FEFD |\
    JSR _battle_effect_get_sine_value_2                                         ; $01FEFE | | Set the current second sine value, add it to the X coordinate
    PLX                                                                         ; $01FF01 | | offset data, and then save that as the final X offset for this
    CLC                                                                         ; $01FF02 | | sprite.
    ADC bank0D.battle_effect_spell_vertical_pair_shift_offset_data.l + 0,X      ; $01FF03 | |
    STA r_battle_effect_spell_oam_coordinate_offsets.1.x.w,X                    ; $01FF07 |/
    PHX                                                                         ; $01FF0A |\
    TYA                                                                         ; $01FF0B | | Repeat the above, except for the Y coordinate.
    TAX                                                                         ; $01FF0C | |
    JSR _battle_effect_get_sine_value                                           ; $01FF0D | |
    PLX                                                                         ; $01FF10 | |
    CLC                                                                         ; $01FF11 | |
    ADC bank0D.battle_effect_spell_vertical_pair_shift_offset_data.l + 1,X      ; $01FF12 | |
    STA r_battle_effect_spell_oam_coordinate_offsets.1.y.w,X                    ; $01FF16 |/
    PHX                                                                         ; $01FF19 |\
    TYA                                                                         ; $01FF1A | | Increment the sine indexes by 12, to induce a gentle rotation
    TAX                                                                         ; $01FF1B | | effect.
    LDA #12.b                                                                   ; $01FF1C | |
    JSR _battle_effect_increment_sine_indexes                                   ; $01FF1E |/
    LDA r_battle_effect_sine_magnitude.w                                        ; $01FF21 |\
    BEQ +                                                                       ; $01FF24 | | Decrement the sine magnitude by one, unless it has already reached
    LDA #-1.b                                                                   ; $01FF26 | | zero.
    JSR _battle_effect_increment_sine_magnitudes                                ; $01FF28 |/
+   PLX                                                                         ; $01FF2B |\
    INY                                                                         ; $01FF2C | | Increment the registers and loop until all eight sprites have had
    INX                                                                         ; $01FF2D | | their offsets set.
    INX                                                                         ; $01FF2E | |
    CPX #16.w                                                                   ; $01FF2F | |
    BNE -                                                                       ; $01FF32 |/
    RTL                                                                         ; $01FF34

UNUSED_01FF35:
    .dsb $00CB $FF                                                              ; $01FF35.FFFF

.ends
