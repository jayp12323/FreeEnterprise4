.include "header.inc"

.define r_math_multiply_16bit_arg_1             $0026 ; 16-bit
.define r_math_multiply_16bit_arg_2             $0028 ; 16-bit
.define r_math_multiply_16bit_result_lo         $002A ; 16-bit
.define r_math_multiply_16bit_result_lo_lo      $002A ; 8-bit
.define r_math_multiply_16bit_result_lo_hi      $002B ; 8-bit
.define r_math_multiply_16bit_result_hi         $002C ; 16-bit
.define r_math_multiply_16bit_result_hi_lo      $002C ; 8-bit
.define r_math_multiply_16bit_result_hi_hi      $002D ; 8-bit
.define r_math_multiply_16bit_tmp               $002E ; 16-bit

.define r_math_divide_16bit_arg_1               $0026 ; 16-bit
.define r_math_divide_16bit_arg_2               $0028 ; 16-bit
.define r_math_divide_16bit_result              $002A ; 16-bit
.define r_math_divide_16bit_result_lo           $002A ; 16-bit
.define r_math_divide_16bit_result_hi           $002B ; 16-bit
.define r_math_divide_16bit_remainder           $002C ; 16-bit

.bank 2 slot 1
.section "Bank" namespace "bank02"

    NOP                                                                         ; $028000
    NOP                                                                         ; $028001
    NOP                                                                         ; $028002

; battle_update ($02:8003)
;
; Ultimately calls _battle_update, which performs various battle updates
; depending on the value in the accumulator.
battle_update:
    JMP battle_update_proxy                                                     ; $028003 | Jump to the proxy function that will call _battle_update.

; battle_wait_next_frame_preserve_x_y ($02:8006)
;
; Waits for the next frame while preserving X and Y and performing necessary
; dialog and DMA updates.
battle_wait_next_frame_preserve_x_y:
    JSR _battle_wait_next_frame_preserve_x_y                                    ; $028006 | Wait for the next frame while preserving the X and Y registers.
    RTL                                                                         ; $028009

; battle_update_proxy ($02:800A)
;
; Calls _battle_update and then returns long.
battle_update_proxy:
    JSR _battle_update                                                          ; $02800A | Call the core _battle_update function.
    RTL                                                                         ; $02800D

; _battle_update ($02:800E)
;
; Depending on the value in the accumulator, executes a number of miscellaneous
; battle update functions, mostly relating to dialogs.
_battle_update:
    ASL                                                                         ; $02800E |\ Calculate the offset into the pointer table.
    TAX                                                                         ; $02800F |/
    LDA battle_update_pointer_data.l + 0,X                                      ; $028010 |\
    STA <r_battle_generic_tmp_index_2_lo                                        ; $028014 | | Load the pointer into memory.
    LDA battle_update_pointer_data.l + 1,X                                      ; $028016 | |
    STA <r_battle_generic_tmp_index_2_hi                                        ; $02801A |/
    JMP (<r_battle_generic_tmp_index_2)                                         ; $02801C | Jump to the resulting pointer.

; battle_update_pointer_data ($02:801F)
;
; A series of pointers to various functions executed by the _battle_update
; function.
battle_update_pointer_data:
    .addr _battle_update_command_menu_open                                      ; $02801F | $00: Flags that a command menu should be opened.
    .addr _battle_update_command_menu_close                                     ; $028021 | $01: Flags that a command menu should be closed.
    .addr _battle_update_next_frame_active                                      ; $028023 | $02: Extensive updates for the next frame for the main battle loop.
    .addr _battle_update_animate_battle_start                                   ; $028025 | $03: Animates the start of the battle.
    .addr _battle_update_change_rows                                            ; $028027 | $04: Changes rows.
    .addr _battle_update_audiovisual_and_check_caller                           ; $028029 | $05: Animates audiovisual scripts.
    .addr _battle_update_inventory_entry                                        ; $02802B | $06: Updates a single inventory entry.
    .addr _battle_update_spell_list_entry                                       ; $02802D | $07: Updates a single spell list entry.
    .addr _battle_update_hand_inventory_entry                                   ; $02802F | $08: Updates a single hand inventory entry.
    .addr _battle_update_command_menu_entries                                   ; $028031 | $09: Updates the command menu entries for a single slot.
    .addr _battle_update_dialog_character_names                                 ; $028033 | $0A: Updates the character name dialog data.
    .addr _battle_update_dialog_monster_names                                   ; $028035 | $0B: Updates the monster name dialog data.
    .addr _battle_update_dialog_character_hp                                    ; $028037 | $0C: Updates the character HP dialog data.
    .addr _battle_update_dialog_character_mp                                    ; $028039 | $0D: Updates the character MP dialog data.
    .addr _battle_update_spell_list_palettes                                    ; $02803B | $0E: Updates the palettes for spell list entries.
    .addr _battle_update_next_frame                                             ; $02803D | $0F: Handles various updates needed to execute each frame.
    .addr _battle_animate_monster_death                                         ; $02803F | $10: Animates monster death.
    .addr _battle_update_animate_damage                                         ; $028041 | $11: Animates the damage effect.
    .addr _battle_animate_party_victory                                         ; $028043 | $12: Animates the party's victory in battle.
    .addr _battle_animate_party_escape                                          ; $028045 | $13: Animates the party running from battle.
    .addr _battle_update_monster_back_row                                       ; $028047 | $14: Updates the back row status of each monster.
    .addr _battle_finalize_pending_dialogs_no_copy                              ; $028049 | $15: Finalizes pending dialog updates at the end of battle.

; _battle_finalize_pending_dialogs ($02:804B)
;
; Loops until the dialog update dispatch argument variable is zero.
;
; NOTE: The Easytype version adds some additional code to copy the hand
;       inventory for each charcter back to their character records. This is
;       only executed when the routine is directly called, and not via the
;       generic battle update jump table.
_battle_finalize_pending_dialogs:
.if FF4_VERSION == "JAPAN_EASYTYPE"
    JSR _battle_copy_hand_inventory_to_records                                  ; $02804B | For Easytype, copy the hand inventory back to the records.
.endif
_battle_finalize_pending_dialogs_no_copy:
    TDC                                                                         ; $02804B |\ Disable the multi-controller input.
    STA r_multi_active.l & $FFFF                                                ; $02804C |/
    LDA r_battle_pause_disabled.w                                               ; $028050 |\
    BNE @start                                                                  ; $028053 | | Disable pausing if not already disabled.
    INC r_battle_pause_disabled.w                                               ; $028055 |/
@start:
    JSR _battle_wait_for_nmi.w                                                  ; $028058 |\
    JSR _execute_battle_dialog_updates                                          ; $02805B | | Loop until any pending dialog updates are taken care of.
    LDA r_battle_update_dialog_dispatch_arg_mode.w                              ; $02805E | |
    BNE @start                                                                  ; $028061 |/
    RTS                                                                         ; $028063

; _battle_update_monster_back_row ($02:8064)
;
; Calls a function in another back to update the monster's back row status in
; $35EB.
_battle_update_monster_back_row:
    JSL bank01.battle_update_monster_back_row                                   ; $028064 | Update the monster back row status.
    RTS                                                                         ; $028068

; _battle_animate_party_escape ($02:8069)
;
; Animates the party running from the battle.
_battle_animate_party_escape:
    JSR _battle_finalize_pending_dialogs                                        ; $028069 | Handle any pending dialog updates.
    LDA r_battle_suspend_animation.w                                            ; $02806C |\
    BEQ +                                                                       ; $02806F | | Skip this routine if animation is suspended. Additionally set the
    INC r_battle_suppress_character_y_offset_reset.w                            ; $028071 | | flag that prevents the Y offset from being reset.
    RTS                                                                         ; $028074 |/
+   STZ r_battle_play_audio_pan_monster.w                                       ; $028075 |\
    LDA #AUDIO_EFFECT_ESCAPE.b                                                  ; $028078 | | Play the escape sound effect, panned to the character side.
    JSR _battle_play_sound_effect                                               ; $02807A |/
    TDC                                                                         ; $02807D |\ Initialize the X register to zero.
    TAX                                                                         ; $02807E |/
-   LDA r_character_slot_if_active.w,X                                          ; $02807F |\
    CMP #$FF.b                                                                  ; $028082 | | Skip this next block if the current slot is empty.
    BEQ +                                                                       ; $028084 |/
    TXA                                                                         ; $028086 | Transfer the slot number in the X register.
    ASL A                                                                       ; $028087 |\
    ASL A                                                                       ; $028088 | | Set the Y register to the slot number times four.
    TAY                                                                         ; $028089 |/
    STZ r_battle_character_pose.w,X                                             ; $02808A | Unset the character pose.
    LDA r_character_visual_status.1.status_1.w,Y                                ; $02808D |\
    AND #(STATUS_1_SWOON | STATUS_1_STONE).b                                    ; $028090 | | If the character in this slot isn't swoon or stone, set their pose
    BNE +                                                                       ; $028092 | | to the walking pose.
    LDA #BATTLE_POSE_WALKING.b                                                  ; $028094 | |
    STA r_battle_character_pose.w,X                                             ; $028096 |/
+   LDA #1.b                                                                    ; $028099 |\
    STA r_battle_character_disable_automatic_movement.w,X                       ; $02809B | | Prevent automatic movement and flag characters as moving.
    STA r_battle_character_moving.w,X                                           ; $02809E |/
    INX                                                                         ; $0280A1 |\
    CPX #5.w                                                                    ; $0280A2 | | Loop until all five character slots have been processed.
    BNE -                                                                       ; $0280A5 |/
    INC r_battle_suppress_character_y_offset_reset.w                            ; $0280A7 | Prevent the animation code from overriding the character Y offset.
-   JSR _battle_wait_next_frame_preserve_x_y                                    ; $0280AA |\
    LDA r_battle_character_visual_properties.1.pending_steps.w                  ; $0280AD | | Wait until all characters are done with any pending movements.
    ORA r_battle_character_visual_properties.2.pending_steps.w                  ; $0280B0 | |
    ORA r_battle_character_visual_properties.3.pending_steps.w                  ; $0280B3 | |
    ORA r_battle_character_visual_properties.4.pending_steps.w                  ; $0280B6 | |
    ORA r_battle_character_visual_properties.5.pending_steps.w                  ; $0280B9 | |
    BNE -                                                                       ; $0280BC |/
    TDC                                                                         ; $0280BE |\ Initialize the X register to zero.
    TAX                                                                         ; $0280BF |/
-   STZ r_battle_character_visual_properties.1.frame_counter.w,X                ; $0280C0 | Set the character's frame counter to zero.
    STZ r_battle_character_visual_properties.1.pose_frame_counter.w,X           ; $0280C3 | Set the character's pose frame counter to zero.
    TXA                                                                         ; $0280C6 |\
    CLC                                                                         ; $0280C7 | | Increment the X register by the record size and loop until all
    ADC #_sizeof_character_visual.b                                             ; $0280C8 | | five characters have been handled.
    TAX                                                                         ; $0280CA | |
    CPX #_sizeof_r_battle_character_visual_properties.w                         ; $0280CB | |
    BNE -                                                                       ; $0280CE |/
--  JSR _battle_wait_next_frame_preserve_x_y                                    ; $0280D0 |\
    TDC                                                                         ; $0280D3 | | Initialize both the count and index to zero.
    TAX                                                                         ; $0280D4 | |
    STZ <r_battle_animate_party_escape_tmp_count                                ; $0280D5 | |
    STZ <r_battle_animate_party_escape_tmp_index                                ; $0280D7 |/
-   LDA <r_battle_animate_party_escape_tmp_index                                ; $0280D9 |\
    TAY                                                                         ; $0280DB | | If this slot is empty, branch forward to the code that adds one to
    LDA r_character_slot_if_active.w,Y                                          ; $0280DC | | the count, as this slot is finished.
    CMP #$FF.b                                                                  ; $0280DF | |
    BEQ +                                                                       ; $0280E1 |/
    LDA <r_battle_animate_party_escape_tmp_index                                ; $0280E3 |\
    ASL A                                                                       ; $0280E5 | | Calculate the visual properties index by multiplying the slot by
    ASL A                                                                       ; $0280E6 | | four.
    TAY                                                                         ; $0280E7 |/
    LDA r_character_visual_status.1.status_1.w,Y                                ; $0280E8 |\
    AND #(STATUS_1_SWOON | STATUS_1_STONE).b                                    ; $0280EB | | If the character is swooned or stoned, branch to increment count.
    BNE +                                                                       ; $0280ED |/
    LDA r_battle_character_visual_properties.1.id.w,X                           ; $0280EF |\ Skip this slot if the character ID is zero.
    BEQ +                                                                       ; $0280F2 |/
    LDA r_battle_character_visual_properties.1.flags.w,X                        ; $0280F4 |\
    ORA #CHARACTER_VISUAL_FLAG_REVERSE.b                                        ; $0280F7 | | Set the character's reverse flag.
    STA r_battle_character_visual_properties.1.flags.w,X                        ; $0280F9 |/
    JSR _battle_update_coordinates_walk_right                                   ; $0280FC | Update the character's coordinates for this frame.
    LDA r_battle_character_visual_properties.1.x.w,X                            ; $0280FF |\
    CMP #240.b                                                                  ; $028102 | | If the character's X coordinate has reached 240, unset the ID
    BCC ++                                                                      ; $028104 | | and increment the count of complete characters.
    TDC                                                                         ; $028106 | |
    STA r_battle_character_visual_properties.1.id.w,X                           ; $028107 | |
    INC <r_battle_animate_party_escape_tmp_count                                ; $02810A | |
    BRA ++                                                                      ; $02810C |/
+   INC <r_battle_animate_party_escape_tmp_count                                ; $02810E | Increment the complete character count (branched from above).
++  INC <r_battle_animate_party_escape_tmp_index                                ; $028110 | Increment the slot number.
    TXA                                                                         ; $028112 |\
    CLC                                                                         ; $028113 | | Increment the offset into the visual properties array.
    ADC #_sizeof_character_visual.b                                             ; $028114 | |
    TAX                                                                         ; $028116 |/
    CPX #_sizeof_r_battle_character_visual_properties.w                         ; $028117 |\ Loop until all five slots are checked.
    BNE -                                                                       ; $02811A |/
    LDA <r_battle_animate_party_escape_tmp_count                                ; $02811C |\
    CMP #$05.b                                                                  ; $02811E | | Loop until all five characters have completed their action.
    BNE --                                                                      ; $028120 |/
    RTS                                                                         ; $028122

; _battle_update_coordinates_walk_right ($02:8123)
;
; Calls a function in another bank which updates the X coordinate for the slot
; and potentially updates the Y offset if the slot is a toad.
_battle_update_coordinates_walk_right:
    JSL bank03.battle_update_coordinates_walk_right                             ; $028123 | Update the coordinates for the character.
    RTS                                                                         ; $028127

; _battle_update_coordinates_walk_left ($02:8128)
;
; Calls a function in another bank which updates the X coordinate for the slot
; and potentially updates the Y offset if the slot is a toad.
_battle_update_coordinates_walk_left:
    JSL bank03.battle_update_coordinates_walk_left                              ; $028128 | Update the coordinates for the character.
    RTS                                                                         ; $02812C

; _battle_animate_party_victory ($02:812D)
;
; Animate the party victory.
_battle_animate_party_victory:
    INC r_battle_party_victory.w                                                ; $02812D | Flag the party as victorious.
    JSR _battle_finalize_pending_dialogs                                        ; $028130 | Execute any pending dialog updates.
    TDC                                                                         ; $028133 |\
    TAX                                                                         ; $028134 | | Initialize the X and Y registers to zero.
    TAY                                                                         ; $028135 |/
-   TYA                                                                         ; $028136 |\
    TAX                                                                         ; $028137 | | Set the X register to the offset into the battle record.
    JSR _multiply_x_by_128                                                      ; $028138 |/
    LDA r_character_battle.1.status_1.w,X                                       ; $02813B |\
    AND #(STATUS_1_SWOON | STATUS_1_STONE).b                                    ; $02813E | | If the character in this slot doesn't have the swoon or stone
    BNE +                                                                       ; $028140 | | statuses, set their pose to cheering and disable the status-based
    LDA #BATTLE_POSE_CHEERING.b                                                 ; $028142 | | poses.
    STA r_battle_character_pose.w,Y                                             ; $028144 | |
    LDA #1.b                                                                    ; $028147 | |
    STA r_battle_disable_status_pose.w,Y                                        ; $028149 |/
+   INY                                                                         ; $02814C |\
    CPY #5.w                                                                    ; $02814D | | Loop until all five slots have been processed.
    BNE -                                                                       ; $028150 |/
    LDA #%00001111.b                                                            ; $028152 |\ Set the pose frame mask override to update the pose frame counters
    STA r_battle_pose_frame_mask_override.w                                     ; $028154 |/ every sixteen frames.
    RTS                                                                         ; $028157

; _battle_update_inventory_entry ($02:8158)
;
; Updates the dialog inventory entry with the index passed in $01.
_battle_update_inventory_entry:
    LDX <r_battle_update_arg_slot                                               ; $028158 |\
    STX r_battle_update_dialog_arg_slot.w                                       ; $02815A | | Update the inventory entry passed in the relevant variable.
    JMP _battle_update_dialog_inventory_entry                                   ; $02815D |/

; _battle_update_spell_list_entry ($02:8160)
;
; Updates the spell list entry for the slot passed in $00 with the index passed
; in $01.
_battle_update_spell_list_entry:
    LDX <r_battle_update_arg_slot                                               ; $028160 |\
    STX r_battle_update_dialog_arg_slot.w                                       ; $028162 | | Update the spell list entry for the slot passed in $00.
    JMP _battle_update_dialog_spell_list_entry                                  ; $028165 |/

; _battle_update_hand_inventory_entry ($02:8168)
;
; Updates the hand inventory entry for the slot passed in $00 with the index
; passed in $01.
_battle_update_hand_inventory_entry:
    LDX <r_battle_update_arg_slot                                               ; $028168 |\
    STX r_battle_update_dialog_arg_slot.w                                       ; $02816A | | Updates the hand inventory entry for the slot passed in $00.
    JMP _battle_update_dialog_hand_inventory_entry                              ; $02816D |/

; _battle_update_command_menu_entries ($02:8175)
;
; Updates the command menu entries for the slot passed in $00.
_battle_update_command_menu_entries:
    LDA <r_battle_update_arg_slot                                               ; $028170 |\
    STA r_battle_update_dialog_arg_slot.w                                       ; $028172 | | Update the command menu entries for the slot in $00.
    JMP _battle_update_dialog_command_entries_single_slot                       ; $028175 |/

; _battle_update_change_rows ($02:8178)
;
; Sets the variable to change the rows of the party. The actual animation is
; not done here.
_battle_update_change_rows:
    LDA r_battle_party_formation_two_front.w                                    ; $028178 |\
    EOR #%00000001.b                                                            ; $02817B | | Toggle the value of the variable between 0 and 1.
    STA r_battle_party_formation_two_front.w                                    ; $02817D |/
    RTS                                                                         ; $028180

; _battle_update_animate_battle_start ($02:8181)
;
; Animates the start of the battle.
_battle_update_animate_battle_start:
    JSR _init                                                                   ; $028181 | Do basic initialization.
    JSR _battle_init_graphics                                                   ; $028184 | Do basic graphics initialization for the battle.
    JSR _battle_initialize_dialogs                                              ; $028187 | Initializes the dialog tilemaps.
    JSL bank01.battle_initialize_menu_hdma_data                                 ; $02818A | Initializes menu HDMA data.
    JSR _battle_initialize_graphics                                             ; $02818E | Initializes most of the battle graphics.
    JSR _battle_load_character_sprites                                          ; $028191 | Load the character sprite data to VRAM.
    JSR _battle_set_coordinates                                                 ; $028194 | Set various coordinates.
    JSR _battle_sort_monsters                                                   ; $028197 | Generate the sorted monsters lists.
    JSR _battle_load_palettes                                                   ; $02819A | Load any non-monster palettes.
    LDA r_formation_back_attack_copy.w                                          ; $02819D |\
    BEQ +                                                                       ; $0281A0 | | If the battle is a back attack and the formation is not floating,
    LDA r_formation_flags2_copy_2.w                                             ; $0281A2 | | set the high byte of the BG1 horizontal scroll to $01, to display
    AND #FORMATION_FLAGS_2_FLOATING.b                                           ; $0281A5 | | the right half of BG1.
    BNE +                                                                       ; $0281A7 | |
    LDA #$01.b                                                                  ; $0281A9 | |
    JSR _battle_set_bg1_horizontal_hi_scroll                                    ; $0281AB | |
    BRA ++                                                                      ; $0281AE |/
+   LDA #$FF.b                                                                  ; $0281B0 |\ Otherwise, set the monster scroll value to $FF.
    JSR _battle_set_monster_scroll                                              ; $0281B2 |/
++  JSR _battle_menu_open_main                                                  ; $0281B5 | Open the main battle menu.
    LDA #%11110010.b                                                            ; $0281B8 |\ Set the mosaic such that BG2 is completely mosaiced.
    STA r_battle_ppu_mosaic.w                                                   ; $0281BA |/
    LDA #%00011111.b                                                            ; $0281BD |\ Set all screens as main screen.
    STA reg_ppu_tm.l                                                            ; $0281BF |/
    STA reg_ppu_tmw.l                                                           ; $0281C3 | Enable main screen windowing on all backgrounds.
-   LDA reg_cpu_rdnmi.l                                                         ; $0281C7 |\ Wait for the next NMI.
    BPL -                                                                       ; $0281CB |/
    LDA #141.b                                                                  ; $0281CD |\
    STA reg_cpu_vtimel.l                                                        ; $0281CF | | Set the vertical IRQ timer to to 141.
    TDC                                                                         ; $0281D3 | |
    STA reg_cpu_vtimeh.l                                                        ; $0281D4 |/
    STA reg_cpu_htimel.l                                                        ; $0281D8 |\ Set the horizontal IRQ timer to zero.
    STA reg_cpu_htimeh.l                                                        ; $0281DC |/
    JSL bank03.battle_init_hdma                                                 ; $0281E0 | Enable the battle HDMA channels.
    LDA #%10100001.b                                                            ; $0281E4 |\ Enable NMI, enable the vertical IRQ timer, and enable the standard
    STA reg_cpu_nmitimen.l                                                      ; $0281E6 |/ controller processing.
    CLI                                                                         ; $0281EA | Enable interrupts.
    JSR _battle_wait_for_nmi                                                    ; $0281EB | Wait for the next NMI.
    STZ r_battle_next_ppu_brightness.w                                          ; $0281EE | Initialize the next brightness value to zero.
    TDC                                                                         ; $0281F1 |\
    TAX                                                                         ; $0281F2 | | Set one battle frame counter to zero.
    STX r_battle_frame_counter.w                                                ; $0281F3 |/
    LDA #22.b                                                                   ; $0281F6 |\ Initialize the slide counter to 22.
    STA r_battle_monster_slide_counter.w                                        ; $0281F8 |/
    LDA #32.b                                                                   ; $0281FB |\ Initialize the frame counter to 32.
    STA r_battle_effect_frame_counter.w                                         ; $0281FD |/
    LDA #$10.b                                                                  ; $028200 |\ TODO: Both this and the previous location are used in multiple places,
    STA r_unknown_f134.w                                                        ; $028202 |/       so which use are they initializing?
-   JSR _battle_wait_for_nmi                                                    ; $028205 | Wait for the next NMI.
    LDA r_battle_next_ppu_brightness.w                                          ; $028208 |\ Update the PPU brightness.
    STA r_battle_ppu_brightness.w                                               ; $02820B |/
    CMP #$0F.b                                                                  ; $02820E |\
    BEQ +                                                                       ; $028210 | | If the next brightness isn't already at max, increment it by one.
    INC r_battle_next_ppu_brightness.w                                          ; $028212 |/
+   LDA r_battle_effect_frame_counter.w                                         ; $028215 |\
    BEQ +                                                                       ; $028218 | | If the frame counter is greater than zero, decrement the value,
    LDA r_battle_effect_frame_counter.w                                         ; $02821A | | and then calculate the actual mosaic value by shifting left three
    DEC A                                                                       ; $02821D | | bits, masking out the irrelevant bit, and then enable the mosaic
    STA r_battle_effect_frame_counter.w                                         ; $02821E | | on BG2 only. The resuls is that the mosaic value changes once
    ASL A                                                                       ; $028221 | | every time the counter changes twice.
    ASL A                                                                       ; $028222 | |
    ASL A                                                                       ; $028223 | |
    AND #%11110000.b                                                            ; $028224 | |
    ORA #%00000010.b                                                            ; $028226 | |
    STA r_battle_ppu_mosaic.w                                                   ; $028228 | |
    BRA ++                                                                      ; $02822B |/
+   STZ r_battle_ppu_mosaic.w                                                   ; $02822D | Otherwise, zero out the PPU mosaic value.
++  JSR _execute_battle_dialog_updates                                          ; $028230 | Execute any pending dialog updates.
    LDA r_battle_monster_slide_counter.w                                        ; $028233 |\
    BEQ +                                                                       ; $028236 | | If the slide counter hasn't yet reached zero, decrement it by one
    LDA r_battle_monster_slide_counter.w                                        ; $028238 | | and save it back to memory.
    DEC A                                                                       ; $02823B | |
    STA r_battle_monster_slide_counter.w                                        ; $02823C |/
    PHA                                                                         ; $02823F | Preserve the slide counter.
    TAX                                                                         ; $028240 |\
    LDA bank1C.sine_data.l,X                                                    ; $028241 | | Calculate the new scroll position of the monsters by loading data
    ASL A                                                                       ; $028245 | | from the sine table and multiplying by 4. (The values read range
    ASL A                                                                       ; $028246 | | from $00 to $3F.) Apply the scroll value.
    JSR _battle_set_monster_scroll                                              ; $028247 |/
    PLA                                                                         ; $02824A |\
    BNE +                                                                       ; $02824B | | The first time the scroll value reaches 0, set the high bits of
    TDC                                                                         ; $02824D | | the horizontal scroll values to scroll to the left half of BG1.
    JSR _battle_set_bg1_horizontal_hi_scroll                                    ; $02824E |/
+   LDA r_battle_dialog_update_pending.w                                        ; $028251 |\
    ORA r_battle_menu_update_mode.w                                             ; $028254 | | Loop until all actions are complete.
    ORA r_battle_monster_slide_counter.w                                        ; $028257 | |
    ORA r_battle_effect_frame_counter.w                                         ; $02825A | |
    BNE -                                                                       ; $02825D |/
    INC r_battle_enable_input.w                                                 ; $02825F | Enable battle input.
    RTS                                                                         ; $028262

; _battle_set_monster_scroll ($02:8263)
;
; Sets the scroll value for the monsters on screen by adjusting the first 152
; lines of the BG1 HDMA table. Note that for floating formations, the vertical
; value is modified, and for all others, the horizontal value is modified.
_battle_set_monster_scroll:
    LDX #0.w                                                                    ; $028263 | Initialize the X register to zero.
    PHA                                                                         ; $028266 | Preserve the value of the accumulator.
    LDA r_formation_flags2_copy_2.w                                             ; $028267 |\
    AND #FORMATION_FLAGS_2_FLOATING.b                                           ; $02826A | | If this is a floating formation, skip the next batch of code.
    BNE ++                                                                      ; $02826C |/
    LDA r_formation_back_attack_copy.w                                          ; $02826E |\
    BEQ +                                                                       ; $028271 | | If this is a back attack, restore the accumulator, flip the bits
    PLA                                                                         ; $028273 | | and add one to negate the value.
    EOR #%11111111.b                                                            ; $028274 | |
    INC A                                                                       ; $028276 | |
    BRA @start                                                                  ; $028277 |/
+   PLA                                                                         ; $028279 | Otherwise, simly restore the accumulator.
@start:
    STA r_battle_bg1_hdma_data.1.horizontal_lo.w,X                              ; $02827A | Set the value to the horizontal HDMA scroll data.
    INX                                                                         ; $02827D |\
    INX                                                                         ; $02827E | | Increment the X register by four to move to the next HDMA entry.
    INX                                                                         ; $02827F | |
    INX                                                                         ; $028280 |/
    CPX #_sizeof_scroll_hdma_data_entry.w * 152                                 ; $028281 |\ Loop until 152 lines have been processed.
    BNE @start                                                                  ; $028284 |/
    RTS                                                                         ; $028286 | Return.
++  PLA                                                                         ; $028287 |\
-   STA r_battle_bg1_hdma_data.1.vertical_lo.w,X                                ; $028288 | | If the formation was floating, do the same, except setting the
    INX                                                                         ; $02828B | | vertical value instead.
    INX                                                                         ; $02828C | |
    INX                                                                         ; $02828D | |
    INX                                                                         ; $02828E | |
    CPX #_sizeof_scroll_hdma_data_entry.w * 152.w                               ; $02828F | |
    BNE -                                                                       ; $028292 |/
    RTS                                                                         ; $028294

; _battle_update_next_frame_active ($02:8295)
;
; This battle update method waits for the next frame, and does a bunch of other
; updates that make sense to apply while nothing else is happening. In
; particular, it appears to be central to the main battle loop that executes
; when there are no other visual effects occurring.
_battle_update_next_frame_active:
    JSR _battle_wait_for_nmi                                                    ; $028295 | Wait for the next NMI to execute.
    JSR _execute_battle_dialog_updates                                          ; $028298 | Handle any pending dialog tilemap updates.
    JSR _execute_periodic_battle_dialog_updates                                 ; $02829B | Execute any periodic battle dialog updates.
    JSR _battle_update_cursors_and_empty_inventory_slot                         ; $02829E | Updates cursors and finds the first empty inventory slot.
    JSR _battle_update_info_areas_tilemap_data                                  ; $0282A1 | Update the info area tilemaps, but in a weird order.
    JSL bank03.battle_check_character_disabled_or_monsters_dead                 ; $0282A4 |\ If the active character has a menu-preventing status or if all
    BCC +                                                                       ; $0282A8 |/ monsters are dead, close any open command menu.
    JSR _battle_update_command_menu_close                                       ; $0282AA | Flag that the command menu should be closed.
+   JMP _battle_update_misc                                                     ; $0282AD | Update visual status and slot maps.

; _battle_update_next_frame ($02:82B0)
;
; This miscellaneous battle function waits for the next frame, excutes any
; battle dialog updates and periodic battle DMA updates, and then falls through
; to the next function which updates cursors and finds the first inventory slot.
; It seems like a reasonable choice for a function to call each frame during
; longer processing sequences.
_battle_update_next_frame:
    JSR _battle_wait_for_nmi                                                    ; $0282B0 | Wait for the next NMI.
    JSR _execute_battle_dialog_updates                                          ; $0282B3 | Handle any pending dialog tilemap updates.
    JSR _execute_periodic_battle_dma_updates                                    ; $0282B6 | Execute any periodic battle DMA updates.

; _battle_update_cursors_and_empty_inventory_slot ($02:82B9)
;
; This miscellaneous update function copies character cursor coordinates,
; updates the scroll values for floating monsters, sets the monster cursor
; coordinates, and finds the first empty slot in the inventory.
_battle_update_cursors_and_empty_inventory_slot:
    JSR _battle_copy_character_cursor_coordinates                               ; $0282B9 | Copies character cursor coordinates.
    JSR _battle_update_float_scroll                                             ; $0282BC | Updates the current scroll value for floating monsters.
    JSR _set_monster_cursor_coordinates                                         ; $0282BF | Set the cursor coordinates for the monsters.
    TDC                                                                         ; $0282C2 |\
    TAX                                                                         ; $0282C3 | | Initialize the X and Y registers to zero.
    TAY                                                                         ; $0282C4 |/
-   LDA r_battle_inventory.1.id.w,X                                             ; $0282C5 |\ If this inventory entry is empty, exit the loop.
    BEQ +                                                                       ; $0282C8 |/
    INX                                                                         ; $0282CA |\
    INX                                                                         ; $0282CB | | Increment X four times to move to the next inventory entry and
    INX                                                                         ; $0282CC | | increment Y once. Loop until the entire battle inventory is
    INX                                                                         ; $0282CD | | examined.
    INY                                                                         ; $0282CE | |
    CPX #_sizeof_r_battle_inventory.w                                           ; $0282CF | |
    BNE -                                                                       ; $0282D2 |/
    LDA #$FF.b                                                                  ; $0282D4 |\ If no empty slots were found, explicitly load $FF into the
    BRA ++                                                                      ; $0282D6 |/ accumulator and branch forward.
    RTS                                                                         ; $0282D8 | Useless return instruction that will never be reached.
+   TYA                                                                         ; $0282D9 | Transfer the Y register to the accumulator.
++  STA r_battle_inventory_first_empty.w                                        ; $0282DA | Set the first empty slot variable.
    STA r_battle_swap_inventory_arg_inventory_target.w                          ; $0282DD | Additionally, set the value as an argument for inventory swaps.
    RTS                                                                         ; $0282E0

; _battle_update_float_scroll ($02:82E1)
;
; If the current formation is a floating formation, updates the value of the
; BG1 scroll values depending on the value of the frame counter at $1813. Waits
; until the IRQ handler signals it has completed during this frame.
_battle_update_float_scroll:
    LDA r_formation_flags2_copy_2.w                                             ; $0282E1 |\
    AND #FORMATION_FLAGS_2_FLOATING.b                                           ; $0282E4 | | Skip this function if the formation is not flagged as floating.
    BEQ +                                                                       ; $0282E6 |/
-   LDA r_battle_irq_complete.w                                                 ; $0282E8 |\ Wait until the IRQ for this frame has been completed.
    BEQ -                                                                       ; $0282EB |/
    LDA r_battle_frame_counter.w                                                ; $0282ED |\
    PHA                                                                         ; $0282F0 | | Calculate the index into the floating scroll data by taking the
    LSR A                                                                       ; $0282F1 | | frame counter, shifting right twice, and then taking it mod 16.
    LSR A                                                                       ; $0282F2 | | The result is 16 different values, changing every four frames.
    AND #%00001111.b                                                            ; $0282F3 | |
    TAX                                                                         ; $0282F5 |/
    LDA bank0D.battle_floating_monster_scroll_data.l,X                          ; $0282F6 |\ Load the value and set the BG1 vertical scroll data.
    JSR _battle_set_bg1_vertical_scroll                                         ; $0282FA |/
    PLA                                                                         ; $0282FD |\ Save the current value of the frame counter to memory.
    STA r_battle_last_float_scroll_update_frame.w                               ; $0282FE |/
+   RTS                                                                         ; $028301

; _battle_set_bg1_vertical_scroll ($02:8302)
;
; Given a value in the accumulator, writes the value to the entire HDMA data
; array in the low byte of the vertical scroll value. Therefore, unless the
; processor is in 16-bit mode, it is impossible to write negative values.
_battle_set_bg1_vertical_scroll:
    LDX #0.w                                                                    ; $028302 | Initialize the X register to zero.
-   STA r_battle_bg1_hdma_data.1.vertical_lo.w,X                                ; $028305 |\
    STA r_battle_bg1_hdma_data.36.vertical_lo.w,X                               ; $028308 | | Write the value to the low byte of the vertical scroll value in
    STA r_battle_bg1_hdma_data.71.vertical_lo.w,X                               ; $02830B | | four places.
    STA r_battle_bg1_hdma_data.106.vertical_lo.w,X                              ; $02830E |/
    INX                                                                         ; $028311 |\
    INX                                                                         ; $028312 | | Increment the X register by four to move to the next entry.
    INX                                                                         ; $028313 | |
    INX                                                                         ; $028314 |/
    CPX #(35 * _sizeof_scroll_hdma_data_entry).w                                ; $028315 |\ Loop until all four sets of 35 lines have been written.
    BNE -                                                                       ; $028318 |/
    RTS                                                                         ; $02831A

; _update_floating_monster_shadows ($02:831B)
;
; Based on a frame counter at $ED4F, updates the shadow tiles in VRAM used for
; the shadow of floating monsters. This function only executes if the floating
; bit is set in the copy of the second set of formation flags at $ED4E.
_update_floating_monster_shadows:
    LDA r_formation_flags2_copy_2.w                                             ; $02831B |\
    AND #FORMATION_FLAGS_2_FLOATING.b                                           ; $02831E | | Only execute this function if the formation is floating.
    BEQ +                                                                       ; $028320 |/
    LDA r_battle_last_float_scroll_update_frame.w                               ; $028322 |\
    LSR A                                                                       ; $028325 | | Determine the current shadow to use based on the value of the
    LSR A                                                                       ; $028326 | | frame counter when the float scroll was last updated. The value is
    AND #%00001111.b                                                            ; $028327 | | divided by four and taken mod 16, so it would produce 16 values,
    TAX                                                                         ; $028329 | | changing every four frames.
    LDA bank0D.battle_monster_shadow_offset_data.l,X                            ; $02832A |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $02832E |\
    CLC                                                                         ; $028330 | | Transfer the selected shadow tiles to the location in VRAM where
    ADC #r_battle_shadow_tiles.w                                                ; $028331 | | the shadow is.
    TAX                                                                         ; $028334 | |
    LDA #$0040.w                                                                ; $028335 | |
    STA <r_battle_start_vram_dma4_arg_bytes                                     ; $028338 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $02833A | |
    LDA #:r_battle_shadow_tiles.b                                               ; $02833C | |
    LDY #$4510.w                                                                ; $02833E | |
    JSR _start_vram_dma4                                                        ; $028341 |/
+   RTS                                                                         ; $028344

; nmi_handler ($02:8345)
;
; Handles any NMI during battle.
nmi_handler:
    PHP                                                                         ; $028345 |\
    REP #FLAG_P_ACCUMULATOR | FLAG_P_INDEX                                      ; $028346 | | Preserve the contents of the various registers.
    PHA                                                                         ; $028348 | |
    PHX                                                                         ; $028349 | |
    PHY                                                                         ; $02834A | |
    PHB                                                                         ; $02834B | |
    PHD                                                                         ; $02834C |/
    LDX #$0000.w                                                                ; $02834D |\
    PHX                                                                         ; $028350 | | Set the direct register to $0000.
    PLD                                                                         ; $028351 |/
    TDC                                                                         ; $028352 |\ Return to 8-bit accumulator mode.
    SEP #FLAG_P_ACCUMULATOR                                                     ; $028353 |/
    LDA reg_cpu_rdnmi.l                                                         ; $028355 | Reset the NMI flag register.
    LDA #$7E.b                                                                  ; $028359 |\
    PHA                                                                         ; $02835B | | Set the data bank register to $7E.
    PLB                                                                         ; $02835C |/
    LDA r_battle_nmi_lock.w                                                     ; $02835D |\
    BEQ +                                                                       ; $028360 | | Skip most of the handler if the lock is currently set.
    JMP ++                                                                      ; $028362 |/
+   STZ r_battle_nmi_handler_tmp_unpaused.w                                     ; $028365 | Initialize the unpaused state to zero.
    INC r_battle_nmi_lock.w                                                     ; $028368 | Set the NMI lock.
    STZ r_battle_irq_complete.w                                                 ; $02836B | Reset the IRQ completion flag.
    JSL bank03.battle_copy_oam_to_ppu.l                                         ; $02836E | Transfer the current OAM values to the actual OAM.
    JSL bank03.battle_copy_cgram_to_ppu.l                                       ; $028372 | Transfer the current CG-RAM data to CG-RAM
    JSR _update_floating_monster_shadows                                        ; $028376 | Update the floating monster shadows.
    JSR _execute_battle_dma                                                     ; $028379 | Execute any configured battle DMA operations.
    JSR _battle_execute_pending_dialog_dma                                      ; $02837C | Execute any configured battle dialog DMA operations.
    LDA r_battle_ppu_brightness.w                                               ; $02837F |\ Set the PPU brightness.
    STA reg_ppu_inidisp.l                                                       ; $028382 |/
    LDA r_battle_ppu_mosaic.w                                                   ; $028386 |\ Set the PPU mosaic effect.
    STA reg_ppu_mosaic.l                                                        ; $028389 |/
    JSL bank03.battle_update_color_math                                         ; $02838D | Update the battle color math settings.
    JSR _battle_menu_update                                                     ; $028391 | Do any menu opening, closing or scrolling.
    JSL bank03.battle_update_joypad                                             ; $028394 | Update the battle joypad values.
    JSL bank03.battle_check_pause                                               ; $028398 | Handle pausing and unpausing.
    BCS +                                                                       ; $02839C | If the game is currently paused, skip the next two instructions.
    INC r_battle_nmi_handler_tmp_unpaused.w                                     ; $02839E | Set a flag to indicate the game is not paused.
    JSR _battle_menu_dispatch                                                   ; $0283A1 | Handle the battle menus.
+   JSR _draw_battle_menu_cursors                                               ; $0283A4 | Draw the battle menu cursors.
    JSR _draw_battle_target_cursors                                             ; $0283A7 | Draw the targeting cursors.
    JSR _draw_battle_arrows                                                     ; $0283AA | Draw the up/down arrows used on item/magic selection menus.
    JSR _set_target_cursor_coordinates                                          ; $0283AD | Update the coordinates of the four targeting cursors.
    JSR _battle_draw_character_sprites                                          ; $0283B0 | Draw the character sprites.
    JSR _battle_copy_effect_sprites_to_oam                                      ; $0283B3 | Draw configured effect sprites to the OAM mirror.
    JSR _battle_copy_weapon_sprite_to_oam                                       ; $0283B6 | Draw configured weapon sprite to the OAM mirror.
    JSR _battle_effect_spell_draw                                               ; $0283B9 | Draw any configure spell effects to the OAM mirror.
    JSR _battle_effect_target_palette_cycling_cycle                             ; $0283BC | Perform any configured target palette cycling.
    JSR _battle_animate_damage                                                  ; $0283BF | Animate the damage effect.
    JSL bank01.battle_finalize_nmi                                              ; $0283C2 | Do several miscellaneous battle updates to finish the NMI.
++  LDA r_battle_nmi_handler_tmp_unpaused.l                                     ; $0283C6 |\
    BEQ +                                                                       ; $0283CA | | If the battle isn't paused, increment the game time.
    LDA r_battle_paused.w                                                       ; $0283CC | |
    BNE +                                                                       ; $0283CF | |
    JSL bank03.battle_increment_game_time                                       ; $0283D1 |/
+   REP #FLAG_P_ACCUMULATOR | FLAG_P_INDEX                                      ; $0283D5 | Switch to 16-bit mode for register restoration.
    INC r_battle_frame_counter.w                                                ; $0283D7 | Increment the battle frame counter.
    PLD                                                                         ; $0283DA |\
    PLB                                                                         ; $0283DB | | Restore the saved registers.
    PLY                                                                         ; $0283DC | |
    PLX                                                                         ; $0283DD | |
    PLA                                                                         ; $0283DE | |
    PLP                                                                         ; $0283DF |/
    RTI                                                                         ; $0283E0

; _clear_vram ($02:83E1)
;
; Fills VRAM with zeroes at the address provided in the X register up to the
; number of bytes provided in the Y register.
_clear_vram:
    PHB                                                                         ; $0283E1 |\
    TDC                                                                         ; $0283E2 | | Set the data bank register to $00.
    PHA                                                                         ; $0283E3 | |
    PLB                                                                         ; $0283E4 |/
    STX reg_ppu_vmadd                                                           ; $0283E5 | Set the VRAM write address to the value in the X register.
    LDX #fixed_dma_zero_data.w                                                  ; $0283E8 |\ Set the source address to $8407.
    STX reg_cpu_a1t5                                                            ; $0283EB |/
    LDA #%00001001.b                                                            ; $0283EE |\ Set the DMA to write 2 addresses from a fixed source.
    STA reg_cpu_dmap5                                                           ; $0283F0 |/
    LDA #<reg_ppu_vmdatal_write.b                                               ; $0283F3 |\ Set the DMA to write to VRAM.
    STA reg_cpu_bbad5                                                           ; $0283F5 |/
    LDA #:fixed_dma_zero_data.b                                                 ; $0283F8 |\ Set the source bank to $02.
    STA reg_cpu_a1b5                                                            ; $0283FA |/
    STY reg_cpu_das5                                                            ; $0283FD | Set the number of bytes to the value in the Y register.
    LDA #%00100000.b                                                            ; $028400 |\ Enable the DMA on channel 5.
    STA reg_cpu_mdmaen                                                          ; $028402 |/
    PLB                                                                         ; $028405 | Restore the data bank register.
    RTS                                                                         ; $028406

; fixed_dma_zero_data ($02:8407)
;
; Provides two zero values that can be transferred to VRAM using DMA using a
; fixed address transfer.
fixed_dma_zero_data:
    .dw $0000                                                                   ; $028407.8408

; _battle_copy_call_sprite_to_vram ($02:8409)
;
; Given a 16-bit source address in the X register and a source bank in the
; accumulator, copies a Call sprite from $DBE6 to VRAM starting at $0000. The
; source address and bank should point to a data structure consisting of a
; series of bytes. An $FF byte signifies the end of the sequence. Any other
; byte with the high bit set will cause a tile (presumably blank) to be copied
; from $F376 to the tile number referenced by the lower seven bits. Any other
; byte will cause the next tile to be copied in order from $DBE6 to the tile
; number referenced by the byte.
_battle_copy_call_sprite_to_vram:
    PHA                                                                         ; $028409 |\
    PHX                                                                         ; $02840A | | Preserve the accumulator and X and Y registers.
    PHY                                                                         ; $02840B |/
    STX r_battle_copy_call_sprite_to_vram_tmp_ptr_addr.w                        ; $02840C |\ Save the 24-bit source address to a temporary variable.
    STA r_battle_copy_call_sprite_to_vram_tmp_ptr_bank.w                        ; $02840F |/
    STZ r_battle_copy_call_sprite_to_vram_tmp_index.w                           ; $028412 |\ Initialize index and source index to zero.
    STZ r_battle_copy_call_sprite_to_vram_tmp_source_index.w                    ; $028415 |/
-   LDA r_battle_dma_1_pending.w                                                ; $028418 |\
    ORA r_battle_dma_2_pending.w                                                ; $02841B | | Wait frames until there are no pending battle DMA transfers.
    BEQ @outer_start                                                            ; $02841E | |
    JSR _battle_wait_next_frame_preserve_x_y                                    ; $028420 | |
    JMP -                                                                       ; $028423 |/
@outer_start:
    LDX r_battle_copy_call_sprite_to_vram_tmp_ptr_addr.w                        ; $028426 |\
    STX <r_battle_generic_tmp_ptr_2_addr                                        ; $028429 | | Transfer the pointer to a new local variable.
    LDA r_battle_copy_call_sprite_to_vram_tmp_ptr_bank.w                        ; $02842B | |
    STA <r_battle_generic_tmp_ptr_2_bank                                        ; $02842E |/
    STZ <r_battle_copy_call_sprite_to_vram_tmp_dma_index                        ; $028430 | Initialize the DMA index to zero.
    STZ <r_battle_copy_call_sprite_to_vram_tmp_vram_index_hi                    ; $028432 | Zero out the high byte of the VRAM index.
@inner_start:
    LDA r_battle_copy_call_sprite_to_vram_tmp_index.w                           ; $028434 |\ Transfer the current index into the Y register.
    TAY                                                                         ; $028437 |/
    LDA [<r_battle_generic_tmp_ptr_2],Y                                         ; $028438 | Read the next byte from the data.
    BMI +                                                                       ; $02843A | If the high bit is set, branch to a different set of code.
    STA <r_battle_copy_call_sprite_to_vram_tmp_vram_index_lo                    ; $02843C | Save the value as the VRAM index.
    LDA <r_battle_copy_call_sprite_to_vram_tmp_dma_index                        ; $02843E |\
    ASL A                                                                       ; $028440 | | Set the Y register to the DMA index times four (as each DMA record
    ASL A                                                                       ; $028441 | | has four bytes).
    TAY                                                                         ; $028442 |/
    LDA r_battle_copy_call_sprite_to_vram_tmp_source_index.w                    ; $028443 |\
    REP #FLAG_P_ACCUMULATOR                                                     ; $028446 | | Set the source address to the base address plus the current source
    ASL A                                                                       ; $028448 | | index times 32 (an 8x8 tile).
    ASL A                                                                       ; $028449 | |
    ASL A                                                                       ; $02844A | |
    ASL A                                                                       ; $02844B | |
    ASL A                                                                       ; $02844C | |
    CLC                                                                         ; $02844D | |
    ADC #r_battle_load_sprite_data.w                                            ; $02844E | |
    STA r_battle_fixed_dma_1_source_address.w,Y                                 ; $028451 |/
    LDA <r_battle_copy_call_sprite_to_vram_tmp_vram_index                       ; $028454 |\
    ASL A                                                                       ; $028456 | | Set the target VRAM address to the base VRAM address ($0000) plus
    ASL A                                                                       ; $028457 | | the VRAM index times 16 (also an 8x8 tile).
    ASL A                                                                       ; $028458 | |
    ASL A                                                                       ; $028459 | |
    STA r_battle_fixed_dma_1_target_vram_address.w,Y                            ; $02845A | |
    TDC                                                                         ; $02845D | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $02845E |/
    LDA <r_battle_copy_call_sprite_to_vram_tmp_dma_index                        ; $028460 |\
    TAX                                                                         ; $028462 | | Flag the current DMA as pending.
    INC r_battle_fixed_dma_1_pending.w,X                                        ; $028463 |/
    INC r_battle_copy_call_sprite_to_vram_tmp_index.w                           ; $028466 | Increment the index to move to next byte.
    INC r_battle_copy_call_sprite_to_vram_tmp_source_index.w                    ; $028469 | Increment the source index to move to the next source tile.
    JMP @next                                                                   ; $02846C | Branch to the next iteration of the loop.
+   CMP #$FF.b                                                                  ; $02846F |\ If the value is $FF, there is no more data, so branch to the end.
    BEQ @done                                                                   ; $028471 |/
    AND #%01111111.b                                                            ; $028473 |\ Extract only the low seven bits and save that as the VRAM index.
    STA <r_battle_copy_call_sprite_to_vram_tmp_vram_index                       ; $028475 |/
    LDA <r_battle_copy_call_sprite_to_vram_tmp_dma_index                        ; $028477 |\
    ASL A                                                                       ; $028479 | | Set the Y register to the DMA index times four.
    ASL A                                                                       ; $02847A | |
    TAY                                                                         ; $02847B |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $02847C |\
    LDA #r_battle_copy_call_sprite_to_vram_tmp_blank_source.w                   ; $02847E | | Set the source address to the blank source location.
    STA r_battle_fixed_dma_1_source_address.w,Y                                 ; $028481 |/
    LDA <r_battle_copy_call_sprite_to_vram_tmp_vram_index                       ; $028484 |\
    ASL A                                                                       ; $028486 | | Set the target VRAM address to the base VRAM address plus the
    ASL A                                                                       ; $028487 | | VRAM index times four.
    ASL A                                                                       ; $028488 | |
    ASL A                                                                       ; $028489 | |
    STA r_battle_fixed_dma_1_target_vram_address.w,Y                            ; $02848A | |
    TDC                                                                         ; $02848D | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $02848E |/
    LDA <r_battle_copy_call_sprite_to_vram_tmp_dma_index                        ; $028490 |\
    TAX                                                                         ; $028492 | | Flag the DMA as pending.
    INC r_battle_fixed_dma_1_pending.w,X                                        ; $028493 |/
    INC r_battle_copy_call_sprite_to_vram_tmp_index.w                           ; $028496 | Increment the index to move to the next byte.
@next:
    INC <r_battle_copy_call_sprite_to_vram_tmp_dma_index                        ; $028499 | Increment the DMA index to move to the next DMA channel.
    LDA <r_battle_copy_call_sprite_to_vram_tmp_dma_index                        ; $02849B |\
    CMP #4.b                                                                    ; $02849D | | Loop until all four DMA channels have been set.
    BNE @inner_start                                                            ; $02849F |/
    JSR _battle_wait_next_frame_preserve_x_y                                    ; $0284A1 |\ Once all four have been set, wait a frame and loop back to the
    JMP @outer_start                                                            ; $0284A4 |/ start.
@done:
    JSR _battle_wait_next_frame_preserve_x_y                                    ; $0284A7 | Wait a frame to ensure all transfers have been completed.
    PLY                                                                         ; $0284AA |\
    PLX                                                                         ; $0284AB | | Restore the accumulator and X and Y registers.
    PLA                                                                         ; $0284AC |/
    RTS                                                                         ; $0284AD

; battle_copy_to_vram ($02:84AE)
;
; Proxy function to call _battle_copy_to_vram from another bank.
battle_copy_to_vram:
    JSR _battle_copy_to_vram                                                    ; $0284AE | Call the function.
    RTL                                                                         ; $0284B1

; _battle_copy_to_vram ($02:84B2)
;
; Given a source bank in the accumulator, a source address in the X register, a
; target VRAM address in the Y register, and a number of bytes to transfer in
; $00, copies the specified data to VRAM. Note that data is transferred in
; blocks of 128 bytes each frame, and is primarily suited to transferring
; tilemap data.
_battle_copy_to_vram:
    PHA                                                                         ; $0284B2 |\
    PHX                                                                         ; $0284B3 | | Preserve the contents of the parameters in memory and in registers.
    PHY                                                                         ; $0284B4 | |
    LDX <r_battle_copy_to_vram_arg_bytes                                        ; $0284B5 | |
    PHX                                                                         ; $0284B7 |/
-   LDA r_battle_dma_1_pending.w                                                ; $0284B8 |\
    ORA r_battle_dma_2_pending.w                                                ; $0284BB | | Wait frames until there are no pending battle DMA transfers.
    BEQ +                                                                       ; $0284BE | |
    JSR _battle_wait_next_frame_preserve_x_y                                    ; $0284C0 | |
    BRA -                                                                       ; $0284C3 |/
+   PLX                                                                         ; $0284C5 |\
    STX <r_battle_copy_to_vram_arg_bytes                                        ; $0284C6 | | Restore the preserved parameter and registers.
    PLY                                                                         ; $0284C8 | |
    PLX                                                                         ; $0284C9 | |
    PLA                                                                         ; $0284CA |/
    STA r_battle_dma_1_source_bank.w                                            ; $0284CB |\
    STX r_battle_dma_1_source_address.w                                         ; $0284CE | | Set the bank, source address and target VRAM address.
    STY r_battle_dma_1_target_vram_address.w                                    ; $0284D1 |/
    LDX #(64 * 2).w                                                             ; $0284D4 |\ Set to transfer 128 bytes (two lines).
    STX r_battle_dma_1_bytes.w                                                  ; $0284D7 |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $0284DA |\
    LDA <r_battle_copy_to_vram_arg_bytes                                        ; $0284DC | | Calculate the number of operations to do. Each operation transfers
    ASL A                                                                       ; $0284DE | | 128 bytes. Shift the number of bytes left once and then take the
    AND #$FF00.w                                                                ; $0284DF | | high byte (or shift right eight times, for a total of seven right
    STA <r_battle_copy_to_vram_arg_bytes                                        ; $0284E2 | | shifts, or dividing by 128).
    TDC                                                                         ; $0284E4 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $0284E5 | |
    LDA <r_battle_copy_to_vram_arg_bytes_hi                                     ; $0284E7 | |
    STA r_battle_dma_1_tmp_index.w                                              ; $0284E9 |/
-   INC r_battle_dma_1_pending.w                                                ; $0284EC | Let the handler know a DMA is ready to take place.
    JSR _battle_wait_next_frame_preserve_x_y                                    ; $0284EF | Wait a frame.
    DEC r_battle_dma_1_tmp_index.w                                              ; $0284F2 | Decrement the counter.
    BEQ +                                                                       ; $0284F5 | If it has reached zero, branch to the end.
    REP #FLAG_P_ACCUMULATOR                                                     ; $0284F7 |\
    LDA r_battle_dma_1_source_address.w                                         ; $0284F9 | | Add 128 (two lines) to the source address.
    CLC                                                                         ; $0284FC | |
    ADC #128.w                                                                  ; $0284FD | |
    STA r_battle_dma_1_source_address.w                                         ; $028500 |/
    LDA r_battle_dma_1_target_vram_address.w                                    ; $028503 |\
    CLC                                                                         ; $028506 | | Add 64 (two lines) to the target VRAM address.
    ADC #(128 / 2).w                                                            ; $028507 | |
    STA r_battle_dma_1_target_vram_address.w                                    ; $02850A |/
    TDC                                                                         ; $02850D |\
    SEP #FLAG_P_ACCUMULATOR                                                     ; $02850E | | Go to the next loop.
    BRA -                                                                       ; $028510 |/
+   RTS                                                                         ; $028512

; _battle_wait_next_frame_preserve_x_y ($02:8513)
;
; Waits for the next frame, while handling any necessary processing. Preserves
; the X and Y registers.
_battle_wait_next_frame_preserve_x_y:
    PHY                                                                         ; $028513 |\ Preserve the X and Y registers.
    PHX                                                                         ; $028514 |/
    LDA #BATTLE_UPDATE_MODE_NEXT_FRAME                                          ; $028515 |\ Wait for the next frame and handle any needed processing.
    JSL battle_update                                                           ; $028517 |/
    PLX                                                                         ; $02851B |\ Restore the X and Y registers.
    PLY                                                                         ; $02851C |/
    RTS                                                                         ; $02851D

; _battle_wait_for_nmi ($02:851E)
;
; Waits until the next battle NMI completes.
_battle_wait_for_nmi:
    INC r_battle_nmi_status.w                                                   ; $02851E | Set the NMI status flag.
-   LDA r_battle_nmi_status.w                                                   ; $028521 |\ Loop until the NMI handler resets the flag.
    BNE -                                                                       ; $028524 |/
    RTS                                                                         ; $028526

; unused_math_divide_16bit ($02:8527)
;
; Unused proxy function to call _math_divide_16bit.
unused_math_divide_16bit:
    JSR _math_divide_16bit                                                      ; $028527
    RTL                                                                         ; $02852A

; _math_divide_16bit ($02:852B)
;
; Given two 16-bit numbers in $26 and $28, divides the first by the second and
; returns the 16-bit quotient in $2A and the 16-bit remainder in $2B.
_math_divide_16bit:
    PHX                                                                         ; $02852B |\
    REP #FLAG_P_ACCUMULATOR                                                     ; $02852C | | Preserve the X register and the accumulator.
    PHA                                                                         ; $02852E |/
    STZ <r_math_divide_16bit_result                                             ; $02852F |\ Initialize the results to zero.
    STZ <r_math_divide_16bit_remainder                                          ; $028531 |/
    LDA <r_math_divide_16bit_arg_1                                              ; $028533 |\
    BEQ ++                                                                      ; $028535 | | If either argument is zero, jump to the end (which will simply
    LDA <r_math_divide_16bit_arg_2                                              ; $028537 | | return zero).
    BEQ ++                                                                      ; $028539 |/
    LDX #16.w                                                                   ; $02853B |\
-   ROL <r_math_divide_16bit_arg_1                                              ; $02853E | | Loop through the sixteen bits of the first argument, repeatedly
    ROL <r_math_divide_16bit_remainder                                          ; $028540 | | attempting to subtract the second argument. This essentially
    SEC                                                                         ; $028542 | | performs binary long division in the same way you would do it on
    LDA <r_math_divide_16bit_remainder                                          ; $028543 | | paper.
    SBC <r_math_divide_16bit_arg_2                                              ; $028545 | |
    STA <r_math_divide_16bit_remainder                                          ; $028547 | |
    BCS +                                                                       ; $028549 | |
    LDA <r_math_divide_16bit_remainder                                          ; $02854B | |
    ADC <r_math_divide_16bit_arg_2                                              ; $02854D | |
    STA <r_math_divide_16bit_remainder                                          ; $02854F | |
    CLC                                                                         ; $028551 | |
+   ROL <r_math_divide_16bit_result                                             ; $028552 | |
    DEX                                                                         ; $028554 | |
    BNE -                                                                       ; $028555 |/
++  PLA                                                                         ; $028557 |\
    SEP #FLAG_P_ACCUMULATOR                                                     ; $028558 | | Restore the X register and accumulator.
    PLX                                                                         ; $02855A |/
    RTS                                                                         ; $02855B

; math_multiply_8bit ($02:855C)
;
; Multiplies the 8-bit value in $26 by the 8-bit value in $28. The 16-bit result
; is returned in $2A.
math_multiply_8bit:
    JSR _math_multiply_8bit                                                     ; $02855C | Call the bank-local function.
    RTL                                                                         ; $02855F

; _math_multiply_8bit ($02:8560)
;
; This function multiplies the 8-bit value in $26 by the 8-bit value in $28. The
; 16-bit result is returned in $2A.
_math_multiply_8bit:
    PHX                                                                         ; $028560 | Save the previous value of X.
    LDX #$0008.w                                                                ; $028561 | Initialize X to loop 8 times.
    STZ r_math_multiply_8bit_result_lo                                          ; $028564 |\ Initialize result to zero.
    STZ r_math_multiply_8bit_result_hi                                          ; $028566 |/
-   ROR r_math_multiply_8bit_arg_2                                              ; $028568 |\
    BCC +                                                                       ; $02856A | | Perform binary multiplication the same way
    LDA r_math_multiply_8bit_arg_1                                              ; $02856C | | you might do it on paper.
    CLC                                                                         ; $02856E | |
    ADC r_math_multiply_8bit_result_hi                                          ; $02856F | |
    STA r_math_multiply_8bit_result_hi                                          ; $028571 | |
+   ROR r_math_multiply_8bit_result_hi                                          ; $028573 | |
    ROR r_math_multiply_8bit_result_lo                                          ; $028575 |/
    DEX                                                                         ; $028577 |\ Repeat the loop.
    BNE -                                                                       ; $028578 |/
    PLX                                                                         ; $02857A | Restore the original value of X.
    RTS                                                                         ; $02857B

; _math_multiply_16bit ($02:857C)
;
; Given two 16-bit operands in $0026 and $0028, returns the 32-bit result in
; $002A.
_math_multiply_16bit:
    PHX                                                                         ; $02857C |\
    REP #FLAG_P_ACCUMULATOR                                                     ; $02857D | | Initialize variables.
    PHA                                                                         ; $02857F | |
    TDC                                                                         ; $028580 | |
    STA <r_math_multiply_16bit_tmp                                              ; $028581 | |
    STA <r_math_multiply_16bit_result_lo                                        ; $028583 | |
    STA <r_math_multiply_16bit_result_hi                                        ; $028585 |/
    LDX #16.w                                                                   ; $028587 |\
-   LSR <r_math_multiply_16bit_arg_1                                            ; $02858A | | Loop through, performing long multiplication.
    BCC +                                                                       ; $02858C | |
    CLC                                                                         ; $02858E | |
    LDA <r_math_multiply_16bit_result_lo                                        ; $02858F | |
    ADC <r_math_multiply_16bit_arg_2                                            ; $028591 | |
    STA <r_math_multiply_16bit_result_lo                                        ; $028593 | |
    LDA <r_math_multiply_16bit_result_hi                                        ; $028595 | |
    ADC <r_math_multiply_16bit_tmp                                              ; $028597 | |
    STA <r_math_multiply_16bit_result_hi                                        ; $028599 | |
+   ASL <r_math_multiply_16bit_arg_2                                            ; $02859B | |
    ROL <r_math_multiply_16bit_tmp                                              ; $02859D | |
    DEX                                                                         ; $02859F | |
    BNE -                                                                       ; $0285A0 |/
    PLA                                                                         ; $0285A2 |\
    SEP #FLAG_P_ACCUMULATOR                                                     ; $0285A3 | | Restore saved registers.
    PLX                                                                         ; $0285A5 |/
    RTS                                                                         ; $0285A6

; _unused_math_multiply_16bit_2 ($02:85A7)
;
; Given two 16-bit operands in $1C and $1E, returns the 32-bit result in $20.
; This is a completely useless duplication of the previous routine, and appears
; to be unused.
_unused_math_multiply_16bit_2:
    PHX                                                                         ; $0285A7 |\
    REP #FLAG_P_ACCUMULATOR                                                     ; $0285A8 | | Initialize variables.
    PHA                                                                         ; $0285AA | |
    TDC                                                                         ; $0285AB | |
    STA <r_bank02_math_multiply_16bit_2_tmp                                     ; $0285AC | |
    STA <r_bank02_math_multiply_16bit_2_result.lo                               ; $0285AE | |
    STA <r_bank02_math_multiply_16bit_2_result.hi                               ; $0285B0 |/
    LDX #16.w                                                                   ; $0285B2 |\
-   LSR <r_bank02_math_multiply_16bit_2_arg_1                                   ; $0285B5 | | Loop through, performing long multiplication.
    BCC +                                                                       ; $0285B7 | |
    CLC                                                                         ; $0285B9 | |
    LDA <r_bank02_math_multiply_16bit_2_result.lo                               ; $0285BA | |
    ADC <r_bank02_math_multiply_16bit_2_arg_2                                   ; $0285BC | |
    STA <r_bank02_math_multiply_16bit_2_result.lo                               ; $0285BE | |
    LDA <r_bank02_math_multiply_16bit_2_result.hi                               ; $0285C0 | |
    ADC <r_bank02_math_multiply_16bit_2_tmp                                     ; $0285C2 | |
    STA <r_bank02_math_multiply_16bit_2_result.hi                               ; $0285C4 | |
+   ASL <r_bank02_math_multiply_16bit_2_arg_2                                   ; $0285C6 | |
    ROL <r_bank02_math_multiply_16bit_2_tmp                                     ; $0285C8 | |
    DEX                                                                         ; $0285CA | |
    BNE -                                                                       ; $0285CB |/
    PLA                                                                         ; $0285CD |\
    SEP #FLAG_P_ACCUMULATOR                                                     ; $0285CE | | Restore saved registers.
    PLX                                                                         ; $0285D0 |/
    RTS                                                                         ; $0285D1

; _math_multiply_8bit_reg ($02:85D2)
;
; Multiplies the 8-bit value in $1C by the 8-bit value in $1E. The 16-bit result
; is returned in $20. This function is named after the fact that it uses the
; multiplication registers to do the multiplication.
_math_multiply_8bit_reg:
    PHX                                                                         ; $0285D2 | Preserve the value of the X register.
    LDA <r_math_multiply_8bit_reg_arg_1                                         ; $0285D3 |\
    STA reg_cpu_wrmpya.l                                                        ; $0285D5 | | Set the two arguments into the multiplication registers.
    LDA <r_math_multiply_8bit_reg_arg_2                                         ; $0285D9 | |
    STA reg_cpu_wrmpyb.l                                                        ; $0285DB |/
    PHB                                                                         ; $0285DF |\
    TDC                                                                         ; $0285E0 | | Wait eight cycles by changing the data bank register to $00.
    PHA                                                                         ; $0285E1 | |
    PLB                                                                         ; $0285E2 |/
    LDX reg_cpu_rdmpy.w                                                         ; $0285E3 |\ Save the calculated result.
    STX <r_math_multiply_8bit_reg_result                                        ; $0285E6 |/
    PLB                                                                         ; $0285E8 | Restore the data bank register.
    PLX                                                                         ; $0285E9 | Restore the X register.
    RTS                                                                         ; $0285EA

; _math_divide_16bit_reg ($02:85EB)
;
; Divides the 16-bit value in $1C by the 8-bit value in $1E. The 16-bit result
; is returned in $20. The 16-bit remainder is returned in $22. This function is
; named after the fact that it uses the division registers to do the division.
_math_divide_16bit_reg:
    PHX                                                                         ; $0285EB |\
    PHB                                                                         ; $0285EC | | Preserve the X register and the data bank register, before setting
    TDC                                                                         ; $0285ED | | the data bank register to zero.
    PHA                                                                         ; $0285EE | |
    PLB                                                                         ; $0285EF |/
    STZ <r_math_divide_16bit_reg_unused                                         ; $0285F0 |\
    LDX <r_math_divide_16bit_reg_arg_1                                          ; $0285F2 | | Transfer the arguments into the division registers.
    STX reg_cpu_wrdiv.w                                                         ; $0285F4 | |
    LDA <r_math_divide_16bit_reg_arg_2                                          ; $0285F7 | |
    STA reg_cpu_wrdivb.w                                                        ; $0285F9 |/
    LDX #4.w                                                                    ; $0285FC |\
-   DEX                                                                         ; $0285FF | | Loop to waste sixteen cycles.
    BNE -                                                                       ; $028600 |/
    LDX reg_cpu_rddiv.w                                                         ; $028602 |\
    STX <r_math_divide_16bit_reg_result                                         ; $028605 | | Transfer the quotient and remainder into the appropriate return
    LDX reg_cpu_rdmpy.w                                                         ; $028607 | | variables.
    STX <r_math_divide_16bit_reg_remainder                                      ; $02860A |/
    PLB                                                                         ; $02860C |\ Restore the data bank register and X register.
    PLX                                                                         ; $02860D |/
    RTS                                                                         ; $02860E

; _battle_copy_3bpp_to_vram ($02:860F)
;
; Copies 3 bits per pixel data from memory to VRAM, expanding it to 4 bits per
; pixel in the process. The source bank is passed in the accumulator. The source
; address is passed in the X register. The target VRAM address is passed in the
; Y register. Finally, the number of tiles to copy (where each tile is 24 bytes)
; is passed in $00.
_battle_copy_3bpp_to_vram:
    PHB                                                                         ; $02860F |\
    PHA                                                                         ; $028610 | | Set the data bank register to the value in the accumulator.
    PLB                                                                         ; $028611 |/
    STY reg_ppu_vmadd.w                                                         ; $028612 | Set the target VRAM address to the value in the Y register.
    STX <r_battle_copy_3bpp_to_vram_offset                                      ; $028615 | Set the indirect pointer to the value in the X register.
    LDY #$0000.w                                                                ; $028617 | Initialize Y to zero.
--  REP #FLAG_P_ACCUMULATOR                                                     ; $02861A |\ Switch to 16-bit mode and preserve the value of the accumulator.
    PHA                                                                         ; $02861C |/
    LDX #$0008.w                                                                ; $02861D |\
-   LDA (<r_battle_copy_3bpp_to_vram_offset),Y                                  ; $028620 | | Copy the first sixteen bytes of data directly to the target
    STA reg_ppu_vmdatal_write.w                                                 ; $028622 | | location in VRAM.
    INY                                                                         ; $028625 | |
    INY                                                                         ; $028626 | |
    DEX                                                                         ; $028627 | |
    BNE -                                                                       ; $028628 |/
    LDX #$0008.w                                                                ; $02862A | Re-initialize the X register.
    PLA                                                                         ; $02862D |\ Restore the accumulator and switch to 8-bit mode (effectively
    SEP #FLAG_P_ACCUMULATOR                                                     ; $02862E |/ preserve the upper byte of the accumulator).
-   LDA (<r_battle_copy_3bpp_to_vram_offset),Y                                  ; $028630 |\
    STA reg_ppu_vmdatal_write.w                                                 ; $028632 | | Copy the next eight bytes to VRAM, filling the extra bytes in with
    STZ reg_ppu_vmdatah_write.w                                                 ; $028635 | | zeroes to expand the data from eight to sixteen bytes.
    INY                                                                         ; $028638 | |
    DEX                                                                         ; $028639 | |
    BNE -                                                                       ; $02863A |/
    DEC <r_battle_copy_3bpp_to_vram_arg_tiles                                   ; $02863C |\ Loop until all tiles have been copied.
    BNE --                                                                      ; $02863E |/
    PLB                                                                         ; $028640 | Restore the value of the data bank register.
    RTS                                                                         ; $028641

; _unused_battle_copy_3bpp_to_vram_2 ($02:8642)
;
; Copies 3 bits per pixel data from memory to VRAM, expanding it to 4 bits per
; pixel in the process. The source bank is passed in the accumulator. The source
; address is passed in the X register. The target VRAM address is passed in the
; Y register. Finally, the number of tiles to copy (where each tile is 24 bytes)
; is passed in $0E.
_unused_battle_copy_3bpp_to_vram_2:
    PHB                                                                         ; $028642 |\
    PHA                                                                         ; $028643 | | Preserve the data bank register and set it to the value in the
    PLB                                                                         ; $028644 |/  accumulator.
    STY reg_ppu_vmadd.w                                                         ; $028645 | Set the target VRAM address to the value in the Y register.
    STX <r_battle_copy_3bpp_to_vram_2_offset                                    ; $028648 | Set the indirect pointer to the value in the X register.
    LDY #0.w                                                                    ; $02864A | Initialize the Y register to zero.
--  REP #FLAG_P_ACCUMULATOR                                                     ; $02864D |\ Switch to 16-bit mode and preserve the value in the accumulator.
    PHA                                                                         ; $02864F |/
    LDX #8.w                                                                    ; $028650 |\
-   LDA (<r_battle_copy_3bpp_to_vram_2_offset),Y                                ; $028653 | | Copy the first sixteen bytes of data directly to the target
    STA reg_ppu_vmdata_write.w                                                  ; $028655 | | location in VRAM.
    INY                                                                         ; $028658 | |
    INY                                                                         ; $028659 | |
    DEX                                                                         ; $02865A | |
    BNE -                                                                       ; $02865B |/
    LDX #8.w                                                                    ; $02865D | Initialize the X register to eight.
    PLA                                                                         ; $028660 | Restore the value of the accumulator.
    SEP #FLAG_P_ACCUMULATOR                                                     ; $028661 | Switch back to 8-bit accumulator mode.
-   LDA (<r_battle_copy_3bpp_to_vram_2_offset),Y                                ; $028663 |\
    STA reg_ppu_vmdatal_write.w                                                 ; $028665 | | Copy the next eight bytes to VRAM, filling the extra bytes in with
    STZ reg_ppu_vmdatah_write.w                                                 ; $028668 | | zeroes to expand the data from eight to sixteen bytes.
    INY                                                                         ; $02866B | |
    DEX                                                                         ; $02866C | |
    BNE -                                                                       ; $02866D |/
    DEC <r_battle_copy_3bpp_to_vram_2_arg_tiles                                 ; $02866F |\ Loop until all tiles have been copied.
    BNE --                                                                      ; $028671 |/
    PLB                                                                         ; $028673 | Restore the data bank register.
    RTS                                                                         ; $028674

; _start_vram_dma5 ($02:8675)
;
; Starts a DMA transfer to transfer data from the bank in the accumulator at the
; address in the X register to the VRAM address in the Y register. The number of
; bytes transferred should be in $00.
_start_vram_dma5:
    PHB                                                                         ; $028675 |\
    PHA                                                                         ; $028676 | | Set the data bank register to $00.
    TDC                                                                         ; $028677 | |
    PHA                                                                         ; $028678 | |
    PLB                                                                         ; $028679 | |
    PLA                                                                         ; $02867A |/
    STY reg_ppu_vmadd.w                                                         ; $02867B | Use the value in the Y register as the VRAM write address.
    STX reg_cpu_a1t5.w                                                          ; $02867E | Use the value in the X register as the source address.
    STA reg_cpu_a1b5.w                                                          ; $028681 | Use the value in the accumulator as the source bank.
    LDA #%00000001.b                                                            ; $028684 |\ Configure DMA to write to two addresses.
    STA reg_cpu_dmap5.w                                                         ; $028686 |/
    LDA #<reg_ppu_vmdatal_write.b                                               ; $028689 |\ Configure DMA to write to VRAM.
    STA reg_cpu_bbad5.w                                                         ; $02868B |/
    LDX <r_battle_start_vram_dma5_arg_bytes.b                                   ; $02868E |\ Set the number of bytes to transfer.
    STX reg_cpu_das5.w                                                          ; $028690 |/
    LDA #%00100000.b                                                            ; $028693 |\ Enable the DMA.
    STA reg_cpu_mdmaen.w                                                        ; $028695 |/
    PLB                                                                         ; $028698 | Restore the data bank register.
    RTS                                                                         ; $028699

; _start_vram_dma4 ($02:869A)
;
; Given a source bank in the accumulator, a source address in the X register, a
; target VRAM address in the Y register, and a number of bytes to transfer in
; $0E, executes a DMA to transfer said bytes from RAM or ROM to VRAM.
_start_vram_dma4:
    PHB                                                                         ; $02869A |\
    PHA                                                                         ; $02869B | | Preserve the value of the data bank register and then set it to
    TDC                                                                         ; $02869C | | $00.
    PHA                                                                         ; $02869D | |
    PLB                                                                         ; $02869E | |
    PLA                                                                         ; $02869F |/
    STY reg_ppu_vmadd.w                                                         ; $0286A0 | Set the target VRAM address to the value in the Y register.
    STX reg_cpu_a1t4.w                                                          ; $0286A3 | Set the source address to the value in the X register.
    STA reg_cpu_a1b4.w                                                          ; $0286A6 | Set the source bank to the value in the accumulator.
    LDA #%00000001.b                                                            ; $0286A9 |\ Configure the DMA to transfer two addresses low, high.
    STA reg_cpu_dmap4.w                                                         ; $0286AB |/
    LDA #<reg_ppu_vmdatal_write.b                                               ; $0286AE |\ Set the target address to write to VRAM.
    STA reg_cpu_bbad4.w                                                         ; $0286B0 |/
    LDX <r_battle_start_vram_dma4_arg_bytes.b                                   ; $0286B3 |\ Set the number of bytes to transfer to the value in $0E.
    STX reg_cpu_das4.w                                                          ; $0286B5 |/
    LDA #%00010000.b                                                            ; $0286B8 |\ Execute the DMA.
    STA reg_cpu_mdmaen.w                                                        ; $0286BA |/
    PLB                                                                         ; $0286BD | Restore the value of the data bank register.
    RTS                                                                         ; $0286BE

; _battle_format_number ($02:86BF)
;
; Given a 16-bit number in the X register, returns the decimal format of the
; 5 digit number as BG3 tile numbers (digit plus 128) at $180C.
_battle_format_number:
    STX <r_math_divide_16bit_arg_1                                              ; $0286BF |\
    LDX #10000.w                                                                ; $0286C1 | | Calculate the ten-thousands digit.
    STX <r_math_divide_16bit_arg_2                                              ; $0286C4 | |
    JSR _math_divide_16bit                                                      ; $0286C6 | |
    LDA <r_math_divide_16bit_result                                             ; $0286C9 | |
    CLC                                                                         ; $0286CB | |
    ADC #$80.b                                                                  ; $0286CC | |
    STA r_battle_format_number_result.w + 0                                     ; $0286CE |/
    LDX <r_math_divide_16bit_remainder                                          ; $0286D1 |\
    STX <r_math_divide_16bit_arg_1                                              ; $0286D3 | | Calculate the thousands digit.
    LDX #1000.w                                                                 ; $0286D5 | |
    STX <r_math_divide_16bit_arg_2                                              ; $0286D8 | |
    JSR _math_divide_16bit                                                      ; $0286DA | |
    LDA <r_math_divide_16bit_result                                             ; $0286DD | |
    CLC                                                                         ; $0286DF | |
    ADC #$80.b                                                                  ; $0286E0 | |
    STA r_battle_format_number_result.w + 1                                     ; $0286E2 |/
    LDX <r_math_divide_16bit_remainder                                          ; $0286E5 |\
    STX <r_math_divide_16bit_arg_1                                              ; $0286E7 | | Calculate the hundreds digit.
    LDX #100.w                                                                  ; $0286E9 | |
    STX <r_math_divide_16bit_arg_2                                              ; $0286EC | |
    JSR _math_divide_16bit                                                      ; $0286EE | |
    LDA <r_math_divide_16bit_result                                             ; $0286F1 | |
    CLC                                                                         ; $0286F3 | |
    ADC #$80.b                                                                  ; $0286F4 | |
    STA r_battle_format_number_result.w + 2                                     ; $0286F6 |/
    LDX <r_math_divide_16bit_remainder                                          ; $0286F9 |\
    STX <r_math_divide_16bit_arg_1                                              ; $0286FB | | Calculate the tens digit.
    LDX #10.w                                                                   ; $0286FD | |
    STX <r_math_divide_16bit_arg_2                                              ; $028700 | |
    JSR _math_divide_16bit                                                      ; $028702 | |
    LDA <r_math_divide_16bit_result                                             ; $028705 | |
    CLC                                                                         ; $028707 | |
    ADC #$80.b                                                                  ; $028708 | |
    STA r_battle_format_number_result.w + 3                                     ; $02870A |/
    LDA <r_math_divide_16bit_remainder                                          ; $02870D |\
    CLC                                                                         ; $02870F | | Calculate the ones digit.
    ADC #$80.b                                                                  ; $028710 | |
    STA r_battle_format_number_result.w + 4                                     ; $028712 |/
    RTS                                                                         ; $028715

; _battle_render_number ($02:8716)
;
; Given a 5-digit decimal representation of a number (in BG3 tile numbers) at
; $180C, converts the number for display by truncating to four digits (limiting
; the max value to 9999) and then converting any leading zeroes to blank tiles.
_battle_render_number:
    LDX #0.w                                                                    ; $028716 |\
-   LDA r_battle_format_number_result.w + 1,X                                   ; $028719 | | Move the four lower digits to the left one location, effectively
    STA r_battle_format_number_result.w + 0,X                                   ; $02871C | | eliminating the ten thousands digit. (So the highest available
    INX                                                                         ; $02871F | | value is now 9999).
    CPX #5.w                                                                    ; $028720 | |
    BNE -                                                                       ; $028723 |/
    LDX #0.w                                                                    ; $028725 |\
-   LDA r_battle_format_number_result.w,X                                       ; $028728 | | Replace any leading zeroes with blank tiles instead.
    CMP #$80.b                                                                  ; $02872B | |
    BNE +                                                                       ; $02872D | |
    LDA #$FF.b                                                                  ; $02872F | |
    STA r_battle_format_number_result.w,X                                       ; $028731 | |
    INX                                                                         ; $028734 | |
    CPX #3.w                                                                    ; $028735 | |
    BNE -                                                                       ; $028738 |/
+   RTS                                                                         ; $02873A

; _battle_render_number_long ($02:873B)
;
; Given an 8-digit decimal representation of a number (in BG3 tile numbers) at
; $F4AD, converts the number for display by converting any leading zeroes to
; blank tiles. As a side effect, the X register will have the index of the first
; non-zero value (or the last value if all are zero).
_battle_render_number_long:
    LDX #0.w                                                                    ; $02873B |\
-   LDA r_battle_format_number_long_result.w,X                                  ; $02873E | | Replace any leading zeroes in the number with blank tiles instead.
    CMP #$80.b                                                                  ; $028741 | |
    BNE +                                                                       ; $028743 | |
    LDA #$FF.b                                                                  ; $028745 | |
    STA r_battle_format_number_long_result.w,X                                  ; $028747 | |
    INX                                                                         ; $02874A | |
    CPX #7.w                                                                    ; $02874B | |
    BNE -                                                                       ; $02874E |/
+   RTS                                                                         ; $028750

; battle_menu_target_map_party_data ($02:8751)
;
; Contains the target map data for the party members, which determines how the
; targeting cursor moves when various buttons are pressed. The data is defined
; in the order of up, down, left, right. Party slots start at $08.
battle_menu_target_map_party_data:
    TARGET_MAP $0B, $0C, $0F, $0F                                               ; $028751.8752 | $00/$08
    TARGET_MAP $0A, $0B, $0F, $0F                                               ; $028753.8754 | $01/$09
    TARGET_MAP $0C, $09, $0F, $0F                                               ; $028755.8756 | $02/$0A
    TARGET_MAP $09, $08, $0F, $0F                                               ; $028757.8758 | $03/$0B
    TARGET_MAP $08, $0A, $0F, $0F                                               ; $028759.875A | $04/$0C

; _battle_sort_monsters ($02:875B)
;
; Generates four 8 byte arrays in RAM, starting at $F333. These arrays contain
; the list of monster slots, sorted by their position on screen, either
; primarily vertically or horizontally. In either case, the other direction is
; used to break ties.
_battle_sort_monsters:
    LDX #0.w                                                                    ; $02875B |\
-   LDA battle_menu_target_map_party_data.l,X                                   ; $02875E | | Copy the target map data for the party from ROM to RAM.
    STA r_battle_menu_target_map.party.w,X                                      ; $028762 | |
    INX                                                                         ; $028765 | |
    CPX #_sizeof_battle_menu_target_map_party_data.w                            ; $028766 | |
    BNE -                                                                       ; $028769 |/
    JSR _battle_sort_monsters_vertical                                          ; $02876B | Generate the vertically-sorted monster lists.
    LDX #0.w                                                                    ; $02876E |\ Initialize the X and Y registers to zero.
    LDY #0.w                                                                    ; $028771 |/
    STZ <r_battle_sort_monsters_count                                           ; $028774 | Initialize the slot number to zero.
-   LDA r_monster_coordinates.w,X                                               ; $028776 |\
    LSR A                                                                       ; $028779 | | Calculate the monster's X coordinate.
    LSR A                                                                       ; $02877A | |
    LSR A                                                                       ; $02877B | |
    LSR A                                                                       ; $02877C | |
    STA r_battle_sort_monsters_coordinates.1.x.w,Y                              ; $02877D |/
    LDA r_monster_coordinates.w,X                                               ; $028780 |\
    AND #%00001111.b                                                            ; $028783 | | Calculate the monster's Y coordinate.
    STA r_battle_sort_monsters_coordinates.1.y.w,Y                              ; $028785 |/
    INY                                                                         ; $028788 |\ Increment the Y register twice to move to the next monster.
    INY                                                                         ; $028789 |/
    LDA <r_battle_sort_monsters_count                                           ; $02878A |\
    STA r_sorted_monsters_horizontal_reversed.w,X                               ; $02878C | | Copy the monster's slot into the sorted monsters arrays.
    STA r_sorted_monsters_horizontal.w,X                                        ; $02878F | |
    INC <r_battle_sort_monsters_count                                           ; $028792 |/
    INX                                                                         ; $028794 | Increment the slot number.
    CPX #8.w                                                                    ; $028795 |\ Loop until all eight slots have been processed.
    BNE -                                                                       ; $028798 |/
    JSR _battle_sort_monsters_horizontal_sort                                   ; $02879A | Sort the horizontal monsters list.
    LDX #0.w                                                                    ; $02879D |\
    LDY #7.w                                                                    ; $0287A0 | | Reverse the horizonally sorted monsters list to generate the
-   LDA r_sorted_monsters_horizontal.w,Y                                        ; $0287A3 | | reversed version.
    STA r_sorted_monsters_horizontal_reversed.w,X                               ; $0287A6 | |
    DEY                                                                         ; $0287A9 | |
    INX                                                                         ; $0287AA | |
    CPX #8.w                                                                    ; $0287AB | |
    BNE -                                                                       ; $0287AE |/
    RTS                                                                         ; $0287B0

; _battle_sort_monsters_horizontal_sort ($02:87B1)
;
; Part of the monster sorting routines, this one is actually responsible for
; sorting the horizontal array, using a simple bubble sort method.
_battle_sort_monsters_horizontal_sort:
    LDA #32.b                                                                   ; $0287B1 |\ Initialize the iteration counter to 32. NOTE: This is pointless, as
    STA <r_battle_sort_monsters_count                                           ; $0287B3 |/ seven iterations should always be enough.
--  LDX #0.w                                                                    ; $0287B5 |\ Initialize the X and Y registers to zero.
    LDY #0.w                                                                    ; $0287B8 |/
-   LDA r_battle_sort_monsters_coordinates.1.x.w,X                              ; $0287BB |\
    CMP r_battle_sort_monsters_coordinates.2.x.w,X                              ; $0287BE | | Compare the two adjacent monsters starting at the value in the X
    BNE +                                                                       ; $0287C1 | | register. If the first monster's X coordinate is greater than the
    LDA r_battle_sort_monsters_coordinates.1.y.w,X                              ; $0287C3 | | second's, or if the X coordinates are the same and if the first
    CMP r_battle_sort_monsters_coordinates.2.y.w,X                              ; $0287C6 | | monster's Y coordinate is greater than the second's, swap the two
    BCC ++                                                                      ; $0287C9 | | monsters in the array. The end result is that monsters are sorted
    JSR _battle_sort_monsters_swap_horizontal                                   ; $0287CB | | horizontally, with their vertical position breaking any ties.
    JMP ++                                                                      ; $0287CE | |
+   BCC ++                                                                      ; $0287D1 | |
    JSR _battle_sort_monsters_swap_horizontal                                   ; $0287D3 |/
++  INX                                                                         ; $0287D6 |\
    INX                                                                         ; $0287D7 | | Increment the index registers.
    INY                                                                         ; $0287D8 |/
    CPX #(7 * 2).w                                                              ; $0287D9 |\ Repeat until all potential 7 pairs have been swapped.
    BNE -                                                                       ; $0287DC |/
    DEC <r_battle_sort_monsters_count                                           ; $0287DE |\ Loop until all 32 iterations have been completed.
    BNE --                                                                      ; $0287E0 |/
    RTS                                                                         ; $0287E2

; _battle_sort_monsters_vertical ($02:87E3)
;
; Part of the monster sorting routines, this one initializes the vertically
; sorted lists, and executes the necessary functions to sort the monsters
; within them and generate the reversed list.
_battle_sort_monsters_vertical:
    LDX #0.w                                                                    ; $0287E3 |\ Initialize the X and Y registers to zero.
    LDY #0.w                                                                    ; $0287E6 |/
    STZ <r_battle_sort_monsters_count                                           ; $0287E9 | Initialize the counter to zero.
-   LDA r_monster_coordinates.w,X                                               ; $0287EB |\
    LSR A                                                                       ; $0287EE | | Determine the monster's X coordinate and save it for later use.
    LSR A                                                                       ; $0287EF | |
    LSR A                                                                       ; $0287F0 | |
    LSR A                                                                       ; $0287F1 | |
    STA r_battle_sort_monsters_coordinates.1.x,Y                                ; $0287F2 |/
    LDA r_monster_coordinates.w,X                                               ; $0287F5 |\
    AND #%00001111.b                                                            ; $0287F8 | | Determine the monster's Y coordinate.
    STA r_battle_sort_monsters_coordinates.1.y,Y                                ; $0287FA |/
    INY                                                                         ; $0287FD |\ Increment the Y register by two to prepare to write the next
    INY                                                                         ; $0287FE |/ monster's coordinates.
    LDA <r_battle_sort_monsters_count.b                                         ; $0287FF |\
    STA r_sorted_monsters_vertical.w,X                                          ; $028801 | | Write the monster's slot number to the two result arrays.
    STA r_sorted_monsters_vertical_reversed.w,X                                 ; $028804 |/
    INC <r_battle_sort_monsters_count.b                                         ; $028807 |\
    INX                                                                         ; $028809 | | Increment the slot number and loop until all eight monsters have
    CPX #8.w                                                                    ; $02880A | | been processed.
    BNE -                                                                       ; $02880D |/
    JSR _battle_sort_monsters_vertical_sort                                     ; $02880F | Sort the array of monsters.
    LDX #0.w                                                                    ; $028812 |\
    LDY #7.w                                                                    ; $028815 | | Reverse the array of monsters and write it to the reversed array.
-   LDA r_sorted_monsters_vertical.w,Y                                          ; $028818 | |
    STA r_sorted_monsters_vertical_reversed.w,X                                 ; $02881B | |
    DEY                                                                         ; $02881E | |
    INX                                                                         ; $02881F | |
    CPX #8.w                                                                    ; $028820 | |
    BNE -                                                                       ; $028823 |/
    RTS                                                                         ; $028825

; _battle_sort_monsters_vertical_sort ($02:8826)
;
; Part of the monster sorting routines, this one is actually responsible for
; sorting the vertical array, using a simple bubble sort method.
_battle_sort_monsters_vertical_sort:
    LDA #32.b                                                                   ; $028826 |\ Initialize the iteration counter to 32. NOTE: This is pointless, as
    STA <r_battle_sort_monsters_count                                           ; $028828 |/ seven iterations should always be enough.
--  LDX #0.w                                                                    ; $02882A |\ Initialize the X and Y registers to zero.
    LDY #0.w                                                                    ; $02882D |/
-   LDA r_battle_sort_monsters_coordinates.1.y.w,X                              ; $028830 |\
    CMP r_battle_sort_monsters_coordinates.2.y.w,X                              ; $028833 | | Compare the two adjacent monsters starting at the value in the X
    BNE +                                                                       ; $028836 | | register. If the first monster's Y coordinate is greater than the
    LDA r_battle_sort_monsters_coordinates.1.x.w,X                              ; $028838 | | second's, or if the Y coordinates are the same and if the first
    CMP r_battle_sort_monsters_coordinates.2.x.w,X                              ; $02883B | | monster's X coordinate is greater than the second's, swap the two
    BCC ++                                                                      ; $02883E | | monsters in the array. The end result is that monsters are sorted
    JSR _battle_sort_monsters_swap_vertical                                     ; $028840 | | vertically, with their horizontal position breaking any ties.
    JMP ++                                                                      ; $028843 | |
+   BCC ++                                                                      ; $028846 | |
    JSR _battle_sort_monsters_swap_vertical                                     ; $028848 |/
++  INX                                                                         ; $02884B |\
    INX                                                                         ; $02884C | | Increment the index registers.
    INY                                                                         ; $02884D |/
    CPX #(7 * 2).w                                                              ; $02884E |\ Repeat until all potential 7 pairs have been swapped.
    BNE -                                                                       ; $028851 |/
    DEC <r_battle_sort_monsters_count                                           ; $028853 |\ Loop until all 32 iterations have been completed.
    BNE --                                                                      ; $028855 |/
    RTS                                                                         ; $028857

; _battle_sort_monsters_swap_* ($02:8858)
;
; Intended to be used as part of the monster sorting routines, this routine
; swaps the positions of monsters in the array at either $F343 (vertical) or
; $F33B (horizontal), depending on the entry point, as well as in the temporary
; coordinate data at $74FD. The two monsters to swap are determined by the
; values in the Y register (for the main array) and the X register (for the
; temporary coordinate data). A monster is always swapped with the monster
; following it in the list.
_battle_sort_monsters_swap_horizontal:
    LDA r_sorted_monsters_horizontal.w + 0,Y                                    ; $028858 |\
    STA <r_battle_generic_tmp_index_lo                                          ; $02885B | | Swap the monsters in the horizontally sorted list at positions Y
    LDA r_sorted_monsters_horizontal.w + 1,Y                                    ; $02885D | | and Y + 1.
    STA r_sorted_monsters_horizontal.w + 0,Y                                    ; $028860 | |
    LDA <r_battle_generic_tmp_index_lo                                          ; $028863 | |
    STA r_sorted_monsters_horizontal.w + 1,Y                                    ; $028865 |/
    JMP _battle_sort_monsters_swap_coordinates                                  ; $028868 | Jump to the section that swaps the coordinates.
_battle_sort_monsters_swap_vertical:
    LDA r_sorted_monsters_vertical.w + 0,Y                                      ; $02886B |\
    STA <r_battle_generic_tmp_index_lo                                          ; $02886E | | Swap the monsters in the vertically sorted list at positions Y and
    LDA r_sorted_monsters_vertical.w + 1,Y                                      ; $028870 | | Y + 1.
    STA r_sorted_monsters_vertical.w + 0,Y                                      ; $028873 | |
    LDA <r_battle_generic_tmp_index_lo                                          ; $028876 | |
    STA r_sorted_monsters_vertical.w + 1,Y                                      ; $028878 |/
_battle_sort_monsters_swap_coordinates:
    LDA r_battle_sort_monsters_coordinates.2.x.w,X                              ; $02887B |\
    STA <r_battle_generic_tmp_index_lo                                          ; $02887E | | Swap the X coordinates of the pair of monsters.
    LDA r_battle_sort_monsters_coordinates.1.x.w,X                              ; $028880 | |
    STA r_battle_sort_monsters_coordinates.2.x.w,X                              ; $028883 | |
    LDA <r_battle_generic_tmp_index_lo                                          ; $028886 | |
    STA r_battle_sort_monsters_coordinates.1.x.w,X                              ; $028888 |/
    LDA r_battle_sort_monsters_coordinates.2.y.w,X                              ; $02888B |\
    STA <r_battle_generic_tmp_index_lo                                          ; $02888E | | Swap the Y coordinates of the pair of monsters.
    LDA r_battle_sort_monsters_coordinates.1.y.w,X                              ; $028890 | |
    STA r_battle_sort_monsters_coordinates.2.y.w,X                              ; $028893 | |
    LDA <r_battle_generic_tmp_index_lo                                          ; $028896 | |
    STA r_battle_sort_monsters_coordinates.1.y.w,X                              ; $028898 |/
    RTS                                                                         ; $02889B

; _battle_set_monster_size ($02:889C)
;
; Loops through the eight monster slots, and if a monster is in that slot sets
; the monster's size variables as appropriate (in tiles). If the monster is a
; pig, small, toad or egg, the size is adjusted to match those sprites.
_battle_set_monster_size:
    LDY #0.w                                                                    ; $02889C | Initialize the Y register to zero.
-   LDA r_monster_slot_to_id_index_initial.w,Y                                  ; $02889F |\
    ASL A                                                                       ; $0288A2 | | Set the X register to the monster's ID index times two.
    TAX                                                                         ; $0288A3 |/
    LDA r_monster_type_size.1.width.w,X                                         ; $0288A4 |\
    STA <r_battle_generic_tmp_index_lo                                          ; $0288A7 | | Load this monster type's width and height in tiles and store them
    LDA r_monster_type_size.1.height.w,X                                        ; $0288A9 | | in temporary variables.
    STA <r_battle_generic_tmp_index_hi                                          ; $0288AC |/
    TYA                                                                         ; $0288AE |\
    ASL A                                                                       ; $0288AF | | Set the X register to the monster slot number times two.
    TAX                                                                         ; $0288B0 |/
    STX <r_battle_generic_tmp_index_2                                           ; $0288B1 | Save the X register to a variable.
    LDA <r_battle_generic_tmp_index_lo                                          ; $0288B3 |\ Set the individual monster's width.
    STA r_monster_size.1.width.w,X                                              ; $0288B5 |/
    LDA <r_battle_generic_tmp_index_hi                                          ; $0288B8 |\ Set the individual monster's height.
    STA r_monster_size.1.height.w,X                                             ; $0288BA |/
    STY <r_math_multiply_8bit_arg_1                                             ; $0288BD |\
    LDA #_sizeof_character_battle.b                                             ; $0288BF | | Set the X register to the offset to this monster's in-battle stats
    STA <r_math_multiply_8bit_arg_2                                             ; $0288C1 | | record.
    JSR _math_multiply_8bit                                                     ; $0288C3 | |
    LDX <r_math_multiply_8bit_result                                            ; $0288C6 |/
    LDA r_character_battle.6.status_3.w,X                                       ; $0288C8 |\
    AND #STATUS_3_EGG.b                                                         ; $0288CB | | If the monster is an egg, load the monster size index back into
    BEQ +                                                                       ; $0288CD | | the X register and jump to relevant code.
    LDX <r_battle_generic_tmp_index_2                                           ; $0288CF | |
    JMP ++                                                                      ; $0288D1 |/
+   LDA r_character_battle.6.status_1.w,X                                       ; $0288D4 | Otherwise, load another status byte.
    LDX <r_battle_generic_tmp_index_2                                           ; $0288D7 | Load the X register back to the monster size index.
    AND #(STATUS_1_TOAD | STATUS_1_SMALL | STATUS_1_PIG).b                      ; $0288D9 |\ If the monster is not a toad, small or pig, jump ahead as their
    BEQ +                                                                       ; $0288DB |/ size doesn't need to be adjusted.
    AND #(STATUS_1_TOAD | STATUS_1_SMALL).b                                     ; $0288DD |\
    BEQ ++                                                                      ; $0288DF | | If the monster is a toad or small, set their width and height
    LDA #2.b                                                                    ; $0288E1 | | explicitly to 2 tiles each.
    STA r_monster_size.1.width.w,X                                              ; $0288E3 | |
    STA r_monster_size.1.height.w,X                                             ; $0288E6 | |
    JMP +                                                                       ; $0288E9 |/
++  LDA #4.b                                                                    ; $0288EC |\
    STA r_monster_size.1.width.w,X                                              ; $0288EE | | If the monster is a pig or an egg, set the width and height to 4.
    STA r_monster_size.1.height.w,X                                             ; $0288F1 |/
+   INY                                                                         ; $0288F4 |\
    CPY #8.w                                                                    ; $0288F5 | | Increment the Y register and loop until all 8 slots are done.
    BNE -                                                                       ; $0288F8 |/
    RTS                                                                         ; $0288FA

; _battle_set_coordinates ($02:88FB)
;
; Sets the monster center coordinates, the character coordinates, and sets the
; monster sizes.
_battle_set_coordinates:
    JSL bank03.battle_set_monster_center_coordinates                            ; $0288FB | Set the monster center coordinate variables.
    JSR _battle_copy_character_cursor_coordinates                               ; $0288FF | Set the character coordinates.
    JMP _battle_set_monster_size                                                ; $028902 | Set the monster size.

; _battle_copy_character_cursor_coordinates ($02:8905)
;
; Copies the cursor coordinates for the five character slots into two arrays.
; Additionally copies the coordinates plus 24 into another array.
_battle_copy_character_cursor_coordinates:
    LDX #0.w                                                                    ; $028905 | Initialize the X register to zero.
-   LDA r_battle_character_cursor_coordinates.1.x.w,X                           ; $028908 |\
    STA r_battle_character_cursor_coordinates_copy_2.1.x.w,X                    ; $02890B | | TODO: Copy the X coordinate into the array copies.
    STA r_battle_character_cursor_coordinates_copy_1.1.x.w,X                    ; $02890E |/
    CLC                                                                         ; $028911 |\
    ADC #24.b                                                                   ; $028912 | | TODO: Add 24 and save it to the plus 24 array.
    STA r_battle_character_cursor_coordinates_plus_24.1.x.w,X                   ; $028914 |/
    LDA r_battle_character_cursor_coordinates.1.y.w,X                           ; $028917 |\
    STA r_battle_character_cursor_coordinates_copy_2.1.y.w,X                    ; $02891A | | Repeat the above with the Y coordinate.
    STA r_battle_character_cursor_coordinates_copy_1.1.y.w,X                    ; $02891D | |
    CLC                                                                         ; $028920 | |
    ADC #24.b                                                                   ; $028921 | |
    STA r_battle_character_cursor_coordinates_plus_24.1.y.w,X                   ; $028923 |/
    INX                                                                         ; $028926 |\
    INX                                                                         ; $028927 | | Increment the X register twice to move to the next set of
    CPX #_sizeof_r_battle_character_cursor_coordinates.w                        ; $028928 | | coordinates and loop until all five slots are complete.
    BNE -                                                                       ; $02892B |/
    RTS                                                                         ; $02892D

; _battle_update_misc ($02:892E)
;
; Updates several miscellaneous battle data structures, such as the visual
; status bytes, the character slot to slot map, and the pre-action copy of the
; monster slot to type index map.
_battle_update_misc:
    LDA #5.b                                                                    ; $02892E |\ Initialize the counter to examine all five character records.
    STA <r_battle_generic_tmp_index_lo                                          ; $028930 |/
    TDC                                                                         ; $028932 |\
    STA <r_battle_generic_tmp_index_2_lo                                        ; $028933 | | Initialize the actual indexes to zero.
    LDX #0.w                                                                    ; $028935 | |
    LDY #0.w                                                                    ; $028938 |/
-   REP #FLAG_P_ACCUMULATOR.b                                                   ; $02893B |\
    LDA r_character_battle.1.status_1.w,X                                       ; $02893D | | Copy the character's status bytes to the copy used for visual
    STA r_character_visual_status.1.status_1.w,Y                                ; $028940 | | status.
    LDA r_character_battle.1.status_3.w,X                                       ; $028943 | |
    STA r_character_visual_status.1.status_3,Y                                  ; $028946 |/
    TXA                                                                         ; $028949 |\
    CLC                                                                         ; $02894A | | Add 128 to the record index to move to the next record.
    ADC #_sizeof_character_battle.w                                             ; $02894B | |
    TAX                                                                         ; $02894E |/
    TYA                                                                         ; $02894F |\
    CLC                                                                         ; $028950 | | Add 4 to the second index to move to the next set of status
    ADC #_sizeof_character_status.w                                             ; $028951 | | copies.
    TAY                                                                         ; $028954 | |
    TDC                                                                         ; $028955 |/
    SEP #FLAG_P_ACCUMULATOR.b                                                   ; $028956 |\
    PHY                                                                         ; $028958 | | Initialize an array in RAM which maps the character's slot number
    LDA <r_battle_generic_tmp_index_2_lo                                        ; $028959 | | to their slot number. Empty slots are replaced with $FF instead.
    TAY                                                                         ; $02895B | |
    LDA r_character_battle.1.id.w - _sizeof_character_battle,X                  ; $02895C | |
    DEC A                                                                       ; $02895F | |
    CMP #$FF.b                                                                  ; $028960 | |
    BEQ +                                                                       ; $028962 | |
    LDA <r_battle_generic_tmp_index_2_lo                                        ; $028964 | |
+   STA r_character_slot_if_active.w,Y                                          ; $028966 | |
    PLY                                                                         ; $028969 |/
    INC <r_battle_generic_tmp_index_2_lo                                        ; $02896A | Increment the index.
    DEC <r_battle_generic_tmp_index_lo                                          ; $02896C |\ Loop until all five character slots have been examined.
    BNE -                                                                       ; $02896E |/
    LDX #0.w                                                                    ; $028970 |\
-   LDA r_monster_slot_to_id_index.w,X                                          ; $028973 | | Update the pre-action copy of the monster slot to type index map.
    STA r_monster_slot_to_id_index_pre_action.w,X                               ; $028976 | | (That copy is only updated when an action is not occurring and is
    INX                                                                         ; $028979 | | used during animations.)
    CPX #8.w                                                                    ; $02897A | |
    BNE -                                                                       ; $02897D |/
    RTS                                                                         ; $02897F

; _init_oam ($02:8980)
;
; Clears the OAM by setting every value to 240, which results in all sprites
; being drawn off screen, as their Y coordinate is off screen.
_init_oam:
    LDX #$0000.w                                                                ; $028980 |\
    LDA #240.b                                                                  ; $028983 | | Write 240 to all of the OAM. This results in all sprites being
-   STA r_oam.w,X                                                               ; $028985 | | drawn off screen.
    INX                                                                         ; $028988 | |
    CPX #_sizeof_r_oam.w + _sizeof_r_oam_hi                                     ; $028989 | |
    BNE -                                                                       ; $02898C |/
    RTS                                                                         ; $02898E

; _battle_init_graphics ($02:898F)
;
; Initializes several graphical related items for battles.
_battle_init_graphics:
    JSL bank01.battle_init_misc                                                 ; $02898F | Do some miscellaneous battle initialization.
    JSL bank03.battle_copy_cgram_to_ppu                                         ; $028993 | Transfer the current CG-RAM data in RAM to the PPU.
    JSR _init_oam                                                               ; $028997 | Initialize the OAM to draw all sprites off screen.
    JSR _init_battle_tilemap                                                    ; $02899A | Initialize the battle tilemap in RAM to blank tiles.
    LDY #$5800.w                                                                ; $02899D |\
    JSR _copy_battle_tilemap_to_vram                                            ; $0289A0 | | Transfer the blank tilemap to VRAM to reset the relevant areas of
    LDY #$5C00.w                                                                ; $0289A3 | | VRAM.
    JSR _copy_battle_tilemap_to_vram                                            ; $0289A6 | |
    LDY #$6000.w                                                                ; $0289A9 | |
    JSR _copy_battle_tilemap_to_vram                                            ; $0289AC | |
    LDY #$6400.w                                                                ; $0289AF | |
    JSR _copy_battle_tilemap_to_vram                                            ; $0289B2 | |
    LDY #$6800.w                                                                ; $0289B5 | |
    JSR _copy_battle_tilemap_to_vram                                            ; $0289B8 | |
    LDY #$6C00.w                                                                ; $0289BB | |
    JSR _copy_battle_tilemap_to_vram                                            ; $0289BE |/
    JSR _battle_update_misc                                                     ; $0289C1 | Update visual status and slot maps.
    JSR _battle_initialize_character_visual_properties                          ; $0289C4 | Initializes the visual properties data.
    LDA #$01.b                                                                  ; $0289C7 |\ Enable the multi-joystick mode for the battle.
    STA r_multi_active.l & $FFFF                                                ; $0289C9 |/
    JMP _battle_effect_spell_set_random_oam_offsets                             ; $0289CD | Initialize the array of random OAM coordinate offsets.

; _init (02:89D0)
;
; Performs some basic initialization for the battle subsystem. Its major task is
; setting the battle NMI and IRQ handlers. Also sets some PPU registers.
_init:
    TDC                                                                         ; $0289D0 |\
    PHA                                                                         ; $0289D1 | | Set the data bank register to $00.
    PLB                                                                         ; $0289D2 |/
    STA reg_cpu_nmitimen                                                        ; $0289D3 | Disable NMI, timer interrupts and joypad reading.
    STA reg_ppu_setini                                                          ; $0289D6 |\ Set normal PPU settings.
    STA reg_ppu_cgswsel                                                         ; $0289D9 |/
    LDA #:nmi_handler                                                           ; $0289DC |\
    STA r_nmi_handler.w + 3                                                     ; $0289DE | | Set the battle NMI handler.
    LDX #nmi_handler.w                                                          ; $0289E1 | |
    STX r_nmi_handler.w + 1                                                     ; $0289E4 | |
    LDA #$5C.b                                                                  ; $0289E7 | |
    STA r_nmi_handler.w                                                         ; $0289E9 |/
    STA r_irq_handler.w                                                         ; $0289EC |\
    LDA #:bank02.irq_handler                                                    ; $0289EF | | Set the battle IRQ handler.
    STA r_irq_handler.w + 3                                                     ; $0289F1 | |
    LDX #irq_handler.w                                                          ; $0289F4 | |
    STX r_irq_handler.w + 1                                                     ; $0289F7 |/
    LDX #$7000.w                                                                ; $0289FA |\
    LDY #$2000.w                                                                ; $0289FD | | Clears VRAM from $7000 to $7FFF.
    JSR _clear_vram                                                             ; $028A00 |/
    LDX #$4000.w                                                                ; $028A03 |\
    LDY #$0020.w                                                                ; $028A06 | | Clears VRAM from $4000 to $400F.
    JSR _clear_vram                                                             ; $028A09 |/
    LDX #$1FF0.w                                                                ; $028A0C |\
    LDY #$0020.w                                                                ; $028A0F | | Clears VRAM from $1FF0 to $1FFF.
    JSR _clear_vram                                                             ; $028A12 |/
    LDA #%00110011.b                                                            ; $028A15 |\
    STA reg_ppu_w12sel                                                          ; $028A17 | | Configure the BG1 and OBJ window.
    STA reg_ppu_wobjsel                                                         ; $028A1A |/
    LDA #8.b                                                                    ; $028A1D |\ Start the window 8 pixels from the left.
    STA reg_ppu_wh0                                                             ; $028A1F |/
    LDA #248.b                                                                  ; $028A22 |\ End the window 8 pixels from the right.
    STA reg_ppu_wh1                                                             ; $028A24 |/
    TDC                                                                         ; $028A27 |\
    STA reg_ppu_tmw                                                             ; $028A28 | | Disable window mask for main screen and sub screen.
    STA reg_ppu_tsw                                                             ; $028A2B |/
    LDA #$7E.b                                                                  ; $028A2E |\
    PHA                                                                         ; $028A30 | | Set the data bank register to $7E.
    PLB                                                                         ; $028A31 |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $028A32 |\
    LDA r_battle_formation.w                                                    ; $028A34 | | Multiply the battle formation number by 8 to determine the index.
    STA <r_math_multiply_16bit_arg_1                                            ; $028A37 | |
    LDA #8.w                                                                    ; $028A39 | |
    STA <r_math_multiply_16bit_arg_2                                            ; $028A3C | |
    TDC                                                                         ; $028A3E | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $028A3F | |
    JSR _math_multiply_16bit                                                    ; $028A41 | |
    LDX <r_math_multiply_16bit_result_lo                                        ; $028A44 |/
    LDA bank0E.formation_property_data.l + formation_properties.flags2,X        ; $028A46 |\ Copy the second formation flags byte to another memory address.
    STA r_formation_flags2_copy_2.w                                             ; $028A4A |/
    STZ r_battle_flash_mode.w                                                   ; $028A4D | Disable any battle flash effect.
    RTS                                                                         ; $028A50

; irq_handler ($02:8A51)
;
; IRQ handler for in battle. Resets the IRQ flag and sets the variable that
; indicates the IRQ is complete.
irq_handler:
    PHP                                                                         ; $028A51 | Preserve the processor flags register.
    REP #FLAG_P_ACCUMULATOR                                                     ; $028A52 |\
    PHA                                                                         ; $028A54 | | Preserve the 16-bit accumulator.
    SEP #FLAG_P_ACCUMULATOR                                                     ; $028A55 |/
    LDA reg_cpu_timeup.l                                                        ; $028A57 | Reset the IRQ timer flag.
    LDA #1.b                                                                    ; $028A5B |\ Set the flag that indicates this IRQ has been processed.
    STA r_battle_irq_complete.l                                                 ; $028A5D |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $028A61 |\
    PLA                                                                         ; $028A63 | | Restore the accumulator and processor flags register.
    PLP                                                                         ; $028A64 |/
    RTI                                                                         ; $028A65

; _init_battle_tilemap ($02:8A66)
;
; Initializes the battle tilemap by filling the entire space with blank tiles.
; Nothing is copied to VRAM at this stage.
_init_battle_tilemap:
    LDX #$0000.w                                                                ; $028A66 | Initialize the X register to zero.
    REP #FLAG_P_ACCUMULATOR                                                     ; $028A69 |\ Initialize the accumulator to $0200, which will place a blank tile
    LDA #$0200.w                                                                ; $028A6B |/ in the tilemap.
-   STA r_battle_tilemap_data.w,X                                               ; $028A6E |\
    INX                                                                         ; $028A71 | | Loop until the entire tilemap staging area has been filled with
    INX                                                                         ; $028A72 | | blank tiles.
    CPX #_sizeof_r_battle_tilemap_data.w                                        ; $028A73 | |
    BNE -                                                                       ; $028A76 | |
    TDC                                                                         ; $028A78 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $028A79 |/
    RTS                                                                         ; $028A7B

; _copy_battle_tilemap_to_vram ($02:8A7C)
;
; Transfers the battle tilemap from RAM to VRAM at the VRAM address provided in
; the Y register.
_copy_battle_tilemap_to_vram:
    LDX #_sizeof_r_battle_tilemap_data.w                                        ; $028A7C |\
    STX <r_battle_start_vram_dma5_arg_bytes.b                                   ; $028A7F | | Use a DMA to transfer the battle background from RAM to the VRAM
    LDX #r_battle_tilemap_data.w                                                ; $028A81 | | address passed in the Y register.
    LDA #:r_battle_tilemap_data.b                                               ; $028A84 | |
    JMP _start_vram_dma5                                                        ; $028A86 |/

; _battle_update_monster_palette ($02:8A89)
;
; Given a monster slot number in $F109 and a new palette number in $F10A,
; updates the tilemap area in memory for that monster to change the palette to
; the new value. Nothing is transferred to VRAM at this time.
_battle_update_monster_palette:
    LDA r_battle_update_monster_palette_arg_slot.w                              ; $028A89 |\
    TAX                                                                         ; $028A8C | | Check that a monster is actually present in the slot that was
    LDA r_monster_slot_to_id_index_initial.w,X                                  ; $028A8D | | passed. If not, simply return.
    CMP #$FF.b                                                                  ; $028A90 | |
    BNE +                                                                       ; $028A92 | |
    RTS                                                                         ; $028A94 |/
+   LDA r_monster_coordinates.w,X                                               ; $028A95 |\
    AND #%11110000.b                                                            ; $028A98 | | Calculate the X coordinate of the monster.
    LSR A                                                                       ; $028A9A | |
    LSR A                                                                       ; $028A9B | |
    LSR A                                                                       ; $028A9C | |
    LSR A                                                                       ; $028A9D | |
    INC A                                                                       ; $028A9E | |
    INC A                                                                       ; $028A9F | |
    STA <r_battle_generic_tmp_index_lo                                          ; $028AA0 |/
    LDA r_monster_coordinates.w,X                                               ; $028AA2 |\
    AND #%00001111.b                                                            ; $028AA5 | | Calculate the Y coordinate of the monster.
    STA <r_battle_generic_tmp_index_hi                                          ; $028AA7 |/
    LDA <r_battle_generic_tmp_index_hi                                          ; $028AA9 |\
    STA <r_math_multiply_8bit_arg_1                                             ; $028AAB | | Multiply the Y coordinate by 64, as each line has 64 bytes.
    LDA #64.b                                                                   ; $028AAD | |
    STA <r_math_multiply_8bit_arg_2                                             ; $028AAF | |
    JSR _math_multiply_8bit                                                     ; $028AB1 |/
    LDA <r_battle_generic_tmp_index_lo                                          ; $028AB4 |\
    REP #FLAG_P_ACCUMULATOR                                                     ; $028AB6 | | Calculate the address of the tilemap data for this monster by
    ASL A                                                                       ; $028AB8 | | taking the base address, adding the calculated Y value, and
    CLC                                                                         ; $028AB9 | | adding the X coordinate times two.
    ADC <r_math_multiply_8bit_result                                            ; $028ABA | |
    ADC #r_battle_tilemap_data.w                                                ; $028ABC | |
    STA <r_battle_generic_tmp_index_3                                           ; $028ABF | |
    TDC                                                                         ; $028AC1 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $028AC2 |/
    LDA r_battle_update_monster_palette_arg_slot.w                              ; $028AC4 |\
    TAX                                                                         ; $028AC7 | | Load the width and height for this monster type.
    LDA r_monster_slot_to_id_index_initial.w,X                                  ; $028AC8 | |
    ASL A                                                                       ; $028ACB | |
    TAX                                                                         ; $028ACC | |
    LDA r_monster_type_size.1.width.w,X                                         ; $028ACD | |
    STA <r_battle_generic_tmp_index_lo                                          ; $028AD0 | |
    LDA r_monster_type_size.1.height.w,X                                        ; $028AD2 | |
    STA <r_battle_generic_tmp_index_hi                                          ; $028AD5 |/
    LDA <r_battle_generic_tmp_index_lo                                          ; $028AD7 |\
    CMP #2.b                                                                    ; $028AD9 | | If the monster width is 2, set the width and height variables to 4
    BNE +                                                                       ; $028ADB | | and subtract 2 from pointer to move one tile left. The result is
    LDA #4.b                                                                    ; $028ADD | | always a 4 tile grid with the monster aligned on the top row in
    STA <r_battle_generic_tmp_index_lo                                          ; $028ADF | | the middle.
    STA <r_battle_generic_tmp_index_hi                                          ; $028AE1 | |
    REP #FLAG_P_ACCUMULATOR                                                     ; $028AE3 | |
    LDA <r_battle_generic_tmp_index_3                                           ; $028AE5 | |
    SEC                                                                         ; $028AE7 | |
    SBC #2.w                                                                    ; $028AE8 | |
    STA <r_battle_generic_tmp_index_3                                           ; $028AEB | |
    TDC                                                                         ; $028AED | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $028AEE |/
+   LDA r_battle_update_monster_palette_arg_palette.w                           ; $028AF0 |\
    ASL A                                                                       ; $028AF3 | | Shift the palette left by two bits to put it in flags format.
    ASL A                                                                       ; $028AF4 | |
    STA <r_battle_update_monster_palette_palette_flags                          ; $028AF5 |/
--  LDY #1.w                                                                    ; $028AF7 | Initialize Y to 1 to point to the flags byte.
    LDA <r_battle_generic_tmp_index_lo                                          ; $028AFA |\ Initialize the X register to the sprite width in tiles.
    TAX                                                                         ; $028AFC |/
-   LDA (<r_battle_generic_tmp_index_3),Y                                       ; $028AFD |\
    AND #%11100011.b                                                            ; $028AFF | | Update the byte with the new palette flags.
    ORA <r_battle_update_monster_palette_palette_flags                          ; $028B01 | |
    STA (<r_battle_generic_tmp_index_3),Y                                       ; $028B03 |/
    INY                                                                         ; $028B05 |\ Increment the Y register by two to move to the next tile.
    INY                                                                         ; $028B06 |/
    DEX                                                                         ; $028B07 |\ Decrement the count and loop until the line is finished.
    BNE -                                                                       ; $028B08 |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $028B0A |\
    LDA <r_battle_generic_tmp_index_3                                           ; $028B0C | | Increment the pointer by 64 to move to the next line.
    CLC                                                                         ; $028B0E | |
    ADC #64.w                                                                   ; $028B0F | |
    STA <r_battle_generic_tmp_index_3                                           ; $028B12 | |
    TDC                                                                         ; $028B14 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $028B15 |/
    DEC <r_battle_generic_tmp_index_hi                                          ; $028B17 |\ Loop until all lines have been updated.
    BNE --                                                                      ; $028B19 |/
    RTS                                                                         ; $028B1B

; _battle_initialize_graphics ($02:8B1C)
;
; Initializes various aspects of the battle graphics, including the background,
; loading various tiles and sprites, loading the monster tilemaps, and
; transferring everything to VRAM.
_battle_initialize_graphics:
    JSR _copy_battle_background_to_vram                                         ; $028B1C | Load the battle background and transfer it to VRAM.
    JSR _battle_copy_dialog_tiles_to_vram                                       ; $028B1F | Load the BG3 dialog tiles.
    JSR _copy_bg2_dialog_tiles_to_vram                                          ; $028B22 | Load the BG2 dialog tiles.
    JSR _copy_battle_sprite_icons_to_vram                                       ; $028B25 | Load the battle sprite icons.
    JSR _battle_load_monster_sprites                                            ; $028B28 | Load the monster sprite data.
    JSR _load_status_battle_sprites                                             ; $028B2B | Load additional sprites used for monster status effects.
    JSR _battle_prepare_monster_tilemap                                         ; $028B2E | Initialize the monster tilemap and load the monster sprites.
    LDX #(18 * 64).w                                                            ; $028B31 |\
    STX <r_battle_start_vram_dma5_arg_bytes                                     ; $028B34 | | Copy the monster tilemap to VRAM on BG1.
    LDA #:r_battle_tilemap_data                                                 ; $028B36 | |
    LDX #r_battle_tilemap_data.w                                                ; $028B38 | |
    LDY #$6000.w                                                                ; $028B3B | |
    JSR _start_vram_dma5                                                        ; $028B3E |/
    JMP _set_monster_cursor_coordinates                                         ; $028B41 | Set the monster cursor coordinates.

; _load_status_battle_sprites ($02:8B44)
;
; Loads some miscellaneous battle sprites, including the TinyMage, TinyToad, pig
; and egg sprites used on monsters with the associated status as well as some
; shadow tiles used for floating monsters.
_load_status_battle_sprites:
    LDX #40.w                                                                   ; $028B44 |\
    STX <r_battle_copy_3bpp_to_vram_arg_tiles                                   ; $028B47 | | Transfer 40 tiles from ROM starting at $09:8000 to $4290 in VRAM.
    LDX #bank09.battle_sprite_monster_tinymage_data.w                           ; $028B49 | | This transfers the TinyMage, TinyToad, pig and egg sprites for use
    LDY #$4290.w                                                                ; $028B4C | | on monsters that have the respective status.
    LDA #:bank09.battle_sprite_monster_tinymage_data.b                          ; $028B4F | |
    JSR _battle_copy_3bpp_to_vram                                               ; $028B51 |/
    LDX #2.w                                                                    ; $028B54 |\
    STX <r_battle_copy_3bpp_to_vram_arg_tiles                                   ; $028B57 | | Transfers two tiles of the battle icons set from ROM to VRAM.
    LDX #bank0C.battle_sprite_icon_data.w + 24 * 58                             ; $028B59 | | Specifically, the two lowest shadow tiles are copied.
    LDY #$4510.w                                                                ; $028B5C | |
    LDA #:bank0C.battle_sprite_icon_data.b                                      ; $028B5F | |
    JSR _battle_copy_3bpp_to_vram                                               ; $028B61 |/
    TDC                                                                         ; $028B64 |\
    TAX                                                                         ; $028B65 | | Zero out the in-RAM shadow tiles.
-   STA r_battle_shadow_tiles.w,X                                               ; $028B66 | |
    INX                                                                         ; $028B69 | |
    CPX #_sizeof_r_battle_shadow_tiles.w                                        ; $028B6A | |
    BNE -                                                                       ; $028B6D |/
    LDX #8.w                                                                    ; $028B6F |\
    STX <r_battle_copy_3bpp_to_ram_arg_tiles                                    ; $028B72 | | Copy the full set of eight shadow tiles to RAM.
    LDY #bank0C.battle_sprite_icon_data.w + 24 * 58                             ; $028B74 | |
    LDX #r_battle_shadow_tiles.w                                                ; $028B77 | |
    LDA #:bank0C.battle_sprite_icon_data.b                                      ; $028B7A | |
    JMP _battle_copy_3bpp_to_ram                                                ; $028B7C |/

; _set_monster_cursor_coordinates ($02:8B7F)
;
; Loops through the eight monster slots, setting the coordinates for each
; monster's cursors.
_set_monster_cursor_coordinates:
    TDC                                                                         ; $028B7F |\ Initialize the X register to zero.
    TAX                                                                         ; $028B80 |/
-   TXA                                                                         ; $028B81 |\
    ASL A                                                                       ; $028B82 | | Set the Y register to twice the value in the X register.
    TAY                                                                         ; $028B83 |/
    LDA r_monster_slot_to_id_index_pre_action.w,X                               ; $028B84 |\
    CMP #$FF.b                                                                  ; $028B87 | | If this slot is empty, skip to the next part of the loop.
    BEQ +                                                                       ; $028B89 |/
    PHY                                                                         ; $028B8B | Preserve the value of the Y register.
    ASL A                                                                       ; $028B8C |\ Set the Y register to the monster type index times two.
    TAY                                                                         ; $028B8D |/
    LDA r_monster_type_size.1.height.w,Y                                        ; $028B8E |\
    ASL A                                                                       ; $028B91 | | Multiply the tile height by four to get half the height in pixels.
    ASL A                                                                       ; $028B92 |/
    SEC                                                                         ; $028B93 |\
    SBC #4.b                                                                    ; $028B94 | | Subtract four (half a tile) and save the value for later.
    STA <r_battle_generic_tmp_index_lo                                          ; $028B96 |/
    PLY                                                                         ; $028B98 | Restore the value of the Y register.
    LDA r_monster_coordinates.w,X                                               ; $028B99 |\
    AND #%00001111.b                                                            ; $028B9C | | Set the Y coordinate of this monster's cursor to the monster's Y
    ASL A                                                                       ; $028B9E | | coordinate (in pixels) plus the previously calculated value, which
    ASL A                                                                       ; $028B9F | | will center the cursor vertically.
    ASL A                                                                       ; $028BA0 | |
    CLC                                                                         ; $028BA1 | |
    ADC <r_battle_generic_tmp_index_lo                                          ; $028BA2 | |
    STA r_battle_monster_cursor_coordinates.1.y.w,Y                             ; $028BA4 |/
    LDA r_monster_coordinates.w,X                                               ; $028BA7 |\
    AND #%11110000.b                                                            ; $028BAA | | Set the X coordinate of the cursor to the monster's X coordinate
    LSR A                                                                       ; $028BAC | | in pixels plus eight.
    CLC                                                                         ; $028BAD | |
    ADC #8.b                                                                    ; $028BAE | |
    STA r_battle_monster_cursor_coordinates.1.x.w,Y                             ; $028BB0 | |
    BRA ++                                                                      ; $028BB3 |/
+   LDA #$FF.b                                                                  ; $028BB5 |\
    STA r_battle_monster_cursor_coordinates.1.x.w,Y                             ; $028BB7 | | If the slot was empty, set both cursor coordinates to $FF.
    STA r_battle_monster_cursor_coordinates.1.y.w,Y                             ; $028BBA |/
++  INX                                                                         ; $028BBD |\
    CPX #_sizeof_r_monster_coordinates.w                                        ; $028BBE | | Loop until all eight monster slots have been examined.
    BNE -                                                                       ; $028BC1 |/
    JSR _battle_set_coordinates                                                 ; $028BC3 | Set various coordinates.
    RTS                                                                         ; $028BC6

; _flip_battle_monster_tilemap ($02:8BC7)
;
; Proxy function to call the flip_battle_monster_tilemap function in bank 1.
_flip_battle_monster_tilemap:
    JSL bank01.flip_battle_monster_tilemap                                      ; $028BC7
    RTS                                                                         ; $028BCB

; _battle_load_monster_variable_tilemap ($02:8BCC)
;
; Loads and sets in the tilemap mirror in RAM the tilemap for a variable monster
; sprite. The index of the variable sprite is passed in the accumulator and the
; monster slot is passed in the Y register.
_battle_load_monster_variable_tilemap:
    STA r_battle_load_monster_variable_tilemap_index.w                          ; $028BCC | Save the variable sprite properties index to memory.
    STY r_battle_load_monster_variable_tilemap_slot.w                           ; $028BCF | Save the monster slot to memory.
    STA <r_math_multiply_8bit_arg_1                                             ; $028BD2 |\
    LDA #_sizeof_variable_sprite_properties.b                                   ; $028BD4 | | Prepare to calculate the offset into variable sprite properties.
    STA <r_math_multiply_8bit_arg_2                                             ; $028BD6 |/
    LDA #$20.b                                                                  ; $028BD8 |\ Set the default tile flags to set the priority to 1.
    STA r_battle_load_monster_variable_tilemap_tile_flags.w                     ; $028BDA |/
    JSR _math_multiply_8bit                                                     ; $028BDD |\ Finish the multiplication and copy the resulting index into the X
    LDX <r_math_multiply_8bit_result                                            ; $028BE0 |/ register.
    TDC                                                                         ; $028BE2 |\ Initialize the Y register to zero.
    TAY                                                                         ; $028BE3 |/
-   LDA bank0F.variable_sprite_properties_data.l,X                              ; $028BE4 |\
    STA r_variable_sprite_properties.w,Y                                        ; $028BE8 | | Copy the variable sprite properties to RAM.
    INX                                                                         ; $028BEB | |
    INY                                                                         ; $028BEC | |
    CPY #_sizeof_variable_sprite_properties.w                                   ; $028BED | |
    BNE -                                                                       ; $028BF0 |/
    LDA r_variable_sprite_properties.size_index.w                               ; $028BF2 |\
    BPL +                                                                       ; $028BF5 | | If the high bit of the size index is set, reset the tilemap.
    JSR _init_battle_tilemap                                                    ; $028BF7 |/
+   LDA r_variable_sprite_properties.type_transition.w                          ; $028BFA |\
    AND #MONSTER_VARIABLE_SPRITE_TYPE_TRANSITION_TYPE.b                         ; $028BFD | | Extract the monster type index from the variable sprite properties
    LSR A                                                                       ; $028BFF | | and save it both to RAM and to the X register.
    LSR A                                                                       ; $028C00 | |
    LSR A                                                                       ; $028C01 | |
    LSR A                                                                       ; $028C02 | |
    STA <r_battle_load_monster_variable_tilemap_type_index                      ; $028C03 | |
    TAX                                                                         ; $028C05 |/
    LDA r_variable_sprite_properties.palette_index.w                            ; $028C06 |\ Set the monster's palette index.
    STA r_monster_type_palette.w,X                                              ; $028C09 |/
    INX                                                                         ; $028C0C |\
    INX                                                                         ; $028C0D | | Increment the X register by 3 to determine this monster's palette
    INX                                                                         ; $028C0E | | number and load the associated palette.
    JSR _battle_load_monster_palette                                            ; $028C0F |/
    LDA <r_battle_load_monster_variable_tilemap_type_index                      ; $028C12 |\
    ASL A                                                                       ; $028C14 | | Set the Y register to the monster type index times two.
    TAY                                                                         ; $028C15 |/
    LDA r_variable_sprite_properties.size_index.w                               ; $028C16 |\
    AND #MONSTER_VARIABLE_SPRITE_SIZE_INDEX.b                                   ; $028C19 | | Set the X register to the size index times two.
    ASL A                                                                       ; $028C1B | |
    TAX                                                                         ; $028C1C |/
    LDA bank0D.battle_sprite_size_data.l + size.width,X                         ; $028C1D |\
    STA <r_battle_generic_tmp_index_lo                                          ; $028C21 | | Load the sprite's width.
    STA r_monster_type_size.1.width.w,Y                                         ; $028C23 |/
    LDA bank0D.battle_sprite_size_data.l + size.height,X                        ; $028C26 |\
    STA <r_battle_generic_tmp_index_hi                                          ; $028C2A | | Load the sprite's height.
    STA r_monster_type_size.1.height.w,Y                                        ; $028C2C |/
    PHY                                                                         ; $028C2F |\
    LDY r_battle_load_monster_variable_tilemap_slot.w                           ; $028C30 | | Copy the coordinates to the monster coordinates area in RAM.
    LDA r_variable_sprite_properties.coordinates.w                              ; $028C33 | |
    STA r_monster_coordinates.w,Y                                               ; $028C36 | |
    PLY                                                                         ; $028C39 |/
    LDA r_variable_sprite_properties.coordinates.w                              ; $028C3A |\
    AND #%11110000.b                                                            ; $028C3D | | Determine the monster's X coordinate (in tiles) by masking the
    LSR A                                                                       ; $028C3F | | relevant bits, shifting right, and incrementing by two, saving the
    LSR A                                                                       ; $028C40 | | result in a temporary variable.
    LSR A                                                                       ; $028C41 | |
    LSR A                                                                       ; $028C42 | |
    INC A                                                                       ; $028C43 | |
    INC A                                                                       ; $028C44 | |
    STA <r_battle_load_monster_tilemaps_offset_lo                               ; $028C45 |/
    LDA r_variable_sprite_properties.coordinates.w                              ; $028C47 |\
    AND #%00001111.b                                                            ; $028C4A | | Get the monster's Y coordinate and save it temporarily.
    STA <r_battle_load_monster_tilemaps_offset_hi                               ; $028C4C |/
    LDA <r_battle_load_monster_tilemaps_offset_hi                               ; $028C4E |\
    STA <r_math_multiply_8bit_arg_1                                             ; $028C50 | | Multiply the Y coordinates by 64 to determine the base offset for
    LDA #64.b                                                                   ; $028C52 | | that row number.
    STA <r_math_multiply_8bit_arg_2                                             ; $028C54 | |
    JSR _math_multiply_8bit                                                     ; $028C56 |/
    LDA <r_battle_load_monster_tilemaps_offset_lo                               ; $028C59 |\
    ASL A                                                                       ; $028C5B | | Calculate the offset into the tilemap data in RAM by taking the
    REP #FLAG_P_ACCUMULATOR                                                     ; $028C5C | | base tilemap address, adding the previously calculated row offset,
    CLC                                                                         ; $028C5E | | and then adding the X coordinate multiplied by two (as each tile
    ADC <r_math_multiply_8bit_result                                            ; $028C5F | | uses two bytes).
    ADC #r_battle_tilemap_data.w                                                ; $028C61 | |
    STA <r_battle_load_monster_tilemaps_offset                                  ; $028C64 | |
    TDC                                                                         ; $028C66 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $028C67 |/
    LDA <r_battle_load_monster_variable_tilemap_type_index                      ; $028C69 |\
    INC A                                                                       ; $028C6B | | Set the default flags value by taking the monster type index,
    INC A                                                                       ; $028C6C | | adding three to get the palette index for that monster type, and
    INC A                                                                       ; $028C6D | | then shifting left twice to put the palette bits in the right
    ASL A                                                                       ; $028C6E | | spot for tilemap flags.
    ASL A                                                                       ; $028C6F | |
    STA <r_battle_load_monster_tilemaps_flags                                   ; $028C70 |/
    LDA r_variable_sprite_properties.size_index.w                               ; $028C72 |\
    AND #MONSTER_VARIABLE_SPRITE_SIZE_HIGH.b                                    ; $028C75 | | Set the base tile number to $100 if the second highest bit of the
    BEQ +                                                                       ; $028C77 | | size index is set.
    INC <r_battle_load_monster_tilemaps_flags                                   ; $028C79 |/
+   LDA <r_battle_load_monster_tilemaps_type_index                              ; $028C7B |\
    TAX                                                                         ; $028C7D | | Load the base tile number for this monster type and save it to a
    LDA r_monster_type_vram_base_tile.w,X                                       ; $028C7E | | local variable.
    STA <r_battle_load_monster_tilemaps_base_tile                               ; $028C81 |/
    LDA r_variable_sprite_properties.layout_index.w                             ; $028C83 |\
    ASL A                                                                       ; $028C86 | | Set the X register to the layout index times two.
    TAX                                                                         ; $028C87 |/
    LDA bank0E.variable_sprite_layout_offset_data.l + 0,X                       ; $028C88 |\
    STA <r_battle_load_monster_variable_tilemap_ptr_lo                          ; $028C8C | | Load the pointer to the layout data.
    LDA bank0E.variable_sprite_layout_offset_data.l + 1,X                       ; $028C8E | |
    STA <r_battle_load_monster_variable_tilemap_ptr_hi                          ; $028C92 | |
    LDA #:bank0E.variable_sprite_layout_offset_data                             ; $028C94 | |
    STA <r_battle_load_monster_variable_tilemap_ptr_bank                        ; $028C96 |/
    TDC                                                                         ; $028C98 |\ Initialize the X register to zero.
    TAX                                                                         ; $028C99 |/
    STZ <r_battle_load_monster_variable_tilemap_fetch_count                     ; $028C9A | Zero out the count variable.
--  LDA <r_battle_generic_tmp_index_lo                                          ; $028C9C |\ Set the second count to the width of the sprite.
    STA <r_battle_load_monster_variable_tilemap_count                           ; $028C9E |/
    LDY #0.w                                                                    ; $028CA0 | Initialize the Y register to zero.
-   JSR _battle_load_monster_variable_tilemap_fetch                             ; $028CA3 |\ Fetch the next tilemap byte and store it in the tilemap area in
    STA (<r_battle_load_monster_tilemaps_offset),Y                              ; $028CA6 |/ RAM.
    INY                                                                         ; $028CA8 | Increment the Y register to move to the flags byte.
    LDA <r_battle_load_monster_tilemaps_flags                                   ; $028CA9 |\
    AND <r_battle_load_monster_variable_tilemap_fetch_flag_mask                 ; $028CAB | | Set the flags byte equal to the palette and high bit, with the high
    ORA <r_battle_load_monster_variable_tilemap_fetch_flags                     ; $028CAD | | bit potentially masked out, and then add in the returned flags and
    ORA <r_math_multiply_8bit_result                                            ; $028CAF | | any overflow tile number. Store it in the tilemap.
    STA (<r_battle_load_monster_tilemaps_offset),Y                              ; $028CB1 |/
    INY                                                                         ; $028CB3 | Increment the Y register to move to the next tile byte.
    DEC <r_battle_load_monster_variable_tilemap_count                           ; $028CB4 |\ Loop until an entire row of the sprite has been set.
    BNE -                                                                       ; $028CB6 |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $028CB8 |\
    LDA <r_battle_load_monster_tilemaps_offset                                  ; $028CBA | | Add 64 to the tilemap offset to move to the next line of the
    CLC                                                                         ; $028CBC | | tilemap.
    ADC #64.w                                                                   ; $028CBD | |
    STA <r_battle_load_monster_tilemaps_offset                                  ; $028CC0 | |
    TDC                                                                         ; $028CC2 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $028CC3 |/
    LDA r_battle_zeromus_dead.w                                                 ; $028CC5 |\
    BNE +                                                                       ; $028CC8 | | If Zeromus has been flagged dead or if this is the final Zeromus
    LDA r_battle_load_monster_variable_tilemap_index.w                          ; $028CCA | | sprite and there are three rows left, set the default tile flags
    CMP #VARIABLE_SPRITE_ZEROMUS.b                                              ; $028CCD | | to zero, which will result in the tiles having a priority of zero
    BNE ++                                                                      ; $028CCF | | instead of a priority of 1.
    LDA <r_battle_generic_tmp_index_hi                                          ; $028CD1 | |
    CMP #4.b                                                                    ; $028CD3 | |
    BNE ++                                                                      ; $028CD5 | |
+   STZ r_battle_load_monster_variable_tilemap_tile_flags.w                     ; $028CD7 |/
++  DEC <r_battle_generic_tmp_index_hi                                          ; $028CDA |\ Decrement the height variable and loop until it reaches zero.
    BNE --                                                                      ; $028CDC |/
    JMP _battle_set_monster_size                                                ; $028CDE | Update the size of all eight monster slots and return.

; _battle_load_monster_variable_tilemap_fetch ($02:8CE1)
;
; While reading a variable monster sprite tilemap, returns the next value in the
; tilemap in the accumulator, and sets a flag mask and flags variable with flags
; that should be incorporated into the tilemap. The function decodes the tilemap
; and simply returns the next tile.
_battle_load_monster_variable_tilemap_fetch:
    STZ <r_math_multiply_8bit_result                                            ; $028CE1 | Zero out a variable used an overflow location.
    LDA <r_battle_load_monster_variable_tilemap_fetch_count                     ; $028CE3 |\ If the current pending count is zero, branch forward to fetch the
    BEQ +                                                                       ; $028CE5 |/ next byte.
    DEC <r_battle_load_monster_variable_tilemap_fetch_count                     ; $028CE7 | Decrease the pending count.
    LDA #%11111110.b                                                            ; $028CE9 |\ Set the flag mask to mask out the lower high tile number bit.
    STA <r_battle_load_monster_variable_tilemap_fetch_flag_mask                 ; $028CEB |/
    LDA #%00000010.b                                                            ; $028CED |\
    ORA r_battle_load_monster_variable_tilemap_tile_flags.w                     ; $028CEF | | Set the new flags to set the tile number to $200 priority 1.
    STA <r_battle_load_monster_variable_tilemap_fetch_flags                     ; $028CF2 |/
    TDC                                                                         ; $028CF4 |\ Return a tile number of $00 (a blank tile).
    RTS                                                                         ; $028CF5 |/
+   PHY                                                                         ; $028CF6 |\
    PHX                                                                         ; $028CF7 | | Preserve the value of the Y register and transfer X to Y.
    PLY                                                                         ; $028CF8 |/
    LDA [<r_battle_load_monster_variable_tilemap_ptr],Y                         ; $028CF9 |\
    CMP #$FF.b                                                                  ; $028CFB | | Read the next byte and branch to the correct code depending on its
    BEQ +                                                                       ; $028CFD | | value.
    CMP #$FE.b                                                                  ; $028CFF | |
    BNE ++                                                                      ; $028D01 |/
    INY                                                                         ; $028D03 |\
    LDA [<r_battle_load_monster_variable_tilemap_ptr],Y                         ; $028D04 | | If the value was $FE, read the next byte and set its value minus
    DEC A                                                                       ; $028D06 | | one to the pending count variable, so later calls will know that
    STA <r_battle_load_monster_variable_tilemap_fetch_count                     ; $028D07 | | many more blanks are required.
    INX                                                                         ; $028D09 |/
+   LDA #%11111110.b                                                            ; $028D0A |\
    STA <r_battle_load_monster_variable_tilemap_fetch_flag_mask                 ; $028D0C | | If the value was $FE or $FF, set the flags and accumulator to
    LDA #%00000010.b                                                            ; $028D0E | | return a blank tile (with the value of $200). The flag mask is set
    ORA r_battle_load_monster_variable_tilemap_tile_flags.w                     ; $028D10 | | to mask out the first high tile bit (or else the value might be
    STA <r_battle_load_monster_variable_tilemap_fetch_flags                     ; $028D13 | | $300). Afterward, jump to nearly the end of the function.
    TDC                                                                         ; $028D15 | |
    BRA +                                                                       ; $028D16 |/
++  PHA                                                                         ; $028D18 |\
    LDA #%11111111.b                                                            ; $028D19 | | For all other values, set the flag mask to not mask out any bits,
    STA <r_battle_load_monster_variable_tilemap_fetch_flag_mask                 ; $028D1B | | and to keep the tile flags set to whatever the default was (sets
    LDA r_battle_load_monster_variable_tilemap_tile_flags.w                     ; $028D1D | | the priority to 1).
    STA <r_battle_load_monster_variable_tilemap_fetch_flags                     ; $028D20 | |
    PLA                                                                         ; $028D22 |/
    CLC                                                                         ; $028D23 |\ Set the tile number to the base, plus the read value.
    ADC <r_battle_load_monster_tilemaps_base_tile                               ; $028D24 |/
    ROL <r_math_multiply_8bit_result                                            ; $028D26 | Put any overflow into the overflow variable.
+   INX                                                                         ; $028D28 | Increment the X register.
    PLY                                                                         ; $028D29 | Restore the Y register.
    RTS                                                                         ; $028D2A

; battle_load_monster_tilemaps ($02:8D2B)
;
; Proxy function to call _battle_load_monster_tilemaps from another bank, which
; draws the tilemaps for the eight monster slots to RAM.
battle_load_monster_tilemaps:
    JSR _battle_load_monster_tilemaps                                           ; $028D2B | Call the function to load monster tilemaps.
    RTL                                                                         ; $028D2E

; _battle_prepare_monster_tilemap ($02:8D2F)
;
; Loads the monster tilemaps to the battle tilemap area in RAM, flips the
; tilemap if appropriate, shifts the tilemap if appropriate, and also will
; display any character apparitions through the functions it calls.
_battle_prepare_monster_tilemap:
    JSR _battle_load_monster_tilemaps                                           ; $028D2F | Load the monster tilemaps for the battle.
    JMP _flip_battle_monster_tilemap                                            ; $028D32 | Flip the monster tilemap if this is a back attack.

; _battle_load_monster_tilemaps ($02:8D35)
;
; Loops through the eight monster slots, drawing the relevant tilemaps to the
; tilemap area in RAM. Also is responsible for drawing any configured character
; apparitions.
_battle_load_monster_tilemaps:
    JSR _init_battle_tilemap                                                    ; $028D35 | Initialize the battle tilemap to blank tiles.
    LDA r_battle_disable_monster_drawing.w                                      ; $028D38 |\ Skip drawing the monsters if monster drawing is disabled.
    BNE @done                                                                   ; $028D3B |/
    TDC                                                                         ; $028D3D |\ Initialize the X register to zero.
    TAX                                                                         ; $028D3E |/
@start:
    PHX                                                                         ; $028D3F | Preserve the value of the X register.
    TXA                                                                         ; $028D40 |\ Copy the X register to memory for later use.
    STA <r_battle_load_monster_tilemaps_slot                                    ; $028D41 |/
    LDA r_monster_slot_to_id_index.w,X                                          ; $028D43 |\
    CMP #$FF.b                                                                  ; $028D46 | | If this slot doesn't have a monster in it, skip to the next loop.
    BEQ @next                                                                   ; $028D48 |/
    STA <r_battle_load_monster_tilemaps_type_index                              ; $028D4A | Save the monster's type index to memory.
    TAX                                                                         ; $028D4C |\
    LDA r_monster_ids_original.w,X                                              ; $028D4D | | Set the X register to this monster's ID times four.
    JSR _set_x_to_a_times_four                                                  ; $028D50 |/
    LDA bank0F.monster_sprite_properties_data.l + 0,X                           ; $028D53 |\ If the monster does not use a variable tilemap, skip forward to
    BPL ++                                                                      ; $028D57 |/ later code.
    LDA <r_battle_load_monster_tilemaps_slot                                    ; $028D59 |\ Load the slot number and store it in the Y register.
    TAY                                                                         ; $028D5B |/
    LDA r_monster_variable_sprite_index.w,Y                                     ; $028D5C |\
    CMP #$FF.b                                                                  ; $028D5F | | If the variable sprite index of this monster has not yet already
    BNE +                                                                       ; $028D61 | | been loaded from ROM, do so and save it to RAM.
    LDA bank0F.monster_sprite_properties_data.l + 0,X                           ; $028D63 | |
    AND #MONSTER_SPRITE_SIZE_INDEX.b                                            ; $028D67 | |
    STA r_monster_variable_sprite_index.w,Y                                     ; $028D69 |/
+   JSR _battle_load_monster_variable_tilemap                                   ; $028D6C | Load the variable tilemap associated with this monster.
    JMP @next                                                                   ; $028D6F | Skip to the next loop.
++  LDA <r_battle_load_monster_tilemaps_type_index                              ; $028D72 |\ Set the X register to the monster's type index.
    TAX                                                                         ; $028D74 |/
    ASL A                                                                       ; $028D75 |\ Set the Y register to the monster's type index times two.
    TAY                                                                         ; $028D76 |/
    LDA r_monster_type_size.1.width.w,Y                                         ; $028D77 |\
    STA <r_battle_load_monster_tilemaps_size.width                              ; $028D7A | | Copy the monster's width and height to local variables.
    LDA r_monster_type_size.1.height.w,Y                                        ; $028D7C | |
    STA <r_battle_load_monster_tilemaps_size.height                             ; $028D7F |/
    PLX                                                                         ; $028D81 |\ Restore the slot to the X register and save it again.
    PHX                                                                         ; $028D82 |/
    LDA r_monster_coordinates.w,X                                               ; $028D83 |\
    AND #%00001111.b                                                            ; $028D86 | | Set the monster's Y coordinate.
    STA <r_battle_load_monster_tilemaps_coordinates.y                           ; $028D88 |/
    LDA r_monster_coordinates.w,X                                               ; $028D8A |\
    AND #%11110000.b                                                            ; $028D8D | | Set the monster's X coordinate.
    LSR A                                                                       ; $028D8F | |
    LSR A                                                                       ; $028D90 | |
    LSR A                                                                       ; $028D91 | |
    LSR A                                                                       ; $028D92 | |
    INC A                                                                       ; $028D93 | |
    INC A                                                                       ; $028D94 | |
    STA <r_battle_load_monster_tilemaps_coordinates.x                           ; $028D95 |/
    JSR _battle_load_monster_fixed_tilemap                                      ; $028D97 | Load the monster's tilemap.
@next:
    PLX                                                                         ; $028D9A |\
    INX                                                                         ; $028D9B | | Loop until all eight monster slots have been handled.
    CPX #8.w                                                                    ; $028D9C | |
    BNE @start                                                                  ; $028D9F |/
@done:
    JSL bank01.battle_draw_character_apparitions                                ; $028DA1 | Draw any configured character apparitions to the tilemap.
    JMP _battle_set_monster_size                                                ; $028DA5

; _battle_load_monster_fixed_tilemap ($02:8DA8)
;
; Loads the tilemap associated with the 8-bit monster slot passed in $02 and
; stores it in the RAM mirror of the tilemap at the coordinates passed in $04
; and $05. Additionally, the base size should be stored in $00 and $01, but
; this will be overridden as necessary.
_battle_load_monster_fixed_tilemap:
    LDA <r_battle_load_monster_tilemaps_slot                                    ; $028DA8 |\
    STA <r_math_multiply_8bit_arg_1                                             ; $028DAA | | Set the X register to the offset to this monster's battle stats
    LDA #_sizeof_character_battle.b                                             ; $028DAC | | record.
    STA <r_math_multiply_8bit_arg_2                                             ; $028DAE | |
    JSR _math_multiply_8bit                                                     ; $028DB0 | |
    LDX <r_math_multiply_8bit_result                                            ; $028DB3 |/
    LDA r_character_battle.6.status_3.w,X                                       ; $028DB5 |\
    AND #STATUS_3_EGG.b                                                         ; $028DB8 | | Determine if the monster is currently an egg, small, toad or pig
    BNE +                                                                       ; $028DBA | | and if not, branch to the relevant code sequence. If the monster
    LDA r_character_battle.6.status_1.w,X                                       ; $028DBC | | is a small, toad or pig, save the status variable to another
    AND #STATUS_1_SMALL | STATUS_1_TOAD | STATUS_1_PIG.b                        ; $028DBF | | variable for later use in calculating the base tile.
    BEQ @no_status                                                              ; $028DC1 | |
    STA <r_battle_load_monster_tilemaps_base_tile                               ; $028DC3 |/
+   LDA <r_battle_load_monster_tilemaps_size.width                              ; $028DC5 |\
    LSR A                                                                       ; $028DC7 | | Add half the width, minus one to the X coordinate.
    DEC A                                                                       ; $028DC8 | |
    CLC                                                                         ; $028DC9 | |
    ADC <r_battle_load_monster_tilemaps_coordinates.x                           ; $028DCA | |
    STA <r_battle_load_monster_tilemaps_coordinates.x                           ; $028DCC |/
    LDA <r_battle_load_monster_tilemaps_size.height                             ; $028DCE |\
    LSR A                                                                       ; $028DD0 | | Add half the height, minus one to the Y coordinate.
    DEC A                                                                       ; $028DD1 | |
    CLC                                                                         ; $028DD2 | |
    ADC <r_battle_load_monster_tilemaps_coordinates.y                           ; $028DD3 | |
    STA <r_battle_load_monster_tilemaps_coordinates.y                           ; $028DD5 |/
    LDA #2.b                                                                    ; $028DD7 |\
    STA <r_battle_load_monster_tilemaps_size.width                              ; $028DD9 | | Set the monster's size to 2x2.
    STA <r_battle_load_monster_tilemaps_size.height                             ; $028DDB |/
    LDA #%00111010.b                                                            ; $028DDD |\ Set the tile flags to use palette 6, and to set the base tile
    STA <r_battle_load_monster_tilemaps_flags                                   ; $028DDF |/ number to $200.
    LDA r_character_battle.6.status_3.w,X                                       ; $028DE1 |\
    AND #STATUS_3_EGG.b                                                         ; $028DE4 | | If the monster status is not an egg, skip this next block of code.
    BEQ +                                                                       ; $028DE6 |/
    DEC <r_battle_load_monster_tilemaps_coordinates.x                           ; $028DE8 |\ If the monster was an egg, decrement the coordinates by one, as the
    DEC <r_battle_load_monster_tilemaps_coordinates.y                           ; $028DEA |/ egg is larger than the other alternate sprites.
    LDA #4.b                                                                    ; $028DEC |\
    STA <r_battle_load_monster_tilemaps_size.width                              ; $028DEE | | Set the width and height to 4.
    STA <r_battle_load_monster_tilemaps_size.height                             ; $028DF0 |/
    LDA #BATTLE_BASE_TILE_EGG.b                                                 ; $028DF2 | Set the base tile number for the egg.
    BRA ++                                                                      ; $028DF4 | Skip ahead to the next set of code.
+   LDA <r_battle_load_monster_tilemaps_base_tile                               ; $028DF6 |\
    AND #STATUS_1_TOAD.b                                                        ; $028DF8 | | If the monster is a toad, set the base tile to the toad base tile.
    BEQ +                                                                       ; $028DFA | |
    LDA #BATTLE_BASE_TILE_TOAD.b                                                ; $028DFC | |
    BRA ++                                                                      ; $028DFE |/
+   LDA <r_battle_load_monster_tilemaps_base_tile                               ; $028E00 |\
    AND #STATUS_1_SMALL.b                                                       ; $028E02 | | If the monster is not small (and therefore a pig), decrease the
    BNE +                                                                       ; $028E04 | | coordinates and set the size explicily to 4x4. Additionally set
    DEC <r_battle_load_monster_tilemaps_coordinates.x                           ; $028E06 | | the tile number to the base tile number for the pig.
    DEC <r_battle_load_monster_tilemaps_coordinates.y                           ; $028E08 | |
    LDA #4.b                                                                    ; $028E0A | |
    STA <r_battle_load_monster_tilemaps_size.width                              ; $028E0C | |
    STA <r_battle_load_monster_tilemaps_size.height                             ; $028E0E | |
    LDA #BATTLE_BASE_TILE_PIG.b                                                 ; $028E10 | |
    BRA ++                                                                      ; $028E12 |/
+   LDA #BATTLE_BASE_TILE_SMALL.b                                               ; $028E14 | Otherwise, set the tile number for the small sprite.
++  STA <r_battle_load_monster_tilemaps_base_tile                               ; $028E16 | Regardless, store the value that has been set in the accumulator.
    BRA +                                                                       ; $028E18 | Branch forward past the no status-specific code.
@no_status:
    LDA <r_battle_load_monster_tilemaps_type_index                              ; $028E1A |\ Load the monster type index into the X register.
    TAX                                                                         ; $028E1C |/
    LDA r_monster_type_vram_flags.w,X                                           ; $028E1D |\ Load the monster's specific flags.
    STA <r_battle_load_monster_tilemaps_flags                                   ; $028E20 |/
    LDA r_monster_type_vram_base_tile.w,X                                       ; $028E22 |\ Load the monter type's sepecific base tile.
    STA <r_battle_load_monster_tilemaps_base_tile                               ; $028E25 |/
    LDA r_formation_flags2_copy_2.w                                             ; $028E27 |\
    AND #FORMATION_FLAGS_2_CHARACTER_SPRITE.b                                   ; $028E2A | | If the formation flags have the character sprite bit set, toggle
    BEQ +                                                                       ; $028E2C | | the horizontal flip bit in the tile flags, and load the character
    JSR _calculate_battle_tilemap_address                                       ; $028E2E | | sprite tilemap, returning afterward.
    LDA <r_battle_load_monster_tilemaps_flags                                   ; $028E31 | |
    EOR #%01000000.b                                                            ; $028E33 | |
    STA <r_battle_load_monster_tilemaps_flags                                   ; $028E35 | |
    JSL bank01.battle_load_monster_character_sprite_tilemap                     ; $028E37 | |
    RTS                                                                         ; $028E3B |/
+   JSR _calculate_battle_tilemap_address                                       ; $028E3C | Otherwise, calculate the tilemap address.
--  LDA <r_battle_load_monster_tilemaps_size.width                              ; $028E3F |\ Set the X register to the sprite width.
    TAX                                                                         ; $028E41 |/
    TDC                                                                         ; $028E42 |\ Initialize the Y register to zero.
    TAY                                                                         ; $028E43 |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $028E44 |\
-   LDA <r_battle_load_monster_tilemaps_base_tile                               ; $028E46 | | Loop through the row, setting the tiles in consecutive order,
    STA (<r_battle_load_monster_tilemaps_offset),Y                              ; $028E48 | | starting at the base tile on the first row, and incrementing the
    INY                                                                         ; $028E4A | | tile number after each byte. The Y register is incremented twice
    INY                                                                         ; $028E4B | | to skip the flags byte.
    INC <r_battle_load_monster_tilemaps_base_tile                               ; $028E4C | |
    DEX                                                                         ; $028E4E | |
    BNE -                                                                       ; $028E4F |/
    LDA <r_battle_load_monster_tilemaps_offset                                  ; $028E51 |\
    CLC                                                                         ; $028E53 | | Add 64 to the offset to move to the next row.
    ADC #64.w                                                                   ; $028E54 | |
    STA <r_battle_load_monster_tilemaps_offset                                  ; $028E57 |/
    TDC                                                                         ; $028E59 |\
    SEP #FLAG_P_ACCUMULATOR                                                     ; $028E5A | | Loop until all rows have been completed.
    DEC <r_battle_load_monster_tilemaps_size.height                             ; $028E5C | |
    BNE --                                                                      ; $028E5E |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $028E60 |\
    LDA <r_battle_load_monster_tilemaps_offset                                  ; $028E62 | | Increment the tilemap offset by 64 to move to the next row.
    CLC                                                                         ; $028E64 | |
    ADC #64.w                                                                   ; $028E65 | |
    STA <r_battle_load_monster_tilemaps_offset                                  ; $028E68 | |
    TDC                                                                         ; $028E6A | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $028E6B |/
    LDA r_formation_flags2_copy_2.w                                             ; $028E6D | |
    AND #FORMATION_FLAGS_2_FLOATING.b                                           ; $028E70 | | If the formation is not floating, skip to the end.
    BEQ +                                                                       ; $028E72 |/
    TDC                                                                         ; $028E74 |\ Initialize the Y register to zero.
    TAY                                                                         ; $028E75 |/
    LDA #$51.b                                                                  ; $028E76 |\
    STA (<r_battle_load_monster_tilemaps_offset),Y                              ; $028E78 | | Write the left end shadow tile.
    INY                                                                         ; $028E7A |/
    LDA #%00111010.b                                                            ; $028E7B |\ Set the flags to priority 1, palette 6, with the base tile being
    STA (<r_battle_load_monster_tilemaps_offset),Y                              ; $028E7D |/ $200.
    LDA <r_battle_load_monster_tilemaps_size.width                              ; $028E7F |\
    DEC A                                                                       ; $028E81 | | Set the Y register to double the width minus one, to index to the
    ASL A                                                                       ; $028E82 | | end of the shadow.
    TAY                                                                         ; $028E83 |/
    LDA #$51.b                                                                  ; $028E84 |\
    STA (<r_battle_load_monster_tilemaps_offset),Y                              ; $028E86 | | Write the end shadow tile, flipped horizontally to draw the right
    INY                                                                         ; $028E88 | | end fo the shadow.
    LDA #%01111010.b                                                            ; $028E89 | |
    STA (<r_battle_load_monster_tilemaps_offset),Y                              ; $028E8B |/
    DEC <r_battle_load_monster_tilemaps_size.width                              ; $028E8D |\ Decrement the width by two.
    DEC <r_battle_load_monster_tilemaps_size.width                              ; $028E8F |/
    BEQ +                                                                       ; $028E91 |\
    LDY #2.w                                                                    ; $028E93 | | Loop through, writing the middle shadow tile until the entire
-   LDA #$52.b                                                                  ; $028E96 | | shadow is filled out.
    STA (<r_battle_load_monster_tilemaps_offset),Y                              ; $028E98 | |
    INY                                                                         ; $028E9A | |
    LDA #%00111010.b                                                            ; $028E9B | |
    STA (<r_battle_load_monster_tilemaps_offset),Y                              ; $028E9D | |
    INY                                                                         ; $028E9F | |
    DEC <r_battle_load_monster_tilemaps_size.width                              ; $028EA0 | |
    BNE -                                                                       ; $028EA2 |/
+   RTS                                                                         ; $028EA4

; _calculate_battle_tilemap_address ($02:8EA5)
;
; Calculates the address in the battle tilemap in RAM for a given X and Y
; coordinate. The X and Y coordinates should be passed in $04 and $05. The
; 16-bit result will then be returned in $04.
_calculate_battle_tilemap_address:
    LDA <r_battle_load_monster_tilemaps_coordinates.y.b                         ; $028EA5 |\
    STA <r_math_multiply_8bit_arg_1                                             ; $028EA7 | | Start by multiplying the Y coordinate by 64, as each row has 32
    LDA #64.b                                                                   ; $028EA9 | | tiles and each tile has two bytes in the tilemap and saving that
    STA <r_math_multiply_8bit_arg_2                                             ; $028EAB | | calculated value.
    JSR _math_multiply_8bit                                                     ; $028EAD |/
    LDA <r_battle_load_monster_tilemaps_coordinates.x.b                         ; $028EB0 |\
    ASL A                                                                       ; $028EB2 | | Calculate the result by taking the X coordinate times two, adding
    REP #FLAG_P_ACCUMULATOR                                                     ; $028EB3 | | the previously multiplied Y coordinate, and then adding the base
    CLC                                                                         ; $028EB5 | | tilemap address.
    ADC <r_math_multiply_8bit_result                                            ; $028EB6 | |
    ADC #r_battle_tilemap_data.w                                                ; $028EB8 | |
    STA <r_battle_load_monster_tilemaps_offset                                  ; $028EBB | |
    TDC                                                                         ; $028EBD | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $028EBE |/
    RTS                                                                         ; $028EC0

; _set_x_to_a_times_four ($02:8EC1)
;
; Multiplies the value in the 16-bit accumulator by four and then puts the
; result in the X register. The accumulator will be zero after returning.
_set_x_to_a_times_four:
    REP #FLAG_P_ACCUMULATOR                                                     ; $028EC1 |\
    ASL A                                                                       ; $028EC3 | | Multiply the 16-bit accumulator by four, and store the result in
    ASL A                                                                       ; $028EC4 | | the X register.
    TAX                                                                         ; $028EC5 | |
    TDC                                                                         ; $028EC6 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $028EC7 |/
    RTS                                                                         ; $028EC9

; _battle_load_monster_sprites ($02:8ECA)
;
; Loops through the three monster types in the current formation, loading the
; sprites for each of them to VRAM, as well as setting various variables in
; memory regarding these up to three sprites.
_battle_load_monster_sprites:
    LDA r_formation_flags1.w                                                    ; $028ECA |\
    AND #FORMATION_FLAGS_1_VRAM_LAYOUT.b                                        ; $028ECD | | Load the VRAM layout bits for this formation, and use it to
    ASL A                                                                       ; $028ECF | | calculate two different indexes. One for loading from four byte
    ASL A                                                                       ; $028ED0 | | data structures is stored in the accumulator, and the other for
    PHA                                                                         ; $028ED1 | | indexing eight byte data structures is put in the X register.
    ASL A                                                                       ; $028ED2 | |
    TAX                                                                         ; $028ED3 |/
    TDC                                                                         ; $028ED4 |\ Initialize the Y register to zero.
    TAY                                                                         ; $028ED5 |/
-   LDA bank16.battle_formation_vram_address_data.l,X                           ; $028ED6 |\ Copy the VRAM address data for each monster type's sprite data.
    STA r_monster_type_vram_address.w,Y                                         ; $028EDA |/
    LDA bank16.battle_formation_vram_variable_tile_counts_data.l,X              ; $028EDD |\ Copy the number of tiles to load for each monster type if using
    STA r_monster_type_variable_tile_count.w,Y                                  ; $028EE1 |/ a variable number of tiles.
    INX                                                                         ; $028EE4 |\
    INY                                                                         ; $028EE5 | | Loop until all eight bytes have been copied.
    CPY #8.w                                                                    ; $028EE6 | |
    BNE -                                                                       ; $028EE9 |/
    TDC                                                                         ; $028EEB |\ Initialize the Y register to zero once again.
    TAY                                                                         ; $028EEC |/
    PLA                                                                         ; $028EED |\ Load the four byte indexing variable into the X register.
    TAX                                                                         ; $028EEE |/
-   LDA bank16.battle_formation_vram_flags_data.l,X                             ; $028EEF |\ Copy the tile flags for each monster type.
    STA r_monster_type_vram_flags.w,Y                                           ; $028EF3 |/
    LDA bank16.battle_formation_vram_base_tile_data.l,X                         ; $028EF6 |\ Copy the base tile for each monster type.
    STA r_monster_type_vram_base_tile.w,Y                                       ; $028EFA |/
    INY                                                                         ; $028EFD |\
    INX                                                                         ; $028EFE | | Increment the indexes and loop until all four bytes have been
    CPY #4.w                                                                    ; $028EFF | | copied.
    BNE -                                                                       ; $028F02 |/
    TDC                                                                         ; $028F04 |\ Initialize the X register to zero.
    TAX                                                                         ; $028F05 |/
@start:
    PHX                                                                         ; $028F06 |\ Update the current monster type index.
    STX <r_battle_load_monster_sprites_index                                    ; $028F07 |/
    LDA r_monster_ids.w,X                                                       ; $028F09 |\
    CMP #$FF.b                                                                  ; $028F0C | | Load the ID for this monster type and skip to the next loop if
    BNE +                                                                       ; $028F0E | | this slot is empty.
    JMP @next                                                                   ; $028F10 |/
+   JSR _set_x_to_a_times_four                                                  ; $028F13 | Set X to the monster ID times four to index the sprite properties.
    LDA bank0F.monster_sprite_properties_data.l + 0,X                           ; $028F16 |\
    STA <r_battle_load_monster_sprites_size_index                               ; $028F1A | | Load the four sprite properties bytes for this monster and save
    LDA bank0F.monster_sprite_properties_data.l + 1,X                           ; $028F1C | | them to local variables.
    STA <r_battle_load_monster_sprites_palette_index                            ; $028F20 | |
    LDA bank0F.monster_sprite_properties_data.l + 2,X                           ; $028F22 | |
    STA <r_battle_load_monster_sprites_data_offset_lo                           ; $028F26 | |
    LDA bank0F.monster_sprite_properties_data.l + 3,X                           ; $028F28 | |
    STA <r_battle_load_monster_sprites_data_offset_hi                           ; $028F2C |/
    LDA <r_battle_load_monster_sprites_size_index                               ; $028F2E |\
    AND #MONSTER_SPRITE_SIZE_CHARACTER                                          ; $028F30 | | If the character sprite bit is not set, skip ahead.
    BEQ @non_character                                                          ; $028F32 |/
    LDA #2.b                                                                    ; $028F34 |\
    STA <r_battle_load_monster_sprites_size.width                               ; $028F36 | | The size for any monster that uses a character sprite is 2x3, the
    LDA #3.b                                                                    ; $028F38 | | same size as the character sprite.
    STA <r_battle_load_monster_sprites_size.height                              ; $028F3A |/
    LDA <r_battle_load_monster_sprites_index                                    ; $028F3C |\
    ASL A                                                                       ; $028F3E | | Set the Y register to the monster type index times two.
    TAY                                                                         ; $028F3F |/
    LDA <r_battle_load_monster_sprites_size.width                               ; $028F40 |\
    STA r_monster_type_size.1.width.w,Y                                         ; $028F42 | | Copy the width and height into the array for this monster type.
    LDA <r_battle_load_monster_sprites_size.height                              ; $028F45 | |
    STA r_monster_type_size.1.height.w,Y                                        ; $028F47 |/
    LDA <r_battle_load_monster_sprites_size_index                               ; $028F4A |\ Push the size index value to the stack.
    PHA                                                                         ; $028F4C |/
    LDX <r_battle_load_monster_sprites_index                                    ; $028F4D | Set the X register to the current monster type index.
    LDA <r_battle_load_monster_sprites_palette_index                            ; $028F4F |\ Set this monster type's palette index.
    STA r_monster_type_palette.w,X                                              ; $028F51 |/
    INX                                                                         ; $028F54 |\
    INX                                                                         ; $028F55 | | Increment the X register by 3 to get the desired palette number.
    INX                                                                         ; $028F56 |/
    JSR _battle_load_character_palette                                          ; $028F57 | Load the character palette referenced in the monster data.
    PLA                                                                         ; $028F5A | Restore the size index to the accumulator.
    AND #MONSTER_SPRITE_SIZE_INDEX.b                                            ; $028F5B |\ Mask out the actual index bits and transfer the result to the X
    TAX                                                                         ; $028F5D |/ register.
    STX <r_math_multiply_16bit_arg_1                                            ; $028F5E |\
    LDX #bank1A._sizeof_battle_sprite_character_cecil_dknight_data.w            ; $028F60 | | Multiply that index by the size of a character sprite set.
    STX <r_math_multiply_16bit_arg_2                                            ; $028F63 | |
    JSR _math_multiply_16bit                                                    ; $028F65 |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $028F68 |\
    LDA <r_math_multiply_16bit_result_lo                                        ; $028F6A | | Add that calculated offset to the base address for the character
    CLC                                                                         ; $028F6C | | sprite data and transfer it to the X register.
    ADC #bank1A.battle_sprite_character_cecil_dknight_data.w                    ; $028F6D | |
    TAX                                                                         ; $028F70 |/
    LDA #bank1A._sizeof_battle_sprite_character_cecil_dknight_data.w            ; $028F71 |\ Tell the DMA function to load the number of bytes equal to the size
    STA <r_battle_start_vram_dma5_arg_bytes                                     ; $028F74 |/ of a sprite set.
    TDC                                                                         ; $028F76 |\
    SEP #FLAG_P_ACCUMULATOR                                                     ; $028F77 | | Push the X register to the stack.
    PHX                                                                         ; $028F79 |/
    LDA <r_battle_load_monster_sprites_index                                    ; $028F7A |\
    ASL A                                                                       ; $028F7C | | Set the Y register to the target VRAM address for this monster
    TAX                                                                         ; $028F7D | | type.
    LDY r_monster_type_vram_address.w,X                                         ; $028F7E |/
    LDA #:bank1A.battle_sprite_character_cecil_dknight_data                     ; $028F81 | Set the accumulator to the bank to the character sprite data.
    PLX                                                                         ; $028F83 | Set the X register to the offset to read from.
    JSR _start_vram_dma5                                                        ; $028F84 | Transfer the character sprite data to VRAM.
    JMP @next                                                                   ; $028F87 | Jump to the next loop.
@non_character:
    LDA <r_battle_load_monster_sprites_size_index                               ; $028F8A |\ If the variable size bit is not set, jump to the next section.
    BPL @non_variable                                                           ; $028F8C |/
    LDA <r_battle_load_monster_sprites_size_index                               ; $028F8E |\
    AND #MONSTER_SPRITE_SIZE_INDEX.b                                            ; $028F90 | | Multiply the index bits portion of the size index by 5 to index
    STA <r_math_multiply_8bit_arg_1                                             ; $028F92 | | the variable data table and transfer this value into the X
    LDA #5.b                                                                    ; $028F94 | | register.
    STA <r_math_multiply_8bit_arg_2                                             ; $028F96 | |
    JSR _math_multiply_8bit                                                     ; $028F98 | |
    LDX <r_math_multiply_8bit_result                                            ; $028F9B |/
    LDA <r_battle_load_monster_sprites_index                                    ; $028F9D |\
    ASL A                                                                       ; $028F9F | | Set the Y register to the monster type index times two.
    TAY                                                                         ; $028FA0 |/
    LDA bank0F.variable_sprite_properties_data.l + 1,X                          ; $028FA1 |\
    AND #%00111111.b                                                            ; $028FA5 | | Load the actual size index from the variable sprite properties
    ASL A                                                                       ; $028FA7 | | table.
    TAX                                                                         ; $028FA8 |/
    LDA bank0D.battle_sprite_size_data.l + size.width,X                         ; $028FA9 |\
    STA <r_battle_load_monster_sprites_size.width                               ; $028FAD | | Load the monster type's width.
    STA r_monster_type_size.1.width.w,Y                                         ; $028FAF |/
    LDA bank0D.battle_sprite_size_data.l + size.height,X                        ; $028FB2 |\
    STA <r_battle_load_monster_sprites_size.height                              ; $028FB6 | | Load the monster type's height.
    STA r_monster_type_size.1.height.w,Y                                        ; $028FB8 |/
    LDX <r_math_multiply_8bit_result                                            ; $028FBB | Load the secondary table into the X register again.
    LDA bank0F.variable_sprite_properties_data.l + 2,X                          ; $028FBD | Load the palette byte from the secondary table.
    LDX <r_battle_load_monster_sprites_index                                    ; $028FC1 |\ Store the palette index byte for this monster type index.
    STA r_monster_type_palette.w,X                                              ; $028FC3 |/
    INX                                                                         ; $028FC6 |\
    INX                                                                         ; $028FC7 | | Increment the X register by 3 to get the desired palette nuumber.
    INX                                                                         ; $028FC8 |/
    JSR _battle_load_monster_palette                                            ; $028FC9 | Load the associated monster palette into CG-RAM.
    LDA <r_battle_load_monster_sprites_index                                    ; $028FCC |\
    ASL A                                                                       ; $028FCE | | Set the X register to the monster type index times two.
    TAX                                                                         ; $028FCF |/
    LDA r_monster_type_variable_tile_count.w,X                                  ; $028FD0 |\ Set the X register to the monster type's variable tile count.
    TAX                                                                         ; $028FD3 |/
    JMP @load                                                                   ; $028FD4 | Jump to the loading code.
@non_variable:
    AND #MONSTER_SPRITE_SIZE_INDEX.b                                            ; $028FD7 |\
    ASL A                                                                       ; $028FD9 | | Set the X register to the size index times two.
    TAX                                                                         ; $028FDA |/
    LDA bank0D.battle_sprite_size_data.l + size.width,X                         ; $028FDB |\
    STA <r_battle_load_monster_sprites_size.width                               ; $028FDF | | Load the sprite's width and height.
    LDA bank0D.battle_sprite_size_data.l + size.height,X                        ; $028FE1 | |
    STA <r_battle_load_monster_sprites_size.height                              ; $028FE5 |/
    LDA <r_battle_load_monster_sprites_index                                    ; $028FE7 |\
    ASL A                                                                       ; $028FE9 | | Set the Y register to the monster type index times two.
    TAY                                                                         ; $028FEA |/
    LDA <r_battle_load_monster_sprites_size.width                               ; $028FEB |\
    STA r_monster_type_size.1.width.w,Y                                         ; $028FED | | Transfer the width and height into the monster type size array.
    LDA <r_battle_load_monster_sprites_size.height                              ; $028FF0 | |
    STA r_monster_type_size.1.height.w,Y                                        ; $028FF2 |/
    LDX <r_battle_load_monster_sprites_index                                    ; $028FF5 |\
    LDA <r_battle_load_monster_sprites_palette_index                            ; $028FF7 | | Copy the monster type's palette index into the RAM variable.
    STA r_monster_type_palette.w,X                                              ; $028FF9 |/
    INX                                                                         ; $028FFC |\
    INX                                                                         ; $028FFD | | Increment the X register by 3 to get the desired palette number.
    INX                                                                         ; $028FFE |/
    JSR _battle_load_monster_palette                                            ; $028FFF | Load the associated monster palette.
    JSR _battle_load_monster_sprites_multiply_dimensions                        ; $029002 |\ Multiply the width by the height and put the result in the X
    LDX <r_math_multiply_8bit_result                                            ; $029005 |/ register.
@load:
    STX <r_battle_generic_tmp_index                                             ; $029007 |\ Store the desired tile count as the index and in the multiplication
    STX <r_math_multiply_8bit_result                                            ; $029009 |/ result variable.
    LDA <r_battle_load_monster_sprites_index                                    ; $02900B |\
    ASL A                                                                       ; $02900D | | Set the X register to the monster type index times two.
    TAX                                                                         ; $02900E |/
    LDY r_monster_type_vram_address.w,X                                         ; $02900F | Set the Y register to the target VRAM address.
    LDA <r_battle_load_monster_sprites_data_offset_hi                           ; $029012 |\
    AND #%01110000.b                                                            ; $029014 | | Extract the bank bits from the data offset, shift them to the
    LSR A                                                                       ; $029016 | | right, and add the result to $09 to determine the correct bank
    LSR A                                                                       ; $029017 | | number to read sprite data from. Push the result to the stack
    LSR A                                                                       ; $029018 | | for the moment.
    LSR A                                                                       ; $029019 | |
    CLC                                                                         ; $02901A | |
    ADC #:bank09.battle_sprite_monster_tinymage_data                            ; $02901B | |
    PHA                                                                         ; $02901D |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $02901E |\
    LDA <r_math_multiply_8bit_result                                            ; $029020 | | Multiply one copy of the tile count by 32. This can later be used
    ASL A                                                                       ; $029022 | | if the sprite happens to have 4 bits per pixel data.
    ASL A                                                                       ; $029023 | |
    ASL A                                                                       ; $029024 | |
    ASL A                                                                       ; $029025 | |
    ASL A                                                                       ; $029026 | |
    STA <r_math_multiply_8bit_result                                            ; $029027 |/
    LDA <r_battle_load_monster_sprites_data_offset                              ; $029029 |\
    AND #$0FFF.w                                                                ; $02902B | | Extract the remaining 12 bits from the data offset bytes, shift
    ASL A                                                                       ; $02902E | | them to the left, and then add $8000 to determine the offset
    ASL A                                                                       ; $02902F | | within the previously calculated bank.
    ASL A                                                                       ; $029030 | |
    CLC                                                                         ; $029031 | |
    ADC #$8000.w                                                                ; $029032 | |
    TAX                                                                         ; $029035 | |
    TDC                                                                         ; $029036 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $029037 |/
    LDA <r_battle_load_monster_sprites_data_offset_hi                           ; $029039 |\ If the high bit of the data offset is set, the sprite uses 3bpp, so
    BMI +                                                                       ; $02903B |/ branch accordingly.
    PHX                                                                         ; $02903D |\
    LDX <r_math_multiply_8bit_result                                            ; $02903E | | The sprite uses four bits per pixel, so put the number of bytes in
    STX <r_battle_start_vram_dma5_arg_bytes                                     ; $029040 | | $00, the offset to read from in the X register, and the bank to
    PLX                                                                         ; $029042 | | read from in the accumulator, and then call the function do the
    PLA                                                                         ; $029043 | | transfer to VRAM. The Y register already holds the target VRAM
    JSR _start_vram_dma5                                                        ; $029044 | | address. Afterward, branch to the next loop.
    BRA @next                                                                   ; $029047 |/
+   PLA                                                                         ; $029049 |\ Otherwise, call the function that copies the 3bpp data to VRAM.
    JSR _battle_copy_3bpp_to_vram                                               ; $02904A |/
@next:
    PLX                                                                         ; $02904D |\
    INX                                                                         ; $02904E | | Increment the monster type index and loop until all three have
    CPX #3.w                                                                    ; $02904F | | been loaded.
    BEQ +                                                                       ; $029052 | |
    JMP @start                                                                  ; $029054 |/
+   RTS                                                                         ; $029057

; _battle_load_monster_sprites_multiply_dimensions ($02:9058)
;
; Multiplies the 8-bit integer in $06 by the 8-bit integer in $07 and returns
; the 16-bit product in $2A. Used by _battle_load_monster_sprites specifically
; to multiply the sprite dimensions to determine the number of tiles.
_battle_load_monster_sprites_multiply_dimensions:
    LDA <r_battle_load_monster_sprites_size.width                               ; $029058 |\
    STA <r_math_multiply_8bit_arg_1                                             ; $02905A | | Multiply the width and the height.
    LDA <r_battle_load_monster_sprites_size.height                              ; $02905C | |
    STA <r_math_multiply_8bit_arg_2                                             ; $02905E | |
    JMP _math_multiply_8bit                                                     ; $029060 |/

; _copy_battle_sprite_icons_to_vram ($02:9063)
;
; Copies the 66 battle sprite icons to VRAM.
_copy_battle_sprite_icons_to_vram:
    LDX #80.w                                                                   ; $029063 |\
    STX <r_battle_copy_3bpp_to_vram_arg_tiles                                   ; $029066 | | Copies 80 tiles from $1C:F9C0 to VRAM at $1400.
    LDX #bank0C.battle_sprite_icon_data.w                                       ; $029068 | |
    LDY #$1400.w                                                                ; $02906B | | BUG: There doesn't seem to be any good reason to copy 80 tiles, as
    LDA #:bank0C.battle_sprite_icon_data.b                                      ; $02906E | |      there are only 66 in the bank, and the next data is palette
    JMP _battle_copy_3bpp_to_vram                                               ; $029070 |/       data in the following bank.

; _copy_bg2_dialog_tiles_to_vram ($02:9073)
;
; Copies 16 of the dialog tiles from ROM to VRAM for use on BG2. These tiles
; are specific to battles and include numbers and a few letters needed for the
; battle displays. BG2 is used for the Parry and Change menu items, as well as
; the MP display when choosing a spell.
_copy_bg2_dialog_tiles_to_vram:
    LDX #$4DB0.w                                                                ; $029073 |\
    LDY #$04A0.w                                                                ; $029076 | | Clear 37 tiles of BG2's tile area.
    JSR _clear_vram                                                             ; $029079 |/
    LDX #$4DB0.w                                                                ; $02907C |\
    STX <r_copy_bg2_dialog_tiles_to_vram_address                                ; $02907F | | Initialize the target VRAM address.
    TDC                                                                         ; $029081 | |
    TAX                                                                         ; $029082 |/
-   LDY <r_copy_bg2_dialog_tiles_to_vram_address                                ; $029083 |\
    LDA bank16.battle_background_dialog_tiles_data.l,X                          ; $029085 | | Copy the next tile into VRAM.
    JSR _copy_dialog_tile_to_vram                                               ; $029089 |/
    REP #FLAG_P_ACCUMULATOR.b                                                   ; $02908C |\
    LDA <r_copy_bg2_dialog_tiles_to_vram_address                                ; $02908E | | Increment the VRAM address by 16 words. Even though the tile
    CLC                                                                         ; $029090 | | itself is only 16 bytes, this expands it to the 4bpp needed by
    ADC #16.w                                                                   ; $029091 | | BG2.
    STA <r_copy_bg2_dialog_tiles_to_vram_address                                ; $029094 | |
    TDC                                                                         ; $029096 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $029097 |/
    INX                                                                         ; $029099 |\
    CPX #37.w                                                                   ; $02909A | | Continue until all 37 tiles have been copied.
    BNE -                                                                       ; $02909D |/
    RTS                                                                         ; $02909F

; _copy_dialog_tile_to_vram ($02:90A0)
;
; Copies a single dialog tile from ROM to VRAM. The desired tile number should
; be passed in the accumulator. The target VRAM address should be in the Y
; register.
_copy_dialog_tile_to_vram:
    PHX                                                                         ; $0290A0 | Save the value in the X register.
    STA <r_math_multiply_8bit_arg_1                                             ; $0290A1 |\
    LDA #16.b                                                                   ; $0290A3 | | Determine the offset into the data by multiplying the tile number
    STA <r_math_multiply_8bit_arg_2                                             ; $0290A5 | | by 16 (as each tile has 16 bytes at 2bpp).
    JSR _math_multiply_8bit                                                     ; $0290A7 | |
    REP #FLAG_P_ACCUMULATOR                                                     ; $0290AA | |
    LDA <r_math_multiply_8bit_result                                            ; $0290AC |/
    CLC                                                                         ; $0290AE |\
    ADC #bank0A.dialog_tile_data.w                                              ; $0290AF | | Add the base offset into the dialog tile data.
    TAX                                                                         ; $0290B2 |/
    LDA #16.w                                                                   ; $0290B3 |\ Transfer 16 bytes (one complete tile).
    STA <r_battle_start_vram_dma5_arg_bytes                                     ; $0290B6 |/
    TDC                                                                         ; $0290B8 |\
    SEP #FLAG_P_ACCUMULATOR                                                     ; $0290B9 | | Copy a tile from the data at $0A:F000 to the VRAM address passed
    LDA #:bank0A.dialog_tile_data.b                                             ; $0290BB | | in the Y register.
    JSR _start_vram_dma5                                                        ; $0290BD |/
    PLX                                                                         ; $0290C0 | Restore the value of the X register.
    RTS                                                                         ; $0290C1

; _battle_load_palettes ($02:90C2)
;
; Loads the various battle-relevant palettes, except for the monster palettes.
_battle_load_palettes:
    TDC                                                                         ; $0290C2 |\ Initialize the X register to zero.
    TAX                                                                         ; $0290C3 |/
-   LDA bank0D.dialog_palette_data.l,X                                          ; $0290C4 |\ Copy the next byte from the dialog palette to the CG-RAM mirror.
    STA r_battle_cgram_data.1.w,X                                               ; $0290C8 |/
    LDA bank0E.battle_palette_data.l,X                                          ; $0290CB |\ Copy the next byte from the stone palette to the CG-RAM mirror.
    STA r_battle_cgram_data.9.w,X                                               ; $0290CF |/
    INX                                                                         ; $0290D2 |\
    CPX #_sizeof_palette.w                                                      ; $0290D3 | | Loop until the entire 16 color palette is copied.
    BNE -                                                                       ; $0290D6 |/
    LDX r_window_color.w                                                        ; $0290D8 |\
    STX r_battle_cgram_data.1.color2.w                                          ; $0290DB | | Set the configured window color to the four dialog palettes.
    STX r_battle_cgram_data.1.color6.w                                          ; $0290DE | |
    STX r_battle_cgram_data.1.color10.w                                         ; $0290E1 | |
    STX r_battle_cgram_data.1.color14.w                                         ; $0290E4 |/
    LDA #2.b                                                                    ; $0290E7 |\
    LDX #14.w                                                                   ; $0290E9 | | TODO: Load an unknown palette to the fifteenth palette.
    JSR _battle_load_miscellaneous_palette                                      ; $0290EC |/
    LDA #3.b                                                                    ; $0290EF |\
    LDX #6.w                                                                    ; $0290F1 | | Load the battle small/toad/pig palette to the seventh palette.
    JSR _battle_load_miscellaneous_palette                                      ; $0290F4 |/
    JSL bank03.battle_load_background_palette                                   ; $0290F7 | Load the background palettes.
    LDA #0.b                                                                    ; $0290FB |\
    JSR _battle_get_character_palette_index                                     ; $0290FD | | Load the palette for the character in slot 0 to the tenth palette.
    LDX #9.w                                                                    ; $029100 | |
    JSR _battle_load_character_palette                                          ; $029103 |/
    LDA #1.b                                                                    ; $029106 |\
    JSR _battle_get_character_palette_index                                     ; $029108 | | Load the palette for the character in slot 1 to the eleventh
    LDX #10.w                                                                   ; $02910B | | palette.
    JSR _battle_load_character_palette                                          ; $02910E |/
    LDA #2.b                                                                    ; $029111 |\
    JSR _battle_get_character_palette_index                                     ; $029113 | | Load the palette for the character in slot 2 to the twelfth
    LDX #11.w                                                                   ; $029116 | | palette.
    JSR _battle_load_character_palette                                          ; $029119 |/
    LDA #3.b                                                                    ; $02911C |\
    JSR _battle_get_character_palette_index                                     ; $02911E | | Load the palette for the character in slot 3 to the thirteenth
    LDX #12.w                                                                   ; $029121 | | palette.
    JSR _battle_load_character_palette                                          ; $029124 |/
    LDA #4.b                                                                    ; $029127 |\
    JSR _battle_get_character_palette_index                                     ; $029129 | | Load the palette for the character in slot 4 to the fourteenth
    LDX #13.w                                                                   ; $02912C | | palette.
    JMP _battle_load_character_palette                                          ; $02912F |/

; _battle_get_character_palette_index ($02:9132)
;
; Calls a function in another bank that sets the character palette to the
; appropriate value for the slot passed in the accumulator. Returns the palette
; index in the accumulator.
_battle_get_character_palette_index:
    JSL bank03.battle_get_character_palette_index                               ; $029132 | Call the function in another bank.
    RTS                                                                         ; $029136


; _battle_copy_dialog_tiles_to_vram ($02:9137)
;
; Copies the dialog tiles to VRAM at $5000, which is the base location for BG3's
; tile data. Also blanks out the first tile.
_battle_copy_dialog_tiles_to_vram:
    LDX #bank0A._sizeof_dialog_tile_data.w                                      ; $029137 |\
    STX <r_battle_start_vram_dma5_arg_bytes                                     ; $02913A | | Copy $1000 bytes from ROM at $0A:F000 to VRAM at $5000, which is
    LDA #:bank0A.dialog_tile_data.b                                             ; $02913C | | the BG3 tile area. This copies the dialog tiles to VRAM.
    LDX #bank0A.dialog_tile_data.w                                              ; $02913E | |
    LDY #$5000.w                                                                ; $029141 | |
    JSR _start_vram_dma5                                                        ; $029144 |/
    LDX #$5000.w                                                                ; $029147 |\
    LDY #16.w                                                                   ; $02914A | | Clear the first tile in BG3's tile area to be blank.
    JMP _clear_vram                                                             ; $02914D |/

; _battle_load_monster_palette ($02:9150)
;
; Given a monster palette number in the accumulator and the number of a CG-RAM
; palette in the X register, loads the palette data for that value into the
; specified location in the battle CG-RAM mirror.
_battle_load_monster_palette:
    STA <r_math_multiply_8bit_arg_1                                             ; $029150 |\
    LDA #16.b                                                                   ; $029152 | | Multiply the argument in the accumulator by 16 to determine the
    STA <r_math_multiply_8bit_arg_2                                             ; $029154 | | location in ROM where to load from.
    JSR _math_multiply_8bit                                                     ; $029156 |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $029159 |\
    TXA                                                                         ; $02915B | | Multiply the value in the X register by 32 to determine where
    ASL A                                                                       ; $02915C | | in CG-RAM to store the palette data.
    ASL A                                                                       ; $02915D | |
    ASL A                                                                       ; $02915E | |
    ASL A                                                                       ; $02915F | |
    ASL A                                                                       ; $029160 | |
    TAY                                                                         ; $029161 | |
    TDC                                                                         ; $029162 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $029163 |/
    LDA #32.b                                                                   ; $029165 |\ Initialize the index to 32 to load 32 bytes (16 colors).
    STA <r_battle_generic_tmp_index_lo                                          ; $029167 |/
    LDX <r_math_multiply_8bit_result                                            ; $029169 | Set the X register to the ROM indexing offset.
-   LDA bank1C.battle_monster_palette_data.l,X                                  ; $02916B |\ Load the next byte.
    STA r_battle_cgram_data.w,Y                                                 ; $02916F |/
    INX                                                                         ; $029172 |\
    INY                                                                         ; $029173 | | Loop until all bytes have been copied.
    DEC <r_battle_generic_tmp_index_lo                                          ; $029174 | |
    BNE -                                                                       ; $029176 |/
    RTS                                                                         ; $029178

; _battle_load_miscellaneous_palette ($02:9179)
;
; Given an index in the accumulator and a palette number in the X register,
; copies the given miscellaneous battle palette into the battle CG-RAM mirror.
; Each palette consists of eight colors, and will be copied to both the low
; colors and the high colors.
_battle_load_miscellaneous_palette:
    STA <r_math_multiply_8bit_arg_1                                             ; $029179 |\
    LDA #16.b                                                                   ; $02917B | | Multiply the value in the accumulator by 16 to determine the
    STA <r_math_multiply_8bit_arg_2                                             ; $02917D | | index into the palette data.
    JSR _math_multiply_8bit                                                     ; $02917F |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $029182 |\
    TXA                                                                         ; $029184 | | Set the Y register to the value in the X register times 32, or the
    ASL A                                                                       ; $029185 | | size of a palette.
    ASL A                                                                       ; $029186 | |
    ASL A                                                                       ; $029187 | |
    ASL A                                                                       ; $029188 | |
    ASL A                                                                       ; $029189 | |
    TAY                                                                         ; $02918A | |
    TDC                                                                         ; $02918B | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $02918C |/
    LDA #16.b                                                                   ; $02918E |\ Initialize the counter to 16, as eight colors need to be copied.
    STA <r_battle_generic_tmp_index_lo                                          ; $029190 |/
    LDX <r_math_multiply_8bit_result                                            ; $029192 | Set the X register to the palette data index.
-   LDA bank0E.battle_palette_data.l,X                                          ; $029194 |\
    STA r_battle_cgram_data.1.color1.w,Y                                        ; $029198 | | Copy the byte to both the low and high parts of the palette.
    STA r_battle_cgram_data.1.color9.w,Y                                        ; $02919B |/
    INX                                                                         ; $02919E |\
    INY                                                                         ; $02919F | | Increment index registers and loop until all bytes have been
    DEC <r_battle_generic_tmp_index_lo                                          ; $0291A0 | | copied.
    BNE -                                                                       ; $0291A2 |/
    RTS                                                                         ; $0291A4

; battle_load_character_palette ($02:91A5)
;
; Proxy function to call _battle_load_character_palette from another bank.
battle_load_character_palette:
    JSR _battle_load_character_palette                                          ; $0291A5 | Call the function.
    RTL                                                                         ; $0291A8

; _battle_load_character_palette ($02:91A9)
;
; Given a palette index in the accumulator and a palette number in the X
; register, loads that palette index into the battle CG-RAM staging area in the
; palette specified in the X register.
_battle_load_character_palette:
    STA <r_math_multiply_8bit_arg_1                                             ; $0291A9 |\
    LDA #32.b                                                                   ; $0291AB | | Multiply the value in the accumulator by 32 to determine the index
    STA <r_math_multiply_8bit_arg_2                                             ; $0291AD | | into the palette data in ROM.
    JSR _math_multiply_8bit                                                     ; $0291AF |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $0291B2 |\
    TXA                                                                         ; $0291B4 | | Determine the offset into the CG-RAM staging area by multiplying
    ASL A                                                                       ; $0291B5 | | the value in the X register by 32.
    ASL A                                                                       ; $0291B6 | |
    ASL A                                                                       ; $0291B7 | |
    ASL A                                                                       ; $0291B8 | |
    ASL A                                                                       ; $0291B9 | |
    TAY                                                                         ; $0291BA | |
    TDC                                                                         ; $0291BB | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $0291BC |/
    LDX <r_math_multiply_8bit_result                                            ; $0291BE | Set the X register to the ROM index value.
    LDA #32.b                                                                   ; $0291C0 |\ Set the index variable to copy 32 bytes (one 16-color palette).
    STA <r_battle_generic_tmp_index_lo                                          ; $0291C2 |/
-   LDA bank1C.battle_character_palette_data.l,X                                ; $0291C4 |\ Copy the next byte.
    STA r_battle_cgram_data.w,Y                                                 ; $0291C8 |/
    INX                                                                         ; $0291CB |\
    INY                                                                         ; $0291CC | | Increment the indexes and loop until all 16 colors have been
    DEC <r_battle_generic_tmp_index_lo                                          ; $0291CD | | copied.
    BNE -                                                                       ; $0291CF |/
    RTS                                                                         ; $0291D1

; _copy_battle_background_to_vram ($02:91D2)
;
; Loads the battle background specified in $1802, including its tileset, and
; transfers this data to VRAM.
_copy_battle_background_to_vram:
    LDA r_battle_background.w                                                   ; $0291D2 |\
    AND #%00011111.b                                                            ; $0291D5 | | Determine the X register by taking the lower five bits of the
    ASL A                                                                       ; $0291D7 | | battle background and multiplying by two.
    TAX                                                                         ; $0291D8 |/
    REP #FLAG_P_ACCUMULATOR.b                                                   ; $0291D9 |\
    LDA #40.w                                                                   ; $0291DB | | Load the tileset associated with the background. Load up to 40
    STA <r_battle_copy_3bpp_to_vram_arg_tiles                                   ; $0291DE | | tiles. The data gets copied to VRAM address $4010.
    LDA bank16.battle_background_offset_data.l,X                                ; $0291E0 | |
    TAX                                                                         ; $0291E4 | |
    TDC                                                                         ; $0291E5 | |
    SEP #FLAG_P_ACCUMULATOR.b                                                   ; $0291E6 | |
    LDA #:bank1C.tileset_battle_background_grassland_data.b                     ; $0291E8 | |
    LDY #$4010.w                                                                ; $0291EA | |
    JSR _battle_copy_3bpp_to_vram                                               ; $0291ED |/
    JSL bank01.draw_battle_background                                           ; $0291F0 | Draw the battle background tilemap to RAM.
    LDX #$0480.w                                                                ; $0291F4 |\
    STX <r_battle_start_vram_dma5_arg_bytes                                     ; $0291F7 | | Copy the 18 lines of the battle background from RAM to VRAM at
    LDA #:r_battle_tilemap_data.b                                               ; $0291F9 | | $5800, which is the start of BG2.
    LDX #r_battle_tilemap_data.w                                                ; $0291FB | |
    LDY #$5800.w                                                                ; $0291FE | |
    JSR _start_vram_dma5                                                        ; $029201 |/
    LDA r_formation_back_attack_copy.w                                          ; $029204 |\
    PHA                                                                         ; $029207 | | Flip the battle background tilemap horizontally. The function
    LDA #$FF.b                                                                  ; $029208 | | will only operate if the battle is a back attack, so we fake it
    STA r_formation_back_attack_copy.w                                          ; $02920A | | by setting the appropriate variable.
    JSL bank01.flip_battle_background_tilemap                                   ; $02920D | |
    PLA                                                                         ; $029211 | |
    STA r_formation_back_attack_copy.w                                          ; $029212 |/
    LDX #$0480.w                                                                ; $029215 |\
    STX <r_battle_start_vram_dma5_arg_bytes                                     ; $029218 | | Copy the 18 lines of the (now flipped) battle background from RAM
    LDA #:r_battle_tilemap_data.b                                               ; $02921A | | to VRAM at $5C00, which is the start of the second half of BG2.
    LDX #r_battle_tilemap_data.w                                                ; $02921C | |
    LDY #$5C00.w                                                                ; $02921F | |
    JMP _start_vram_dma5                                                        ; $029222 |/

; _execute_battle_fixed_dma ($02:9225)
;
; If any of the fixed battle DMA channels is pending, execute it. These are
; four areas in RAM which can be configured to DMA exactly 32 bytes to VRAM from
; a given address in bank $7E. They would suffice for transferring one 8x8 tile
; each (at 4 bits per pixel).
_execute_battle_fixed_dma:
    LDA r_battle_fixed_dma_1_pending.w                                          ; $029225 |\
    BEQ +                                                                       ; $029228 | | Execute the first fixed DMA, if pending.
    STZ r_battle_fixed_dma_1_pending.w                                          ; $02922A | |
    LDX #32.w                                                                   ; $02922D | |
    STX <r_battle_start_vram_dma4_arg_bytes                                     ; $029230 | |
    LDX r_battle_fixed_dma_1_source_address.w                                   ; $029232 | |
    LDY r_battle_fixed_dma_1_target_vram_address.w                              ; $029235 | |
    LDA #$7E.b                                                                  ; $029238 | |
    JSR _start_vram_dma4                                                        ; $02923A |/
+   LDA r_battle_fixed_dma_2_pending.w                                          ; $02923D |\
    BEQ +                                                                       ; $029240 | | Execute the second fixed DMA, if pending.
    STZ r_battle_fixed_dma_2_pending.w                                          ; $029242 | |
    LDX #$0020.w                                                                ; $029245 | |
    STX <r_battle_start_vram_dma4_arg_bytes                                     ; $029248 | |
    LDX r_battle_fixed_dma_2_source_address.w                                   ; $02924A | |
    LDY r_battle_fixed_dma_2_target_vram_address.w                              ; $02924D | |
    LDA #$7E.b                                                                  ; $029250 | |
    JSR _start_vram_dma4                                                        ; $029252 |/
+   LDA r_battle_fixed_dma_3_pending.w                                          ; $029255 |\
    BEQ +                                                                       ; $029258 | | Execute the third fixed DMA, if pending.
    STZ r_battle_fixed_dma_3_pending.w                                          ; $02925A | |
    LDX #$0020.w                                                                ; $02925D | |
    STX <r_battle_start_vram_dma4_arg_bytes                                     ; $029260 | |
    LDX r_battle_fixed_dma_3_source_address.w                                   ; $029262 | |
    LDY r_battle_fixed_dma_3_target_vram_address.w                              ; $029265 | |
    LDA #$7E.b                                                                  ; $029268 | |
    JSR _start_vram_dma4                                                        ; $02926A |/
+   LDA r_battle_fixed_dma_4_pending.w                                          ; $02926D |\
    BEQ +                                                                       ; $029270 | | Execute the fourth fixed DMA, if pending.
    STZ r_battle_fixed_dma_4_pending.w                                          ; $029272 | |
    LDX #$0020.w                                                                ; $029275 | |
    STX <r_battle_start_vram_dma4_arg_bytes                                     ; $029278 | |
    LDX r_battle_fixed_dma_4_source_address.w                                   ; $02927A | |
    LDY r_battle_fixed_dma_4_target_vram_address.w                              ; $02927D | |
    LDA #$7E.b                                                                  ; $029280 | |
    JSR _start_vram_dma4                                                        ; $029282 |/
+   RTS                                                                         ; $029285

; _execute_battle_dma ($02:9286)
;
; Executes the various battle DMA channels. If any of the fixed-size channels is
; pending, those will be executed. Otherwise, the more general DMA channels will
; be executed if pending. The general ones have both a configurable source bank
; and size of the transfer.
_execute_battle_dma:
    LDA r_battle_fixed_dma_1_pending.w                                          ; $029286 |\
    ORA r_battle_fixed_dma_2_pending.w                                          ; $029289 | | If any of the fixed DMA channels is pending, preferentially
    ORA r_battle_fixed_dma_3_pending.w                                          ; $02928C | | execute those.
    ORA r_battle_fixed_dma_4_pending.w                                          ; $02928F | |
    BEQ +                                                                       ; $029292 | |
    JMP _execute_battle_fixed_dma                                               ; $029294 |/
+   LDA r_battle_dma_1_pending.w                                                ; $029297 |\
    BEQ +                                                                       ; $02929A | | Execute the first DMA if pending.
    STZ r_battle_dma_1_pending.w                                                ; $02929C | |
    LDX r_battle_dma_1_bytes.w                                                  ; $02929F | |
    STX <r_battle_start_vram_dma4_arg_bytes                                     ; $0292A2 | |
    LDX r_battle_dma_1_source_address.w                                         ; $0292A4 | |
    LDY r_battle_dma_1_target_vram_address.w                                    ; $0292A7 | |
    LDA r_battle_dma_1_source_bank.w                                            ; $0292AA | |
    JSR _start_vram_dma4                                                        ; $0292AD |/
+   LDA r_battle_dma_2_pending.w                                                ; $0292B0 |\
    BEQ +                                                                       ; $0292B3 | | Execute the second DMA if pending.
    STZ r_battle_dma_2_pending.w                                                ; $0292B5 | |
    LDX r_battle_dma_2_bytes.w                                                  ; $0292B8 | |
    STX <r_battle_start_vram_dma4_arg_bytes                                     ; $0292BB | |
    LDX r_battle_dma_2_source_address.w                                         ; $0292BD | |
    LDY r_battle_dma_2_target_vram_address.w                                    ; $0292C0 | |
    LDA r_battle_dma_2_source_bank.w                                            ; $0292C3 | |
    JSR _start_vram_dma4                                                        ; $0292C6 |/
+   RTS                                                                         ; $0292C9

; _battle_clear_battle_message_tilemap ($02:92CA)
;
; Clears the battle message tilemap area in RAM, and sets everything to $00,
; which would result in black tiles if copies to VRAM. (This function does not
; copy anything to VRAM.)
_battle_clear_battle_message_tilemap:
    TDC                                                                         ; $0292CA |\ Initialize the X register to zero.
    TAX                                                                         ; $0292CB |/
-   STA r_battle_tilemap_bg3_battle_message.w,X                                 ; $0292CC |\
    INX                                                                         ; $0292CF | | Fill the battle message dialog area with zeroes
    CPX #_sizeof_r_battle_tilemap_bg3_battle_message.w                          ; $0292D0 | |
    BNE -                                                                       ; $0292D3 |/
    RTS                                                                         ; $0292D5

; _battle_draw_battle_message ($02:92D6)
;
; Draws the battle message dialog box to screen and decodes the dialog to be
; drawn in that box. Finally, transfers the dialog to VRAM. The dialog to load
; is determined by directly setting the dialog source location at $EF50.
; Usually, the message of interest is copied into RAM at some location, and then
; that location is set to $EF50.
_battle_draw_battle_message:
    JSR _battle_clear_battle_message_tilemap                                    ; $0292D6 | Clear the message tilemap area in RAM.
    LDX #r_battle_tilemap_bg3_battle_message.w                                  ; $0292D9 |\ Set the dialog box destination to the battle message tilemap area.
    STX r_battle_draw_dialog_box_arg_destination.w                              ; $0292DC |/
    LDX #$0003.w                                                                ; $0292DF |\ Set the coordinates of the dialog box to 3,0 within the tilemap
    STX r_battle_draw_dialog_box_arg_coordinates.w                              ; $0292E2 |/ area.
    LDX #$041A.w                                                                ; $0292E5 |\ Set the width of the dialog box to $1A (or 26) and the height to 4.
    STX r_battle_draw_dialog_box_arg_width.w                                    ; $0292E8 |/
    JSR _battle_draw_dialog_box_bg3_expanded.w                                  ; $0292EB | Draw the expanded BG3 dialog box.
    LDA #$20.b                                                                  ; $0292EE |\ Set the flags to give each tile a priority of 1.
    STA r_battle_update_dialog_arg_flags.w                                      ; $0292F0 |/
    LDA #32.b                                                                   ; $0292F3 |\ Set the row length to 32, as each row is full width on the tilemap.
    STA r_battle_update_dialog_arg_line_length.w                                ; $0292F5 |/
    LDX #r_battle_tilemap_bg3_battle_message.w + 64 + 8                         ; $0292F8 |\ Configure the dialog target to write to the 4th tile from the left
    STX r_battle_update_dialog_arg_target.w                                     ; $0292FB |/ on the second row of the battle message tilemap.
    JSR _battle_update_dialog                                                   ; $0292FE | Decode and write the dialog tiles.
    JMP _copy_battle_message_to_vram                                            ; $029301 | Copy the updated battle message to VRAM.

; _battle_draw_battle_message_left ($02:9304)
;
; Draws a left-aligned battle message dialog box. The data to be decoded and
; put into the dialog box should already be in the array at $74FD.
_battle_draw_battle_message_left:
    JSR _battle_clear_battle_message_tilemap                                    ; $029304 | Clear the battle message tilemap area in RAM.
    LDX #r_battle_tilemap_bg3_battle_message.w                                  ; $029307 |\ Set the parameter to draw a dialog box in the battle message
    STX r_battle_draw_dialog_box_arg_destination.w                              ; $02930A |/ tilemap area.
    LDX #$0002.w                                                                ; $02930D |\ Set the coordinates to draw the dialog box at coordinates 2,0
    STX r_battle_draw_dialog_box_arg_coordinates.w                              ; $029310 |/ within that area.
    LDX #$040A.w                                                                ; $029313 |\ Set the width to 10x4, in terms of tiles.
    STX r_battle_draw_dialog_box_arg_width.w                                    ; $029316 |/
    JSR _battle_draw_dialog_box_bg3_expanded                                    ; $029319 | Draw the dialog box as configured.
    LDA #%00100000.b                                                            ; $02931C |\ Set the default tile flags to give the tile priority 1.
    STA r_battle_update_dialog_arg_flags.w                                      ; $02931E |/
    LDA #32.b                                                                   ; $029321 |\ Set the line length to 32, as each line is full width.
    STA r_battle_update_dialog_arg_line_length.w                                ; $029323 |/
    LDX #r_battle_tilemap_bg3_battle_message.w + 64 + 6                         ; $029326 |\ Set the dialog update target to 3 characters in on the second line.
    STX r_battle_update_dialog_arg_target.w                                     ; $029329 |/
    JSR _battle_update_dialog                                                   ; $02932C | Decode the dialog data.
    JMP _copy_battle_message_to_vram                                            ; $02932F | Copy the tilemap to VRAM.

; _battle_draw_battle_message_center ($02:9332)
;
; Draws a center-aligned battle message dialog box. The data to be decoded and
; put into the dialog box should already be in the array at $74FD.
_battle_draw_battle_message_center:
    JSR _battle_clear_battle_message_tilemap                                    ; $029332 | Clear the battle message tilemap area in RAM.
    LDX #r_battle_tilemap_bg3_battle_message.w                                  ; $029335 |\ Set the parameter to draw a dialog box in the battle message
    STX r_battle_draw_dialog_box_arg_destination.w                              ; $029338 |/ tilemap area.
    LDX #$000B.w                                                                ; $02933B |\ Set the coordinates to draw the dialog box at coordinates 11,0
    STX r_battle_draw_dialog_box_arg_coordinates.w                              ; $02933E |/ within that area.
    LDX #$040A.w                                                                ; $029341 |\ Set the width to 10x4, in terms of tiles.
    STX r_battle_draw_dialog_box_arg_width.w                                    ; $029344 |/
    JSR _battle_draw_dialog_box_bg3_expanded                                    ; $029347 | Draw the dialog box as configured.
    LDA #%00100000.b                                                            ; $02934A |\ Set the default tile flags to give the tile priority 1.
    STA r_battle_update_dialog_arg_flags.w                                      ; $02934C |/
    LDA #32.b                                                                   ; $02934F |\ Set the line length to 32, as each line is full width.
    STA r_battle_update_dialog_arg_line_length.w                                ; $029351 |/
    LDX #r_battle_tilemap_bg3_battle_message.w + 64 + 24                        ; $029354 |\ Set the dialog update target to 12 characters in on the second line.
    STX r_battle_update_dialog_arg_target.w                                     ; $029357 |/
    JSR _battle_update_dialog                                                   ; $02935A | Decode the dialog data.
    JMP _copy_battle_message_to_vram                                            ; $02935D | Copy the tilemap to VRAM.

; _battle_draw_battle_message_right ($02:9360)
;
; Draws a right-aligned battle message dialog box. The data to be decoded and
; put into the dialog box should already be in the array at $74FD.
_battle_draw_battle_message_right:
    JSR _battle_clear_battle_message_tilemap.w                                  ; $029360 | Clear the battle message tilemap area in RAM.
    LDX #r_battle_tilemap_bg3_battle_message.w                                  ; $029363 |\ Set the parameter to draw a dialog box in the battle message
    STX r_battle_draw_dialog_box_arg_destination.w                              ; $029366 |/ tilemap area.
    LDX #$0014.w                                                                ; $029369 |\ Set the parameter to draw the dialog box at coordinates 20,0 within
    STX r_battle_draw_dialog_box_arg_coordinates.w                              ; $02936C |/ that area.
    LDX #$040A.w                                                                ; $02936F |\ Set the width to 10x4, in terms of tiles.
    STX r_battle_draw_dialog_box_arg_width.w                                    ; $029372 |/
    JSR _battle_draw_dialog_box_bg3_expanded                                    ; $029375 | Draw the dialog box as configured.
    LDA #%00100000.b                                                            ; $029378 |\ Set the default tile flags to give the tile priority 1.
    STA r_battle_update_dialog_arg_flags.w                                      ; $02937A |/
    LDA #32.b                                                                   ; $02937D |\ Set the line length to 32, as each line is full width.
    STA r_battle_update_dialog_arg_line_length.w                                ; $02937F |/
    LDX #r_battle_tilemap_bg3_battle_message.w + 64 + 42                        ; $029382 |\ Set the dialog update targe to 21 characters in on the second line.
    STX r_battle_update_dialog_arg_target.w                                     ; $029385 |/
    JSR _battle_update_dialog                                                   ; $029388 | Decode the dialog data.
    JMP _copy_battle_message_to_vram                                            ; $02938B | Copy the tilemap to VRAM.

; _copy_battle_message_to_vram ($02:938E)
;
; Configures a DMA transfer to copy four rows of tiles from RAM at $DAE6 to a
; location on BG3. This area is used for messages during battle.
_copy_battle_message_to_vram:
    LDX #r_battle_tilemap_bg3_battle_message.w                                  ; $02938E |\ Set the source address to the tilemap area for the battle messages.
    STX r_battle_menu_dma_source_address.w                                      ; $029391 |/
    LDX #$78E0.w                                                                ; $029394 |\ Set the target VRAM address to a location on BG3.
    STX r_battle_menu_dma_target_vram_address.w                                 ; $029397 |/
    LDA #4.b                                                                    ; $02939A |\ Transfer four rows of tiles.
    STA r_battle_menu_dma_rows.w                                                ; $02939C |/
    STZ r_battle_menu_dma_reverse.w                                             ; $02939F | Do not use reverse mode.
    LDA #1.b                                                                    ; $0293A2 |\ Flag the DMA transfer as pending.
    STA r_battle_menu_dma_pending.w                                             ; $0293A4 |/
    RTS                                                                         ; $0293A7

; _battle_close_battle_message ($02:93A8)
;
; Clears the battle message tilemap area in RAM and then transfers it to VRAM
; in reverse order, so that the bottom row is erased first.
_battle_close_battle_message:
    JSR _battle_clear_battle_message_tilemap                                    ; $0293A8 | Clear out the battle message tilemap area.
    LDX #r_battle_tilemap_bg3_battle_message.w + (64 * 3)                       ; $0293AB |\ Set the initial source address to the last row of the battle
    STX r_battle_menu_dma_source_address.w                                      ; $0293AE |/ message tilemap area.
    LDX #$7940.w                                                                ; $0293B1 |\ Set the target VRAM address to point to the same area on the
    STX r_battle_menu_dma_target_vram_address.w                                 ; $0293B4 |/ actual tilemap in VRAM.
    LDA #4.b                                                                    ; $0293B7 |\ Transfer four rows of tiles.
    STA r_battle_menu_dma_rows.w                                                ; $0293B9 |/
    LDA #$01.b                                                                  ; $0293BC |\ Use reverse mode so the dialog will be wiped from bottom up.
    STA r_battle_menu_dma_reverse.w                                             ; $0293BE |/
    STA r_battle_menu_dma_pending.w                                             ; $0293C1 | Flag the transfer as pending.
    RTS                                                                         ; $0293C4

; _copy_battle_menu_row_to_vram ($02:93C5)
;
; Copies a single row of the battle menu on BG3 (32 8x8 tiles) from RAM to VRAM,
; depending on the values of the bytes ranging from $EF9B to $EFA1.
_copy_battle_menu_row_to_vram:
    LDA r_battle_menu_dma_pending.w                                             ; $0293C5 |\ Skip this function if there is no menu update pending.
    BEQ @done                                                                   ; $0293C8 |/
    LDX #64.w                                                                   ; $0293CA |\
    STX <r_battle_start_vram_dma4_arg_bytes                                     ; $0293CD | | Transfer 64 bytes (32 tiles, or one row) from the designated
    LDX r_battle_menu_dma_source_address.w                                      ; $0293CF | | location in RAM to VRAM.
    LDY r_battle_menu_dma_target_vram_address.w                                 ; $0293D2 | |
    LDA #$7E.b                                                                  ; $0293D5 | |
    JSR _start_vram_dma4                                                        ; $0293D7 |/
    DEC r_battle_menu_dma_rows.w                                                ; $0293DA | Decrement the row counter for next time.
    BEQ +++                                                                     ; $0293DD | If no rows are remaining, jump to near the end.
    LDA r_battle_menu_dma_reverse.w                                             ; $0293DF |\
    BNE +                                                                       ; $0293E2 | | If reverse mode is not enabled, add 64 to the source pointer and
    REP #FLAG_P_ACCUMULATOR                                                     ; $0293E4 | | 32 to the target pointer to move to the next row.
    LDA r_battle_menu_dma_source_address.w                                      ; $0293E6 | |
    CLC                                                                         ; $0293E9 | |
    ADC #64.w                                                                   ; $0293EA | |
    STA r_battle_menu_dma_source_address.w                                      ; $0293ED | |
    LDA r_battle_menu_dma_target_vram_address.w                                 ; $0293F0 | |
    CLC                                                                         ; $0293F3 | |
    ADC #32.w                                                                   ; $0293F4 | |
    STA r_battle_menu_dma_target_vram_address.w                                 ; $0293F7 | |
    BRA ++                                                                      ; $0293FA |/
+   REP #FLAG_P_ACCUMULATOR                                                     ; $0293FC |\
    LDA r_battle_menu_dma_source_address.w                                      ; $0293FE | | Otherwise, if it is enabled, subtract 64 and 32 instead of adding
    SEC                                                                         ; $029401 | | them to move to the previous row.
    SBC #64.w                                                                   ; $029402 | |
    STA r_battle_menu_dma_source_address.w                                      ; $029405 | |
    LDA r_battle_menu_dma_target_vram_address.w                                 ; $029408 | |
    SEC                                                                         ; $02940B | |
    SBC #32.w                                                                   ; $02940C | |
    STA r_battle_menu_dma_target_vram_address.w                                 ; $02940F |/
++  TDC                                                                         ; $029412 |\
    SEP #FLAG_P_ACCUMULATOR                                                     ; $029413 | | If rows remain, simply return.
    RTS                                                                         ; $029415 |/
+++ STZ r_battle_menu_dma_pending.w                                             ; $029416 | If no rows remain, unset the pending flag and return.
@done:
    RTS                                                                         ; $029419

; _copy_needed_mp_to_vram ($02:941A)
;
; If $1838 is non-zero, copies the six bytes at $1839 to VRAM at the location of
; the "Need MP" display on BG2, which allows the game to update the value
; displayed there.
_copy_needed_mp_to_vram:
    LDA r_battle_needed_mp_pending.w                                            ; $02941A |\ Only execute this function if needed MP updates are pending.
    BEQ +                                                                       ; $02941D |/
    LDX #_sizeof_r_battle_needed_mp_data.w                                      ; $02941F |\
    STX <r_battle_start_vram_dma4_arg_bytes                                     ; $029422 | | Execute a DMA to transfer the tilemap data to VRAM.
    LDA #$00.b                                                                  ; $029424 | |
    LDX #r_battle_needed_mp_data.w                                              ; $029426 | |
    LDY #$5F39.w                                                                ; $029429 | |
    JSR _start_vram_dma4                                                        ; $02942C |/
    STZ r_battle_needed_mp_pending.w                                            ; $02942F | Reset the pending flag.
+   RTS                                                                         ; $029432

; _battle_execute_pending_dialog_dma ($02:9433)
;
; Executes any pending battle dialog DMA actions, as specified in $1824 to
; $1837.
_battle_execute_pending_dialog_dma:
    LDA r_battle_dialog_dma_pending.w                                           ; $029433 |\ Skip most of this function if nothing is pending.
    BEQ +                                                                       ; $029436 |/
    LDA r_battle_dialog_dma_index.w                                             ; $029438 |\
    TAX                                                                         ; $02943B | | Load the appropriate index to read based on which DMA index has
    LDA battle_dialog_dma_index_data.l,X                                        ; $02943C | | been specified.
    TAX                                                                         ; $029440 |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $029441 |\
    LDA r_battle_dialog_dma_data.1.source_address.w - 2,X                       ; $029443 | | Load the DMA parameters and execute the DMA.
    PHA                                                                         ; $029446 | |
    LDA r_battle_dialog_dma_data.1.target_vram_address.w - 2,X                  ; $029447 | |
    TAY                                                                         ; $02944A | |
    LDA r_battle_dialog_dma_data.1.bytes.w - 2,X                                ; $02944B | |
    STA <r_battle_start_vram_dma4_arg_bytes                                     ; $02944E | |
    TDC                                                                         ; $029450 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $029451 | |
    PLX                                                                         ; $029453 | |
    LDA #$7E.b                                                                  ; $029454 | |
    JSR _start_vram_dma4                                                        ; $029456 |/
    DEC r_battle_dialog_dma_index.w                                             ; $029459 |\
    BNE +                                                                       ; $02945C | | Decrement the index and reset pending if all have been finished.
    STZ r_battle_dialog_dma_pending.w                                           ; $02945E |/
+   JSR _copy_needed_mp_to_vram                                                 ; $029461 | Copy any needed MP updates to VRAM.
    JMP _copy_battle_menu_row_to_vram                                           ; $029464 | Copy any pending battle menu rows to VRAM.

; battle_dialog_dma_index_data ($02:9467)
;
; For each of the battle dialog DMA index values, contains the proper value to
; add to the offset to read the designated values.
;
; NOTE: These values are really weird. For whatever reason, instead of
;       explicitly specifying 0, 6 and 12 as the values, 0, 2, 8 and 14 are
;       instead specified, and the reads are adjusted two lower. A 0 value is
;       almost certainly completely invalid. (It could possibly work, but the
;       source address would have to be less than $100 and not $00, and the
;       meaning of the bytes would change.) Doing it this way does all them to
;       use 0 as a termination value, but it's still odd that they specified
;       the offsets shifted by two.
battle_dialog_dma_index_data:
    .db 0                                                                       ; $029467 | $00: Invalid
    .db 2                                                                       ; $029468 | $01
    .db 8                                                                       ; $029469 | $02
    .db 14                                                                      ; $02946A | $03

; _battle_update_dialog_dispatch_and_clear ($02:946B)
;
; Calls _battle_update_dialog_dispatch and then resets its mode argument back
; to zero.
_battle_update_dialog_dispatch_and_clear:
    JSR _battle_update_dialog_dispatch.w                                        ; $02946B | Call the update function.
    STZ r_battle_update_dialog_dispatch_arg_mode.w                              ; $02946E | Zero out the argument for the update function.
    RTS                                                                         ; $029471

; _battle_update_dialog_dispatch ($02:9472)
;
; A dispatch function which serves as a wrapper for various battle dialog update
; functions. Takes a mode parameter in $1821, along with the arguments for the
; various modes.
_battle_update_dialog_dispatch:
    LDA r_battle_update_dialog_dispatch_arg_mode.w                              ; $029472 |\
    ASL A                                                                       ; $029475 | | Multiply the mode by 2 and store the result in the X register.
    TAX                                                                         ; $029476 |/
    LDA battle_update_dialog_mode_offset_data.l + 0,X                           ; $029477 |\
    STA <r_battle_generic_tmp_index_lo                                          ; $02947B | | Load the address to jump to and jump there.
    LDA battle_update_dialog_mode_offset_data.l + 1,X                           ; $02947D | |
    STA <r_battle_generic_tmp_index_hi                                          ; $029481 | |
    JMP (<r_battle_generic_tmp_index)                                           ; $029483 |/

; battle_update_dialog_mode_offset_data ($02:9486)
;
; For each mode of the dialog update function, contains the address to jump to
; to execute that mode.
battle_update_dialog_mode_offset_data:
    .addr _do_nothing_but_return                                                ; $029486.9487 | $00: Nothing
    .addr _battle_update_dialog_character_names                                 ; $029488.9489 | $01: Update the tilemap for the character names.
    .addr _battle_update_dialog_inventory_entry                                 ; $02948A.948B | $02: Update the tilemap for a single inventory entry.
    .addr _battle_update_dialog_spell_list_entry                                ; $02948C.948D | $03: Update the tilemap for a single spell list entry.
    .addr _battle_update_dialog_character_hp                                    ; $02948E.948F | $04: Update the tilemap for the character HP.
    .addr _battle_update_dialog_monster_names                                   ; $029490.9491 | $05: Update the tilemap for the monster names and counts.
    .addr _battle_update_dialog_character_mp                                    ; $029492.9493 | $06: Update the tilemap for the character MP.
    .addr _battle_update_dialog_command_entry                                   ; $029494.9495 | $07: Update the tilemap for a single command entry.
    .addr _battle_swap_inventory                                                ; $029496.9497 | $08: Swaps two inventory entries and updates their tilemaps.
    .addr _battle_swap_hand_inventory_and_update_record                         ; $029498.9499 | $09: Swaps hand inventory and battle inventory entries.

; _do_nothing_but_return ($02:949A)
;
; Does nothing but return.
_do_nothing_but_return:
    RTS                                                                         ; $02949A

; _battle_get_equip_count ($02:949B)
;
; Given the offset to a battle inventory entry in the Y register, determines if
; the item in question is an arrow or not. If so, it returns 20 in $04 and sets
; the carry flag. Otherwise, it returns 1 in $04 and clears the carry flag.
_battle_get_equip_count:
    LDA r_battle_inventory.1.id.w,Y                                             ; $02949B |\
    CMP #ITEM_FIRST_SHIELD.b                                                    ; $02949E | | Determine if the item in the inventory slot indexed by Y is an
    BCC +                                                                       ; $0294A0 | | arrow or not.
    BRA ++                                                                      ; $0294A2 | |
+   CMP #ITEM_FIRST_ARROW.b                                                     ; $0294A4 | |
    BCC ++                                                                      ; $0294A6 |/
    LDA #20.b                                                                   ; $0294A8 |\
    STA <r_battle_get_equip_count_result                                        ; $0294AA | | If the item is an arrow, set the equip count to 20, set the carry
    SEC                                                                         ; $0294AC | | flag and return.
    RTS                                                                         ; $0294AD |/
++  LDA #1.b                                                                    ; $0294AE |\
    STA <r_battle_get_equip_count_result                                        ; $0294B0 | | Otherwise, set the equip count to 1, clear the carry flag and
    CLC                                                                         ; $0294B2 | | return.
    RTS                                                                         ; $0294B3 |/

; _battle_swap_hand_inventory_and_update_record ($02:94B4)
;
; Calls _battle_swap_hand_inventory immediately and afterward copies each
; character's hand inventory to their in-battle character record. Falls through
; to the next function.
_battle_swap_hand_inventory_and_update_record:
    JSR _battle_swap_hand_inventory                                             ; $0294B4 | Swap the items between the inventory and hand as passed.

; _battle_copy_hand_inventory_to_records ($02:94B7)
;
; Copies each character's hand inventory back to their in-battle character
; records.
_battle_copy_hand_inventory_to_records:
    TDC                                                                         ; $0294B7 |\
    TAX                                                                         ; $0294B8 | | Zero out the X and Y registers.
    TAY                                                                         ; $0294B9 | |
    REP #FLAG_P_ACCUMULATOR                                                     ; $0294BA |/
-   LDA r_battle_hand_inventory.1.id.w,X                                        ; $0294BC |\ Copy the right hand item and count to the character's battle
    STA r_character_battle.1.right_hand_item.w,Y                                ; $0294BF |/ record.
.if FF4_VERSION == "JAPAN_EASYTYPE"                                             ;         |\
    AND #$00FF.w                                                                ; $0294C6 | | If the count is zero, set the item ID to zero as well.
.else                                                                           ;         | |
    AND #$FF00.w                                                                ; $0294C2 | | NOTE: The Easytype version instead zeroes the count if the ID is
.endif                                                                          ;         | |       zero. It's not clear if this was the original intent, but it
    BNE +                                                                       ; $0294C5 | |       does serve as an item duplication fix.
    STA r_character_battle.1.right_hand_item.w,Y                                ; $0294C7 |/
+   LDA r_battle_hand_inventory.2.id.w,X                                        ; $0294CA |\ Copy the left hand item and count to the character's battle record.
    STA r_character_battle.1.left_hand_item.w,Y                                 ; $0294CD |/
.if FF4_VERSION == "JAPAN_EASYTYPE"                                             ;         |\
    AND #$00FF.w                                                                ; $0294D4 | | If the count is zero, set the item ID to zero as well.
.else                                                                           ;         | |
    AND #$FF00.w                                                                ; $0294D0 | | NOTE: Similar to above, the Easytype version zeroes the count if
.endif                                                                          ;         | |       the ID is zero.
    BNE +                                                                       ; $0294D3 | |
    STA r_character_battle.1.left_hand_item.w,Y                                 ; $0294D5 |/
+   TXA                                                                         ; $0294D8 |\
    CLC                                                                         ; $0294D9 | | Add the size of the inventory entry to the X register.
    ADC #_sizeof_battle_inventory_entry.w * 2                                   ; $0294DA | |
    TAX                                                                         ; $0294DD |/
    TYA                                                                         ; $0294DE |\
    CLC                                                                         ; $0294DF | | Add the size of the character battle record to the Y register.
    ADC #_sizeof_character_battle.w                                             ; $0294E0 | |
    TAY                                                                         ; $0294E3 |/
    CPY #_sizeof_character_battle.w * 5                                         ; $0294E4 |\ Keep looping until all five slots have been handled.
    BNE -                                                                       ; $0294E7 |/
    TDC                                                                         ; $0294E9 |\ Switch back to 8-bit accumulator mode.
    SEP #FLAG_P_ACCUMULATOR                                                     ; $0294EA |/
    RTS                                                                         ; $0294EC

; _battle_swap_hand_inventory ($02:94ED)
;
; Given a mode in $181C, swaps inventory items between the battle inventory and
; a particular character's hand inventory. The character slot number is passed
; in $1819. The hand index is passed in $181A, and the inventory entry is passed
; in $181B. The modes are as follows:
;
;   $00: Directly swaps the two inventory entries.
;   $01: Transfers from the hand to the inventory, leaving the hand empty.
;   $02: Transfers from the inventory to the hand. Used when the hand contains
;        a different item to that being transferred in. The unequipped item is
;        placed in the entry passed in $181D.
;   $03: Equips arrows.
;   $04: Transfers from the inventory to an assumed empty hand.
_battle_swap_hand_inventory:
    LDA r_battle_swap_inventory_arg_items.1.w                                   ; $0294ED |\
    ASL A                                                                       ; $0294F0 | | Multiply the first index by four and store it for later.
    ASL A                                                                       ; $0294F1 | |
    STA <r_battle_generic_tmp_index_lo                                          ; $0294F2 |/
    LDA r_battle_swap_inventory_arg_slot.w                                      ; $0294F4 |\
    ASL A                                                                       ; $0294F7 | | Calculate the X register by multiplying the slot number by eight
    ASL A                                                                       ; $0294F8 | | and adding the previously calculated offset.
    ASL A                                                                       ; $0294F9 | |
    CLC                                                                         ; $0294FA | |
    ADC <r_battle_generic_tmp_index_lo                                          ; $0294FB | |
    TAX                                                                         ; $0294FD |/
    LDA r_battle_swap_inventory_arg_items.2.w                                   ; $0294FE |\
    ASL A                                                                       ; $029501 | | Set the Y register to the second index times four.
    ASL A                                                                       ; $029502 | |
    TAY                                                                         ; $029503 |/
    LDA r_battle_swap_inventory_arg_mode.w                                      ; $029504 |\
    BEQ @direct_swap_proxy                                                      ; $029507 | | Dispatch to the correct section of code depending on the selected
    CMP #BATTLE_SWAP_INVENTORY_MODE_FROM_HAND.b                                 ; $029509 | | mode.
    BEQ @hand_to_inventory_proxy                                                ; $02950B | |
    CMP #BATTLE_SWAP_INVENTORY_MODE_TO_DIFFERENT_HAND.b                         ; $02950D | |
    BEQ @inventory_to_different_hand                                            ; $02950F | |
    CMP #BATTLE_SWAP_INVENTORY_MODE_ARROW_TO_HAND.b                             ; $029511 | |
    BEQ @inventory_arrow_to_hand                                                ; $029513 | |
    CMP #BATTLE_SWAP_INVENTORY_MODE_TO_EMPTY_HAND.b                             ; $029515 | |
    BEQ @inventory_to_empty_hand                                                ; $029517 |/
    RTS                                                                         ; $029519
@inventory_to_empty_hand:
    JSR _battle_get_equip_count                                                 ; $02951A | Determine if the item in question is an arrow and set the count.
    LDA r_battle_inventory.1.count.w,Y                                          ; $02951D |\
    SEC                                                                         ; $029520 | | Update the item count by subtracting the calculated result.
    SBC <r_battle_get_equip_count_result                                        ; $029521 | |
    STA r_battle_inventory.1.count.w,Y                                          ; $029523 |/
    LDA r_battle_inventory.1.flags.w,Y                                          ; $029526 |\ Transfer the item flags to the new location.
    STA r_battle_hand_inventory.1.flags.w,X                                     ; $029529 |/
    LDA r_battle_inventory.1.id.w,Y                                             ; $02952C |\ Set the item ID in the hand.
    STA r_battle_hand_inventory.1.id.w,X                                        ; $02952F |/
    LDA <r_battle_get_equip_count_result                                        ; $029532 |\ Set the count to the calculated value.
    STA r_battle_hand_inventory.1.count.w,X                                     ; $029534 |/
    LDA r_battle_inventory.1.effect.w,Y                                         ; $029537 |\ Directly transfer the effect byte.
    STA r_battle_hand_inventory.1.effect.w,X                                    ; $02953A |/
    JMP @done                                                                   ; $02953D
@direct_swap_proxy:
    JMP @direct_swap                                                            ; $029540 | Jump to the actual section of code.
@hand_to_inventory_proxy:
    JMP @hand_to_inventory                                                      ; $029543 | Jump to the actual section of code.
@inventory_arrow_to_hand:
    LDA r_battle_inventory.1.count.w,Y                                          ; $029546 |\ Save the inventory count to a temporary location.
    STA <r_battle_generic_tmp_index_hi                                          ; $029549 |/
    LDA #20.b                                                                   ; $02954B |\
    SEC                                                                         ; $02954D | | Calculate 20 minus the hand count and store it in another
    SBC r_battle_hand_inventory.1.count.w,X                                     ; $02954E | | temporary location.
    STA <r_battle_generic_tmp_index_lo                                          ; $029551 |/
    CMP <r_battle_generic_tmp_index_hi                                          ; $029553 |\ If 20 minus the hand count is less than the inventory count, skip
    BCC +                                                                       ; $029555 |/ ahead.
    LDA <r_battle_generic_tmp_index_hi                                          ; $029557 |\
    CLC                                                                         ; $029559 | | Add the complete inventory count to the hand count.
    ADC r_battle_hand_inventory.1.count.w,X                                     ; $02955A | |
    STA r_battle_hand_inventory.1.count.w,X                                     ; $02955D |/
    LDA #BATTLE_INVENTORY_FLAG_DISABLED.b                                       ; $029560 |\ Set the inventory flags suitable for no item.
    STA r_battle_inventory.1.flags.w,Y                                          ; $029562 |/
    TDC                                                                         ; $029565 |\
    STA r_battle_inventory.1.id.w,Y                                             ; $029566 | | Zero out the item ID and the count.
    STA r_battle_inventory.1.count.w,Y                                          ; $029569 |/
    JMP @done                                                                   ; $02956C | Jump to the end.
+   LDA r_battle_hand_inventory.1.count.w,X                                     ; $02956F |\
    CLC                                                                         ; $029572 | | Otherwise, add the calculated value to the hand inventory (which
    ADC <r_battle_generic_tmp_index_lo                                          ; $029573 | | should raise it to 20).
    STA r_battle_hand_inventory.1.count.w,X                                     ; $029575 |/
    LDA <r_battle_generic_tmp_index_hi                                          ; $029578 |\
    SEC                                                                         ; $02957A | | Subtract the added value from the actual inventory.
    SBC <r_battle_generic_tmp_index_lo                                          ; $02957B | |
    STA r_battle_inventory.1.count.w,Y                                          ; $02957D |/
    JMP @done                                                                   ; $029580
@inventory_to_different_hand:
    LDA r_battle_hand_inventory.1.flags.w,X                                     ; $029583 |\
    STA <r_battle_swap_inventory_tmp_flags                                      ; $029586 | | Copy the four bytes in the hand to temporary varaibles.
    LDA r_battle_hand_inventory.1.id.w,X                                        ; $029588 | |
    STA <r_battle_swap_inventory_tmp_id                                         ; $02958B | |
    LDA r_battle_hand_inventory.1.count.w,X                                     ; $02958D | |
    STA <r_battle_swap_inventory_tmp_count                                      ; $029590 | |
    LDA r_battle_hand_inventory.1.effect.w,X                                    ; $029592 | |
    STA <r_battle_swap_inventory_tmp_effect                                     ; $029595 |/
    JSR _battle_get_equip_count                                                 ; $029597 | Determine if the inventory item is an arrow and set the count.
    LDA r_battle_inventory.1.count.w,Y                                          ; $02959A |\
    SEC                                                                         ; $02959D | | Subtract the correct number of items from the inventory.
    SBC <r_battle_get_equip_count_result                                        ; $02959E | | TODO: Is there protection against this going negative/zero?
    STA r_battle_inventory.1.count.w,Y                                          ; $0295A0 |/
    LDA r_battle_inventory.1.flags.w,Y                                          ; $0295A3 |\ Copy the flags from the inventory to the hand.
    STA r_battle_hand_inventory.1.flags.w,X                                     ; $0295A6 |/
    LDA r_battle_inventory.1.id.w,Y                                             ; $0295A9 |\ Copy the ID from the inventory to the hand.
    STA r_battle_hand_inventory.1.id.w,X                                        ; $0295AC |/
    LDA <r_battle_get_equip_count_result                                        ; $0295AF |\ Set the number of items in the hand to the calculated count.
    STA r_battle_hand_inventory.1.count.w,X                                     ; $0295B1 |/
    LDA r_battle_inventory.1.effect.w,Y                                         ; $0295B4 |\ Transfer the effect byte from the inventory to the hand.
    STA r_battle_hand_inventory.1.effect.w,X                                    ; $0295B7 |/
    LDA r_battle_swap_inventory_arg_inventory_target.w                          ; $0295BA |\
    ASL A                                                                       ; $0295BD | | Set the Y register to the desired target inventory slot times
    ASL A                                                                       ; $0295BE | | four.
    TAY                                                                         ; $0295BF |/
    LDA <r_battle_swap_inventory_tmp_flags                                      ; $0295C0 |\
    STA r_battle_inventory.1.flags.w,Y                                          ; $0295C2 | | Transfer the previously saved values from the hand to the target
    LDA <r_battle_swap_inventory_tmp_id                                         ; $0295C5 | | inventory location.
    STA r_battle_inventory.1.id.w,Y                                             ; $0295C7 | |
    LDA <r_battle_swap_inventory_tmp_count                                      ; $0295CA | |
    STA r_battle_inventory.1.count.w,Y                                          ; $0295CC | |
    LDA <r_battle_swap_inventory_tmp_effect                                     ; $0295CF | |
    STA r_battle_inventory.1.effect.w,Y                                         ; $0295D1 |/
    LDA r_battle_swap_inventory_arg_inventory_target.w                          ; $0295D4 |\
    STA r_battle_update_dialog_arg_entry.w                                      ; $0295D7 | | Update the tilemap for the target inventory entry.
    JSR _battle_update_dialog_inventory_entry                                   ; $0295DA |/
    JMP @done                                                                   ; $0295DD
@hand_to_inventory:
    LDA r_battle_inventory.1.count.w,Y                                          ; $0295E0 |\
    CLC                                                                         ; $0295E3 | | Add the hand inventory count to the inventory count.
    ADC r_battle_hand_inventory.1.count.w,X                                     ; $0295E4 |/
    CMP #100.b                                                                  ; $0295E7 |\
    BCC +                                                                       ; $0295E9 | | If 100 or greater, replace with 99.
    LDA #99.b                                                                   ; $0295EB |/
+   STA r_battle_inventory.1.count.w,Y                                          ; $0295ED | Store the updated count in the inventory.
    LDA #BATTLE_INVENTORY_FLAG_DISABLED.b                                       ; $0295F0 |\ Set the tile flags to disabled.
    STA r_battle_hand_inventory.1.flags.w,X                                     ; $0295F2 |/ TODO: Does this affect more than just palettes?
    STZ r_battle_hand_inventory.1.id.w,X                                        ; $0295F5 | Set the hand inventory to empty.
    STZ r_battle_hand_inventory.1.count.w,X                                     ; $0295F8 | Zero out the count of the hand inventory.
    JMP @done                                                                   ; $0295FB
@direct_swap:
    LDA #_sizeof_battle_inventory_entry.b                                       ; $0295FE |\
    STA <r_battle_generic_tmp_index_lo                                          ; $029600 | | Directly swap the four bytes of each entry, one in the character's
-   LDA r_battle_hand_inventory.w,X                                             ; $029602 | | hand, the other in the actual inventory.
    PHA                                                                         ; $029605 | |
    LDA r_battle_inventory.w,Y                                                  ; $029606 | |
    STA r_battle_hand_inventory.w,X                                             ; $029609 | |
    PLA                                                                         ; $02960C | |
    STA r_battle_inventory.w,Y                                                  ; $02960D | |
    INX                                                                         ; $029610 | |
    INY                                                                         ; $029611 | |
    DEC <r_battle_generic_tmp_index_lo                                          ; $029612 | |
    BNE -                                                                       ; $029614 |/
@done:
    LDA r_battle_swap_inventory_arg_slot.w                                      ; $029616 |\ Set the slot for the update functions.
    STA r_battle_update_dialog_arg_slot.w                                       ; $029619 |/
    LDX r_battle_swap_inventory_arg_items.w                                     ; $02961C |\ Transfer the items to the update function argument.
    STX r_battle_update_dialog_arg_entry.w                                      ; $02961F |/
    LDA r_battle_update_dialog_arg_entry.w                                      ; $029622 | Pointlessly load the entry into the accumulator.
    JSR _battle_update_dialog_hand_inventory_entry                              ; $029625 | Update the tilemap for the hand inventory entry.
    LDA r_battle_update_dialog_tmp_entry.w                                      ; $029628 |\
    STA r_battle_update_dialog_arg_entry.w                                      ; $02962B | | Update the variable and then update the tilemap for the inventory.
    JMP _battle_update_dialog_inventory_entry                                   ; $02962E |/

; _battle_swap_inventory ($02:9631)
;
; Swaps two items in the in-battle inventory by directly swapping the four bytes
; for each entry. Also updates the tilemap by calling the relevant tilemap
; update function.
_battle_swap_inventory:
    LDA r_battle_swap_inventory_arg_items.1.w                                   ; $029631 |\
    ASL A                                                                       ; $029634 | | Set the X register the offset to the first item.
    ASL A                                                                       ; $029635 | |
    TAX                                                                         ; $029636 |/
    LDA r_battle_swap_inventory_arg_items.2.w                                   ; $029637 |\
    ASL A                                                                       ; $02963A | | Set the Y register to the offset to the second item.
    ASL A                                                                       ; $02963B | |
    TAY                                                                         ; $02963C |/
    LDA #4.b                                                                    ; $02963D |\ Initialize the index to copy four bytes.
    STA <r_battle_generic_tmp_index_lo                                          ; $02963F |/
-   LDA r_battle_inventory.w,X                                                  ; $029641 |\
    PHA                                                                         ; $029644 | | Swap the two bytes by reading the first, storing it on the stack,
    LDA r_battle_inventory.w,Y                                                  ; $029645 | | moving the second, and then restoring the first and storing it.
    STA r_battle_inventory.w,X                                                  ; $029648 | |
    PLA                                                                         ; $02964B | |
    STA r_battle_inventory.w,Y                                                  ; $02964C |/
    INX                                                                         ; $02964F |\
    INY                                                                         ; $029650 | | Increment the X and Y registers and loop until all four bytes have
    DEC <r_battle_generic_tmp_index_lo                                          ; $029651 | | been copied.
    BNE -                                                                       ; $029653 |/
    LDA r_battle_swap_inventory_arg_slot.w                                      ; $029655 |\  Copy the slot into the update dialog argument.
    STA r_battle_update_dialog_arg_slot.w                                       ; $029658 |/
    LDX r_battle_swap_inventory_arg_items.w                                     ; $02965B |\ Copy both inventory items to the argument location and a temporary
    STX r_battle_update_dialog_arg_entry.w                                      ; $02965E |/ location.
    JSR _battle_update_dialog_inventory_entry                                   ; $029661 | Update the tilemap for the first entry.
    LDA r_battle_update_dialog_tmp_entry.w                                      ; $029664 |\
    STA r_battle_update_dialog_arg_entry.w                                      ; $029667 | | Copy the location of the second entry and update its tilemap.
    JMP _battle_update_dialog_inventory_entry                                   ; $02966A |/

; _execute_battle_dialog_updates ($02:966D)
;
; Executes any currently pending battle dialog updates, including configuring
; the DMA to transfer the updates to VRAM during the next NMI.
_execute_battle_dialog_updates:
    LDA r_battle_dialog_dma_pending.w                                           ; $02966D |\ Skip this function if a dialog DMA is already pending.
    BNE +                                                                       ; $029670 |/
    JSR _battle_update_dialog_dispatch_and_clear                                ; $029672 | Do any pending updates of individual dialog tilemaps.
    JSR _battle_execute_pending_dialog_update                                   ; $029675 | Do any pending updates of the primary tilemaps.
    LDA r_battle_dialog_update_pending_2.w                                      ; $029678 |\
    STA r_battle_dialog_update_pending.w                                        ; $02967B | | Transfer the second pending value to the pending variable.
    STZ r_battle_dialog_update_pending_2.w                                      ; $02967E |/
+   RTS                                                                         ; $029681

; _battle_execute_pending_dialog_update ($02:9682)
;
; If a dialog tilemap update is currently pending, jump to the function that
; handles that particular update.
_battle_execute_pending_dialog_update:
    LDA r_battle_dialog_update_pending.w                                        ; $029682 |\
    ASL A                                                                       ; $029685 | | Load the pending update ID, multiply by two, and transfer to X.
    TAX                                                                         ; $029686 |/
    LDA battle_dialog_tilemap_update_offset_data.l + 0,X                        ; $029687 |\
    STA <r_battle_generic_tmp_index_lo                                          ; $02968B | | Load the associated pointer and jump to it.
    LDA battle_dialog_tilemap_update_offset_data.l + 1,X                        ; $02968D | |
    STA <r_battle_generic_tmp_index_hi                                          ; $029691 | |
    JMP (<r_battle_generic_tmp_index)                                           ; $029693 |/

; battle_dialog_tilemap_update_offset_data ($02:9696)
;
; Provides several different pointers to functions related to updating the
; dialog tilemaps in battle.
battle_dialog_tilemap_update_offset_data:
    .addr _do_nothing_but_return_2                                              ; $029696.9697 | $00: Do nothing.
    .addr _do_nothing_but_return_2                                              ; $029698.9699 | $01: Do nothing.
    .addr _battle_update_info_area_tilemap                                      ; $02969A.969B | $02: Update information area on BG3.
    .addr _battle_update_info_area_menu_tilemap                                 ; $02969C.969D | $03: Update information area with menu on BG3.
    .addr _battle_update_spell_list_tilemap_1                                   ; $02969E.969F | $04: Update spell list on BG3 with first spell list.
    .addr _battle_update_spell_list_tilemap_2                                   ; $0296A0.96A1 | $05: Update spell list on BG3 with second spell list.
    .addr _battle_update_spell_list_tilemap_3                                   ; $0296A2.96A3 | $06: Update spell list on BG3 with third spell list.
    .addr _battle_update_inventory_tilemap                                      ; $0296A4.96A5 | $07: Update inventory on BG3.
    .addr _battle_update_mp_tilemap                                             ; $0296A6.96A7 | $08: Update MP on BG2.
    .addr _battle_update_hand_inventory_tilemap                                 ; $0296A8.96A9 | $09: Update hand inventory on BG3.
    .addr _do_nothing_but_return_3                                              ; $0296AA.96AB | $0A: Do nothing.
    .addr _do_nothing_but_return_3                                              ; $0296AC.96AD | $0B: Do nothing.
    .addr _battle_update_hp_and_status_tilemap                                  ; $0296AE.96AF | $0C: Update HP and status on BG3.

; battle_periodic_dialog_update_offset_data ($02:96B0)
;
; During times when no other battle dialog updates are occuring, the game
; schedules one of the following functions to run on an alternating basis.
battle_periodic_dialog_update_offset_data:
    .addr _battle_update_info_area_tilemap                                      ; $0296B0.96B1 | $00: Update information area on BG3.
    .addr _battle_update_info_area_menu_tilemap                                 ; $0296B2.96B3 | $01: Update information area with menu on BG3.
    .addr _battle_update_mp_tilemap                                             ; $0296B4.96B5 | $02: Update MP on BG2.
    .addr _battle_update_hand_inventory_tilemap                                 ; $0296B6.96B7 | $03: Update hand inventory on BG3.
    .addr _battle_update_inventory_spell_list_tilemap                           ; $0296B8.96B9 | $04: Update inventory/spell list on BG3 depending on a flag.
    .addr _battle_update_hp_and_status_tilemap                                  ; $0296BA.96BB | $05: Update HP and status on BG3.
    .addr _battle_update_info_area_tilemap                                      ; $0296BC.96BD | $06: Update information area on BG3.
    .addr _battle_update_dialog_character_names                                 ; $0296BE.96BF | $07: Update character names.

; battle_periodic_dma_update_offset_data ($02:96C0)
;
; During certain times (TODO, but possibly during animations) when no battle
; dialog DMA is pending, the game periodically schedules the following updates
; on an alternating basis.
battle_periodic_dma_update_offset_data:
    .addr _battle_update_dialog_character_names                                 ; $0296C0.96C1 | $00: Update character names.
    .addr _battle_set_info_area_dma                                             ; $0296C2.96C3 | $01: Configure DMA to transfer info area to VRAM.
    .addr _battle_set_info_area_menu_dma                                        ; $0296C4.96C5 | $02: Configure DMA to transfer info area with menu to VRAM.
    .addr _battle_set_hp_and_status_dma                                         ; $0296C6.96C7 | $03: Configure DMA to transfer HP and status to VRAM.

; _battle_update_info_areas_tilemap_data ($02:96C8)
;
; A weird wrapper for the routines that update tilemaps for the info areas on
; BG3. In particular, it updates the HP and Status and Info Area (menu) tilemaps
; first, and then updates the names and HP. The consequence is that if the
; latter change, those updates will not be reflected on the first two.
;
; TODO: Figure out if this is a bug.
_battle_update_info_areas_tilemap_data:
    JSR _battle_update_hp_and_status_tilemap_data                               ; $0296C8 | Update the HP and Status tilemap mirror in RAM.
    JSR _battle_update_info_area_menu_tilemap_data                              ; $0296CB | Update the information area with menu tilemap mirror.
    JSR _battle_update_info_area_names                                          ; $0296CE | Update the information area names.
    JMP _battle_update_info_area_hp                                             ; $0296D1 | Update the information area HP.

; _battle_update_inventory_spell_list_tilemap ($02:96D4)
;
; Updates the inventory/spell list tilemap to either the inventory or one of the
; spell lists depending on the value of $4A.
_battle_update_inventory_spell_list_tilemap:
    LDA <r_battle_menu_flags.1                                                  ; $0296D4 |\
    AND #BATTLE_MENU_FLAG_1_SPELL_AND_INVENTORY.b                               ; $0296D6 | | Mask out the spell list, inventory and hand inventory flags.
    BEQ ++                                                                      ; $0296D8 |/
    CMP #BATTLE_MENU_FLAG_1_SPELL_LIST_3.b                                      ; $0296DA |\
    BNE +                                                                       ; $0296DC | | If only the third spell list bit is set, do the third spell list.
    JMP _battle_update_spell_list_tilemap_3                                     ; $0296DE |/
+   CMP #BATTLE_MENU_FLAG_1_SPELL_LIST_2.b                                      ; $0296E1 |\
    BNE +                                                                       ; $0296E3 | | Do the second spell list if it's the only set bit.
    JMP _battle_update_spell_list_tilemap_2                                     ; $0296E5 |/
+   CMP #BATTLE_MENU_FLAG_1_SPELL_LIST_1.b                                      ; $0296E8 |\
    BNE +                                                                       ; $0296EA | | Do the first spell list if it's the only set bit.
    JMP _battle_update_spell_list_tilemap_1                                     ; $0296EC |/
+   LDA <r_battle_menu_flags.1                                                  ; $0296EF |\
    AND #BATTLE_MENU_FLAG_1_INVENTORY.b                                         ; $0296F1 | | Otherwise, if the inventory bit is set, draw the inventory.
    BEQ ++                                                                      ; $0296F3 | |
    JMP _battle_update_inventory_tilemap                                        ; $0296F5 |/
++  RTS                                                                         ; $0296F8

UNUSED_CODE_0296F9:
    RTS                                                                         ; $0296F9

; _execute_periodic_battle_dialog_updates ($02:96FA)
;
; If no battle dialog DMA is currently configured, configures one of the eight
; periodic updates depending on the value of the counter at $1845.
_execute_periodic_battle_dialog_updates:
    LDA r_battle_dialog_dma_pending.w                                           ; $0296FA |\ Skip this function if a dialog DMA is already pending.
    BNE +                                                                       ; $0296FD |/
    INC r_battle_periodic_dialog_update_counter.w                               ; $0296FF | Increment the periodic dialog update counter.
    LDA r_battle_periodic_dialog_update_counter.w                               ; $029702 |\
    AND #%00000111.b                                                            ; $029705 | | Set the index by taking the counter mod 8 and multiplying by two.
    ASL A                                                                       ; $029707 | |
    TAX                                                                         ; $029708 |/
    LDA battle_periodic_dialog_update_offset_data.l + 0,X                       ; $029709 |\
    STA <r_battle_generic_tmp_index_lo                                          ; $02970D | | Load the pointer and jump to that function.
    LDA battle_periodic_dialog_update_offset_data.l + 1,X                       ; $02970F | |
    STA <r_battle_generic_tmp_index_hi                                          ; $029713 | |
    JMP (<r_battle_generic_tmp_index)                                           ; $029715 |/
+   RTS                                                                         ; $029718

; _execute_periodic_battle_dma_updates ($02:9719)
;
; If no battle dialog DMA is currnetly configured, configures one of the four
; periodic DMA updates depending on the value of the counter at $F44D.
_execute_periodic_battle_dma_updates:
    LDA r_battle_dialog_dma_pending.w                                           ; $029719 |\ Skip this function if a dialog DMA is already pending.
    BNE +                                                                       ; $02971C |/
    INC r_battle_periodic_dma_update_counter.w                                  ; $02971E | Increment the periodic DMA update counter.
    LDA r_battle_periodic_dma_update_counter.w                                  ; $029721 |\
    AND #%00000011.b                                                            ; $029724 | | Set the index by taking the counter mod 4 and multiplying by two.
    ASL A                                                                       ; $029726 | |
    TAX                                                                         ; $029727 |/
    LDA battle_periodic_dma_update_offset_data.l + 0,X                          ; $029728 |\
    STA <r_battle_generic_tmp_index_lo                                          ; $02972C | | Load the pointer and jump to that function.
    LDA battle_periodic_dma_update_offset_data.l + 1,X                          ; $02972E | |
    STA <r_battle_generic_tmp_index_hi                                          ; $029732 | |
    JMP (<r_battle_generic_tmp_index)                                           ; $029734 |/
+   RTS                                                                         ; $029737

; _load_battle_dialog_dma_parameters ($02:9738)
;
; Loads parameters for a battle dialog DMA transfer. The desired parameter index
; to load should be specified in the accumulator. The offset to which set of DMA
; data to write to (relative to the first) should be passed in the Y register.
; The data will ultimately be copied to $1824 plus Y, which means values of 2,
; 8 and 14 make sense.
_load_battle_dialog_dma_parameters:
    PHY                                                                         ; $029738 | Preserve the value of the Y register.
    STA <r_math_multiply_8bit_arg_1                                             ; $029739 |\
    LDA #_sizeof_battle_dialog_dma.b                                            ; $02973B | | Set the value of the X register to the value passed in the
    STA <r_math_multiply_8bit_arg_2                                             ; $02973D | | accumulator times six to determine the offset into the dialog DMA
    JSR _math_multiply_8bit                                                     ; $02973F | | data.
    LDX <r_math_multiply_8bit_result                                            ; $029742 |/
    PLY                                                                         ; $029744 | Restore the Y register.
    LDA #_sizeof_battle_dialog_dma.b                                            ; $029745 |\ Set the index variable to copy the six bytes of the data.
    STA <r_battle_generic_tmp_index_lo                                          ; $029747 |/
-   LDA bank16.battle_dialog_dma_data.l,X                                       ; $029749 |\
    STA r_battle_dialog_dma_data.w - 2,Y                                        ; $02974D | | Copy the byte and loop until all six have been copied.
    INY                                                                         ; $029750 | |
    INX                                                                         ; $029751 | |
    DEC <r_battle_generic_tmp_index_lo                                          ; $029752 | |
    BNE -                                                                       ; $029754 |/
    RTS                                                                         ; $029756

; _do_nothing_but_return_2 ($02:9757)
;
; Does nothing but return.
_do_nothing_but_return_2:
    RTS                                                                         ; $029757

; battle_character_slot_mp_tilemap_offset_data ($02:9758)
;
; For each slot, contains the offset to that slot's data in the character MP
; tilemap data in RAM.
battle_character_slot_mp_tilemap_offset_data:
    .db (7 * 2 * 2) * 0                                                         ; $029758 | $00
    .db (7 * 2 * 2) * 1                                                         ; $029759 | $01
    .db (7 * 2 * 2) * 2                                                         ; $02975A | $02
    .db (7 * 2 * 2) * 3                                                         ; $02975B | $03
    .db (7 * 2 * 2) * 4                                                         ; $02975C | $04

; battle_bg2_need_mp_tilemap_data ($02:975D)
;
; Contains the tile numbers necessary to render "Need MP" on BG2.
battle_bg2_need_mp_tilemap_data:
    .db $DE, $DF, $E0, $E1, $FF, $E2, $E3                                       ; $02975D.9763

; _battle_update_mp_tilemap ($02:9764)
;
; Copies the tilemap data for the active character's MP to the BG2 tilemap data
; area in RAM, and then configures the necessary DMA and flags it as pending.
_battle_update_mp_tilemap:
    LDA r_battle_last_active_character_slot.w                                   ; $029764 |\
    TAX                                                                         ; $029767 | | Set the X register to the offset to the currently active character
    LDA battle_character_slot_mp_tilemap_offset_data.l,X                        ; $029768 | | slot's MP tilemap.
    TAX                                                                         ; $02976C |/
    TDC                                                                         ; $02976D |\ Initialize the Y register to zero.
    TAY                                                                         ; $02976E |/
-   LDA r_battle_character_mp_tilemap_data.w,X                                  ; $02976F |\ Copy the first row of the tilemap data to the correct location on
    STA r_battle_tilemap_bg2_lower.w + (64 * 1) + 46,Y                          ; $029772 |/ the BG2 tilemap data in RAM.
    LDA r_battle_character_mp_tilemap_data.w + 14,X                             ; $029775 |\ Copy the second row of the tilemap data exactly one row below the
    STA r_battle_tilemap_bg2_lower.w + (64 * 2) + 46,Y                          ; $029778 |/ first.
    INY                                                                         ; $02977B |\
    INX                                                                         ; $02977C | | Increment the registers and loop until all 7 tiles in both rows
    CPY #14.w                                                                   ; $02977D | | have been transferred.
    BNE -                                                                       ; $029780 |/
    TDC                                                                         ; $029782 |\
    TAX                                                                         ; $029783 | | Initialize the X and Y registers to zero.
    TAY                                                                         ; $029784 |/
-   LDA battle_bg2_need_mp_tilemap_data.l,X                                     ; $029785 |\
    STA r_battle_tilemap_bg2_lower.w + (64 * 4) + 46,Y                          ; $029789 | | Write the tiles corresponding to "Need MP" to two lines below the
    INY                                                                         ; $02978C | | actual MP display.
    INY                                                                         ; $02978D | |
    INX                                                                         ; $02978E | |
    CPX #_sizeof_battle_bg2_need_mp_tilemap_data.w                              ; $02978F | |
    BNE -                                                                       ; $029792 |/
    LDA #BATTLE_DIALOG_DMA_MP.b                                                 ; $029794 |\
    LDY #BATTLE_DIALOG_DMA_OFFSET_1.w                                           ; $029796 | | Load the DMA parameters to transfer the MP data to VRAM.
    JSR _load_battle_dialog_dma_parameters                                      ; $029799 |/
    LDA #1.b                                                                    ; $02979C |\
    STA r_battle_dialog_dma_index.w                                             ; $02979E | | Configure the DMA and flag it as pending.
    STA r_battle_dialog_dma_pending.w                                           ; $0297A1 |/
    RTS                                                                         ; $0297A4

; _do_nothing_but_return_3 ($02:97A5)
;
; Does nothing but return.
_do_nothing_but_return_3:
    RTS                                                                         ; $0297A5

; _battle_update_hand_inventory_tilemap ($02:97A6)
;
; Copies the hand inventory tilemap for the currently active character from RAM
; to the tilemap staging area in RAM and configures the DMA to transfer it to
; VRAM, which will be executed by the NMI handler.
_battle_update_hand_inventory_tilemap:
    LDX #r_battle_tilemap_bg3_hand_inventory.w + (64 * 1) + 6                   ; $0297A6 |\ Set the first index to the location for the right hand data in the
    STX <r_battle_generic_tmp_index                                             ; $0297A9 |/ hand inventory tilemap.
    LDX #r_battle_tilemap_bg3_hand_inventory.w + (64 * 1) + 34                  ; $0297AB |\ Set the second index to the location for the left hand data.
    STX <r_battle_generic_tmp_index_2                                           ; $0297AE |/
    LDA r_battle_last_active_character_slot.w                                   ; $0297B0 |\
    ASL A                                                                       ; $0297B3 | | Set the X register to the active character slot times two.
    TAX                                                                         ; $0297B4 |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $0297B5 |\
    LDA bank16.battle_hand_inventory_slot_tilemap_offset_data.l,X               ; $0297B7 | | Load the offset to the slot's hand inventory tilemap data.
    PHA                                                                         ; $0297BB |/
    LDA bank16.battle_hand_inventory_header_tilemap_offset_data.l,X             ; $0297BC |\ Load the offset to the slot's hand inventory header tilemap data
    TAX                                                                         ; $0297C0 |/ and put it in the X register.
    TDC                                                                         ; $0297C1 |\
    SEP #FLAG_P_ACCUMULATOR                                                     ; $0297C2 | | Zero out the Y register.
    TDC                                                                         ; $0297C4 | |
    TAY                                                                         ; $0297C5 |/
-   LDA 0.w,X                                                                   ; $0297C6 |\ Load the right hand header tile and store it in the destination.
    STA (<r_battle_generic_tmp_index),Y                                         ; $0297C9 |/
    LDA 20.w,X                                                                  ; $0297CB |\ Repeat with the left hand header tile data.
    STA (<r_battle_generic_tmp_index_2),Y                                       ; $0297CE |/
    INX                                                                         ; $0297D0 |\
    INY                                                                         ; $0297D1 | | Increment the index registers and loop until all ten bytes have
    CPY #10.w                                                                   ; $0297D2 | | been copied.
    BNE -                                                                       ; $0297D5 |/
    LDY #64.w                                                                   ; $0297D7 | Set the Y register to 64 to move down one line.
-   LDA 0.w,X                                                                   ; $0297DA |\
    STA (<r_battle_generic_tmp_index),Y                                         ; $0297DD | | Repeat the above process, except copying the second line of the
    LDA 20.w,X                                                                  ; $0297DF | | header tilemap data.
    STA (<r_battle_generic_tmp_index_2),Y                                       ; $0297E2 | |
    INX                                                                         ; $0297E4 | |
    INY                                                                         ; $0297E5 | |
    CPY #74.w                                                                   ; $0297E6 | |
    BNE -                                                                       ; $0297E9 |/
    PLX                                                                         ; $0297EB | Set the X register to the offset to the actual hand inventory data.
    LDY #128.w                                                                  ; $0297EC | Set the Y register to move down yet another line.
-   LDA 0.w,X                                                                   ; $0297EF |\
    STA (<r_battle_generic_tmp_index),Y                                         ; $0297F2 | | Copy the upper row of the actual hand inventory tilemap data. The
    LDA 48.w,X                                                                  ; $0297F4 | | entries are longer in the source data so the offsets are different
    STA (<r_battle_generic_tmp_index_2),Y                                       ; $0297F7 | | from above.
    INX                                                                         ; $0297F9 | |
    INY                                                                         ; $0297FA | |
    CPY #152.w                                                                  ; $0297FB | |
    BNE -                                                                       ; $0297FE |/
    LDY #192.w                                                                  ; $029800 | Set the Y register to move down another line.
-   LDA 0.w,X                                                                   ; $029803 |\
    STA (<r_battle_generic_tmp_index),Y                                         ; $029806 | | Loop once more to copy the second row of the hand inventory
    LDA 48.w,X                                                                  ; $029808 | | tilemap data.
    STA (<r_battle_generic_tmp_index_2),Y                                       ; $02980B | |
    INX                                                                         ; $02980D | |
    INY                                                                         ; $02980E | |
    CPY #216.w                                                                  ; $02980F | |
    BNE -                                                                       ; $029812 |/
    LDA #BATTLE_DIALOG_DMA_HAND_INVENTORY.b                                     ; $029814 |\
    LDY #BATTLE_DIALOG_DMA_OFFSET_1.w                                           ; $029816 | | Load the DMA parameters for transferring the hand inventory.
    JSR _load_battle_dialog_dma_parameters                                      ; $029819 |/
    LDA #1.b                                                                    ; $02981C |\
    STA r_battle_dialog_dma_index.w                                             ; $02981E | | Set the index and flag the DMA as pending.
    STA r_battle_dialog_dma_pending.w                                           ; $029821 |/
    RTS                                                                         ; $029824

; spell_list_tilemap_offset_data ($02:9825)
;
; For each character slot, contains the offset to that character's spell entries
; in the spell list tilemap.
spell_list_tilemap_offset_data:
    .dw (6 * 2 * 2) * (72 * 0)                                                  ; $029825.9826
    .dw (6 * 2 * 2) * (72 * 1)                                                  ; $029827.9828
    .dw (6 * 2 * 2) * (72 * 2)                                                  ; $029829.982A
    .dw (6 * 2 * 2) * (72 * 3)                                                  ; $02982B.982C
    .dw (6 * 2 * 2) * (72 * 4)                                                  ; $02982D.982E

; _battle_update_spell_list_tilemap_* ($02:982F)
;
; This series of three functions updates the inventory tilemap data to hold the
; spell list of the currently active character slot. The spell list to load is
; determined by the entry point. After updating the tilemap, the DMA is send the
; update to VRAM is configured.
_battle_update_spell_list_tilemap_3:
    LDX #(6 * 2 * 2 * 24 * 2).w                                                 ; $02982F |\ Set the offset for the third spell list and branch to the common
    BRA _battle_update_spell_list_tilemap_common                                ; $029832 |/ entry.
_battle_update_spell_list_tilemap_2:
    LDX #(6 * 2 * 2 * 24 * 1).w                                                 ; $029834 |\ Set the offset for the second spell list and branch to the common
    BRA _battle_update_spell_list_tilemap_common                                ; $029837 |/ entry.
_battle_update_spell_list_tilemap_1:
    LDX #(6 * 2 * 2 * 24 * 0).w                                                 ; $029839 | Set the offset for the first spell list and fall through.
_battle_update_spell_list_tilemap_common:
    PHX                                                                         ; $02983C | Preserve the value of the X register.
    LDA r_battle_last_active_character_slot.w                                   ; $02983D |\
    STA <r_battle_update_arg_slot                                               ; $029840 | | Update the palettes for the active character's spell lists.
    JSR _battle_update_spell_list_palettes                                      ; $029842 |/
    PLX                                                                         ; $029845 |\ Restore the X register and save it in a variable for later.
    STX <r_battle_update_spell_list_tilemap_offset                              ; $029846 |/
    LDX #r_battle_tilemap_bg3_inventory.w + 64 + 16                             ; $029848 |\ Set one index to point to the first row of the inventory tilemap.
    STX <r_battle_generic_tmp_index                                             ; $02984B |/ This starts 8 tiles into the line, after the first spell column.
    LDX #16.w                                                                   ; $02984D | Initialize the X register to 16.
--  TDC                                                                         ; $029850 |\
    TAY                                                                         ; $029851 | | Initialize the Y register to zero and the accumulator to $FF.
    DEC A                                                                       ; $029852 |/
-   STA (<r_battle_generic_tmp_index),Y                                         ; $029853 | Store the blank tile on the tilemap.
    INY                                                                         ; $029855 |\ Increment the pointer by two to move to the next tile.
    INY                                                                         ; $029856 |/
    CPY #42.w                                                                   ; $029857 |\ Repeat until the entire rest of the line has been erased.
    BNE -                                                                       ; $02985A |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $02985C |\
    LDA <r_battle_generic_tmp_index                                             ; $02985E | | Add 64 to the index to move to the next line.
    CLC                                                                         ; $029860 | |
    ADC #64.w                                                                   ; $029861 | |
    STA <r_battle_generic_tmp_index                                             ; $029864 | |
    TDC                                                                         ; $029866 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $029867 |/
    DEX                                                                         ; $029869 |\ Decrement the X register and loop until all 8 full rows have been
    BNE --                                                                      ; $02986A |/ erased.
    LDX #r_battle_tilemap_bg3_inventory.w + 64 + 4                              ; $02986C |\ Set the first index to the first spell column.
    STX <r_battle_generic_tmp_index                                             ; $02986F |/
    LDX #r_battle_tilemap_bg3_inventory.w + 64 + 18                             ; $029871 |\ Set the second index to the second spell column.
    STX <r_battle_generic_tmp_index_2                                           ; $029874 |/
    LDX #r_battle_tilemap_bg3_inventory.w + 64 + 32                             ; $029876 |\ Set the third index to the third spell column.
    STX <r_battle_generic_tmp_index_3                                           ; $029879 |/
    LDA r_battle_last_active_character_slot.w                                   ; $02987B |\
    ASL A                                                                       ; $02987E | | Set the X register to the active character slot times two.
    TAX                                                                         ; $02987F |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $029880 |\
    LDA spell_list_tilemap_offset_data.l,X                                      ; $029882 | | Load the offset to this slot's section of the spell list tilemap,
    CLC                                                                         ; $029886 | | and then add the offset for the particular spell list in question.
    ADC <r_battle_update_spell_list_tilemap_offset                              ; $029887 | |
    TAX                                                                         ; $029889 | |
    TDC                                                                         ; $02988A | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $02988B |/
    LDA #8.b                                                                    ; $02988D |\ Set the count to 8 as there are eight rows to go through.
    STA <r_battle_generic_tmp_count                                             ; $02988F |/
@start:
    TDC                                                                         ; $029891 |\ Initialize the Y register to zero.
    TAY                                                                         ; $029892 |/
-   LDA r_battle_spell_list_tilemap_data.w,X                                    ; $029893 |\
    STA (<r_battle_generic_tmp_index),Y                                         ; $029896 | | Copy the first row of the three entries to their respective
    LDA r_battle_spell_list_tilemap_data.w + 24,X                               ; $029898 | | locations.
    STA (<r_battle_generic_tmp_index_2),Y                                       ; $02989B | |
    LDA r_battle_spell_list_tilemap_data.w + 48,X                               ; $02989D | |
    STA (<r_battle_generic_tmp_index_3),Y                                       ; $0298A0 |/
    INY                                                                         ; $0298A2 |\
    INX                                                                         ; $0298A3 | | Increment the indexes and loop until all six characters of each
    CPY #12.w                                                                   ; $0298A4 | | have been copied.
    BNE -                                                                       ; $0298A7 |/
    LDY #64.w                                                                   ; $0298A9 | Update the Y register to point to the next line.
-   LDA r_battle_spell_list_tilemap_data.w,X                                    ; $0298AC |\
    STA (<r_battle_generic_tmp_index),Y                                         ; $0298AF | | Copy the second row of the three entries.
    LDA r_battle_spell_list_tilemap_data.w + 24,X                               ; $0298B1 | |
    STA (<r_battle_generic_tmp_index_2),Y                                       ; $0298B4 | |
    LDA r_battle_spell_list_tilemap_data.w + 48,X                               ; $0298B6 | |
    STA (<r_battle_generic_tmp_index_3),Y                                       ; $0298B9 |/
    INY                                                                         ; $0298BB |\
    INX                                                                         ; $0298BC | | Increment the indexes and loop until all six characters have been
    CPY #64 + 12.w                                                              ; $0298BD | | copied.
    BNE -                                                                       ; $0298C0 |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $0298C2 |\
    TXA                                                                         ; $0298C4 | | Increment the X register by 48 to move to the next triplet of
    CLC                                                                         ; $0298C5 | | spells.
    ADC #48.w                                                                   ; $0298C6 | |
    TAX                                                                         ; $0298C9 |/
    LDA <r_battle_generic_tmp_index                                             ; $0298CA |\
    CLC                                                                         ; $0298CC | | Increment the three indexes by 128 to move two lines down.
    ADC #128.w                                                                  ; $0298CD | |
    STA <r_battle_generic_tmp_index                                             ; $0298D0 | |
    LDA <r_battle_generic_tmp_index_2                                           ; $0298D2 | |
    CLC                                                                         ; $0298D4 | |
    ADC #128.w                                                                  ; $0298D5 | |
    STA <r_battle_generic_tmp_index_2                                           ; $0298D8 | |
    LDA <r_battle_generic_tmp_index_3                                           ; $0298DA | |
    CLC                                                                         ; $0298DC | |
    ADC #128.w                                                                  ; $0298DD | |
    STA <r_battle_generic_tmp_index_3                                           ; $0298E0 |/
    TDC                                                                         ; $0298E2 |\
    SEP #FLAG_P_ACCUMULATOR                                                     ; $0298E3 | | Decrement the counter and loop until all entries have been
    DEC <r_battle_generic_tmp_count                                             ; $0298E5 | | processed.
    BNE @start                                                                  ; $0298E7 |/
    LDA #BATTLE_DIALOG_DMA_SPELL_LIST.b                                         ; $0298E9 |\
    LDY #BATTLE_DIALOG_DMA_OFFSET_1.w                                           ; $0298EB | | Load the parameters for the spell list DMA.
    JSR _load_battle_dialog_dma_parameters                                      ; $0298EE |/
    LDA #1.b                                                                    ; $0298F1 |\
    STA r_battle_dialog_dma_index.w                                             ; $0298F3 | | Set the DMA index to 1 and flag it as pending.
    STA r_battle_dialog_dma_pending.w                                           ; $0298F6 |/
    RTS                                                                         ; $0298F9

; _battle_update_inventory_tilemap ($02:98FA)
;
; Updates the inventory palettes based on the value in $EF9A (calls
; _battle_update_inventory_palettes), updates the tilemap mirror in RAM, and
; then configures the DMA to update VRAM during the NMI handler.
_battle_update_inventory_tilemap:
    JSR _battle_update_inventory_palettes                                       ; $0298FA | Update the inventory palettes.
    LDX #r_battle_tilemap_bg3_inventory.w + 64 + 4                              ; $0298FD |\ Set the first pointer to the inventory entry on the left side.
    STX <r_battle_generic_tmp_index                                             ; $029900 |/
    LDX #r_battle_tilemap_bg3_inventory.w + 64 + 32                             ; $029902 |\ Set the second pointer to the inventory entry on the right side.
    STX <r_battle_generic_tmp_index_2                                           ; $029905 |/
    TDC                                                                         ; $029907 |\ Initialize the X register to zero.
    TAX                                                                         ; $029908 |/
    LDA #24.b                                                                   ; $029909 |\ Initialize the count to copy all 24 rows of entries.
    STA <r_battle_generic_tmp_count                                             ; $02990B |/
@start:
    TDC                                                                         ; $02990D |\ Initialize the accumulator and Y register to zero.
    TAY                                                                         ; $02990E |/
    DEC A                                                                       ; $02990F | Set the accumulator to $FF.
    STA (<r_battle_generic_tmp_index),Y                                         ; $029910 |\ Write the blank tile to both sides.
    STA (<r_battle_generic_tmp_index_2),Y                                       ; $029912 |/
    LDY #64.w                                                                   ; $029914 | Increment the index to move to the next line.
    STA (<r_battle_generic_tmp_index),Y                                         ; $029917 |\ Write the blank tile to both sides again.
    STA (<r_battle_generic_tmp_index_2),Y                                       ; $029919 |/
    LDY #2.w                                                                    ; $02991B | Set the Y register to operate on the second tile.
-   LDA r_battle_inventory_tilemap_data.w,X                                     ; $02991E |\ Copy one entry to the left side.
    STA (<r_battle_generic_tmp_index),Y                                         ; $029921 |/
    LDA r_battle_inventory_tilemap_data.w + 48,X                                ; $029923 |\ Copy the next entry to the right side.
    STA (<r_battle_generic_tmp_index_2),Y                                       ; $029926 |/
    INY                                                                         ; $029928 |\ Increment the index registers.
    INX                                                                         ; $029929 |/
    CPY #26.w                                                                   ; $02992A |\ Loop until all 12 characters of the entries have been copied.
    BNE -                                                                       ; $02992D |/
    LDY #66.w                                                                   ; $02992F | Set the Y register to the next line.
-   LDA r_battle_inventory_tilemap_data.w,X                                     ; $029932 |\
    STA (<r_battle_generic_tmp_index),Y                                         ; $029935 | | Repeat the above process to copy the second line of the entries.
    LDA r_battle_inventory_tilemap_data.w + 48,X                                ; $029937 | |
    STA (<r_battle_generic_tmp_index_2),Y                                       ; $02993A | |
    INY                                                                         ; $02993C | |
    INX                                                                         ; $02993D | |
    CPY #90.w                                                                   ; $02993E | |
    BNE -                                                                       ; $029941 |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $029943 |\
    TXA                                                                         ; $029945 | |  Add 48 to the X register to move to the next pair of entries.
    CLC                                                                         ; $029946 | |
    ADC #48.w                                                                   ; $029947 | |
    TAX                                                                         ; $02994A |/
    LDA <r_battle_generic_tmp_index                                             ; $02994B |\
    CLC                                                                         ; $02994D | | Add 128 to the two pointers to move two lines down.
    ADC #128.w                                                                  ; $02994E | |
    STA <r_battle_generic_tmp_index                                             ; $029951 | |
    LDA <r_battle_generic_tmp_index_2                                           ; $029953 | |
    CLC                                                                         ; $029955 | |
    ADC #128.w                                                                  ; $029956 | |
    STA <r_battle_generic_tmp_index_2                                           ; $029959 |/
    TDC                                                                         ; $02995B |\
    SEP #FLAG_P_ACCUMULATOR                                                     ; $02995C | | Decrement the line count and continue until all have been done.
    DEC <r_battle_generic_tmp_count                                             ; $02995E | |
    BNE @start                                                                  ; $029960 |/
    LDA #BATTLE_DIALOG_DMA_INVENTORY_1.b                                        ; $029962 |\
    LDY #BATTLE_DIALOG_DMA_OFFSET_1.w                                           ; $029964 | | Configure the DMA to transfer the top part of the inventory.
    JSR _load_battle_dialog_dma_parameters                                      ; $029967 |/
    LDA #BATTLE_DIALOG_DMA_INVENTORY_2.b                                        ; $02996A |\
    LDY #BATTLE_DIALOG_DMA_OFFSET_2.w                                           ; $02996C | | Configure the DMA to transfer the middle part of the inventory.
    JSR _load_battle_dialog_dma_parameters                                      ; $02996F |/
    LDA #BATTLE_DIALOG_DMA_INVENTORY_3.b                                        ; $029972 |\
    LDY #BATTLE_DIALOG_DMA_OFFSET_3.w                                           ; $029974 | | Configure the DMA to transfer the bottom part of the inventory.
    JSR _load_battle_dialog_dma_parameters                                      ; $029977 |/
    LDA #3.b                                                                    ; $02997A |\
    STA r_battle_dialog_dma_index.w                                             ; $02997C | | Set the DMA index to 3 and flag the DMA as pending.
    STA r_battle_dialog_dma_pending.w                                           ; $02997F |/
    RTS                                                                         ; $029982

; _battle_update_info_area_menu_tilemap ($02:9983)
;
; Updates the info area with menu tilemap data and then configures the DMA to
; update it in VRAM during the next NMI.
_battle_update_info_area_menu_tilemap:
    JSR _battle_update_info_area_menu_tilemap_data                              ; $029983 | Update the tilemap for the info area with menu.
    JMP _battle_set_info_area_menu_dma                                          ; $029986 | Configure the DMA to update it during the NMI handler.

; _battle_update_info_area_menu_tilemap_data ($02:9989)
;
; Updates the information area (with menu) tilemap on BG3. Commands are drawn
; for the most recently active character.
_battle_update_info_area_menu_tilemap_data:
    LDX #_sizeof_r_battle_tilemap_bg3_info_area.w                               ; $029989 |\
-   LDA r_battle_tilemap_bg3_info_area.w - 1,X                                  ; $02998C | | Duplicate the standard information area into the information area
    STA r_battle_tilemap_bg3_info_area_menu.w - 1,X                             ; $02998F | | with the menu. The offsets are taken minus one because the X
    DEX                                                                         ; $029992 | | register runs from n to 1 rather than n-1 to 0.
    BNE -                                                                       ; $029993 |/
    LDA #BATTLE_DIALOG_BOX_INFO_MENU_MENU.b                                     ; $029995 |\
    JSR _battle_load_dialog_box_parameters                                      ; $029997 | | Draw the dialog box on top for the menu.
    JSR _battle_draw_dialog_box_bg3_normal                                      ; $02999A |/
    LDA #BATTLE_DIALOG_INFO_COMMAND_MENU.b                                      ; $02999D |\
    LDX #_sizeof_r_battle_command_tilemap_data.1.w                              ; $02999F | | Draw the commands for the currently active slot.
    JMP _battle_copy_info_area_text_slot                                        ; $0299A2 |/

; _battle_set_info_area_menu_dma (02:99A5)
;
; Configures the DMA that will transfer the updated information area with menu
; to VRAM during the NMI handler.
_battle_set_info_area_menu_dma:
    LDA #BATTLE_DIALOG_DMA_INFO_AREA_MENU.b                                     ; $0299A5 |\
    LDY #BATTLE_DIALOG_DMA_OFFSET_1.w                                           ; $0299A7 | | Load the DMA parameters for transferring the menu info area.
    JSR _load_battle_dialog_dma_parameters                                      ; $0299AA |/
    LDA #1.b                                                                    ; $0299AD |\
    STA r_battle_dialog_dma_index.w                                             ; $0299AF | | Set the DMA index to 1 and flag the DMA as pending.
    STA r_battle_dialog_dma_pending.w                                           ; $0299B2 |/
    RTS                                                                         ; $0299B5

; _battle_update_hp_and_status_tilemap ($02:99B6)
;
; Updates the tilemap data in RAM for the HP and status text area on BG3 and
; then schedules a DMA to transfer the update to VRAM. The second is handled by
; falling through to the next function.
_battle_update_hp_and_status_tilemap:
    JSR _battle_update_hp_and_status_tilemap_data                               ; $0299B6 | Update the tilemap in RAM.

; _battle_set_hp_and_status_dma ($02:99B9)
;
; Configures the DMA that will transfer the updated HP and status area to VRAM
; during the NMI handler.
_battle_set_hp_and_status_dma:
    LDY #BATTLE_DIALOG_DMA_OFFSET_1.w                                           ; $0299B9 |\
    LDA #BATTLE_DIALOG_DMA_HP_AND_STATUS.b                                      ; $0299BC | | Load the DMA parameters to the first DMA block.
    JSR _load_battle_dialog_dma_parameters                                      ; $0299BE |/
    LDA #1.b                                                                    ; $0299C1 |\
    STA r_battle_dialog_dma_index.w                                             ; $0299C3 | | Set the index and flag the DMA as pending.
    STA r_battle_dialog_dma_pending.w                                           ; $0299C6 |/
    RTS                                                                         ; $0299C9

; _battle_update_info_area_tilemap ($02:99CA)
;
; Updates the info area tilemap in RAM and configures the DMA to transfer it to
; VRAM.
_battle_update_info_area_tilemap:
    JSR _battle_update_info_area_names                                          ; $0299CA | Update the monster and character names on the tilemap.
    JSR _battle_update_info_area_hp                                             ; $0299CD | Update the HP on the tilemap.
    JMP _battle_set_info_area_dma                                               ; $0299D0 | Configure the DMA to transfer the tilemap to VRAM.

; _battle_update_info_area_names ($02:99D3)
;
; Copies the current monster and character names from their individual tilemap
; areas to the primary info area tilemap area in RAM.
_battle_update_info_area_names:
    TDC                                                                         ; $0299D3 |\ Copy the monster names to the info area tilemap.
    JSR _battle_copy_info_area_text_fixed                                       ; $0299D4 |/
    LDA #BATTLE_DIALOG_INFO_CHARACTER_NAMES.b                                   ; $0299D7 |\ Copy the character names to the info area tilemap.
    JMP _battle_copy_info_area_text_fixed                                       ; $0299D9 |/

; _battle_update_info_area_hp ($02:99DC)
;
; Copies the current character HP from their individual tilemap areas to the
; primary info area tilemap area in RAM.
_battle_update_info_area_hp:
    LDA #BATTLE_DIALOG_INFO_CHARACTER_HP.b                                      ; $0299DC |\ Copy the character HP to the info area tilemap.
    JMP _battle_copy_info_area_text_fixed                                       ; $0299DE |/

; _battle_set_info_area_dma ($02:99E1)
;
; Configures the DMA that will transfer the info area tilemap from RAM to VRAM
; during the next NMI.
_battle_set_info_area_dma:
    TDC                                                                         ; $0299E1 |\
    LDY #BATTLE_DIALOG_DMA_OFFSET_1.w                                           ; $0299E2 | | Load the DMA parameters to transfer the info area tilemap.
    JSR _load_battle_dialog_dma_parameters                                      ; $0299E5 |/
    LDA #1.b                                                                    ; $0299E8 |\
    STA r_battle_dialog_dma_index.w                                             ; $0299EA | | Set the DMA index to and flag the DMA as pending.
    STA r_battle_dialog_dma_pending.w                                           ; $0299ED |/
    RTS                                                                         ; $0299F0

; _battle_copy_info_area_text_* ($02:99F1)
;
; These series of two functions copies four different types of text from their
; original source locations to the BG3 info area: monster names, character
; names, character HP, and the menu commands. The first three should use the
; _fixed variant of the function and copy to the actual info area in RAM. The
; last one depends on the currently active character, and should use the _slot
; variant of the function. The last one is also copied to the info area that
; has the menu, instead of the standard info area.
_battle_copy_info_area_text_slot:
    PHA                                                                         ; $0299F1 |\
    LDA r_battle_last_active_character_slot.w                                   ; $0299F2 | | Multiply the active slot number by the record size in the X
    STA <r_math_multiply_8bit_arg_1                                             ; $0299F5 | | register to determine the overall offset and save it to a
    STX <r_math_multiply_8bit_arg_2                                             ; $0299F7 | | variable.
    JSR _math_multiply_8bit                                                     ; $0299F9 | |
    LDX <r_math_multiply_8bit_result                                            ; $0299FC | |
    STX r_battle_copy_info_area_text_offset.w                                   ; $0299FE | |
    PLA                                                                         ; $029A01 |/
    JMP _battle_copy_info_area_text                                             ; $029A02 | Jump to the actual code.
_battle_copy_info_area_text_fixed:
    LDX #0.w                                                                    ; $029A05 |\ Set the offset to zero.
    STX r_battle_copy_info_area_text_offset.w                                   ; $029A08 |/
_battle_copy_info_area_text:
    STA <r_math_multiply_8bit_arg_1                                             ; $029A0B |\
    LDA #_sizeof_r_battle_copy_info_area_text_data.b                            ; $029A0D | | Set the X register to the value in the accumulator times 6, to
    STA <r_math_multiply_8bit_arg_2                                             ; $029A0F | | index the data array.
    JSR _math_multiply_8bit                                                     ; $029A11 | |
    LDX <r_math_multiply_8bit_result                                            ; $029A14 |/
    TDC                                                                         ; $029A16 |\ Initialize the Y register to zero.
    TAY                                                                         ; $029A17 |/
-   LDA bank16.battle_info_area_text_copy_data.l,X                              ; $029A18 |\
    STA r_battle_copy_info_area_text_data.w,Y                                   ; $029A1C | | Copy the six bytes of the data to the local variables.
    INY                                                                         ; $029A1F | |
    INX                                                                         ; $029A20 | |
    CPY #_sizeof_r_battle_copy_info_area_text_data.w                            ; $029A21 | |
    BNE -                                                                       ; $029A24 |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $029A26 |\
    LDA r_battle_copy_info_area_text_data.source.w                              ; $029A28 | | Add the calculated offset to the source address to determine the
    CLC                                                                         ; $029A2B | | true source address.
    ADC r_battle_copy_info_area_text_offset.w                                   ; $029A2C | |
    STA r_battle_copy_info_area_text_data.source.w                              ; $029A2F | |
    TDC                                                                         ; $029A32 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $029A33 |/
    LDA r_battle_copy_info_area_text_data.width.w                               ; $029A35 |\ Load the width (in bytes) to a temporary index variable.
    TAX                                                                         ; $029A38 | |
    STX <r_battle_generic_tmp_index_2                                           ; $029A39 |/
    LDX r_battle_copy_info_area_text_data.target.w                              ; $029A3B |\ Load the target address into another index variable.
    STX <r_battle_generic_tmp_index                                             ; $029A3E |/
    LDX r_battle_copy_info_area_text_data.source.w                              ; $029A40 | Load the source address into the X register.
--  TDC                                                                         ; $029A43 |\ Zero out the Y register.
    TAY                                                                         ; $029A44 |/
-   LDA 0.w,X                                                                   ; $029A45 |\
    STA (<r_battle_generic_tmp_index),Y                                         ; $029A48 | | Copy the number of bytes specified by the width from the source to
    INX                                                                         ; $029A4A | | the target.
    INY                                                                         ; $029A4B | |
    CPY <r_battle_generic_tmp_index_2                                           ; $029A4C | |
    BNE -                                                                       ; $029A4E |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $029A50 |\
    LDA <r_battle_generic_tmp_index                                             ; $029A52 | | Add 64 to the target address to move to the next line.
    CLC                                                                         ; $029A54 | |
    ADC #64.w                                                                   ; $029A55 | |
    STA <r_battle_generic_tmp_index                                             ; $029A58 | |
    TDC                                                                         ; $029A5A | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $029A5B |/
    DEC r_battle_copy_info_area_text_data.height.w                              ; $029A5D |\ Loop until all the desired number of lines have been copied.
    BNE --                                                                      ; $029A60 |/
    RTS                                                                         ; $029A62

; _battle_initialize_dialogs ($02:9A63)
;
; Initializes the various battle dialog tilemaps and copies them to VRAM.
_battle_initialize_dialogs:
    JSR _battle_update_dialog_character_names                                   ; $029A63 | Update character names.
    JSR _battle_update_dialog_inventory_entries                                 ; $029A66 | Update inventory entries.
    JSR _battle_update_dialog_spell_list_entries                                ; $029A69 | Update spell list entries.
    JSR _battle_update_dialog_character_hp                                      ; $029A6C | Update character HP.
    JSR _battle_update_dialog_monster_names                                     ; $029A6F | Update monster names.
    JSR _battle_update_dialog_character_mp                                      ; $029A72 | Update character MP.
    JSR _battle_update_dialog_command_entries                                   ; $029A75 | Update command entries.
    JSR _battle_update_dialog_hand_inventory_entries                            ; $029A78 | Update hand inventory entries.
    JSR _battle_initialize_dialog_tilemaps                                      ; $029A7B | Initialize the dialog tilemap mirrors.
    JSR _battle_initialize_parry_change_tilemap                                 ; $029A7E | Draw Parry and Change to the BG2 tilemap.
    JSR _battle_update_hp_and_status_tilemap_data                               ; $029A81 | Update the HP and Status tilemap mirror.
    JSL bank01.battle_initialize_pause_tilemap                                  ; $029A84 | Draw PAUSE to the pause tilemap.
    JMP _battle_copy_dialog_tilemaps_to_vram                                    ; $029A88 | Copy the tilemaps to VRAM.

; _battle_initialize_parry_change_tilemap ($02:9A8B)
;
; Writes the tiles necessary to print "Parry" and "Change" to the BG2 lower
; tilemap mirror.
_battle_initialize_parry_change_tilemap:
    LDX #r_battle_tilemap_bg2_lower.w + (1 * 2) + (10 * 32 * 2)                 ; $029A8B |\ Put the location where "Parry" needs to be drawn in a variable.
    STX <r_battle_generic_tmp_index                                             ; $029A8E |/
.if FF4_REGION == "JAPAN"
    LDX #r_battle_tilemap_bg2_lower.w + (27 * 2) + (10 * 32 * 2)                ; $029A90 | Load the location where "Change" needs to be drawn.
.else
    LDX #r_battle_tilemap_bg2_lower.w + (25 * 2) + (10 * 32 * 2)                ; $029A90 | Load the location where "Change" needs to be drawn.
.endif
    STX <r_battle_generic_tmp_index_2                                           ; $029A93 | Save the location to another variable.
    TDC                                                                         ; $029A95 |\
    TAX                                                                         ; $029A96 | | Initialize both X and Y to zero.
    TAY                                                                         ; $029A97 |/
-   LDA parry_bg2_tile_data.l,X                                                 ; $029A98 |\ Copy the tile for "Parry".
    STA (<r_battle_generic_tmp_index),Y                                         ; $029A9C |/
    LDA change_bg2_tile_data.l,X                                                ; $029A9E |\ Copy the tile for "Change".
    STA (<r_battle_generic_tmp_index_2),Y                                       ; $029AA2 |/
    INX                                                                         ; $029AA4 |\
    INY                                                                         ; $029AA5 | | Increment the indexes.
    INY                                                                         ; $029AA6 |/
    CPX #_sizeof_parry_bg2_tile_data.w                                          ; $029AA7 |\ If all 12 characters have been copied, branch to the end.
    BEQ +                                                                       ; $029AAA |/
    CPX #_sizeof_parry_bg2_tile_data.w / 2                                      ; $029AAC |\
    BNE -                                                                       ; $029AAF | | Once the first 6 characters are copied, increment the Y register
    LDY #64.w                                                                   ; $029AB1 | | by 64 to move down a line.
    BRA -                                                                       ; $029AB4 |/
+   RTS                                                                         ; $029AB6

; parry_bg2_tile_data ($02:9AB7)
;
; Provides the tile numbers necessary to draw "Parry" to BG2 during battle.
parry_bg2_tile_data:
.if FF4_REGION == "JAPAN"
    .db $E8, $FF, $E8, $FF                                                      ; $029AB7.9ABA
    .db $E9, $EA, $EB, $EC                                                      ; $029ABB.9ABE
.else
    .asc "      "                                                               ; $029AB7.9ABC
    .asc $E4, $E5, $E6, $E6, $E7, " "                                           ; $029ABD.9AC2
.endif

; change_bg2_tile_data ($02:9AC3)
;
; Provides the tile numbers necessary to draw "Change" to BG2 during battle.
change_bg2_tile_data:
.if FF4_REGION == "JAPAN"
    .db $FF, $FF, $FF, $E8                                                      ; $029ABF.9AC2
    .db $E4, $E5, $E6, $E7                                                      ; $029AC3.9AC6
.else
    .asc "      "                                                               ; $029AC3.9AC8
    .asc $E8, $E9, $E5, $EA, $EB, $EC                                           ; $029AC9.9ACE
.endif

; _battle_copy_dialog_tilemaps_to_vram ($02:9ACF)
;
; Executes several DMA transfers to copy the dialog tilemaps to VRAM. These
; transfers are complete and are intended for use during battle initialization.
_battle_copy_dialog_tilemaps_to_vram:
    TDC                                                                         ; $029ACF |\ Initialize the X register to zero.
    TAX                                                                         ; $029AD0 |/
-   REP #FLAG_P_ACCUMULATOR                                                     ; $029AD1 |\
    LDA bank16.battle_dialog_dma_full_data.l + 0,X                              ; $029AD3 | | Load the source memory address and save it in a variable.
    STA <r_battle_generic_tmp_index_2                                           ; $029AD7 |/
    LDA bank16.battle_dialog_dma_full_data.l + 2,X                              ; $029AD9 |\ Load the target VRAM address into the Y register.
    TAY                                                                         ; $029ADD |/
    LDA bank16.battle_dialog_dma_full_data.l + 4,X                              ; $029ADE |\ Load the desired number of bytes to transfer into another variable.
    STA <r_battle_generic_tmp_index                                             ; $029AE2 |/
    TXA                                                                         ; $029AE4 |\
    CLC                                                                         ; $029AE5 | | Increment the X register by six to move on to the next transfer.
    ADC #6.w                                                                    ; $029AE6 | |
    TAX                                                                         ; $029AE9 | |
    TDC                                                                         ; $029AEA | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $029AEB |/
    LDA #$7E.b                                                                  ; $029AED | Load the source bank number into the accumulator.
    PHX                                                                         ; $029AEF |\
    LDX <r_battle_generic_tmp_index_2                                           ; $029AF0 | | Execute the DMA, loading the source address into the X register
    JSR _start_vram_dma5                                                        ; $029AF2 | | before calling the DMA function.
    PLX                                                                         ; $029AF5 |/
    CPX #(9 * 6).w                                                              ; $029AF6 |\ Loop until all nine transfers have been completed.
    BNE -                                                                       ; $029AF9 |/
    RTS                                                                         ; $029AFB

; _battle_initialize_dialog_tilemaps ($02:9AFC)
;
; Erases the various dialog tilemap mirrors and draws the empty dialog boxes in
; those mirrors afterward. No transfer to VRAM is done.
_battle_initialize_dialog_tilemaps:
    LDX #r_battle_tilemap_bg3_hp_and_status.w - r_battle_tilemap_bg3_info_area  ; $029AFC |\
    TDC                                                                         ; $029AFF | | Zero out most of the BG3 dialog tilemap mirrors in RAM, only
-   STA r_battle_tilemap_bg3_info_area.w - 1,X                                  ; $029B00 | | excluding the one that displays HP and status descriptions.
    DEX                                                                         ; $029B03 | |
    BNE -                                                                       ; $029B04 |/
    TDC                                                                         ; $029B06 |\
    TAX                                                                         ; $029B07 | | Do another round of tilemap mirror initialization. The BG2 tilemap
    REP #FLAG_P_ACCUMULATOR                                                     ; $029B08 | | mirror is adjusted to set the base tile number to $200. The HP and
-   LDA #$0200.w                                                                ; $029B0A | | status mirror is erased while setting the priority of its tiles to
    STA r_battle_tilemap_bg2_lower.w,X                                          ; $029B0D | | 1. The pause tilemap mirror is zeroed.
    LDA #$2000.w                                                                ; $029B10 | |
    STA r_battle_tilemap_bg3_hp_and_status.w,X                                  ; $029B13 | |
    TDC                                                                         ; $029B16 | |
    STA r_battle_tilemap_bg3_pause.w,X                                          ; $029B17 | |
    INX                                                                         ; $029B1A | |
    INX                                                                         ; $029B1B | |
    CPX #_sizeof_r_battle_tilemap_bg2_lower.w                                   ; $029B1C | |
    BNE -                                                                       ; $029B1F | |
    TDC                                                                         ; $029B21 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $029B22 |/
-   JSR _battle_load_dialog_box_parameters                                      ; $029B24 | Load the dialog box parameters for the current value.
    PHA                                                                         ; $029B27 |\
    JSR _battle_draw_dialog_box_bg3_normal                                      ; $029B28 | | Draw the dialog box using a normal BG3 dialog box.
    PLA                                                                         ; $029B2B |/
    INC A                                                                       ; $029B2C |\
    CMP #BATTLE_DIALOG_BOX_CHARACTER_MP.b                                       ; $029B2D | | Increment the value and loop until 7 is reached.
    BNE -                                                                       ; $029B2F |/
    LDA #BATTLE_DIALOG_BOX_CHARACTER_MP.b                                       ; $029B31 |\
    JSR _battle_load_dialog_box_parameters                                      ; $029B33 | | Draw the character MP dialog box using a BG2 dialog box.
    JSR _battle_draw_dialog_box_bg2                                             ; $029B36 |/
    LDA #BATTLE_DIALOG_BOX_PARRY.b                                              ; $029B39 |\
    JSR _battle_load_dialog_box_parameters                                      ; $029B3B | | Draw the Parry dialog box using a BG2 dialog box.
    JSR _battle_draw_dialog_box_bg2                                             ; $029B3E |/
    LDA #BATTLE_DIALOG_BOX_CHANGE.b                                             ; $029B41 |\
    JSR _battle_load_dialog_box_parameters                                      ; $029B43 | | Draw the Change dialog box using a BG2 dialog box.
    JSR _battle_draw_dialog_box_bg2                                             ; $029B46 |/
    LDA #BATTLE_DIALOG_BOX_HP_STATUS_CHARACTER.b                                ; $029B49 |\
    JSR _battle_load_dialog_box_parameters                                      ; $029B4B | | Draw the HP and Status character dialog box using a normal BG3.
    JSR _battle_draw_dialog_box_bg3_normal                                      ; $029B4E |/
    LDA #BATTLE_DIALOG_BOX_HP_STATUS_STATUS.b                                   ; $029B51 |\
    JSR _battle_load_dialog_box_parameters                                      ; $029B53 | | Draw the status description dialog box using a normal BG3 box.
    JSR _battle_draw_dialog_box_bg3_normal                                      ; $029B56 |/
    LDA #BATTLE_DIALOG_BOX_PAUSE.b                                              ; $029B59 |\
    JSR _battle_load_dialog_box_parameters                                      ; $029B5B | | Draw the Pause dialog box using a condensed BG3 dialog box.
    JMP _battle_draw_dialog_box_bg3_condensed                                   ; $029B5E |/

; _battle_load_dialog_box_parameters ($02:9B61)
;
; Given the index to a particular dialog box type in the accumulator, loads the
; parameters for that dialog box and puts them in the dialog box drawing
; function argument memory locations.
_battle_load_dialog_box_parameters:
    PHA                                                                         ; $029B61 | Preserve the value of the accumulator.
    STA <r_math_multiply_8bit_arg_1                                             ; $029B62 |\
    LDA #6.b                                                                    ; $029B64 | | Set the X register to the value in the accumulator times six (the
    STA <r_math_multiply_8bit_arg_2                                             ; $029B66 | | size of the data being read from) to index the data.
    JSR _math_multiply_8bit                                                     ; $029B68 | |
    LDX <r_math_multiply_8bit_result                                            ; $029B6B |/
    TDC                                                                         ; $029B6D |\ Set the Y register to zero.
    TAY                                                                         ; $029B6E |/
-   LDA bank16.battle_dialog_box_data.l,X                                       ; $029B6F |\
    STA r_battle_draw_dialog_box_arg_coordinates.w,Y                            ; $029B73 | | Copy the six bytes from ROM to the parameters for the dialog box
    INY                                                                         ; $029B76 | | drawing function.
    INX                                                                         ; $029B77 | |
    CPY #6.w                                                                    ; $029B78 | |
    BNE -                                                                       ; $029B7B |/
    PLA                                                                         ; $029B7D | Restore the value of the accumulator.
    RTS                                                                         ; $029B7E

; _battle_load_dialog_tiles ($02:9B7F)
;
; Given an initial 16-bit index number in $04, returns the left, middle, and
; right tiles associated with that index in $06, $07 and $08, respectively. The
; parameter is incremented by three to allow the user to make repeated calls to
; this function to get the full set of nine tiles necessary to construct a
; dialog box. For practical use, the initial passed in index should be 0, 9 or
; 18 (or possibly any multiple of three if a particular row is required).
; Obviously other values will still execute, but they are semantically
; meaningless.
_battle_load_dialog_tiles:
    LDX <r_battle_load_dialog_tiles_arg_index                                   ; $029B7F | Load the current index into the X register.
    LDA battle_dialog_tile_pattern_data.l + 0,X                                 ; $029B81 |\ Load the first tile and save it in the return variable.
    STA <r_battle_load_dialog_tiles_result_left                                 ; $029B85 |/
    LDA battle_dialog_tile_pattern_data.l + 1,X                                 ; $029B87 |\ Load the second tile and save it in the return variable.
    STA <r_battle_load_dialog_tiles_result_middle                               ; $029B8B |/
    LDA battle_dialog_tile_pattern_data.l + 2,X                                 ; $029B8D |\ Load the third tile and save it in the return variable.
    STA <r_battle_load_dialog_tiles_result_right                                ; $029B91 |/
    INX                                                                         ; $029B93 |\
    INX                                                                         ; $029B94 | | Increment the index by three to enable repeated calls to
    INX                                                                         ; $029B95 | | this function to get a complete set of three triplets.
    STX <r_battle_load_dialog_tiles_arg_index                                   ; $029B96 |/
    RTS                                                                         ; $029B98

; battle_dialog_tile_pattern_data ($02:9B99)
;
; Defines several different sets of three tiles used in constructing dialog
; boxes. Each entry has three tiles: the first and third tiles are the left and
; right borders, while the second tile is repeated to fill the middle. The sets
; are arranged such that there are three full paterns, each detailing a
; a different variation of dialog box. All three patterns can be used on BG3,
; but only the second pattern can be used on BG2.
battle_dialog_tile_pattern_data:
    .db $10, $11, $12                                                           ; $029B99.9B9B | $00: Standard dialog box
    .db $0B, $FF, $0C                                                           ; $029B9C.9B9E
    .db $0D, $0E, $0F                                                           ; $029B9F.9BA1

    .db $F7, $F8, $F9                                                           ; $029BA2.9BA4 | $09: Reduced gap slightly wider dialog box
    .db $FA, $FF, $FB                                                           ; $029BA5.9BA7
    .db $FC, $FD, $FE                                                           ; $029BA8.9BAA

    .db $16, $17, $18                                                           ; $029BAB.9BAD | $12: Maximum gap slightly wider dialog box
    .db $FA, $FF, $FB                                                           ; $029BAE.9BB0
    .db $FC, $FD, $FE                                                           ; $029BB1.9BB3

; _battle_draw_dialog_box_* ($02:9BB4)
;
; Depending on the exact entry point, draws a dialog box using either BG2 or BG3
; tile numbers to the 16-bit destination address in $EF5A. The X and Y
; coordinates in tiles within that destination to place the upper left corner
; should be passed in $EF56 and $EF57 respectively. The desired total width of
; the dialog box in tiles should be passed in $EF58. The desired total height
; should be passed in $EF59. The tile flags vary by the entry point.
_battle_draw_dialog_box_bg3_condensed:
    LDX #9.w                                                                    ; $029BB4 |\ Set the index to load the condensed dialog box.
    STX <r_battle_load_dialog_tiles_arg_index                                   ; $029BB7 |/
    LDA #$20.b                                                                  ; $029BB9 | Set the flags to priority 1.
    BRA _battle_draw_dialog_box                                                 ; $029BBB | Branch to the actual function.
_battle_draw_dialog_box_bg3_expanded:
    LDX #18.w                                                                   ; $029BBD |\ Set the index to load the expanded dialog box.
    STX <r_battle_load_dialog_tiles_arg_index                                   ; $029BC0 |/
    LDA #$20.b                                                                  ; $029BC2 | Set the flags to priority 1.
    BRA _battle_draw_dialog_box                                                 ; $029BC4 | Branch to the actual function.
_battle_draw_dialog_box_bg2:
    LDX #9.w                                                                    ; $029BC6 |\ Set the index to load the condensed dialog box (works on BG2).
    STX <r_battle_load_dialog_tiles_arg_index                                   ; $029BC9 |/
    LDA #$02.b                                                                  ; $029BCB |\ Set the flags to set the base tile number to $200 (necessary for
    BRA _battle_draw_dialog_box                                                 ; $029BCD |/ BG2).
_battle_draw_dialog_box_bg3_normal:
    TDC                                                                         ; $029BCF |\
    TAX                                                                         ; $029BD0 | | Configure the dialog tile loader to load the first type of dialog.
    STX <r_battle_load_dialog_tiles_arg_index                                   ; $029BD1 |/
_battle_draw_dialog_box:
    STA <r_battle_draw_dialog_box_tile_flags                                    ; $029BD3 | Set the tile flags to zero (which results in using palette 0).
    LDA r_battle_draw_dialog_box_arg_coordinates.y.w                            ; $029BD5 |\
    STA <r_math_multiply_8bit_arg_1                                             ; $029BD8 | | Calculate the initial destination address by taking the passed
    LDA #64.b                                                                   ; $029BDA | | destination location, adding in the desired Y coordinates times
    STA <r_math_multiply_8bit_arg_2                                             ; $029BDC | | 64 (as each line is 32 tiles or 64 bytes long), and finally adding
    JSR _math_multiply_8bit                                                     ; $029BDE | | in the desired X coordinate times two (as each tile has two
    LDA r_battle_draw_dialog_box_arg_coordinates.x.w                            ; $029BE1 | | bytes). Store the result in memory for later use.
    REP #FLAG_P_ACCUMULATOR                                                     ; $029BE4 | |
    PHA                                                                         ; $029BE6 | |
    ASL A                                                                       ; $029BE7 | |
    CLC                                                                         ; $029BE8 | |
    ADC <r_math_multiply_8bit_result                                            ; $029BE9 | |
    ADC r_battle_draw_dialog_box_arg_destination.w                              ; $029BEB | |
    STA <r_battle_generic_tmp_index                                             ; $029BEE | |
    PLA                                                                         ; $029BF0 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $029BF1 |/
    JSR _battle_load_dialog_tiles                                               ; $029BF3 | Load the tiles for the first row of the dialog box.
    LDX <r_battle_generic_tmp_index                                             ; $029BF6 | Load the destination address into the X register.
    LDA r_battle_draw_dialog_box_arg_width.w                                    ; $029BF8 |\ Load the desired width into the Y register.
    TAY                                                                         ; $029BFB |/
    LDA <r_battle_load_dialog_tiles_result_left                                 ; $029BFC |\ Write the left tile to the tile byte.
    STA 0.w,X                                                                   ; $029BFE |/
    LDA <r_battle_draw_dialog_box_tile_flags                                    ; $029C01 |\ Write the predetermined flags to the flag byte.
    STA 1.w,X                                                                   ; $029C03 |/
    INX                                                                         ; $029C06 |\ Increment the X register twice to move to the next character.
    INX                                                                         ; $029C07 |/
    DEY                                                                         ; $029C08 |\ Decrement Y twice to account for both this left tile and the
    DEY                                                                         ; $029C09 |/ rightmost tile (to allow zero comparison while doing the middle).
-   LDA <r_battle_load_dialog_tiles_result_middle                               ; $029C0A |\ Write the middle tile to the tile byte.
    STA 0.w,X                                                                   ; $029C0C |/
    LDA <r_battle_draw_dialog_box_tile_flags                                    ; $029C0F |\ Write the flags to the flag byte.
    STA 1.w,X                                                                   ; $029C11 |/
    INX                                                                         ; $029C14 |\ Increment the X register twice.
    INX                                                                         ; $029C15 |/
    DEY                                                                         ; $029C16 |\ Decrement the Y register and loop until the remaining number of
    BNE -                                                                       ; $029C17 |/ tiles have been written.
    LDA <r_battle_load_dialog_tiles_result_right                                ; $029C19 |\ Write the right tile to the tile byte.
    STA 0.w,X                                                                   ; $029C1B |/
    LDA <r_battle_draw_dialog_box_tile_flags                                    ; $029C1E |\ Write the flags to the flag byte.
    STA 1.w,X                                                                   ; $029C20 |/
    DEC r_battle_draw_dialog_box_arg_height.w                                   ; $029C23 |\ Similar to the width, decrement the height variable by two to
    DEC r_battle_draw_dialog_box_arg_height.w                                   ; $029C26 |/ account for both this row and the bottom row.
    JSR _battle_load_dialog_tiles                                               ; $029C29 | Load the middle set of tiles.
--  REP #FLAG_P_ACCUMULATOR                                                     ; $029C2C |\
    LDA <r_battle_generic_tmp_index                                             ; $029C2E | | Add 64 to the index to move to the next line.
    CLC                                                                         ; $029C30 | |
    ADC #64.w                                                                   ; $029C31 | |
    STA <r_battle_generic_tmp_index                                             ; $029C34 | |
    TDC                                                                         ; $029C36 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $029C37 |/
    LDX <r_battle_generic_tmp_index                                             ; $029C39 | Load the current destination address into the X register.
    LDA r_battle_draw_dialog_box_arg_width.w                                    ; $029C3B |\ Load the desired width into the Y register.
    TAY                                                                         ; $029C3E |/
    LDA <r_battle_load_dialog_tiles_result_left                                 ; $029C3F |\
    STA 0.w,X                                                                   ; $029C41 | | Write the left tile in a similar fashion as above.
    LDA <r_battle_draw_dialog_box_tile_flags                                    ; $029C44 | |
    STA 1.w,X                                                                   ; $029C46 | |
    INX                                                                         ; $029C49 | |
    INX                                                                         ; $029C4A | |
    DEY                                                                         ; $029C4B | |
    DEY                                                                         ; $029C4C |/
-   LDA <r_battle_load_dialog_tiles_result_middle                               ; $029C4D |\
    STA 0.w,X                                                                   ; $029C4F | | Loop through writing all the middle tiles.
    LDA <r_battle_draw_dialog_box_tile_flags                                    ; $029C52 | |
    STA 1.w,X                                                                   ; $029C54 | |
    INX                                                                         ; $029C57 | |
    INX                                                                         ; $029C58 | |
    DEY                                                                         ; $029C59 | |
    BNE -                                                                       ; $029C5A |/
    LDA <r_battle_load_dialog_tiles_result_right                                ; $029C5C |\
    STA 0.w,X                                                                   ; $029C5E | | Write the right tile.
    LDA <r_battle_draw_dialog_box_tile_flags                                    ; $029C61 | |
    STA 1.w,X                                                                   ; $029C63 |/
    DEC r_battle_draw_dialog_box_arg_height.w                                   ; $029C66 |\ Decrement the height and loop until all of the middle lines have
    BNE --                                                                      ; $029C69 |/ been done.
    JSR _battle_load_dialog_tiles                                               ; $029C6B | Load the tiles for the bottom row.
    REP #FLAG_P_ACCUMULATOR                                                     ; $029C6E |\
    LDA <r_battle_generic_tmp_index                                             ; $029C70 | | Add 64 to the destination address to move to the next line.
    CLC                                                                         ; $029C72 | |
    ADC #64.w                                                                   ; $029C73 | |
    STA <r_battle_generic_tmp_index                                             ; $029C76 | |
    TDC                                                                         ; $029C78 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $029C79 |/
    LDX <r_battle_generic_tmp_index                                             ; $029C7B | Load the destination address into the X register.
    LDA r_battle_draw_dialog_box_arg_width.w                                    ; $029C7D |\ Load the desired width into the Y register.
    TAY                                                                         ; $029C80 |/
    LDA <r_battle_load_dialog_tiles_result_left                                 ; $029C81 |\
    STA 0.w,X                                                                   ; $029C83 | | Write the left tile.
    LDA <r_battle_draw_dialog_box_tile_flags                                    ; $029C86 | |
    STA 1.w,X                                                                   ; $029C88 | |
    INX                                                                         ; $029C8B | |
    INX                                                                         ; $029C8C | |
    DEY                                                                         ; $029C8D | |
    DEY                                                                         ; $029C8E |/
-   LDA <r_battle_load_dialog_tiles_result_middle                               ; $029C8F |\
    STA 0.w,X                                                                   ; $029C91 | | Loop to write all the middle tiles.
    LDA <r_battle_draw_dialog_box_tile_flags                                    ; $029C94 | |
    STA 1.w,X                                                                   ; $029C96 | |
    INX                                                                         ; $029C99 | |
    INX                                                                         ; $029C9A | |
    DEY                                                                         ; $029C9B | |
    BNE -                                                                       ; $029C9C |/
    LDA <r_battle_load_dialog_tiles_result_right                                ; $029C9E |\
    STA 0.w,X                                                                   ; $029CA0 | | Write the right tile.
    LDA <r_battle_draw_dialog_box_tile_flags                                    ; $029CA3 | |
    STA 1.w,X                                                                   ; $029CA5 |/
    RTS                                                                         ; $029CA8

; _battle_update_dialog_command_entries ($02:9CA9)
;
; Updates the dialog command entries for each of the five characters.
_battle_update_dialog_command_entries:
    STZ r_battle_update_dialog_arg_slot.w                                       ; $029CA9 | Initialize the slot to zero.
--  STZ r_battle_update_dialog_arg_entry.w                                      ; $029CAC | Initialize the entry to zero.
-   JSR _battle_update_dialog_command_entry.w                                   ; $029CAF | Update the current command entry.
    INC r_battle_update_dialog_arg_entry.w                                      ; $029CB2 |\
    LDA r_battle_update_dialog_arg_entry.w                                      ; $029CB5 | | Loop until all five of the character's command entries are
    CMP #5.b                                                                    ; $029CB8 | | updated.
    BNE -                                                                       ; $029CBA |/
    INC r_battle_update_dialog_arg_slot.w                                       ; $029CBC |\
    LDA r_battle_update_dialog_arg_slot.w                                       ; $029CBF | | Loop until all five character slots are updated.
    CMP #5.b                                                                    ; $029CC2 | |
    BNE --                                                                      ; $029CC4 |/
    RTS                                                                         ; $029CC6

; _battle_update_dialog_command_entries ($02:9CC7)
;
; Updates the dialog command entries for the single character specified by the
; slot number in $1816.
_battle_update_dialog_command_entries_single_slot:
    STZ r_battle_update_dialog_arg_entry.w                                      ; $029CC7 | Initialize the entry to zero.
-   JSR _battle_update_dialog_command_entry                                     ; $029CCA |\
    INC r_battle_update_dialog_arg_entry.w                                      ; $029CCD | | Update the character's five command entries.
    LDA r_battle_update_dialog_arg_entry.w                                      ; $029CD0 | |
    CMP #5.b                                                                    ; $029CD3 | |
    BNE -                                                                       ; $029CD5 |/
    RTS                                                                         ; $029CD7

; _battle_update_dialog_command_entry ($02:9CD8)
;
; Updates the tilemap data for a single command entry. The character slot is
; specified in $1816 and the entry number is specified in $1817.
_battle_update_dialog_command_entry:
    LDX #r_battle_update_dialog_data.w                                          ; $029CD8 |\ Tell the dialog update function where the script data will be.
    STX r_battle_update_dialog_arg_source.w                                     ; $029CDB |/
    LDA #5.b                                                                    ; $029CDE |\ Set the line length to five, as each command has five characters.
    STA r_battle_update_dialog_arg_line_length.w                                ; $029CE0 |/
    LDA r_battle_update_dialog_arg_entry.w                                      ; $029CE3 |\
    STA <r_math_multiply_8bit_arg_1                                             ; $029CE6 | | Multiply the entry number by twenty, as each command will use
    LDA #20.b                                                                   ; $029CE8 | | twenty bytes in the tilemap.
    STA <r_math_multiply_8bit_arg_2                                             ; $029CEA | |
    JSR _math_multiply_8bit                                                     ; $029CEC |/
    LDA r_battle_update_dialog_arg_entry.w                                      ; $029CEF |\
    ASL A                                                                       ; $029CF2 | | Multiply the entry number by four, used to index the command data
    ASL A                                                                       ; $029CF3 | | in RAM, where each entry uses four bytes.
    TAX                                                                         ; $029CF4 | |
    STX <r_battle_generic_tmp_index                                             ; $029CF5 |/
    LDA r_battle_update_dialog_arg_slot.w                                       ; $029CF7 |\
    ASL A                                                                       ; $029CFA | | Set the X register to the slot number times two.
    TAX                                                                         ; $029CFB |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $029CFC |\
    LDA bank16.battle_command_tilemap_offset_data.l,X                           ; $029CFE | | Set the target address to the base offset for this slot number
    CLC                                                                         ; $029D02 | | plus the previously calculated offset for this entry.
    ADC <r_math_multiply_8bit_result                                            ; $029D03 | |
    STA r_battle_update_dialog_arg_target.w                                     ; $029D05 |/
    LDA bank16.battle_command_slot_offset_data.l,X                              ; $029D08 |\
    CLC                                                                         ; $029D0C | | Set the X register to the offset for this slot's command data plus
    ADC <r_battle_generic_tmp_index                                             ; $029D0D | | the previously calculated offset.
    TAX                                                                         ; $029D0F |/
    TDC                                                                         ; $029D10 |\
    SEP #FLAG_P_ACCUMULATOR                                                     ; $029D11 | | Preserve the value of the X register.
    PHX                                                                         ; $029D13 |/
    LDA command_entry.id.w,X                                                    ; $029D14 |\ Load the command ID and store it for later multiplication.
    STA <r_math_multiply_8bit_arg_1                                             ; $029D17 |/
    LDA command_entry.flags.w,X                                                 ; $029D19 |\ Load the command flags and push them to the stack.
    PHA                                                                         ; $029D1C |/
    LDA #5.b                                                                    ; $029D1D |\
    STA <r_math_multiply_8bit_arg_2                                             ; $029D1F | | Multiply the command ID by five and store it in the X register
    JSR _math_multiply_8bit                                                     ; $029D21 | | to index the name data.
    LDX <r_math_multiply_8bit_result                                            ; $029D24 |/
    LDA #0.b                                                                    ; $029D26 |\ Initially set the tile flags to zero, which uses the default white
    STA <r_battle_generic_tmp_index_lo                                          ; $029D28 |/ palette.
    PLA                                                                         ; $029D2A |\
    AND #BATTLE_COMMAND_FLAG_DISABLED.b                                         ; $029D2B | | Reload the flags and check to see if the command is disabled. If
    BEQ +                                                                       ; $029D2D | | so, switch to the grey palette.
    LDA #4.b                                                                    ; $029D2F | |
    STA <r_battle_generic_tmp_index_lo                                          ; $029D31 |/
+   TDC                                                                         ; $029D33 |\ Set the Y register to zero.
    TAY                                                                         ; $029D34 |/
    LDA #BATTLE_DIALOG_OPCODE_SET_TILE_FLAGS.b                                  ; $029D35 |\
    STA r_battle_update_dialog_data.w,Y                                         ; $029D37 | | Write bytes to the script to set the tile flags to whatever value
    INY                                                                         ; $029D3A | | was just determined.
    LDA <r_battle_generic_tmp_index_lo                                          ; $029D3B | |
    STA r_battle_update_dialog_data.w,Y                                         ; $029D3D | |
    INY                                                                         ; $029D40 |/
-   LDA bank0F.battle_command_name_data.l,X                                     ; $029D41 |\
    STA r_battle_update_dialog_data.w,Y                                         ; $029D45 | | Loop to copy the five characters of the command name directly to
    INY                                                                         ; $029D48 | | the script area.
    INX                                                                         ; $029D49 | |
    CPY #7.w                                                                    ; $029D4A | |
    BNE -                                                                       ; $029D4D |/
    TDC                                                                         ; $029D4F |\ Write a zero to end the script.
    STA r_battle_update_dialog_data.w,Y                                         ; $029D50 |/
    PLX                                                                         ; $029D53 |\
    LDA command_entry.id.w,X                                                    ; $029D54 | | If the command ID was $FF, overwrite the tilemap with blank tiles.
    CMP #$FF.b                                                                  ; $029D57 | |
    BNE +                                                                       ; $029D59 | |
    LDY #2.w                                                                    ; $029D5B | |
-   STA r_battle_update_dialog_data.w,Y                                         ; $029D5E | |
    INY                                                                         ; $029D61 | |
    CPY #7.w                                                                    ; $029D62 | |
    BNE -                                                                       ; $029D65 |/
+   TDC                                                                         ; $029D67 |\ Set the initial tile flags to zero.
    STA r_battle_update_dialog_arg_flags.w                                      ; $029D68 |/
    JSR _battle_update_dialog                                                   ; $029D6B | Execute the script to update the tilemap.
    RTS                                                                         ; $029D6E

; battle_hand_inventory_hand_tilemap_offset_data ($02:9D6F)
;
; For each of the two hands, contains the offset to that hand's tilemap data.
battle_hand_inventory_hand_tilemap_offset_data:
    .db (12 * 2 * 2) * 0                                                        ; $029D6F
    .db (12 * 2 * 2) * 1                                                        ; $029D70

; _battle_update_dialog_hand_inventory_entries ($02:9D71)
;
; Updates the five characters' hand inventories, including loading and updating
; the headers.
_battle_update_dialog_hand_inventory_entries:
    STZ r_battle_update_dialog_arg_slot.w                                       ; $029D71 | Initialize the slot to zero.
--  STZ r_battle_update_dialog_arg_entry.w                                      ; $029D74 | Initialize the entry to zero.
-   JSR _battle_update_dialog_hand_inventory_entry                              ; $029D77 | Update the current hand inventory entry.
    INC r_battle_update_dialog_arg_entry.w                                      ; $029D7A |\
    LDA r_battle_update_dialog_arg_entry.w                                      ; $029D7D | | Increment the index and loop until both of the character's hands
    CMP #2.b                                                                    ; $029D80 | | have been updated.
    BNE -                                                                       ; $029D82 |/
    JSR _battle_load_hand_inventory_header_tilemap                              ; $029D84 | Load the headers for this character's hand inventory.
    INC r_battle_update_dialog_arg_slot.w                                       ; $029D87 |\
    LDA r_battle_update_dialog_arg_slot.w                                       ; $029D8A | | Increment the slot and loop until all five characters have been
    CMP #5.b                                                                    ; $029D8D | | processed.
    BNE --                                                                      ; $029D8F |/
    RTS                                                                         ; $029D91

; _battle_load_hand_inventory_header_tilemap ($02:9D92)
;
; Given a character slot in $1816, loads the hand inventory header tilemap for
; that character and writes it to the hand inventory header tilemap area in
; $BC86.
_battle_load_hand_inventory_header_tilemap:
    LDA r_battle_update_dialog_arg_slot.w                                       ; $029D92 |\
    TAX                                                                         ; $029D95 | | Set the X register to the offset to this slot's battle record.
    JSR _multiply_x_by_128                                                      ; $029D96 |/
    LDA r_character_battle.1.id.w,X                                             ; $029D99 |\
    AND #%11000000.b                                                            ; $029D9C | | Extract the two handedness bits from the character's ID byte and
    LSR A                                                                       ; $029D9E | | shift them right so the final value ranges from 0-3 (though 0 is
    LSR A                                                                       ; $029D9F | | probably unused).
    LSR A                                                                       ; $029DA0 | |
    LSR A                                                                       ; $029DA1 | |
    LSR A                                                                       ; $029DA2 | |
    LSR A                                                                       ; $029DA3 |/
    STA <r_math_multiply_8bit_arg_1                                             ; $029DA4 |\
    LDA #20.b                                                                   ; $029DA6 | | Multiply the value by 20 to index the header data in ROM.
    STA <r_math_multiply_8bit_arg_2                                             ; $029DA8 | |
    JSR _math_multiply_8bit                                                     ; $029DAA |/
    LDA r_battle_update_dialog_arg_slot.w                                       ; $029DAD |\
    ASL A                                                                       ; $029DB0 | | Set the Y register to the offset to this slot's hand inventory
    TAX                                                                         ; $029DB1 | | header tilemap data.
    REP #FLAG_P_ACCUMULATOR                                                     ; $029DB2 | |
    LDA bank16.battle_hand_inventory_header_tilemap_offset_data.l,X             ; $029DB4 | |
    TAY                                                                         ; $029DB8 | |
    TDC                                                                         ; $029DB9 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $029DBA |/
    LDX <r_math_multiply_8bit_result                                            ; $029DBC | Set the X register to the ROM offset.
    LDA #20.b                                                                   ; $029DBE |\ Initialize the index variable to 20 to copy all 20 bytes.
    STA <r_battle_generic_tmp_index_lo                                          ; $029DC0 |/
-   LDA bank16.battle_hand_inventory_header_data.l,X                            ; $029DC2 |\ Read the next byte and write it to the tilemap.
    STA 0.w,Y                                                                   ; $029DC6 |/
    TDC                                                                         ; $029DC9 |\ Write a zero to the flags byte of the tilemap.
    STA 1.w,Y                                                                   ; $029DCA |/
    INX                                                                         ; $029DCD |\
    INY                                                                         ; $029DCE | | Adjust the indexes and loop until all 20 characters have been
    INY                                                                         ; $029DCF | | written.
    DEC <r_battle_generic_tmp_index_lo                                          ; $029DD0 | |
    BNE -                                                                       ; $029DD2 |/
    RTS                                                                         ; $029DD4

; _battle_update_dialog_hand_inventory_entry ($02:9DD5)
;
; Updates the battle hand inventory tilemap for the hand index passed in $1817
; for the character slot passed in $1816.
_battle_update_dialog_hand_inventory_entry:
    LDX #r_battle_update_dialog_data.w                                          ; $029DD5 |\ Set the location where the dialog script data will be stored.
    STX r_battle_update_dialog_arg_source.w                                     ; $029DD8 |/
    LDA #12.b                                                                   ; $029DDB |\ Set the line length to 12.
    STA r_battle_update_dialog_arg_line_length.w                                ; $029DDD |/
    LDA r_battle_update_dialog_arg_entry.w                                      ; $029DE0 |\
    TAX                                                                         ; $029DE3 | | Load the offset for the hand in question and store it in a
    LDA battle_hand_inventory_hand_tilemap_offset_data.l,X                      ; $029DE4 | | temporary variable.
    TAX                                                                         ; $029DE8 | |
    STX <r_battle_generic_tmp_index_2                                           ; $029DE9 |/
    LDA r_battle_update_dialog_arg_entry.w                                      ; $029DEB |\
    ASL A                                                                       ; $029DEE | | Multiply the hand index by four and store that in another
    ASL A                                                                       ; $029DEF | | temporary variable.
    TAX                                                                         ; $029DF0 | |
    STX <r_battle_generic_tmp_index                                             ; $029DF1 |/
    LDA r_battle_update_dialog_arg_slot.w                                       ; $029DF3 |\
    ASL A                                                                       ; $029DF6 | | Set the X register to the character slot times two.
    TAX                                                                         ; $029DF7 |/
    REP #FLAG_P_ACCUMULATOR.b                                                   ; $029DF8 |\
    LDA bank16.battle_hand_inventory_slot_tilemap_offset_data.l,X               ; $029DFA | | Set the target tilemap address by loading the tilemap offset for
    CLC                                                                         ; $029DFE | | this character slot and adding the previously loaded offset for
    ADC <r_battle_generic_tmp_index_2                                           ; $029DFF | | the hand in question.
    STA r_battle_update_dialog_arg_target.w                                     ; $029E01 |/
    LDA bank16.battle_hand_inventory_slot_offset_data.l,X                       ; $029E04 |\
    CLC                                                                         ; $029E08 | | Add the base offset for the hand inventory data for the slot in
    ADC <r_battle_generic_tmp_index                                             ; $029E09 | | question to the loaded offset for the hand and store it in the X
    TAX                                                                         ; $029E0B | | register.
    TDC                                                                         ; $029E0C | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $029E0D |/
    LDA #0.b                                                                    ; $029E0F |\
    STA <r_battle_generic_tmp_index_lo                                          ; $029E11 | | Set the tile flags variables initially to zero to use the standard
    LDA #0.b                                                                    ; $029E13 | | white palette.
    STA <r_battle_generic_tmp_index_hi                                          ; $029E15 |/
    LDA battle_inventory_entry.id.w,X                                           ; $029E17 |\
    STA <r_math_multiply_8bit_arg_1                                             ; $029E1A | | Load the ID for the item and store it for later multiplication.
    STA <r_battle_update_dialog_tmp_3                                           ; $029E1C |/
    LDA battle_inventory_entry.count.w,X                                        ; $029E1E |\ Load the count and save it on the stack.
    PHA                                                                         ; $029E21 |/
    LDA #9.b                                                                    ; $029E22 |\
    STA <r_math_multiply_8bit_arg_2                                             ; $029E24 | | Multiply the ID by 9, but leave the result in the result variable.
    JSR _math_multiply_8bit                                                     ; $029E26 |/
    LDA battle_inventory_entry.flags.w,X                                        ; $029E29 |\
    AND #BATTLE_INVENTORY_FLAG_DISABLED.b                                       ; $029E2C | | If the entry has the disabled flag set, change the palette to the
    BEQ +                                                                       ; $029E2E | | dark grey palette.
    LDA #4.b                                                                    ; $029E30 | |
    STA <r_battle_generic_tmp_index_lo                                          ; $029E32 | |
    STA <r_battle_generic_tmp_index_hi                                          ; $029E34 |/
+   LDX <r_math_multiply_8bit_result                                            ; $029E36 | Set the X register to the item name index calculated earlier.
    TDC                                                                         ; $029E38 |\ Set the Y register to zero.
    TAY                                                                         ; $029E39 |/
    LDA #BATTLE_DIALOG_OPCODE_SET_TILE_FLAGS.b                                  ; $029E3A |\
    STA r_battle_update_dialog_data.w,Y                                         ; $029E3C | | Write bytes to initially set the tile flags to one of the values.
    INY                                                                         ; $029E3F | |
    LDA <r_battle_generic_tmp_index_hi                                          ; $029E40 | |
    STA r_battle_update_dialog_data.w,Y                                         ; $029E42 | |
    INY                                                                         ; $029E45 |/
    LDA #BATTLE_DIALOG_OPCODE_TILE.b                                            ; $029E46 |\
    STA r_battle_update_dialog_data.w,Y                                         ; $029E48 | | Next, copy the first character of the item name.
    INY                                                                         ; $029E4B | |
    LDA bank0F.item_name_data.l,X                                               ; $029E4C | |
    STA r_battle_update_dialog_data.w,Y                                         ; $029E50 | |
    INY                                                                         ; $029E53 |/
    LDA #BATTLE_DIALOG_OPCODE_SET_TILE_FLAGS.b                                  ; $029E54 |\
    STA r_battle_update_dialog_data.w,Y                                         ; $029E56 | | Next, set the tile flags to the other value.
    INY                                                                         ; $029E59 | |
    LDA <r_battle_generic_tmp_index_lo                                          ; $029E5A | |
    STA r_battle_update_dialog_data.w,Y                                         ; $029E5C | |
    INY                                                                         ; $029E5F |/
    LDA #8.b                                                                    ; $029E60 |\ Initialize the index variable to copy eight characters.
    STA <r_battle_generic_tmp_index_lo                                          ; $029E62 |/
-   LDA bank0F.item_name_data.l + 1,X                                           ; $029E64 |\
    STA r_battle_update_dialog_data.w,Y                                         ; $029E68 | | Copy the remaining eight characters from the item name.
    INY                                                                         ; $029E6B | |
    INX                                                                         ; $029E6C | |
    DEC <r_battle_generic_tmp_index_lo                                          ; $029E6D | |
    BNE -                                                                       ; $029E6F |/
    LDA <r_battle_update_dialog_tmp_3                                           ; $029E71 |\
    BNE +                                                                       ; $029E73 | | If the item slot was empty, prepare to write three blanks to the
    PLA                                                                         ; $029E75 | | tilemap.
    LDA #BATTLE_DIALOG_OPCODE_BLANKS.b                                          ; $029E76 | |
    STA r_battle_update_dialog_data.w,Y                                         ; $029E78 | |
    INY                                                                         ; $029E7B | |
    LDA #3.b                                                                    ; $029E7C | |
    BRA ++                                                                      ; $029E7E |/
+   LDA #$C8.b                                                                  ; $029E80 |\
    STA r_battle_update_dialog_data.w,Y                                         ; $029E82 | | Otherwise, write a colon and format the count of the item and
    INY                                                                         ; $029E85 | | write the last two digits of the decimal representation of the
    PLA                                                                         ; $029E86 | | number.
    TAX                                                                         ; $029E87 | |
    JSR _battle_format_number                                                   ; $029E88 | |
    JSR _battle_render_number                                                   ; $029E8B | |
    LDA r_battle_format_number_result + 2.w                                     ; $029E8E | |
    STA r_battle_update_dialog_data.w,Y                                         ; $029E91 | |
    INY                                                                         ; $029E94 | |
    LDA r_battle_format_number_result + 3.w                                     ; $029E95 |/
++  STA r_battle_update_dialog_data.w,Y                                         ; $029E98 |\ Store the last byte (either the blanks count or the second digit).
    INY                                                                         ; $029E9B |/
    TDC                                                                         ; $029E9C |\ Write a zero to end the script.
    STA r_battle_update_dialog_data.w,Y                                         ; $029E9D |/
    JSR _battle_update_dialog                                                   ; $029EA0 | Update the dialog using the script.
    RTS                                                                         ; $029EA3

; _battle_update_dialog_inventory_entries ($02:9EA4)
;
; Loops through the battle inventory, updating the tilemap entries for all of
; them.
_battle_update_dialog_inventory_entries:
    STZ r_battle_update_dialog_arg_entry.w                                      ; $029EA4 | Initialize the entry to zero to start.
-   JSR _battle_update_dialog_inventory_entry                                   ; $029EA7 | Update the current inventory entry.
    INC r_battle_update_dialog_arg_entry.w                                      ; $029EAA |\
    LDA r_battle_update_dialog_arg_entry.w                                      ; $029EAD | | Increment the inventory entry and repeat until all 48 entries have
    CMP #48.b                                                                   ; $029EB0 | | been updated.
    BNE -                                                                       ; $029EB2 |/
    RTS                                                                         ; $029EB4

; _battle_update_spell_list_palettes ($02:9EB5)
;
; Given a slot number in $00, updates the palettes of that slot's spell lists
; based on the disabled bit of the flags byte in the spell list for that slot.
_battle_update_spell_list_palettes:
    LDA <r_battle_update_arg_slot                                               ; $029EB5 |\
    ASL A                                                                       ; $029EB7 | | Set the X register to the slot number times two.
    TAX                                                                         ; $029EB8 |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $029EB9 |\
    LDA bank16.current_spell_list_slot_offset_data.l,X                          ; $029EBB | | Set the first index to the slot's spell list location.
    STA <r_battle_generic_tmp_index                                             ; $029EBF |/
    LDA bank16.battle_spell_list_slot_tilemap_offset_data.l,X                   ; $029EC1 |\ Set the second index to the slot's spell list tilemap.
    STA <r_battle_generic_tmp_index_2                                           ; $029EC5 |/
    CLC                                                                         ; $029EC7 |\
    ADC #12.w                                                                   ; $029EC8 | | Set the third index to the second line of the slot's tilemap.
    STA <r_battle_generic_tmp_index_3                                           ; $029ECB |/
    TDC                                                                         ; $029ECD |\
    SEP #FLAG_P_ACCUMULATOR                                                     ; $029ECE | | Set the count variable to loop through all 72 entries.
    LDA #72.b                                                                   ; $029ED0 | |
    STA <r_battle_update_spell_list_palettes_entries                            ; $029ED2 |/
@start:
    LDY #1.w                                                                    ; $029ED4 | Set the Y register to one, to always write to the flags byte.
    LDA (<r_battle_generic_tmp_index)                                           ; $029ED7 |\
    BMI +                                                                       ; $029ED9 | | If the spell entry is not disabled, set the palette to 0 to use
    LDA #0.b                                                                    ; $029EDB | | the white palette.
    STA <r_battle_update_spell_list_palettes_tmp                                ; $029EDD | |
    LDA #0.b                                                                    ; $029EDF | |
    BRA ++                                                                      ; $029EE1 |/
+   LDA #4.b                                                                    ; $029EE3 |\
    STA <r_battle_update_spell_list_palettes_tmp                                ; $029EE5 | | Otherwise, use the dark grey palette.
    BRA ++                                                                      ; $029EE7 |/
-   LDA <r_battle_update_spell_list_palettes_tmp                                ; $029EE9 |\
++  STA (<r_battle_generic_tmp_index_2),Y                                       ; $029EEB | | Load the palette value and store it to both lines.
    STA (<r_battle_generic_tmp_index_3),Y                                       ; $029EED |/
    INY                                                                         ; $029EEF |\ Increment the Y register twice to move to the next flags byte.
    INY                                                                         ; $029EF0 |/
    CPY #12.w + 1                                                               ; $029EF1 |\ Loop until the entire entry has been updated.
    BNE -                                                                       ; $029EF4 |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $029EF6 |\
    LDA <r_battle_generic_tmp_index_2                                           ; $029EF8 | | Add 24 to the index to move to the next entry.
    CLC                                                                         ; $029EFA | |
    ADC #24.w                                                                   ; $029EFB |/
    STA <r_battle_generic_tmp_index_2                                           ; $029EFE |\
    CLC                                                                         ; $029F00 | | Update the second index to be the next line.
    ADC #12.w                                                                   ; $029F01 | |
    STA <r_battle_generic_tmp_index_3                                           ; $029F04 |/
    LDA <r_battle_generic_tmp_index                                             ; $029F06 |\
    CLC                                                                         ; $029F08 | | Move to the next spell entry.
    ADC #_sizeof_spell_entry.w                                                  ; $029F09 | |
    STA <r_battle_generic_tmp_index                                             ; $029F0C |/
    TDC                                                                         ; $029F0E |\
    SEP #FLAG_P_ACCUMULATOR                                                     ; $029F0F | | Decrement the number of entries and loop until all of them have
    DEC <r_battle_update_spell_list_palettes_entries                            ; $029F11 | | been updated.
    BNE @start                                                                  ; $029F13 |/
    RTS                                                                         ; $029F15

; _battle_update_inventory_palettes ($02:9F16)
;
; Updates the the hand inventory tilemap for the most recently active character,
; and then updates the palettes on the entire battle inventory to show disabled
; items as grey and enabled items as white. If the value of $EF9A is non-zero,
; it will assume items that can be darted are enabled, otherwise it will read
; the actual disabled bit of the inventory entry flags to determine status.
_battle_update_inventory_palettes:
    LDA r_battle_last_active_character_slot.w                                   ; $029F16 |\ Set the dialog update slot to the active character slot.
    STA r_battle_update_dialog_arg_slot.w                                       ; $029F19 |/
    STZ r_battle_update_dialog_arg_entry.w                                      ; $029F1C |\ Update the tilemap for the character's right hand.
    JSR _battle_update_dialog_hand_inventory_entry                              ; $029F1F |/
    INC r_battle_update_dialog_arg_entry.w                                      ; $029F22 |\ Update the tilemap for the character's left hand.
    JSR _battle_update_dialog_hand_inventory_entry                              ; $029F25 |/
    LDA r_battle_menu_inventory_dart.w                                          ; $029F28 |\
    BEQ +                                                                       ; $029F2B | | If the palettes should reflect Dart, jump accordingly.
    JMP @dart                                                                   ; $029F2D |/
+   TDC                                                                         ; $029F30 |\
    TAY                                                                         ; $029F31 | | Initialize X and Y registers to zero.
    TAX                                                                         ; $029F32 |/
--  LDA #12.b                                                                   ; $029F33 |\ Initialize loop variable to loop through the 12 characters of the
    STA <r_battle_update_dialog_tmp_3                                           ; $029F35 |/ inventory entry.
    LDA r_battle_inventory.1.flags.w,X                                          ; $029F37 |\
    BMI +                                                                       ; $029F3A | | If the item is not disabled, set the flags variable to use the
    LDA #0.b                                                                    ; $029F3C | | regular white palette.
    STA <r_battle_update_dialog_tmp_1                                           ; $029F3E | |
    LDA #0.b                                                                    ; $029F40 | |
    BRA ++                                                                      ; $029F42 |/
+   LDA #4.b                                                                    ; $029F44 |\
    STA <r_battle_update_dialog_tmp_1                                           ; $029F46 | | Otherwise, use the dark grey palette.
    BRA ++                                                                      ; $029F48 |/
-   LDA <r_battle_update_dialog_tmp_1                                           ; $029F4A |\
++  STA r_battle_inventory_tilemap_data.w + 1,Y                                 ; $029F4C | | Load the palette value and store it to the two lines of the entry.
    STA r_battle_inventory_tilemap_data.w + 25,Y                                ; $029F4F |/
    INY                                                                         ; $029F52 |\
    INY                                                                         ; $029F53 | | Increment the index and loop until all 12 characters are updated.
    DEC <r_battle_update_dialog_tmp_3                                           ; $029F54 | |
    BNE -                                                                       ; $029F56 |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $029F58 |\
    TYA                                                                         ; $029F5A | | Increment the Y register by 24 to move to the next entry, since we
    CLC                                                                         ; $029F5B | | wrote both lines of the entry at the same time.
    ADC #24.w                                                                   ; $029F5C | |
    TAY                                                                         ; $029F5F | |
    TDC                                                                         ; $029F60 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $029F61 |/
    INX                                                                         ; $029F63 |\
    INX                                                                         ; $029F64 | | Increment the X register by four to move to the next ivnentory
    INX                                                                         ; $029F65 | |
    INX                                                                         ; $029F66 |/
    CPX #_sizeof_r_battle_inventory.w                                           ; $029F67 |\ Loop until the entire inventory has been processed.
    BNE --                                                                      ; $029F6A |/
    RTS                                                                         ; $029F6C
@dart:
    TDC                                                                         ; $029F6D |\
    TAX                                                                         ; $029F6E | | Initialize the X and Y registers to zero.
    TAY                                                                         ; $029F6F |/
--  LDA #12.b                                                                   ; $029F70 |\ Initialize the index to loop through the 12 characters of the
    STA <r_battle_update_dialog_tmp_3                                           ; $029F72 |/ entry.
    LDA r_battle_inventory.1.flags.w,X                                          ; $029F74 |\
    AND #BATTLE_INVENTORY_FLAG_DARTABLE.b                                       ; $029F77 | | If the inventory entry has the dartable flag set, set the variable
    BEQ +                                                                       ; $029F79 | | to use the white palette.
    LDA #0.b                                                                    ; $029F7B | |
    STA <r_battle_update_dialog_tmp_1                                           ; $029F7D | |
    LDA #0.b                                                                    ; $029F7F | |
    BRA ++                                                                      ; $029F81 |/
+   LDA #4.b                                                                    ; $029F83 |\
    STA <r_battle_update_dialog_tmp_1                                           ; $029F85 | | Otherwise, use the dark grey palette.
    BRA ++                                                                      ; $029F87 |/
-   LDA <r_battle_update_dialog_tmp_1                                           ; $029F89 |\
++  STA r_battle_inventory_tilemap_data.w + 1,Y                                 ; $029F8B | | Write the flags byte to both lines of the entry.
    STA r_battle_inventory_tilemap_data.w + 25,Y                                ; $029F8E |/
    INY                                                                         ; $029F91 |\
    INY                                                                         ; $029F92 | | Increment the index and loop until all 12 tiles have been done.
    DEC <r_battle_update_dialog_tmp_3                                           ; $029F93 | |
    BNE -                                                                       ; $029F95 |/
    REP #FLAG_P_ACCUMULATOR.b                                                   ; $029F97 |\
    TYA                                                                         ; $029F99 | | Increment the Y register by 12 to skip the second line and move to
    CLC                                                                         ; $029F9A | | the next entry.
    ADC #24.w                                                                   ; $029F9B | |
    TAY                                                                         ; $029F9E | |
    TDC                                                                         ; $029F9F | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $029FA0 |/
    INX                                                                         ; $029FA2 |\
    INX                                                                         ; $029FA3 | | Increment the X register by four to move to the next inventory
    INX                                                                         ; $029FA4 | | entry.
    INX                                                                         ; $029FA5 |/
    CPX #_sizeof_r_battle_inventory.w                                           ; $029FA6 |\ Loop until the entire inventory has been processed.
    BNE --                                                                      ; $029FA9 |/
    RTS                                                                         ; $029FAB

; _battle_update_dialog_inventory_entry ($02:9FAC)
;
; Given an inventory entry number in $1817, updates the dialog in BG3 to
; correctly display that entry based on its current flags.
_battle_update_dialog_inventory_entry:
    LDX #r_battle_update_dialog_data.w                                          ; $029FAC |\ Set the dialog source pointer to the location in memory where data
    STX r_battle_update_dialog_arg_source.w                                     ; $029FAF |/ will be written.
    LDA r_battle_update_dialog_arg_entry.w                                      ; $029FB2 |\
    STA <r_math_multiply_8bit_arg_1                                             ; $029FB5 | | Determine the target address by multiplying the entry number by
    LDA #48.b                                                                   ; $029FB7 | | 48 (as each entry is 2 lines of 12 tiles, each with two bytes) and
    STA <r_math_multiply_8bit_arg_2                                             ; $029FB9 | | adding that to the base address.
    JSR _math_multiply_8bit                                                     ; $029FBB | |
    REP #FLAG_P_ACCUMULATOR                                                     ; $029FBE | |
    LDA <r_math_multiply_8bit_result                                            ; $029FC0 | |
    CLC                                                                         ; $029FC2 | |
    ADC #r_battle_inventory_tilemap_data.w                                      ; $029FC3 | |
    STA r_battle_update_dialog_arg_target.w                                     ; $029FC6 | |
    TDC                                                                         ; $029FC9 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $029FCA |/
    LDA #12.b                                                                   ; $029FCC |\ Set the length of the line to 12.
    STA r_battle_update_dialog_arg_line_length.w                                ; $029FCE |/
    LDA r_battle_update_dialog_arg_entry.w                                      ; $029FD1 |\
    ASL A                                                                       ; $029FD4 | | Set the X register by multiplying the desired entry by 4, as each
    ASL A                                                                       ; $029FD5 | | entry has four bytes of data.
    TAX                                                                         ; $029FD6 |/
    LDA r_battle_inventory.1.id.w,X                                             ; $029FD7 |\ Load the item ID for this inventory entry and save it for later.
    STA <r_battle_update_dialog_tmp_3                                           ; $029FDA |/
    STA <r_math_multiply_8bit_arg_1                                             ; $029FDC | Also save the item ID for later multiplication.
    LDA r_battle_inventory.1.count.w,X                                          ; $029FDE |\ Push the item count to the stack.
    PHA                                                                         ; $029FE1 |/
    LDA #%00000000.b                                                            ; $029FE2 |\
    STA <r_battle_update_dialog_tmp_1                                           ; $029FE4 | | By default, set no extra flags for the tiles.
    LDA #%00000000.b                                                            ; $029FE6 | |
    STA <r_battle_update_dialog_tmp_2                                           ; $029FE8 |/
    LDA r_battle_inventory.1.flags.w,X                                          ; $029FEA |\
    AND #BATTLE_INVENTORY_FLAG_DISABLED.b                                       ; $029FED | | If the current item is disabled, change its palette to use the
    BEQ +                                                                       ; $029FEF | | dark grey palette.
    LDA #%00000100.b                                                            ; $029FF1 | |
    STA <r_battle_update_dialog_tmp_1                                           ; $029FF3 | |
    STA <r_battle_update_dialog_tmp_2                                           ; $029FF5 |/
+   LDA #9.b                                                                    ; $029FF7 |\
    STA <r_math_multiply_8bit_arg_2                                             ; $029FF9 | | Multiply the item ID by 9 and then transfer the result to the X
    JSR _math_multiply_8bit                                                     ; $029FFB | | register.
    LDX <r_math_multiply_8bit_result                                            ; $029FFE |/
    TDC                                                                         ; $02A000 |\ Set the Y register to zero.
    TAY                                                                         ; $02A001 |/
    LDA #BATTLE_DIALOG_OPCODE_SET_TILE_FLAGS.b                                  ; $02A002 |\
    STA r_battle_update_dialog_data.w,Y                                         ; $02A004 | | Set data to set the tile flags initially to the first tile flags
    INY                                                                         ; $02A007 | | value.
    LDA <r_battle_update_dialog_tmp_2                                           ; $02A008 | |
    STA r_battle_update_dialog_data.w,Y                                         ; $02A00A | |
    INY                                                                         ; $02A00D |/
    LDA #BATTLE_DIALOG_OPCODE_TILE.b                                            ; $02A00E |\
    STA r_battle_update_dialog_data.w,Y                                         ; $02A010 | | Set the next byte to copy the first value from the item name.
    INY                                                                         ; $02A013 | |
    LDA bank0F.item_name_data.l,X                                               ; $02A014 | |
    STA r_battle_update_dialog_data.w,Y                                         ; $02A018 | |
    INY                                                                         ; $02A01B |/
    LDA #BATTLE_DIALOG_OPCODE_SET_TILE_FLAGS.b                                  ; $02A01C |\
    STA r_battle_update_dialog_data.w,Y                                         ; $02A01E | | Set the tile flags for the following tiles to the value of the
    INY                                                                         ; $02A021 | | second flags variable.
    LDA <r_battle_update_dialog_tmp_1                                           ; $02A022 | |
    STA r_battle_update_dialog_data.w,Y                                         ; $02A024 | |
    INY                                                                         ; $02A027 |/
    LDA #8.b                                                                    ; $02A028 |\ Initialize the counter to copy the remaining eight tiles of the
    STA <r_battle_update_dialog_tmp_1                                           ; $02A02A |/ item name.
-   LDA bank0F.item_name_data.l + 1,X                                           ; $02A02C |\
    STA r_battle_update_dialog_data.w,Y                                         ; $02A030 | | Loop through the remaining tiles of the item name.
    INY                                                                         ; $02A033 | |
    INX                                                                         ; $02A034 | |
    DEC <r_battle_update_dialog_tmp_1                                           ; $02A035 | |
    BNE -                                                                       ; $02A037 |/
    LDA <r_battle_update_dialog_tmp_3                                           ; $02A039 |\
    BNE +                                                                       ; $02A03B | | If there is no actual item, set the next three tiles explicitly to
    PLA                                                                         ; $02A03D | | blanks, and then branch significantly ahead.
    LDA #BATTLE_DIALOG_OPCODE_BLANKS.b                                          ; $02A03E | |
    STA r_battle_update_dialog_data.w,Y                                         ; $02A040 | |
    INY                                                                         ; $02A043 | |
    LDA #3.b                                                                    ; $02A044 | |
    BRA ++                                                                      ; $02A046 |/
+   LDA #$C8.b                                                                  ; $02A048 |\
    STA r_battle_update_dialog_data.w,Y                                         ; $02A04A | | Otherwise, the next character is a colon.
    INY                                                                         ; $02A04D |/
    PLA                                                                         ; $02A04E |\ Restore the item count from the stack and move it to the X
    TAX                                                                         ; $02A04F |/ register.
    JSR _battle_format_number                                                   ; $02A050 |\ Convert the item count for display.
    JSR _battle_render_number                                                   ; $02A053 |/
    LDA #BATTLE_DIALOG_OPCODE_TILE.b                                            ; $02A056 |\
    STA r_battle_update_dialog_data.w,Y                                         ; $02A058 | | Copy the first digit of the item count.
    INY                                                                         ; $02A05B | |
    LDA r_battle_format_number_result.w + 2                                     ; $02A05C | |
    STA r_battle_update_dialog_data.w,Y                                         ; $02A05F | |
    INY                                                                         ; $02A062 |/
    LDA #BATTLE_DIALOG_OPCODE_TILE.b                                            ; $02A063 |\
    STA r_battle_update_dialog_data.w,Y                                         ; $02A065 | | Copy the second digit of the item count (or the parameter for the
    INY                                                                         ; $02A068 | | blanks opcode if the item was empty).
    LDA r_battle_format_number_result.w + 3                                     ; $02A069 | |
++  STA r_battle_update_dialog_data.w,Y                                         ; $02A06C | |
    INY                                                                         ; $02A06F |/
    TDC                                                                         ; $02A070 |\ Store a zero to end the instruction sequence.
    STA r_battle_update_dialog_data.w,Y                                         ; $02A071 |/
    JSR _battle_update_dialog                                                   ; $02A074 | Actually update the dialog.
    RTS                                                                         ; $02A077

; _battle_update_dialog_spell_list_entries ($02:A078)
;
; Loops through the characters and their three spell lists each, updating all
; spell list entries in the tilemap data.
_battle_update_dialog_spell_list_entries:
    STZ r_battle_update_dialog_arg_slot.w                                       ; $02A078 | Initialize the slot to zero.
--  STZ r_battle_update_dialog_arg_entry.w                                      ; $02A07B | Initialize the entry to zero.
-   JSR _battle_update_dialog_spell_list_entry                                  ; $02A07E | Update the current spell list entry.
    INC r_battle_update_dialog_arg_entry.w                                      ; $02A081 |\
    LDA r_battle_update_dialog_arg_entry.w                                      ; $02A084 | | Increment the entry number and loop until all 72 entries for this
    CMP #(24 * 3).b                                                             ; $02A087 | | character have been updated.
    BNE -                                                                       ; $02A089 |/
    INC r_battle_update_dialog_arg_slot.w                                       ; $02A08B |\
    LDA r_battle_update_dialog_arg_slot.w                                       ; $02A08E | | Increment the slot number and loop until all five characters have
    CMP #5.b                                                                    ; $02A091 | | been handled.
    BNE --                                                                      ; $02A093 |/
    RTS                                                                         ; $02A095

; _battle_update_dialog_spell_list_entry ($02:A096)
;
; Given a character slot number in $1816 and the index of a spell in that slot's
; spell lists (considering all three lists as one contiguous array) in $1817,
; updates the tilemap data for that slot's spell lists for that entry.
_battle_update_dialog_spell_list_entry:
    LDX #r_battle_update_dialog_data.w                                          ; $02A096 |\ Set the location where the update data will be stored to the
    STX r_battle_update_dialog_arg_source.w                                     ; $02A099 |/ update function argument.
    LDA #6.b                                                                    ; $02A09C |\ Set the line length to six, as each spell has six characters.
    STA r_battle_update_dialog_arg_line_length.w                                ; $02A09E |/
    LDA r_battle_update_dialog_arg_entry.w                                      ; $02A0A1 |\
    STA <r_math_multiply_8bit_arg_1                                             ; $02A0A4 | | Multiply the desired entry number by 24, as each entry takes up
    LDA #24.b                                                                   ; $02A0A6 | | 24 bytes in the tilemap (two rows of six tiles, each with two
    STA <r_math_multiply_8bit_arg_2                                             ; $02A0A8 | | bytes). The result remains in the multiply result variable.
    JSR _math_multiply_8bit                                                     ; $02A0AA |/
    LDA r_battle_update_dialog_arg_slot.w                                       ; $02A0AD |\
    ASL A                                                                       ; $02A0B0 | | Set the X register to the slot times two.
    TAX                                                                         ; $02A0B1 |/
    LDA r_battle_update_dialog_arg_entry.w                                      ; $02A0B2 |\
    REP #FLAG_P_ACCUMULATOR                                                     ; $02A0B5 | | Multiply the entry number by four and place it in a temporary
    ASL A                                                                       ; $02A0B7 | | location to use later.
    ASL A                                                                       ; $02A0B8 | |
    STA <r_battle_generic_tmp_index_lo                                          ; $02A0B9 |/
    LDA bank16.battle_spell_list_slot_tilemap_offset_data.l,X                   ; $02A0BB |\
    CLC                                                                         ; $02A0BF | | Set the target address by reading the offset for this character
    ADC <r_math_multiply_8bit_result                                            ; $02A0C0 | | slot and then adding the calculated offset.
    STA r_battle_update_dialog_arg_target.w                                     ; $02A0C2 |/
    LDA bank16.current_spell_list_slot_offset_data.l,X                          ; $02A0C5 |\
    CLC                                                                         ; $02A0C9 | | Set the X register to the offset to the spell list data for this
    ADC <r_battle_generic_tmp_index_lo                                          ; $02A0CA | | slot and adding the offset to the entry in that slot's lists.
    TAX                                                                         ; $02A0CC | |
    TDC                                                                         ; $02A0CD | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $02A0CE |/
    LDA spell_entry.id.w,X                                                      ; $02A0D0 |\ Prepare to multiply the spell's ID number.
    STA <r_math_multiply_8bit_arg_1                                             ; $02A0D3 |/
    LDA #0.b                                                                    ; $02A0D5 |\
    STA <r_battle_generic_tmp_index_lo                                          ; $02A0D7 | | Initialize the flags to zero initially.
    LDA #0.b                                                                    ; $02A0D9 | |
    STA <r_battle_generic_tmp_index_hi                                          ; $02A0DB |/
    LDA spell_entry.flags.w,X                                                   ; $02A0DD |\
    AND #BATTLE_SPELL_FLAG_NO_CAST.b                                            ; $02A0E0 | | If the no cast flag is set for this spell, change the palette to
    BEQ +                                                                       ; $02A0E2 | | the darker grey palette.
    LDA #4.b                                                                    ; $02A0E4 | |
    STA <r_battle_generic_tmp_index_lo                                          ; $02A0E6 | |
    STA <r_battle_generic_tmp_index_hi                                          ; $02A0E8 |/
+   LDA #6.b                                                                    ; $02A0EA |\
    STA <r_math_multiply_8bit_arg_2                                             ; $02A0EC | | Multiply the spell ID by six to index into the name data, and move
    JSR _math_multiply_8bit                                                     ; $02A0EE | | the result into the X register.
    LDX <r_math_multiply_8bit_result                                            ; $02A0F1 |/
    TDC                                                                         ; $02A0F3 |\ Initialize the Y register to zero.
    TAY                                                                         ; $02A0F4 |/
    LDA #BATTLE_DIALOG_OPCODE_SET_TILE_FLAGS.b                                  ; $02A0F5 |\
    STA r_battle_update_dialog_data.w,Y                                         ; $02A0F7 | | Set the tile flags to the first flags variable.
    INY                                                                         ; $02A0FA | |
    LDA <r_battle_generic_tmp_index_hi                                          ; $02A0FB | |
    STA r_battle_update_dialog_data.w,Y                                         ; $02A0FD | |
    INY                                                                         ; $02A100 |/
    LDA #BATTLE_DIALOG_OPCODE_TILE.b                                            ; $02A101 |\
    STA r_battle_update_dialog_data.w,Y                                         ; $02A103 | | Next, copy the first character of the spell name.
    INY                                                                         ; $02A106 | |
    LDA bank0F.spell_name_short_data.l,X                                        ; $02A107 | |
    STA r_battle_update_dialog_data.w,Y                                         ; $02A10B | |
    INY                                                                         ; $02A10E |/
    LDA #BATTLE_DIALOG_OPCODE_SET_TILE_FLAGS.b                                  ; $02A10F |\
    STA r_battle_update_dialog_data.w,Y                                         ; $02A111 | | Next, set the flags to the second flags variable.
    INY                                                                         ; $02A114 | |
    LDA <r_battle_generic_tmp_index_lo                                          ; $02A115 | |
    STA r_battle_update_dialog_data.w,Y                                         ; $02A117 | |
    INY                                                                         ; $02A11A |/
    LDA #5.b                                                                    ; $02A11B |\ Initialize the index to copy the remaining five characters.
    STA <r_battle_generic_tmp_index_lo                                          ; $02A11D |/
-   LDA bank0F.spell_name_short_data.l + 1,X                                    ; $02A11F |\
    STA r_battle_update_dialog_data.w,Y                                         ; $02A123 | | Directly copy the remaining five characters.
    INY                                                                         ; $02A126 | |
    INX                                                                         ; $02A127 | |
    DEC <r_battle_generic_tmp_index_lo                                          ; $02A128 | |
    BNE -                                                                       ; $02A12A |/
    TDC                                                                         ; $02A12C |\ Write a zero to end the instruction sequence.
    STA r_battle_update_dialog_data.w,Y                                         ; $02A12D |/
    JSR _battle_update_dialog                                                   ; $02A130 | Actually update the dialog.
    RTS                                                                         ; $02A133

; _battle_update_dialog_character_hp ($02:A134)
;
; Updates the tilemap data in RAM with the current HP and maximum HP of each
; character. Empty slots are moved to the bottom so all active characters are
; listed at the top.
;
; This function has a bug that results in the small "HP" letters being moved
; horizontally depending on which position is the first non-empty one.
_battle_update_dialog_character_hp:
    LDA #BATTLE_DIALOG_STAT_CHARACTER_HP.b                                      ; $02A134 |\ Load the parameters into $EF50 to $EF55 for updating character HP.
    JSR _battle_update_dialog_load_stat_offsets                                 ; $02A136 |/
    TDC                                                                         ; $02A139 |\
    TAY                                                                         ; $02A13A | | Initialize the index registers to zero.
    TAX                                                                         ; $02A13B |/
    STZ <r_battle_check_position_invisible_arg.b                                ; $02A13C | Initialize the current position to zero.
    STZ <r_battle_update_dialog_empty_count.b                                   ; $02A13E | Initialize the empty slot count to zero.
@start:
    PHX                                                                         ; $02A140 |\
    LDA <r_battle_check_position_invisible_arg.b                                ; $02A141 | | Calculate the offset to this position's in-battle character record
    REP #FLAG_P_ACCUMULATOR                                                     ; $02A143 | | and store it in a temporary variable.
    ASL A                                                                       ; $02A145 | |
    TAX                                                                         ; $02A146 | |
    LDA character_battle_offset_data.l,X                                        ; $02A147 | |
    STA <r_battle_generic_tmp_index                                             ; $02A14B | |
    TDC                                                                         ; $02A14D | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $02A14E | |
    PLX                                                                         ; $02A150 |/
    JSR _battle_check_position_invisible                                        ; $02A151 |\
    BCS +                                                                       ; $02A154 | | Skip ahead if this slot is either empty or the character is
    LDA (<r_battle_generic_tmp_index)                                           ; $02A156 | | invisible.
    BEQ +                                                                       ; $02A158 |/
    LDA #6.b                                                                    ; $02A15A |\
    STA <r_battle_update_dialog_tmp_3                                           ; $02A15C | | Otherwise, copy the six bytes of the character HP update script.
-   LDA bank16.battle_dialog_character_hp_script_data.l,X                       ; $02A15E | |
    STA r_battle_update_dialog_data.w,Y                                         ; $02A162 | |
    INY                                                                         ; $02A165 | |
    INX                                                                         ; $02A166 | |
    DEC <r_battle_update_dialog_tmp_3                                           ; $02A167 | |
    BNE -                                                                       ; $02A169 | |
    BRA ++                                                                      ; $02A16B |/
+   REP #FLAG_P_ACCUMULATOR                                                     ; $02A16D |\
    TXA                                                                         ; $02A16F | | If the slot was empty, increase the script index by six and
    CLC                                                                         ; $02A170 | | increment the empty slot counter.
    ADC #6.w                                                                    ; $02A171 | |
    TAX                                                                         ; $02A174 | |
    TDC                                                                         ; $02A175 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $02A176 | |
    INC <r_battle_update_dialog_empty_count                                     ; $02A178 |/
++  INC <r_battle_check_position_invisible_arg.b                                ; $02A17A |\
    LDA <r_battle_check_position_invisible_arg.b                                ; $02A17C | | Increment the position index and loop until all five positions are
    CMP #5.b                                                                    ; $02A17E | | handled.
    BNE @start                                                                  ; $02A180 |/
    LDA <r_battle_update_dialog_empty_count                                     ; $02A182 |\
    BEQ +                                                                       ; $02A184 | | For each empty slot, write a script to write nine blank tiles
-   LDA #BATTLE_DIALOG_OPCODE_BLANKS.b                                          ; $02A186 | | instead of HP, and then move to the next line.
    STA r_battle_update_dialog_data.w,Y                                         ; $02A188 | |
    INY                                                                         ; $02A18B | |
    LDA #9.b                                                                    ; $02A18C | |
    STA r_battle_update_dialog_data.w,Y                                         ; $02A18E | |
    INY                                                                         ; $02A191 | |
    LDA #BATTLE_DIALOG_OPCODE_NEXT_LINE.b                                       ; $02A192 | |
    STA r_battle_update_dialog_data.w,Y                                         ; $02A194 | |
    INY                                                                         ; $02A197 | |
    DEC <r_battle_update_dialog_empty_count                                     ; $02A198 | |
    BNE -                                                                       ; $02A19A |/
+   TDC                                                                         ; $02A19C |\ Replace the final next line opcode with a zero to end the script.
    STA r_battle_update_dialog_data.w - 1,Y                                     ; $02A19D |/
    JSR _battle_update_dialog                                                   ; $02A1A0 | Update the actual tilemap data in RAM.
    TDC                                                                         ; $02A1A3 |\ Reset the X register to zero.
    TAX                                                                         ; $02A1A4 |/
-   REP #FLAG_P_ACCUMULATOR                                                     ; $02A1A5 |\
    LDA character_battle_offset_data.l,X                                        ; $02A1A7 | | BUG: The intent of this code appears to be to find the offset to
    STA <r_battle_generic_tmp_index                                             ; $02A1AB | |      the character HP tilemap data for the first non-empty
    TDC                                                                         ; $02A1AD | |      position. However, the positions are sorted in order, with
    SEP #FLAG_P_ACCUMULATOR                                                     ; $02A1AE | |      empty ones placed at the end. Therefore, the first non-empty
    LDA (<r_battle_generic_tmp_index)                                           ; $02A1B0 | |      position is always the first one.
    BNE +                                                                       ; $02A1B2 | |
    INX                                                                         ; $02A1B4 | |      Later code attempts to compensate by simply ignoring the read
    INX                                                                         ; $02A1B5 | |      bugged value (which seems to indicate some level of confusion
    BRA -                                                                       ; $02A1B6 | |      about position vs. slot when writing this), but unfortunately
+   LDA bugged_position_to_character_hp_offset_data.l,X                         ; $02A1B8 | |      the incorrect X register is retained and used, causing the
    LDA #$77.b                                                                  ; $02A1BC | |      small "HP" characters to shift horizontally depending on which
    STA r_battle_character_hp_tilemap_data.w + 4,X                              ; $02A1BE | |      position is the first non-empty one. In any case, this code
    INC A                                                                       ; $02A1C1 | |      ultimately writes the small "HP" letters to the tilemap data.
    STA r_battle_character_hp_tilemap_data.w + 6,X                              ; $02A1C2 |/
    RTS                                                                         ; $02A1C5

; bugged_position_to_character_hp_offset_data ($02:A1C6)
;
; BUG: This (probably unused) data appears to be intended to convert a character
;      position to an offset to that position's character HP tilemap data.
;      However, characters are sorted in position order, and not in slot order,
;      so the data here is completely incorrect, which is probably why it's
;      effectively unused in the preceding function.
bugged_position_to_character_hp_offset_data:
    .dw 36                                                                      ; $02A1C6.A1C7
    .dw 108                                                                     ; $02A1C8.A1C9
    .dw 0                                                                       ; $02A1CA.A1CB
    .dw 144                                                                     ; $02A1CC.A1CD
    .dw 72                                                                      ; $02A1CE.A1CF

; battle_index_slot_data ($02:A1D0)
;
; For each character battle position, contains the corresponding slot number for
; accessing character records.
battle_index_slot_data:
    .db 1                                                                       ; $02A1D0
    .db 3                                                                       ; $02A1D1
    .db 0                                                                       ; $02A1D2
    .db 4                                                                       ; $02A1D3
    .db 2                                                                       ; $02A1D4

; character_battle_offset_data ($02:A1D5)
;
; For each character battle position (numbered zero through four from top to
; bottom), provides the offset to that character's battle stats.
character_battle_offset_data:
    .addr r_character_battle.2                                                  ; $02A1D5.A1D6
    .addr r_character_battle.4                                                  ; $02A1D7.A1D8
    .addr r_character_battle.1                                                  ; $02A1D9.A1DA
    .addr r_character_battle.5                                                  ; $02A1DB.A1DC
    .addr r_character_battle.3                                                  ; $02A1DD.A1DE

; _battle_update_dialog_character_mp ($02:A1DF)
;
; Updates the tilemap data for character MP display.
_battle_update_dialog_character_mp:
    LDA #BATTLE_DIALOG_STAT_CHARACTER_MP.b                                      ; $02A1DF |\ Execute the entire character MP script and update the tilemap.
    JSR _battle_update_dialog_generic_stat                                      ; $02A1E1 |/
    TDC                                                                         ; $02A1E4 |\ Initialize the X register to zero.
    TAX                                                                         ; $02A1E5 |/
-   LDA battle_character_slot_mp_tilemap_offset_data.l,X                        ; $02A1E6 |\ Load the offset for this slot into the Y register.
    TAY                                                                         ; $02A1EA |/
    LDA #$DB.b                                                                  ; $02A1EB |\
    STA r_battle_character_mp_tilemap_data.w + 2,Y                              ; $02A1ED | | Add a BG2 "MP" to the first row of this character's tilemap data.
    INC A                                                                       ; $02A1F0 | |
    STA r_battle_character_mp_tilemap_data.w + 4,Y                              ; $02A1F1 | |
    INX                                                                         ; $02A1F4 |/
    CPX #5.w                                                                    ; $02A1F5 |\ Loop until all five characters have been handled.
    BNE -                                                                       ; $02A1F8 |/
    RTS                                                                         ; $02A1FA

; battle_position_to_slot_data ($02:A1FB)
;
; For each battle position (numbered from 0 through 4 from top to bottom) gives
; the character slot that matches that position.
battle_position_to_slot_data:
    .db 1                                                                       ; $02A1FB
    .db 3                                                                       ; $02A1FC
    .db 0                                                                       ; $02A1FD
    .db 4                                                                       ; $02A1FE
    .db 2                                                                       ; $02A1FF

; _battle_check_position_invisible ($02:A200)
;
; Given a character position in $04 (0 through 4 from top to bottom), sets the
; carry flag if that position is invisible and clears the carry flag if it is
; not.
_battle_check_position_invisible:
    PHX                                                                         ; $02A200 | Save the value of X.
    LDA <r_battle_check_position_invisible_arg                                  ; $02A201 |\
    TAX                                                                         ; $02A203 | | Convert the position index to a slot number and determine if
    LDA battle_position_to_slot_data.l,X                                        ; $02A204 | | that slot is invisible.
    TAX                                                                         ; $02A208 | |
    LDA r_battle_character_slot_invisible.w,X                                   ; $02A209 |/
    BEQ +                                                                       ; $02A20C |\
    PLX                                                                         ; $02A20E | | If the slot is not invisible, clear the carry flag and return.
    SEC                                                                         ; $02A20F | | Otherwise, set the carry flag and return.
    RTS                                                                         ; $02A210 | |
+   PLX                                                                         ; $02A211 | |
    CLC                                                                         ; $02A212 | |
    RTS                                                                         ; $02A213 |/

; _battle_update_dialog_character_names ($02:A214)
;
; Updates the battle character names tilemap area in RAM, changing the color to
; yellow for the active character (if any).
_battle_update_dialog_character_names:
    LDA #BATTLE_DIALOG_STAT_CHARACTER_NAMES                                     ; $02A214 |\ Load the correct parameters for character names to $EF50 to $EF55.
    JSR _battle_update_dialog_load_stat_offsets                                 ; $02A216 |/
    TDC                                                                         ; $02A219 |\
    TAY                                                                         ; $02A21A | | Zero out A, X, and Y.
    TAX                                                                         ; $02A21B |/
    STZ <r_battle_check_position_invisible_arg                                  ; $02A21C | Initialize the character battle position to zero.
    STZ <r_battle_update_dialog_empty_count                                     ; $02A21E | Initialze the empty slot counter to zero.
@start:
    PHX                                                                         ; $02A220 |\
    LDA <r_battle_check_position_invisible_arg                                  ; $02A221 | | Determine the offset to the in-battle character record for the
    REP #FLAG_P_ACCUMULATOR                                                     ; $02A223 | | current battle position and save it in a variable for later.
    ASL                                                                         ; $02A225 | |
    TAX                                                                         ; $02A226 | |
    LDA character_battle_offset_data.l,X                                        ; $02A227 | |
    STA <r_battle_generic_tmp_index                                             ; $02A22B | |
    TDC                                                                         ; $02A22D | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $02A22E | |
    PLX                                                                         ; $02A230 |/
    JSR _battle_check_position_invisible                                        ; $02A231 |\
    BCS @empty                                                                  ; $02A234 | | If this position is either empty or if the character is invisible,
    LDA (<r_battle_generic_tmp_index)                                           ; $02A236 | | branch to the code that handles empty slots.
    BEQ @empty                                                                  ; $02A238 |/
    LDA #BATTLE_DIALOG_OPCODE_SET_TILE_FLAGS                                    ; $02A23A |\
    STA r_battle_update_dialog_data.w,Y                                         ; $02A23C | | Write the first byte to set the tile flags.
    INY                                                                         ; $02A23F |/
    LDA <r_battle_current_action.manual_pending                                 ; $02A240 |\ If there is no currently active character, skip forward a bit.
    BEQ ++                                                                      ; $02A242 |/
    PHX                                                                         ; $02A244 |\
    LDA <r_battle_check_position_invisible_arg                                  ; $02A245 | | If the current position is the active character, set the palette
    TAX                                                                         ; $02A247 | | to use yellow text instead of white text by switching to BG3
    LDA battle_index_slot_data.l,X                                              ; $02A248 | | palette 2.
    CMP r_battle_last_active_character_slot.w                                   ; $02A24C | |
    BEQ +                                                                       ; $02A24F | |
    PLX                                                                         ; $02A251 | |
    BRA ++                                                                      ; $02A252 | |
+   PLX                                                                         ; $02A254 | |
    LDA #$08                                                                    ; $02A255 | |
    BRA +                                                                       ; $02A257 |/
++  LDA #$00                                                                    ; $02A259 | Otherwise, use palette zero as normal.
+   STA r_battle_update_dialog_data.w,Y                                         ; $02A25B |\ Store the byte as the updated tile flag value.
    INY                                                                         ; $02A25E |/
    LDA #3.b                                                                    ; $02A25F |\
    STA <r_battle_update_dialog_tmp_3                                           ; $02A261 | | Copy the three bytes of script data for this position that
-   LDA bank16.battle_dialog_character_name_script_data.l,X                     ; $02A263 | | automatically prints the character's name and moves to the next
    STA r_battle_update_dialog_data.w,Y                                         ; $02A267 | | line.
    INY                                                                         ; $02A26A | |
    INX                                                                         ; $02A26B | |
    DEC <r_battle_update_dialog_tmp_3                                           ; $02A26C | |
    BNE -                                                                       ; $02A26E |/
    BRA +                                                                       ; $02A270 | Skip ahead past the empty slot handling.
@empty:
    REP #FLAG_P_ACCUMULATOR                                                     ; $02A272 |\
    TXA                                                                         ; $02A274 | | If the slot is empty, increment the offset into the name script
    CLC                                                                         ; $02A275 | | data by three and increment the empty count.
    ADC #3.w                                                                    ; $02A276 | |
    TAX                                                                         ; $02A279 | |
    TDC                                                                         ; $02A27A | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $02A27B | |
    INC <r_battle_update_dialog_empty_count                                     ; $02A27D |/
+   INC <r_battle_check_position_invisible_arg                                  ; $02A27F |\
    LDA <r_battle_check_position_invisible_arg                                  ; $02A281 | | Increment the position and loop until all five positions have been
    CMP #5.b                                                                    ; $02A283 | | handled.
    BNE @start                                                                  ; $02A285 |/
    LDA <r_battle_update_dialog_empty_count                                     ; $02A287 |\
    BEQ +                                                                       ; $02A289 | | If there are any empty slots, loop through them, writing a blank
-   LDA #BATTLE_DIALOG_OPCODE_BLANKS.b                                          ; $02A28B | | line for each of them. Writing them at the end ensures that all
    STA r_battle_update_dialog_data.w,Y                                         ; $02A28D | | blank lines are consolidated at the end of the list.
    INY                                                                         ; $02A290 | |
    LDA #6.b                                                                    ; $02A291 | |
    STA r_battle_update_dialog_data.w,Y                                         ; $02A293 | |
    INY                                                                         ; $02A296 | |
    LDA #BATTLE_DIALOG_OPCODE_NEXT_LINE.b                                       ; $02A297 | |
    STA r_battle_update_dialog_data.w,Y                                         ; $02A299 | |
    INY                                                                         ; $02A29C | |
    DEC <r_battle_update_dialog_empty_count                                     ; $02A29D | |
    BNE -                                                                       ; $02A29F |/
+   TDC                                                                         ; $02A2A1 |\ Replace the last character of the script (a new line opcode) with
    STA r_battle_update_dialog_data.w - 1,Y                                     ; $02A2A2 |/ a zero to actually end the script instead.
    JSR _battle_update_dialog                                                   ; $02A2A5 | Update the dialog.
    RTS                                                                         ; $02A2A8

; _battle_update_hp_and_status_tilemap_data ($02:A2A9)
;
; Updates the BG3 HP and status tilemap area in RAM. It does not configure the
; DMA to transfer the data to VRAM.
_battle_update_hp_and_status_tilemap_data:
    LDX #r_battle_tilemap_bg3_info_area.w + 28                                  ; $02A2A9 |\ Set one index to the address of the character names and HP data as
    STX <r_battle_generic_tmp_index                                             ; $02A2AC |/ already stored elsewhere.
    LDX #r_battle_tilemap_bg3_hp_and_status.w + 4                               ; $02A2AE |\ Set another index to the destination address in the HP and status
    STX <r_battle_generic_tmp_index_2                                           ; $02A2B1 |/ tilemap area.
    REP #FLAG_P_ACCUMULATOR                                                     ; $02A2B3 |\
    LDA #13.w                                                                   ; $02A2B5 | | Set an index to loop through 13 lines.
    STA <r_battle_update_hp_and_status_tilemap_count                            ; $02A2B8 |/
--  LDA #16.w                                                                   ; $02A2BA |\ Initialize an index to loop through the 16 characters in a line.
    STA <r_battle_update_hp_and_status_tilemap_bytes                            ; $02A2BD |/
    LDY #0.w                                                                    ; $02A2BF | Initialize the Y register to zero.
-   LDA (<r_battle_generic_tmp_index),Y                                         ; $02A2C2 |\ Copy the source byte to the destination.
    STA (<r_battle_generic_tmp_index_2),Y                                       ; $02A2C4 |/
    INY                                                                         ; $02A2C6 |\ Increment the Y register twice to move to the next character
    INY                                                                         ; $02A2C7 |/ (ignoring the flags bytes).
    DEC <r_battle_update_hp_and_status_tilemap_bytes                            ; $02A2C8 |\ Loop until all 16 characters have been copied.
    BNE -                                                                       ; $02A2CA |/
    LDA <r_battle_generic_tmp_index                                             ; $02A2CC |\
    CLC                                                                         ; $02A2CE | | Add 64 to the two indexes to move to the next line.
    ADC #64.w                                                                   ; $02A2CF | |
    STA <r_battle_generic_tmp_index                                             ; $02A2D2 | |
    LDA <r_battle_generic_tmp_index_2                                           ; $02A2D4 | |
    CLC                                                                         ; $02A2D6 | |
    ADC #64.w                                                                   ; $02A2D7 | |
    STA <r_battle_generic_tmp_index_2                                           ; $02A2DA |/
    DEC <r_battle_update_hp_and_status_tilemap_count                            ; $02A2DC |\ Loop until all lines have been copied.
    BNE --                                                                      ; $02A2DE |/
    TDC                                                                         ; $02A2E0 |\
    SEP #FLAG_P_ACCUMULATOR                                                     ; $02A2E1 | | Update the status names themselves on the second half.
    JMP _battle_update_dialog_status_names                                      ; $02A2E3 |/

; status_name_enabled_data ($02:A2E6)
;
; For each status bit of the four status bytes, determines if that status has
; a printable name that should be displayed during battle.
status_name_enabled_data:
    .db %11111111                                                               ; $02A2E6
    .db %11111111                                                               ; $02A2E7
    .db %01000001                                                               ; $02A2E8
    .db %00110000                                                               ; $02A2E9

; _battle_update_dialog_status_names ($02:A2EA)
;
; Loops through the five character positions, updating the description of their
; current status effect in the BG3 tilemap data area in RAM. Does not schedule
; a DMA to actually update VRAM. Also makes sure all tiles in that segment have
; a priority of 1.
_battle_update_dialog_status_names:
    LDX #r_battle_tilemap_bg3_hp_and_status + 64 + 42.w                         ; $02A2EA |\ Set the target address to the location of the status names in the
    STX r_battle_update_dialog_arg_target.w                                     ; $02A2ED |/ BG3 tilemap data.
    TDC                                                                         ; $02A2F0 |\ Initialize the X register to zero.
    TAX                                                                         ; $02A2F1 |/
@start:
    PHX                                                                         ; $02A2F2 | Preserve the current value of the X register.
    LDA battle_index_slot_data.l,X                                              ; $02A2F3 |\
    TAY                                                                         ; $02A2F7 | | Check if the slot associated with this battle position has a
    LDA r_character_slot_if_active.w,Y                                          ; $02A2F8 | | character in it. If not, branch significantly forward to skip the
    CMP #$FF.b                                                                  ; $02A2FB | | status text handling.
    BNE +                                                                       ; $02A2FD | |
    JMP @empty_slot                                                             ; $02A2FF |/
+   TYA                                                                         ; $02A302 |\
    ASL A                                                                       ; $02A303 | | Multiply the Y register (the slot number) by four to index the
    ASL A                                                                       ; $02A304 | | visual status data.
    TAY                                                                         ; $02A305 |/
    TDC                                                                         ; $02A306 |\ Set the X register to zero.
    TAX                                                                         ; $02A307 |/
-   LDA r_character_visual_status.w,Y                                           ; $02A308 |\
    AND status_name_enabled_data.l,X                                            ; $02A30B | | For each of the four status bytes, mask out any bits that don't
    STA <r_battle_generic_tmp_index_lo,X                                        ; $02A30F | | have printable names and store the bytes in a temporary location.
    INY                                                                         ; $02A311 | |
    INX                                                                         ; $02A312 | |
    CPX #4.w                                                                    ; $02A313 | |
    BNE -                                                                       ; $02A316 |/
    TDC                                                                         ; $02A318 |\ Reset the X register to zero.
    TAX                                                                         ; $02A319 |/
-   ASL <r_battle_generic_tmp_index_lo + 3                                      ; $02A31A |\
    ROL <r_battle_generic_tmp_index_lo + 2                                      ; $02A31C | | Loop through the previously masked bits until the first one that
    ROL <r_battle_generic_tmp_index_lo + 1                                      ; $02A31E | | is set is found, leaving its index in the X register.
    ROL <r_battle_generic_tmp_index_lo + 0                                      ; $02A320 | |
    BCS +                                                                       ; $02A322 | |
    INX                                                                         ; $02A324 | |
    CPX #(4 * 8).w                                                              ; $02A325 | |
    BNE -                                                                       ; $02A328 |/
    LDY #0.w                                                                    ; $02A32A |\ If none is found, set the Y register to zero and branch forward to
    BRA @copy_blanks                                                            ; $02A32D |/ code that will write blanks.
+   TXA                                                                         ; $02A32F |\
    ASL A                                                                       ; $02A330 | | Multiply the X register by two to index the name pointers.
    TAX                                                                         ; $02A331 |/
    LDA bank0F.status_name_pointer_data.l + 0,X                                 ; $02A332 |\
    STA <r_battle_generic_tmp_index_lo                                          ; $02A336 | | Load the address of the name text for this status and store it in
    LDA bank0F.status_name_pointer_data.l + 1,X                                 ; $02A338 | | memory.
    STA <r_battle_generic_tmp_index_hi                                          ; $02A33C | |
    LDA #:bank0F.status_name_pointer_data.b                                     ; $02A33E | |
    STA <r_battle_generic_tmp_index_bank                                        ; $02A340 |/
    TDC                                                                         ; $02A342 |\ Set the Y register to zero.
    TAY                                                                         ; $02A343 |/
-   LDA [<r_battle_generic_tmp_index],Y                                         ; $02A344 |\
    BEQ @copy_blanks                                                            ; $02A346 | | Loop through up to eight characters, storing them in the dialog
    STA r_battle_update_dialog_data.w,Y                                         ; $02A348 | | update script area, aborting if a zero is found (as that signals
    INY                                                                         ; $02A34B | | the end of the name).
    CPY #8.w                                                                    ; $02A34C | |
    BNE -                                                                       ; $02A34F |/
@copy_blanks:
    CPY #8.w                                                                    ; $02A351 |\ If eight characters have already been copied, skip this next block
    BEQ +                                                                       ; $02A354 |/ of code.
    LDA #$FF.b                                                                  ; $02A356 |\
    STA r_battle_update_dialog_data.w,Y                                         ; $02A358 | | Copy blanks until a total of eight characters have been copied.
    INY                                                                         ; $02A35B | |
    BRA @copy_blanks                                                            ; $02A35C |/
+   TDC                                                                         ; $02A35E |\ Write a zero to end the dialog update script.
    STA r_battle_update_dialog_data.w,Y                                         ; $02A35F |/
    LDX #r_battle_update_dialog_data.w                                          ; $02A362 |\ Set the source address for the script.
    STX r_battle_update_dialog_arg_source.w                                     ; $02A365 |/
    LDA #32.b                                                                   ; $02A368 |\ Set the line length to 32.
    STA r_battle_update_dialog_arg_line_length.w                                ; $02A36A |/
    LDA #%00100000.b                                                            ; $02A36D |\ Set the default flags to set the tile priority to 1.
    STA r_battle_update_dialog_arg_flags.w                                      ; $02A36F |/
    JSR _battle_update_dialog                                                   ; $02A372 | Execute the update script to set the status name.
    REP #FLAG_P_ACCUMULATOR                                                     ; $02A375 |\
    LDA r_battle_update_dialog_arg_target.w                                     ; $02A377 | | Update the target address to move two lines down (to the next
    CLC                                                                         ; $02A37A | | slot).
    ADC #128.w                                                                  ; $02A37B | |
    STA r_battle_update_dialog_arg_target.w                                     ; $02A37E | |
    TDC                                                                         ; $02A381 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $02A382 |/
@empty_slot:
    PLX                                                                         ; $02A384 | Restore the current position to the X register.
    INX                                                                         ; $02A385 | Increment the position number.
    CPX #5.w                                                                    ; $02A386 |\
    BEQ +                                                                       ; $02A389 | | Loop until all five positions have been updated.
    JMP @start                                                                  ; $02A38B |/
+   REP #FLAG_P_ACCUMULATOR                                                     ; $02A38E |\
    TDC                                                                         ; $02A390 | | Set the X register to zero.
    TAX                                                                         ; $02A391 |/
-   LDA r_battle_tilemap_bg3_hp_and_status.w,X                                  ; $02A392 |\
    ORA #$2000.w                                                                ; $02A395 | | Loop through the entire HP and status tilemap, making sure each
    STA r_battle_tilemap_bg3_hp_and_status.w,X                                  ; $02A398 | | tile has a priority of 1.
    INX                                                                         ; $02A39B | |
    INX                                                                         ; $02A39C | |
    CPX #_sizeof_r_battle_tilemap_bg3_hp_and_status.w                           ; $02A39D | |
    BNE -                                                                       ; $02A3A0 |/
    TDC                                                                         ; $02A3A2 |\ Switch back to 8-bit mode.
    SEP #FLAG_P_ACCUMULATOR.b                                                   ; $02A3A3 |/
    RTS                                                                         ; $02A3A5

; _battle_update_dialog_monster_names ($02:A3A6)
;
; Updates the monster names and counts in the tilemap data in RAM. Seems to
; fully support up to four separate monster types, even though the game itself
; only uses three.
_battle_update_dialog_monster_names:
    TDC                                                                         ; $02A3A6 |\ Load the data into $EF50 through $EF55 suitable for updating
    JSR _battle_update_dialog_load_stat_offsets                                 ; $02A3A7 |/ monster names and counts.
    LDX #r_monster_ids_original.w                                               ; $02A3AA |\ Load the address for the monter IDs in each index to a temporary
    STX <r_battle_generic_tmp_index                                             ; $02A3AD |/ variable.
    LDX #r_monsters_remaining.w                                                 ; $02A3AF |\ Load the address for the remaining monster counts for each index to
    STX <r_battle_update_dialog_monster_names_index                             ; $02A3B2 |/ a temporary variable.
    TDC                                                                         ; $02A3B4 |\
    TAX                                                                         ; $02A3B5 | | Initialize the index registers to zero.
    TAY                                                                         ; $02A3B6 |/
    LDA #4.b                                                                    ; $02A3B7
    STA <r_battle_update_dialog_monster_names_tmp                               ; $02A3B9
    STZ <r_battle_update_dialog_empty_count                                     ; $02A3BB | Initialize the empty count to zero.
@start:
    LDA (<r_battle_generic_tmp_index)                                           ; $02A3BD |\
    CMP #MONSTER_NONE.b                                                         ; $02A3BF | | Skip ahead if the monster slot is empty or if the count of those
    BEQ +                                                                       ; $02A3C1 | | monsters is zero.
    LDA (<r_battle_update_dialog_monster_names_index)                           ; $02A3C3 | |
    BEQ +                                                                       ; $02A3C5 |/
    LDA #6.b                                                                    ; $02A3C7 |\
    STA <r_battle_update_dialog_tmp_3                                           ; $02A3C9 | | Copy the six bytes for this slot that contain the opcodes to print
-   LDA bank16.battle_dialog_monster_name_script_data.l,X                       ; $02A3CB | | the monster name and count.
    STA r_battle_update_dialog_data.w,Y                                         ; $02A3CF | |
    INY                                                                         ; $02A3D2 | |
    INX                                                                         ; $02A3D3 | |
    DEC <r_battle_update_dialog_tmp_3                                           ; $02A3D4 | |
    BNE -                                                                       ; $02A3D6 |/
    BRA ++                                                                      ; $02A3D8 |\
+   REP #FLAG_P_ACCUMULATOR                                                     ; $02A3DA | | If the slot was empty, add six to the opcode index to move to the
    TXA                                                                         ; $02A3DC | | next script and increment the empty count.
    CLC                                                                         ; $02A3DD | |
    ADC #6.w                                                                    ; $02A3DE | |
    TAX                                                                         ; $02A3E1 | |
    TDC                                                                         ; $02A3E2 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $02A3E3 | |
    INC <r_battle_update_dialog_empty_count                                     ; $02A3E5 |/
++  PHX                                                                         ; $02A3E7 |\
    LDX <r_battle_generic_tmp_index                                             ; $02A3E8 | | Increment the two indexes to move to the next monster index.
    INX                                                                         ; $02A3EA | |
    STX <r_battle_generic_tmp_index                                             ; $02A3EB | |
    LDX <r_battle_update_dialog_monster_names_index                             ; $02A3ED | |
    INX                                                                         ; $02A3EF | |
    STX <r_battle_update_dialog_monster_names_index                             ; $02A3F0 | |
    PLX                                                                         ; $02A3F2 |/
    DEC <r_battle_update_dialog_monster_names_tmp                               ; $02A3F3 |\ Loop until all four slots have been considered.
    BNE @start                                                                  ; $02A3F5 |/
    LDA <r_battle_update_dialog_empty_count                                     ; $02A3F7 |\
    BEQ +                                                                       ; $02A3F9 | | For each empty slot, write ten blanks and a next line opcode.
-   LDA #BATTLE_DIALOG_OPCODE_BLANKS.b                                          ; $02A3FB | |
    STA r_battle_update_dialog_data.w,Y                                         ; $02A3FD | |
    INY                                                                         ; $02A400 | |
    LDA #10.b                                                                   ; $02A401 | |
    STA r_battle_update_dialog_data.w,Y                                         ; $02A403 | |
    INY                                                                         ; $02A406 | |
    LDA #BATTLE_DIALOG_OPCODE_NEXT_LINE.b                                       ; $02A407 | |
    STA r_battle_update_dialog_data.w,Y                                         ; $02A409 | |
    INY                                                                         ; $02A40C | |
    DEC <r_battle_update_dialog_empty_count                                     ; $02A40D | |
    BNE -                                                                       ; $02A40F |/
+   TDC                                                                         ; $02A411 |\ Replace the last next line opcode with a zero to end the script.
    STA r_battle_update_dialog_data.w - 1,Y                                     ; $02A412 |/
    JSR _battle_update_dialog                                                   ; $02A415 | Actually update the tilemap data by executing the script.
    RTS                                                                         ; $02A418

; _battle_update_dialog_load_stat_offsets ($02:A419)
;
; Based on the value in the accumulator, loads six bytes determining the
; addresses, line length, and default tile flags for updating one of four
; segments of the battle dialog tilemap (monster names, character names,
; character HP and character MP). The six bytes are stored in $EF50 through
; $EF55, which serve as parameters for other dialog update functions.
_battle_update_dialog_load_stat_offsets:
    PHA                                                                         ; $02A419 | Save the accumulator value.
    STA r_math_multiply_8bit_arg_1                                              ; $02A41A |\
    LDA #6.b                                                                    ; $02A41C | | Multiply the value in A by 6, and
    STA r_math_multiply_8bit_arg_2                                              ; $02A41E | | then transfer it to X.
    JSR _math_multiply_8bit                                                     ; $02A420 | |
    LDX r_math_multiply_8bit_result                                             ; $02A423 |/
    TDC                                                                         ; $02A425 |\ Zero out the accumulator and Y.
    TAY                                                                         ; $02A426 |/
-   LDA bank16.battle_dialog_stat_offset_data.l,X                               ; $02A427 |\
    STA r_battle_update_dialog_arg_source.w,Y                                   ; $02A42B | | Copy the data to the correct location in RAM to serve as
    INY                                                                         ; $02A42E | | parameters to other routines.
    INX                                                                         ; $02A42F | |
    CPY #6.w                                                                    ; $02A430 | |
    BNE -                                                                       ; $02A433 |/
    PLA                                                                         ; $02A435 | Restore the accumulator value.
    RTS                                                                         ; $02A436

; _battle_update_dialog_generic_stat ($02:A437)
;
; Given one of the four battle dialog stats (monster names, character names,
; character HP and character MP) indexes in the accumulator, loads the script
; data associated with that stat and executes the script. Note that this does
; no special processing, so probably doesn't work as expected for anything
; except MP, which is the only one that is never drawn to screen as a unit.
_battle_update_dialog_generic_stat:
    JSR _battle_update_dialog_load_stat_offsets                                 ; $02A437 | Load the data into $EF50 through $EF55 for this parameter.
    ASL A                                                                       ; $02A43A |\
    TAX                                                                         ; $02A43B | | Load the offset to the associated script data for this stat.
    LDA bank16.battle_dialog_stat_script_offset_data.l + 0,X                    ; $02A43C | |
    STA <r_battle_generic_tmp_index_lo                                          ; $02A440 | |
    LDA bank16.battle_dialog_stat_script_offset_data.l + 1,X                    ; $02A442 | |
    STA <r_battle_generic_tmp_index_hi                                          ; $02A446 |/
    LDA #22.b                                                                   ; $02A448 |\ Store 22 in a variable for seemingly no reason.
    STA <r_battle_update_dialog_tmp_3                                           ; $02A44A |/
    TDC                                                                         ; $02A44C |\
    TAY                                                                         ; $02A44D | | Copy up to 32 bytes of script data to the script area in RAM.
-   LDA [<r_battle_generic_tmp_index],Y                                         ; $02A44E | |
    STA r_battle_update_dialog_data.w,Y                                         ; $02A450 | |
    INY                                                                         ; $02A453 | |
    CPY #32.w                                                                   ; $02A454 | |
    BNE -                                                                       ; $02A457 |/
    JSR _battle_update_dialog                                                   ; $02A459 | Execute the actual script.
    RTS                                                                         ; $02A45C

; _battle_update_dialog ($02:A45D)
;
; Calculates and transfers data depending on the arguments from a source
; location to a target location, formatting the result in tile numbers and flags
; suitable for direct transfer to VRAM. The 16-bit source address is passed in
; $EF50. The 16-bit target address is passed in $EF52. The length of each line
; or entry is passed in $EF54. Finally, the initial value for the flags variable
; can be passed in $EF55.
_battle_update_dialog:
    LDA r_battle_update_dialog_arg_flags.w                                      ; $02A45D |\ Copy the flags argument into a local flags variable.
    STA <r_battle_update_dialog_flags                                           ; $02A460 |/
    ASL r_battle_update_dialog_arg_line_length.w                                ; $02A462 | Multiply the line length by two (two bytes per tile).
    LDX r_battle_update_dialog_arg_source.w                                     ; $02A465 |\ Copy the source pointer to a local variable.
    STX <r_battle_update_dialog_source_ptr                                      ; $02A468 |/
    LDX r_battle_update_dialog_arg_target.w                                     ; $02A46A |\ Load the target pointer and use it to set the pointer to the blank
    STX <r_battle_update_dialog_target_diacritic_ptr                            ; $02A46D |/ row.
    LDA <r_battle_update_dialog_target_diacritic_ptr_lo                         ; $02A46F |\
    CLC                                                                         ; $02A471 | | Add the line length in bytes to the blank pointer to determine the
    ADC r_battle_update_dialog_arg_line_length.w                                ; $02A472 | | pointer to the actual desired target data.
    STA <r_battle_update_dialog_target_ptr_lo                                   ; $02A475 | |
    LDA <r_battle_update_dialog_target_diacritic_ptr_hi                         ; $02A477 | |
    ADC #0.b                                                                    ; $02A479 | |
    STA <r_battle_update_dialog_target_ptr_hi                                   ; $02A47B |/
    LDY #0.w                                                                    ; $02A47D | Initialize the Y register to zero, which indexes the target data.
-   LDA (<r_battle_update_dialog_source_ptr)                                    ; $02A480 | Read the next value.
    BEQ ++                                                                      ; $02A482 | Return if the value is zero.
    CMP #BATTLE_DIALOG_OPCODE_FIRST_DIRECT.b                                    ; $02A484 |\
    BCC +                                                                       ; $02A486 | | If the value is $0F or greater, directly copy the value to the
    JSR _battle_update_dialog_update_target_tile                                ; $02A488 | | target location as a tile index, setting the flags according to
    JSR _battle_update_dialog_increment_source_ptr                              ; $02A48B | | the flags variable.
    BRA -                                                                       ; $02A48E |/
+   JSR _battle_update_dialog_dispatch_opcode                                   ; $02A490 |\
    JSR _battle_update_dialog_increment_source_ptr                              ; $02A493 | | Otherwise, call a function to dispatch to the correct handler.
    BRA -                                                                       ; $02A496 |/
++  RTS                                                                         ; $02A498

; _battle_update_dialog_increment_source_ptr ($02:A499)
;
; Increments the battle dialog update function's source pointer at $30 by one.
_battle_update_dialog_increment_source_ptr:
    LDX <r_battle_update_dialog_source_ptr                                      ; $02A499 |\
    INX                                                                         ; $02A49B | | Increment the source pointer.
    STX <r_battle_update_dialog_source_ptr                                      ; $02A49C |/
    RTS                                                                         ; $02A49E

; _battle_update_dialog_update_target_tile ($02:A49F)
;
; Meant to be used as part of the battle dialog update functions, updates the
; current tile pointed to by the Y register and the base pointers in $32 and $34
; with the value in the accumulator (for $34) and a blank tile (for $32).
; Additionally, the next byte is set to the current value of the flags variable
; in $36. The Japanese version uses the pointer at $32 for diacritics. The
; _non_diacritic variant explicitly bypasses the check for a diacritic
; character. In the USA version, the two entry points are identical.
_battle_update_dialog_update_target_tile:
.if FF4_REGION == "JAPAN"
    CMP #TILE_MENU_NON_DIACRITIC_BASE.b                                         ; $02A497 |\ If the character is in the diacritic range, branch to the handling
    BCC __battle_update_dialog_update_target_tile_diacritic                     ; $02A499 |/ code.
.endif
_battle_update_dialog_update_target_tile_non_diacritic:
    PHX                                                                         ; $02A49F | Preserve the value of the X register.
    STA (<r_battle_update_dialog_target_ptr),Y                                  ; $02A4A0 | Store the value in the accumulator at the target location.
    LDA #TEXT_SPACE.b                                                           ; $02A4A2 |\ Store a blank tile at the equivalent location in the associated
    STA (<r_battle_update_dialog_target_diacritic_ptr),Y                        ; $02A4A4 |/ diacritic line.
    INY                                                                         ; $02A4A6 | Increment the Y register to move to the flags byte.
    LDA <r_battle_update_dialog_flags                                           ; $02A4A7 |\
    STA (<r_battle_update_dialog_target_diacritic_ptr),Y                        ; $02A4A9 | | Load the current flags byte and store it to both locations.
    STA (<r_battle_update_dialog_target_ptr),Y                                  ; $02A4AB |/
    INY                                                                         ; $02A4AD | Increment the Y register to move to the next tile byte.
    PLX                                                                         ; $02A4AE | Restore the value of the X register.
    RTS                                                                         ; $02A4AF
__battle_update_dialog_update_target_tile_diacritic:
    PHX                                                                         ; $02A4B0 | Preserve the value of the X register.
    SEC                                                                         ; $02A4B1 |\
    SBC #DIALOG_OPCODE_FIRST_DIACRITIC.b                                        ; $02A4B2 | | Set the X register to the correct value for the passed character.
    ASL A                                                                       ; $02A4B4 | |
    TAX                                                                         ; $02A4B5 |/
    LDA bank16.dialog_diacritic_data.l + 0,X                                    ; $02A4B6 |\
    STA (<r_battle_update_dialog_target_diacritic_ptr),Y                        ; $02A4BA | | Write the two rows of text.
    LDA bank16.dialog_diacritic_data.l + 1,X                                    ; $02A4BC | |
    STA (<r_battle_update_dialog_target_ptr),Y                                  ; $02A4C0 |/
    INY                                                                         ; $02A4C2 |\
    LDA <r_battle_update_dialog_flags                                           ; $02A4C3 | | Set the flags for the two tiles.
    STA (<r_battle_update_dialog_target_diacritic_ptr),Y                        ; $02A4C5 | |
    STA (<r_battle_update_dialog_target_ptr),Y                                  ; $02A4C7 | |
    INY                                                                         ; $02A4C9 |/
    PLX                                                                         ; $02A4CA | Restore the X register.
    RTS                                                                         ; $02A4CB

; battle_update_dialog_opcode_pointer_data ($02:A4CC)
;
; For each battle dialog opcode, provides a pointer to the code to handle that
; opcode.
battle_update_dialog_opcode_pointer_data:
    .addr _battle_update_dialog_opcode_end                                      ; $02A4CC | $00: No action
    .addr _battle_update_dialog_opcode_next_line                                ; $02A4CE | $01: Next line
    .addr _battle_update_dialog_opcode_character_slot_name                      ; $02A4D0 | $02: Name of character in given slot
    .addr _battle_update_dialog_opcode_tile                                     ; $02A4D2 | $03: Tile
    .addr _battle_update_dialog_opcode_character_name                           ; $02A4D4 | $04: Name of character
    .addr _battle_update_dialog_opcode_blanks                                   ; $02A4D6 | $05: Blank tiles
    .addr _battle_update_dialog_opcode_extended                                 ; $02A4D8 | $06: Various miscellaneous opcodes
    .addr _battle_update_dialog_opcode_character_stat_slot_0                    ; $02A4DA | $07: Character stats (slot 0)
    .addr _battle_update_dialog_opcode_character_stat_slot_1                    ; $02A4DC | $08: Character stats (slot 1)
    .addr _battle_update_dialog_opcode_character_stat_slot_2                    ; $02A4DE | $09: Character stats (slot 2)
    .addr _battle_update_dialog_opcode_character_stat_slot_3                    ; $02A4E0 | $0A: Character stats (slot 3)
    .addr _battle_update_dialog_opcode_character_stat_slot_4                    ; $02A4E2 | $0B: Character stats (slot 4)
    .addr _battle_update_dialog_opcode_monster_name                             ; $02A4E4 | $0C: Monster name
    .addr _battle_update_dialog_opcode_monster_count                            ; $02A4E6 | $0D: Monster count
    .addr _battle_update_dialog_opcode_set_tile_flags                           ; $02A4E8 | $0E: Set tile flags

; _battle_update_dialog_opcode_extended ($02:A4EA)
;
; This opcode allows for several extended modes. Any optional parameters for
; these opcodes are taken from $359A through $359F. The actual behavior is
; determined by the byte following the extended opcode:
;
; $00 to $7F: Nothing
; $80: Prints the 24-bit number in $359A to $359C.
; $81: Prints the 24-bit number in $359D to $359F.
; $82: Prints the name of the character in the slot in $359A.
; $83: Prints the item name (except the first character) of the ID in $359A.
; $84: Prints the spell name for the ID in $359A.
; $85 through $FF: Prints the name of the status for the bit in $359A, numbered
;                  with zero being the highest bit of the first status byte.
_battle_update_dialog_opcode_extended:
    JSR _battle_update_dialog_increment_source_ptr                              ; $02A4EA |\ Load the next byte.
    LDA (<r_battle_update_dialog_source_ptr)                                    ; $02A4ED |/
    BMI +                                                                       ; $02A4EF |\ Return if the highest bit is not set.
    RTS                                                                         ; $02A4F1 |/
+   AND #%01111111.b                                                            ; $02A4F2 |\
    BNE +                                                                       ; $02A4F4 | | If the value is $80, print the number in the first location.
    LDX #0.w                                                                    ; $02A4F6 | |
    JMP _battle_update_dialog_opcode_extended_number                            ; $02A4F9 |/
+   CMP #BATTLE_DIALOG_OPCODE_EXTENDED_NUMBER_2.b                               ; $02A4FC |\
    BNE +                                                                       ; $02A4FE | | If the value is $81, print the number in the second location.
    LDX #3.w                                                                    ; $02A500 | |
    JMP _battle_update_dialog_opcode_extended_number                            ; $02A503 |/
+   CMP #BATTLE_DIALOG_OPCODE_EXTENDED_CHARACTER_NAME.b                         ; $02A506 |\
    BNE +                                                                       ; $02A508 | | If the value is $82, print the name of a character.
    JMP _battle_update_dialog_opcode_extended_character_name                    ; $02A50A |/
+   CMP #BATTLE_DIALOG_OPCODE_EXTENDED_ITEM_NAME.b                              ; $02A50D |\
    BNE +                                                                       ; $02A50F | | If the value is $83, print an item name.
    JMP _battle_update_dialog_opcode_extended_item_name                         ; $02A511 |/
+   CMP #BATTLE_DIALOG_OPCODE_EXTENDED_SPELL_NAME.b                             ; $02A514 |\
    BNE +                                                                       ; $02A516 | | If the value is $84, print a spell name.
    JMP _battle_update_dialog_opcode_extended_spell_name                        ; $02A518 |/
+   LDA r_battle_update_dialog_extra_arg_1_lo.w                                 ; $02A51B |\
    ASL A                                                                       ; $02A51E | | For all other values, read a value and multiply by two.
    TAX                                                                         ; $02A51F |/
    LDA bank0F.status_name_pointer_data.l,X                                     ; $02A520 |\
    STA <r_battle_generic_tmp_index_lo                                          ; $02A524 | | Read the pointer data for the status referenced by the variable.
    LDA bank0F.status_name_pointer_data.l + 1,X                                 ; $02A526 | |
    STA <r_battle_generic_tmp_index_hi                                          ; $02A52A |/
    LDA #:bank0F.status_name_pointer_data.b                                     ; $02A52C |\ Explicitly set the bank to the same bank as the pointer data.
    STA <r_battle_generic_tmp_index_bank                                        ; $02A52E |/
-   LDA [<r_battle_generic_tmp_index]                                           ; $02A530 |\
    BEQ +                                                                       ; $02A532 | | Copy characters until a $00 is encountered.
    JSR _battle_update_dialog_update_target_tile                                ; $02A534 | |
    LDX <r_battle_generic_tmp_index                                             ; $02A537 | |
    INX                                                                         ; $02A539 | |
    STX <r_battle_generic_tmp_index                                             ; $02A53A | |
    BRA -                                                                       ; $02A53C |/
+   RTS                                                                         ; $02A53E

; _battle_update_dialog_opcode_extended_spell_name ($02:A53F)
;
; This extended opcode prints a spell name.
_battle_update_dialog_opcode_extended_spell_name:
    LDA r_battle_update_dialog_extra_arg_1_lo.w                                 ; $02A53F |\
    CMP #SPELL_FIRST_LONG_NAME.b                                                ; $02A542 | | Load the spell number and branch to the appropriate code.
    BCC ++                                                                      ; $02A544 |/
    SEC                                                                         ; $02A546 |\
    SBC #SPELL_FIRST_LONG_NAME.b                                                ; $02A547 | | If the spell has a long name (index $48 or higher), subtract $48
    STA <r_math_multiply_8bit_arg_1                                             ; $02A549 | | and multiply the resulting index by 8 to determine the offset into
    LDA #8.b                                                                    ; $02A54B | | the name data.
    STA <r_math_multiply_8bit_arg_2                                             ; $02A54D | |
    JSR _math_multiply_8bit                                                     ; $02A54F | |
    LDX <r_math_multiply_8bit_result                                            ; $02A552 |/
    LDA #8.b                                                                    ; $02A554 |\
    STA <r_battle_generic_tmp_index_lo                                          ; $02A556 | | Loop until all eight characters of the name are copied or a blank
-   LDA bank0F.spell_name_long_data.l,X                                         ; $02A558 | | tile is encountered.
    CMP #$FF.b                                                                  ; $02A55C | |
    BEQ +                                                                       ; $02A55E | |
    JSR _battle_update_dialog_update_target_tile                                ; $02A560 | |
    INX                                                                         ; $02A563 | |
    DEC <r_battle_generic_tmp_index_lo                                          ; $02A564 | |
    BNE -                                                                       ; $02A566 |/
+   RTS                                                                         ; $02A568
++  STA <r_math_multiply_8bit_arg_1                                             ; $02A569 |\
    LDA #6.b                                                                    ; $02A56B | | If the spell has a short name, multiply the index by six to
    STA <r_math_multiply_8bit_arg_2                                             ; $02A56D | | determine the correct offset.
    JSR _math_multiply_8bit                                                     ; $02A56F | |
.if FF4_REGION == "JAPAN"                                                       ;         | | NOTE: For some reason, the Japanese version initializes Y to zero
    LDY #0.w                                                                    ; $02A56E | |       here.
.endif                                                                          ;         | |
    LDX <r_math_multiply_8bit_result                                            ; $02A572 |/
    LDA bank0F.spell_name_short_data.l,X                                        ; $02A574 |\ Read the first character and copy it over.
    JSR _battle_update_dialog_update_target_tile_non_diacritic                  ; $02A578 |/
    LDA #5.b                                                                    ; $02A57B |\
    STA <r_battle_generic_tmp_index_lo                                          ; $02A57D | | Loop until either the remaining five characters are copied or a
-   LDA bank0F.spell_name_short_data.l + 1,X                                    ; $02A57F | | blank tile is encountered.
    CMP #$FF.b                                                                  ; $02A583 | |
    BEQ +                                                                       ; $02A585 | |
    JSR _battle_update_dialog_update_target_tile                                ; $02A587 | |
    INX                                                                         ; $02A58A | |
    DEC <r_battle_generic_tmp_index_lo                                          ; $02A58B | |
    BNE -                                                                       ; $02A58D |/
+   RTS                                                                         ; $02A58F

; _battle_update_dialog_opcode_extended_item_name ($02:A590)
;
; This extended opcode prints the item name referenced by the ID in $359A. The
; first character (an icon or blank) will be ignored.
_battle_update_dialog_opcode_extended_item_name:
    LDA r_battle_update_dialog_extra_arg_1_lo.w                                 ; $02A590 |\
    STA <r_math_multiply_8bit_arg_1                                             ; $02A593 | | Read the extra parameter and multiply by 9 to determine the offset
    LDA #9.b                                                                    ; $02A595 | | into the item names data.
    STA <r_math_multiply_8bit_arg_2                                             ; $02A597 | |
    JSR _math_multiply_8bit                                                     ; $02A599 |/
.if FF4_REGION == "JAPAN"
    LDY #0.w                                                                    ; $02A59B | Initialize the Y register to zero for some reason.
.endif
    LDX <r_math_multiply_8bit_result                                            ; $02A59C | Load the multiplication result into the X register.
    INX                                                                         ; $02A59E | Increment the index to skip any potential icon in the name.
    LDA #8.b                                                                    ; $02A59F |\ Initialize the index to copy eight characters.
    STA <r_battle_generic_tmp_index_lo                                          ; $02A5A1 |/
-   LDA bank0F.item_name_data.l,X                                               ; $02A5A3 |\
    CMP #$FF.b                                                                  ; $02A5A7 | | Loop through the item name copying bytes until either a blank tile
    BEQ +                                                                       ; $02A5A9 | | is encountered or all eight characters are copied.
    JSR _battle_update_dialog_update_target_tile                                ; $02A5AB | |
    INX                                                                         ; $02A5AE | |
    DEC <r_battle_generic_tmp_index_lo                                          ; $02A5AF | |
    BNE -                                                                       ; $02A5B1 |/
+   RTS                                                                         ; $02A5B3

; _battle_update_dialog_opcode_extended_character_name ($02:A5B4)
;
; This extended opcode prints the character name for the slot in $359A, ignoring
; any blanks at the end of the name.
_battle_update_dialog_opcode_extended_character_name:
    LDA r_battle_update_dialog_extra_arg_1_lo.w                                 ; $02A5B4 |\
    REP #FLAG_P_ACCUMULATOR                                                     ; $02A5B7 | | Read the extra argument byte, intepret it as a character slot,
    ASL A                                                                       ; $02A5B9 | | and multiply by 128 to determine the offset into the in-battle
    ASL A                                                                       ; $02A5BA | | character records.
    ASL A                                                                       ; $02A5BB | |
    ASL A                                                                       ; $02A5BC | |
    ASL A                                                                       ; $02A5BD | |
    ASL A                                                                       ; $02A5BE | |
    ASL A                                                                       ; $02A5BF | |
    TAX                                                                         ; $02A5C0 | |
    TDC                                                                         ; $02A5C1 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $02A5C2 |/
    LDA r_character_battle.1.id.w,X                                             ; $02A5C4 |\
    DEC A                                                                       ; $02A5C7 | | Read the character's ID and map it to the correct name index.
    AND #%00111111.b                                                            ; $02A5C8 | | Next, we fall through to the next function which actually
    TAX                                                                         ; $02A5CA | | reads that name and copies it into the destination.
    LDA bank16.character_id_to_name_index_data.l,X                              ; $02A5CB |/

; _battle_update_dialog_opcode_character_name_actual ($02:A5CF)
;
; This opcode copies the specified character name, ignoring any blanks at the
; end of the name.
_battle_update_dialog_opcode_character_name_actual:
    STA <r_math_multiply_8bit_arg_1                                             ; $02A5CF |\
    LDA #_sizeof_character_name.b                                               ; $02A5D1 | | Determine the offset into the name data by multiplying the value
    STA <r_math_multiply_8bit_arg_2                                             ; $02A5D3 | | in the accumulator by the length of a name.
    JSR _math_multiply_8bit                                                     ; $02A5D5 |/
    LDA #_sizeof_character_name.b                                               ; $02A5D8 |\ Save the length of a name into the index variable.
    STA <r_battle_generic_tmp_index_lo                                          ; $02A5DA |/
    LDX <r_math_multiply_8bit_result                                            ; $02A5DC |\
    INX                                                                         ; $02A5DE | | Load the name offset and then add 5 to move to the last character.
    INX                                                                         ; $02A5DF | |
    INX                                                                         ; $02A5E0 | |
    INX                                                                         ; $02A5E1 | |
    INX                                                                         ; $02A5E2 |/
-   LDA r_character_names.w,X                                                   ; $02A5E3 |\
    CMP #$FF.b                                                                  ; $02A5E6 | | Loop backwards through the name until either a non-blank tile is
    BNE +                                                                       ; $02A5E8 | | found or the first character is reached, reducing the count each
    DEX                                                                         ; $02A5EA | | time. This leaves the length of the name in the index.
    DEC <r_battle_generic_tmp_index_lo                                          ; $02A5EB | |
    LDA <r_battle_generic_tmp_index_lo                                          ; $02A5ED | |
    CMP #1.b                                                                    ; $02A5EF | |
    BNE -                                                                       ; $02A5F1 |/
+   LDX <r_math_multiply_8bit_result                                            ; $02A5F3 | Reload the offset into the name data.
-   LDA r_character_names.w,X                                                   ; $02A5F5 |\
    JSR _battle_update_dialog_update_target_tile                                ; $02A5F8 | | Copy characters until the full name has been copied, ignoring any
    INX                                                                         ; $02A5FB | | blanks at the end.
    DEC <r_battle_generic_tmp_index_lo                                          ; $02A5FC | |
    BNE -                                                                       ; $02A5FE |/
    RTS                                                                         ; $02A600

; _battle_update_dialog_opcode_extended_number ($02:A601)
;
; This opcode will read and copy the 24-bit number stored at $359A, indexed by
; the X register. In practice, a value of zero is used to print the dropped GP
; value, and a value of 3 is used to print the earned experience points for the
; battle. The number will be printed in decimal format.
_battle_update_dialog_opcode_extended_number:
    LDA r_battle_update_dialog_extra_arg_1_lo.w,X                               ; $02A601 |\
    STA <r_battle_format_number_long_arg_lo                                     ; $02A604 | | Read the desired value and write it to the number formatter's
    LDA r_battle_update_dialog_extra_arg_1_md.w,X                               ; $02A606 | | argument variable. Note that if X is zero, the dropped GP location
    STA <r_battle_format_number_long_arg_md                                     ; $02A609 | | will be read, but if X is 3, the earned experience variable will
    LDA r_battle_update_dialog_extra_arg_1_hi.w,X                               ; $02A60B | | be read instead, as typically used.
    STA <r_battle_format_number_long_arg_hi                                     ; $02A60E |/
    JSL bank03.battle_format_number_long                                        ; $02A610 | Convert the requested number into decimal format.
    JSR _battle_render_number_long                                              ; $02A614 | Set the X register to the value of the first non-zero digit.
-   LDA r_battle_format_number_long_result.w,X                                  ; $02A617 |\
    JSR _battle_update_dialog_update_target_tile_non_diacritic                  ; $02A61A | | Loop through the digits, copying them to the destination.
    INX                                                                         ; $02A61D | |
    CPX #_sizeof_r_battle_format_number_long_result.w                           ; $02A61E | |
    BNE -                                                                       ; $02A621 |/
    RTS                                                                         ; $02A623

; _battle_update_dialog_dispatch_opcode ($02:A624)
;
; Given a battle dialog opcode in the accumulator, dispatches to the correct
; handler for that opcode.
_battle_update_dialog_dispatch_opcode:
    ASL                                                                         ; $02A624 |\ Multiply the opcode value in the accumulator by two to determine
    TAX                                                                         ; $02A625 |/ the offset in the jump table.
    LDA battle_update_dialog_opcode_pointer_data.l,X                            ; $02A626 |\
    STA <r_battle_generic_tmp_index_lo                                          ; $02A62A | | Copy the pointer data to a temporary variable.
    LDA battle_update_dialog_opcode_pointer_data.l + 1,X                        ; $02A62C | |
    STA <r_battle_generic_tmp_index_hi                                          ; $02A630 |/
    JMP (r_battle_generic_tmp_index.w)                                          ; $02A632 | Jump to the function at the pointer location.

; _battle_update_dialog_opcode_next_line ($02:A635)
;
; This opcode handler updates the battle dialog update pointers to move to the
; next line in the data. The existing line is not modified and the horizontal
; position is not changed, so it literally moved down one line in position.
_battle_update_dialog_opcode_next_line:
    LDA r_battle_update_dialog_arg_line_length.w                                ; $02A635 |\
    REP #FLAG_P_ACCUMULATOR                                                     ; $02A638 | | Read the line length in bytes and multiply by two again, to get
    PHA                                                                         ; $02A63A | | the offset to move to the next true line.
    ASL A                                                                       ; $02A63B |/
    CLC                                                                         ; $02A63C |\
    ADC <r_battle_update_dialog_target_diacritic_ptr                            ; $02A63D | | Update the blank pointer to move to the next blank line.
    STA <r_battle_update_dialog_target_diacritic_ptr                            ; $02A63F |/
    PLA                                                                         ; $02A641 |\
    CLC                                                                         ; $02A642 | | Load the original line length and add that to the blank pointer to
    ADC <r_battle_update_dialog_target_diacritic_ptr                            ; $02A643 | | determine the new target pointer.
    STA <r_battle_update_dialog_target_ptr                                      ; $02A645 |/
    TDC                                                                         ; $02A647 |\
    TAY                                                                         ; $02A648 | | Reset the Y register to zero.
    SEP #FLAG_P_ACCUMULATOR                                                     ; $02A649 |/
    RTS                                                                         ; $02A64B

; _battle_update_dialog_opcode_end ($02:A64C)
;
; This opcode handler, which is probably never actually called, simply returns
; as it does nothing. This value is only used at the end of the sequence to end
; the execution.
_battle_update_dialog_opcode_end:
    RTS                                                                         ; $02A64C

; _battle_update_dialog_opcode_character_name ($02:A64D)
;
; This opcode copies the specified character name to the target, ignoring any
; blanks at the end of the name.
_battle_update_dialog_opcode_character_name:
    JSR _battle_update_dialog_increment_source_ptr                              ; $02A64D
    LDA (<r_battle_update_dialog_source_ptr)                                    ; $02A650
    JMP _battle_update_dialog_opcode_character_name_actual                      ; $02A652

; _battle_update_dialog_opcode_character_slot_name ($02:A655)
;
; This opcode writes the name of the character in a given slot to the target
; area. There are two entry points. The first assumes it needs to read the slot
; number from the dialog update source data, and the second requires the slot
; in the accumulator already.
_battle_update_dialog_opcode_character_slot_name:
    JSR _battle_update_dialog_increment_source_ptr                              ; $02A655 |\ Read the next byte, which serves as the desired character slot.
    LDA (<r_battle_update_dialog_source_ptr)                                    ; $02A658 |/
_battle_update_dialog_opcode_character_slot_name_accumulator:
    PHA                                                                         ; $02A65A | Preserve the value for later.
    TAX                                                                         ; $02A65B |\
    LDA r_character_slot_if_active.w,X                                          ; $02A65C | | Determine if this character slot has a character in it.
    CMP #$FF.b                                                                  ; $02A65F | |
    BNE +                                                                       ; $02A661 |/
    LDX #_sizeof_character_name.w                                               ; $02A663 |\
-   LDA #$FF.b                                                                  ; $02A666 | | If it doesn't, write six blank tiles to the target location.
    JSR _battle_update_dialog_update_target_tile                                ; $02A668 | |
    DEX                                                                         ; $02A66B | |
    BNE -                                                                       ; $02A66C |/
    PLA                                                                         ; $02A66E |\ Restore the read byte, and return.
    RTS                                                                         ; $02A66F |/
+   PLA                                                                         ; $02A670 |\
    REP #FLAG_P_ACCUMULATOR                                                     ; $02A671 | | If the character slot is filled, multiply the slot by 128 to get
    ASL A                                                                       ; $02A673 | | the offset into the in-battle character records.
    ASL A                                                                       ; $02A674 | |
    ASL A                                                                       ; $02A675 | |
    ASL A                                                                       ; $02A676 | |
    ASL A                                                                       ; $02A677 | |
    ASL A                                                                       ; $02A678 | |
    ASL A                                                                       ; $02A679 | |
    TAX                                                                         ; $02A67A | |
    TDC                                                                         ; $02A67B | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $02A67C |/
    LDA r_character_battle.1.id.w,X                                             ; $02A67E |\
    DEC A                                                                       ; $02A681 | | Read the character's ID and use that to determine which name index
    AND #%00111111.b                                                            ; $02A682 | | to use for that character.
    TAX                                                                         ; $02A684 | |
    LDA bank16.character_id_to_name_index_data.l,X                              ; $02A685 |/
    STA <r_math_multiply_8bit_arg_1                                             ; $02A689 |\
    LDA #_sizeof_character_name.b                                               ; $02A68B | | Multiply that by six to determine the index into the actual name
    STA <r_battle_generic_tmp_index_lo                                          ; $02A68D | | data table.
    STA <r_math_multiply_8bit_arg_2                                             ; $02A68F | |
    JSR _math_multiply_8bit                                                     ; $02A691 | |
    LDX <r_math_multiply_8bit_result                                            ; $02A694 |/
-   LDA r_character_names.w,X                                                   ; $02A696 |\
    JSR _battle_update_dialog_update_target_tile                                ; $02A699 | | Copy the character's name into the target area.
    INX                                                                         ; $02A69C | |
    DEC <r_battle_generic_tmp_index_lo                                          ; $02A69D | |
    BNE -                                                                       ; $02A69F |/
    RTS                                                                         ; $02A6A1

; _battle_update_dialog_opcode_tile ($02:A6A2)
;
; This opcode copies the next byte directly as the next tile number. This
; potentially allows one to copy tiles with values that are reserved as opcode
; numbers.
_battle_update_dialog_opcode_tile:
    JSR _battle_update_dialog_increment_source_ptr                              ; $02A6A2 |\
    LDA (<r_battle_update_dialog_source_ptr)                                    ; $02A6A5 | | Read the next byte and copy it to the target.
    JMP _battle_update_dialog_update_target_tile_non_diacritic                  ; $02A6A7 |/

; _battle_update_dialog_opcode_blanks ($02:A6AA)
;
; This opcode writes the number of blank tiles specified by the next byte.
_battle_update_dialog_opcode_blanks:
    JSR _battle_update_dialog_increment_source_ptr                              ; $02A6AA | Increment the source pointer.
    LDA (<r_battle_update_dialog_source_ptr)                                    ; $02A6AD |\ Retrieve the next byte and store it in the index.
    STA <r_battle_generic_tmp_index_lo                                          ; $02A6AF |/
-   LDA #$FF.b                                                                  ; $02A6B1 |\
    JSR _battle_update_dialog_update_target_tile                                ; $02A6B3 | | Write the number of blanks specified by the byte.
    DEC <r_battle_generic_tmp_index_lo                                          ; $02A6B6 | |
    BNE -                                                                       ; $02A6B8 |/
    RTS                                                                         ; $02A6BA

; _battle_update_dialog_opcode_character_stat_slot_* ($02:A6BB)
;
; This series of opcodes prints various statistics about the character in the
; slot determined by the entry point. The statistic printed depends on the value
; of the next byte:
;
; $00: Character's name.
; $01: Character's current HP, in BG3 tile numbers.
; $02: Character's maximum HP, in BG3 tile numbers.
; $03: Character's current MP, in BG2 tile numbers.
; $04: Character's maximum MP, in BG2 tile numbers.
; $05+: Loops forever.
_battle_update_dialog_opcode_character_stat_slot_0:
    LDX #_sizeof_character_battle.w * 0                                         ; $02A6BB |\
    TDC                                                                         ; $02A6BE | | Set the offset and slot for the slot 0 entry.
    BRA _battle_update_dialog_opcode_character_stat_next                        ; $02A6BF |/
_battle_update_dialog_opcode_character_stat_slot_1:
    LDX #_sizeof_character_battle.w * 1                                         ; $02A6C1 |\
    LDA #1.b                                                                    ; $02A6C4 | | Set the offset and slot for the slot 1 entry.
    BRA _battle_update_dialog_opcode_character_stat_next                        ; $02A6C6 |/
_battle_update_dialog_opcode_character_stat_slot_2:
    LDX #_sizeof_character_battle.w * 2                                         ; $02A6C8 |\
    LDA #2.b                                                                    ; $02A6CB | | Set the offset and slot for the slot 2 entry.
    BRA _battle_update_dialog_opcode_character_stat_next                        ; $02A6CD |/
_battle_update_dialog_opcode_character_stat_slot_3:
    LDX #_sizeof_character_battle.w * 3                                         ; $02A6CF |\
    LDA #3.b                                                                    ; $02A6D2 | | Set the offset and slot for the slot 3 entry.
    BRA _battle_update_dialog_opcode_character_stat_next                        ; $02A6D4 |/
_battle_update_dialog_opcode_character_stat_slot_4:
    LDX #_sizeof_character_battle.w * 4                                         ; $02A6D6 |\ Set the offset and slot for the slot 4 entry.
    LDA #4.b                                                                    ; $02A6D9 |/
_battle_update_dialog_opcode_character_stat_next:
    STX <r_battle_update_dialog_character_offset                                ; $02A6DB | Store the offset into a variable.
    PHA                                                                         ; $02A6DD |\
    JSR _battle_update_dialog_increment_source_ptr                              ; $02A6DE | | Read the next byte. If the value is zero, jump to printing the
    LDA (<r_battle_update_dialog_source_ptr)                                    ; $02A6E1 | | character's name.
    BNE +                                                                       ; $02A6E3 | |
    PLA                                                                         ; $02A6E5 | |
    JMP _battle_update_dialog_opcode_character_slot_name_accumulator            ; $02A6E6 |/
+   TAX                                                                         ; $02A6E9 |\
    PLA                                                                         ; $02A6EA | | Otherwise, store the slot number and restore the mode value to
    STA <r_battle_update_dialog_character_slot                                  ; $02A6EB | | the accumulator.
    TXA                                                                         ; $02A6ED |/
    LDX <r_battle_update_dialog_character_offset                                ; $02A6EE | Load the offset into the battle record into the X register.
    CMP #BATTLE_DIALOG_OPCODE_CHARACTER_STAT_HP.b                               ; $02A6F0 |\
    BNE +                                                                       ; $02A6F2 | | If the value is $01, set the skip value to zero and prepare to
    STZ <r_battle_update_dialog_character_skip                                  ; $02A6F4 | | print the character's HP onto BG3.
    LDA #character_battle.hp.b                                                  ; $02A6F6 | |
    JMP _battle_update_dialog_opcode_character_stat_bg3                         ; $02A6F8 |/
+   CMP #BATTLE_DIALOG_OPCODE_CHARACTER_STAT_HP_MAX.b                           ; $02A6FB |\
    BNE +                                                                       ; $02A6FD | | If the value is $02, set the skip value to zero and prepare to
    STZ <r_battle_update_dialog_character_skip                                  ; $02A6FF | | print the character's maximum HP onto BG3.
    LDA #character_battle.hp_max.b                                              ; $02A701 | |
    JMP _battle_update_dialog_opcode_character_stat_bg3                         ; $02A703 |/
+   CMP #BATTLE_DIALOG_OPCODE_CHARACTER_STAT_MP.b                               ; $02A706 |\
    BNE +                                                                       ; $02A708 | | If the value is $03, set the skip value to one (as MP only needs
    LDA #1.b                                                                    ; $02A70A | | three digits) and prepare to print the character's MP to BG2.
    STA <r_battle_update_dialog_character_skip                                  ; $02A70C | |
    LDA #character_battle.mp.b                                                  ; $02A70E | |
    JMP _battle_update_dialog_opcode_character_stat_bg2                         ; $02A710 |/
+   CMP #BATTLE_DIALOG_OPCODE_CHARACTER_STAT_MP_MAX.b                           ; $02A713 |\
    BNE @loop                                                                   ; $02A715 | | If the value is $04, set the skip value to one (as MP only needs
    LDA #1.b                                                                    ; $02A717 | | three digits) and prepare to print the character's maximum MP to
    STA <r_battle_update_dialog_character_skip                                  ; $02A719 | | BG2.
    LDA #character_battle.mp_max.b                                              ; $02A71B | |
    JMP _battle_update_dialog_opcode_character_stat_bg2                         ; $02A71D |/
@loop:
    JMP @loop                                                                   ; $02A720 | Loop forever. Clearly $05+ is not a good value here.

; _unused_battle_clear_format_number_result_first_four ($02:A723)
;
; This seemingly unused function writes blank tiles to the first four digits of
; the format number result array at $180C.
_unused_battle_clear_format_number_result_first_four:
    LDA #TEXT_SPACE.b                                                           ; $02A723
    STA r_battle_format_number_result.w + 0                                     ; $02A725
    STA r_battle_format_number_result.w + 1                                     ; $02A728
    STA r_battle_format_number_result.w + 2                                     ; $02A72B
    STA r_battle_format_number_result.w + 3                                     ; $02A72E
    RTS                                                                         ; $02A731

; _battle_update_dialog_opcode_character_stat_bg2 ($02:A732)
;
; Given the offset within the battle record to the desired 16-bit stat in the
; accumulator and the offset to the character's in-battle record in $0A, draws
; the decimal version of that number using tile numbers suitable for BG2. The
; number is assmued to be 4 digits, and $02 contains the number of leading
; digits to skip.
_battle_update_dialog_opcode_character_stat_bg2:
    LDX <r_battle_update_dialog_character_offset                                ; $02A732 |\ Put the correct offset in the X register and call the routine to
    JSR _render_character_battle_number                                         ; $02A734 |/ render the number.
    LDA <r_battle_update_dialog_character_skip                                  ; $02A737 |\ Skip the desired number of leading digits.
    TAX                                                                         ; $02A739 |/
-   LDA r_battle_format_number_result.w,X                                       ; $02A73A |\
    CMP #$FF.b                                                                  ; $02A73D | | If the next tile is blank, simply pass it through, otherwise add
    BEQ +                                                                       ; $02A73F | | $6D to get the correct tile number for BG2.
    CLC                                                                         ; $02A741 | |
    ADC #$6D.b                                                                  ; $02A742 |/
+   JSR _battle_update_dialog_update_target_tile_non_diacritic                  ; $02A744 |\
    INX                                                                         ; $02A747 | | Loop until all digits are processed.
    CPX #4.w                                                                    ; $02A748 | |
    BNE -                                                                       ; $02A74B |/
    RTS                                                                         ; $02A74D

; _battle_update_dialog_opcode_character_stat_bg3 ($02:A74E)
;
; Given the offset within the battle record to the desired 16-bit stat in the
; accumulator and the offset to the character's in-battle record in $0A, draws
; the decimal version of that number using tile numbers suitable for BG3. The
; number is assumed to be 4 digits, and $02 contains the number of leading
; digits to skip.
_battle_update_dialog_opcode_character_stat_bg3:
    LDX <r_battle_update_dialog_character_offset                                ; $02A74E |\ Put the correct offset in the X register and call the routine to
    JSR _render_character_battle_number                                         ; $02A750 |/ render the number.
    LDA <r_battle_update_dialog_character_skip                                  ; $02A753 |\ Skip the desired number of leading digits.
    TAX                                                                         ; $02A755 |/
-   LDA r_battle_format_number_result.w,X                                       ; $02A756 |\
    JSR _battle_update_dialog_update_target_tile_non_diacritic                  ; $02A759 | | Loop copying the remaining digits.
    INX                                                                         ; $02A75C | |
    CPX #4.w                                                                    ; $02A75D | |
    BNE -                                                                       ; $02A760 |/
    RTS                                                                         ; $02A762

; _render_character_battle_number ($02:A763)
;
; Given an offset to a battle character record in the X register and an offset
; to a variable within that record in the accumulator, converts the 16-bit
; number at that offset for display and stores it at $180C.
_render_character_battle_number:
    REP #FLAG_P_ACCUMULATOR.b                                                   ; $02A763 |\
    STX <r_battle_generic_tmp_index                                             ; $02A765 | | Calculate the offset by adding the record offset in the X register
    CLC                                                                         ; $02A767 | | to the desired variable offset in the accumulator.
    ADC <r_battle_generic_tmp_index                                             ; $02A768 | |
    TAX                                                                         ; $02A76A |/
    LDA r_character_battle.1.w,X                                                ; $02A76B | Load the value from the record.
    TAX                                                                         ; $02A76E |\
    TDC                                                                         ; $02A76F | | Convert the number to decimal and render it for display.
    SEP #FLAG_P_ACCUMULATOR                                                     ; $02A770 | |
    JSR _battle_format_number                                                   ; $02A772 | |
    JMP _battle_render_number                                                   ; $02A775 |/

; _battle_update_dialog_opcode_set_tile_flags ($02:A778)
;
; This opcode sets the default tile flags for each tile occurring after this
; opcode.
_battle_update_dialog_opcode_set_tile_flags:
    JSR _battle_update_dialog_increment_source_ptr                              ; $02A778 |\
    LDA (<r_battle_update_dialog_source_ptr)                                    ; $02A77B | | Read the next byte and store it to the flags variable.
    STA <r_battle_update_dialog_flags                                           ; $02A77D |/
    RTS                                                                         ; $02A77F

; _battle_update_dialog_opcode_monster_count ($02:A780)
;
; Given a monster ID slot in the next byte, prints the number of monsters
; remaining of that type. If zero or one monsters remain or if the slot was
; empty, a blank tile will be displayed. Otherwise, a single digit number with
; the monster count.
_battle_update_dialog_opcode_monster_count:
    JSR _battle_update_dialog_increment_source_ptr                              ; $02A780 |\
    LDA (<r_battle_update_dialog_source_ptr)                                    ; $02A783 | | Read the next byte and transfer it to the X register.
    TAX                                                                         ; $02A785 |/
    LDA r_monsters_remaining.w,X                                                ; $02A786 |\ If there are zero monsters remaining, jump to the end of the
    BEQ +++                                                                     ; $02A789 |/ function.
    LDA r_monster_ids_original.w,X                                              ; $02A78B |\
    CMP #$FF.b                                                                  ; $02A78E | | If the spot is empty, jump to the end, writing a blank tile.
    BEQ ++                                                                      ; $02A790 |/
    LDA r_monsters_remaining.w,X                                                ; $02A792 |\
    TAX                                                                         ; $02A795 | | If there is one monster remaining, also write a blank tile.
    CMP #1.b                                                                    ; $02A796 | |
    BNE +                                                                       ; $02A798 | |
    LDA #$FF.b                                                                  ; $02A79A | |
    BRA ++                                                                      ; $02A79C |/
+   JSR _battle_format_number                                                   ; $02A79E |\ Otherwise, format the number and write the last digit.
    LDA r_battle_format_number_result.w + 4                                     ; $02A7A1 |/
++  JMP _battle_update_dialog_update_target_tile_non_diacritic                  ; $02A7A4 | Regardless, actually copy the value to the destination.
+++ DEC A                                                                       ; $02A7A7 |\ If there were zero monsters remaining, decrement the value (to $FF)
    JMP _battle_update_dialog_update_target_tile_non_diacritic                  ; $02A7A8 |/ and write that (a blank tile).

; _battle_update_dialog_opcode_monster_name ($02:A7AB)
;
; This opcode prints the name of the monster in the index given by the next
; byte. Note that this is not a slot number, but rather an index from 0 to 2
; corresponding to the monster type.
_battle_update_dialog_opcode_monster_name:
    JSR _battle_update_dialog_increment_source_ptr                              ; $02A7AB |\ Load the next byte, which determines the monster index being looked
    LDA (<r_battle_update_dialog_source_ptr)                                    ; $02A7AE |/ at.
    TAX                                                                         ; $02A7B0 | Transfer the index to the X register.
    LDA r_monsters_remaining.w,X                                                ; $02A7B1 |\
    BEQ +                                                                       ; $02A7B4 | | If the number of monsters remaining in this index is greater than
    LDA r_monster_ids_original.w,X                                              ; $02A7B6 | | zero and if the slot isn't empty entirely, skip ahead to the later
    CMP #$FF.b                                                                  ; $02A7B9 | | code.
    BNE ++                                                                      ; $02A7BB |/
+   LDX #8.w                                                                    ; $02A7BD |\
-   LDA #$FF.b                                                                  ; $02A7C0 | | Otherwise, set all eight of the characters to blank tiles and
    JSR _battle_update_dialog_update_target_tile_non_diacritic                  ; $02A7C2 | | return.
    DEX                                                                         ; $02A7C5 | |
    BNE -                                                                       ; $02A7C6 | |
    RTS                                                                         ; $02A7C8 |/
++  PHA                                                                         ; $02A7C9 |\
    LDA r_monster_type_egg.w,X                                                  ; $02A7CA | | If the monster is currently an egg, replace their ID with the ID
    BEQ +                                                                       ; $02A7CD | | of an egg (to print the egg's name).
    PLA                                                                         ; $02A7CF | |
    LDA #MONSTER_EGG.b                                                          ; $02A7D0 | |
    BRA ++                                                                      ; $02A7D2 | |
+   PLA                                                                         ; $02A7D4 |/
++  REP #FLAG_P_ACCUMULATOR                                                     ; $02A7D5 |\
    ASL A                                                                       ; $02A7D7 | | Multiply the monster ID by 8 (the length of a name) and transfer
    ASL A                                                                       ; $02A7D8 | | to the X register.
    ASL A                                                                       ; $02A7D9 | |
    TAX                                                                         ; $02A7DA | |
    TDC                                                                         ; $02A7DB | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $02A7DC |/
    LDA #8.b                                                                    ; $02A7DE |\ Initialize the counter to 8 as each name as eight bytes.
    STA <r_battle_generic_tmp_index_lo                                          ; $02A7E0 |/
-   LDA bank0E.monster_name_data.l,X                                            ; $02A7E2 |\
    JSR _battle_update_dialog_update_target_tile                                ; $02A7E6 | | Loop until all eight characters of the monster's name have been
    INX                                                                         ; $02A7E9 | | processed.
    DEC <r_battle_generic_tmp_index_lo                                          ; $02A7EA | |
    BNE -                                                                       ; $02A7EC |/
    RTS                                                                         ; $02A7EE

; _battle_dialog_inventory_set_scroll ($02:A7EF)
;
; Given a number of lines until the beginning of the next row of text in the Y
; register and a desired 16-bit initial scroll value in the X register, sets
; the HDMA scroll values for BG3 lines 153 through 212 to update the scroll of
; the inventory area.
_battle_dialog_inventory_set_scroll:
    REP #FLAG_P_ACCUMULATOR                                                     ; $02A7EF | Switch to 16-bit accumulator mode.
    TXA                                                                         ; $02A7F1 | Transfer the X register parameter to the accumulator.
    LDX #0.w                                                                    ; $02A7F2 | Initialize the X register to zero.
-   STA r_battle_bg3_hdma_data.153.vertical.w,X                                 ; $02A7F5 | Store the current value as the vertical scroll for this line.
    DEY                                                                         ; $02A7F8 |\
    BNE +                                                                       ; $02A7F9 | | If the Y register reaches zero, add four to the current value (to
    CLC                                                                         ; $02A7FB | | skip four pixels after a set of 12). Reset the Y register to 12
    ADC #4.w                                                                    ; $02A7FC | | for the next cycle.
    LDY #12.w                                                                   ; $02A7FF |/
+   INX                                                                         ; $02A802 |\
    INX                                                                         ; $02A803 | | Increment the X register by four to move to the next HDMA entry.
    INX                                                                         ; $02A804 | |
    INX                                                                         ; $02A805 |/
    CPX #_sizeof_scroll_hdma_data_entry.w * 60                                  ; $02A806 |\ Loop until 60 lines have been set.
    BNE -                                                                       ; $02A809 |/
    TDC                                                                         ; $02A80B |\ Switch back to 8-bit accumulator mode.
    SEP #FLAG_P_ACCUMULATOR                                                     ; $02A80C |/
    RTS                                                                         ; $02A80E

; _battle_menu_update ($02:A80F)
;
; Checks the battle menu update mode and executes the correct handler for that
; mode.
_battle_menu_update:
    LDA r_battle_menu_update_mode.w                                             ; $02A80F |\
    REP #FLAG_P_ACCUMULATOR                                                     ; $02A812 | | Load the pointer for the current menu update mode.
    ASL A                                                                       ; $02A814 | |
    TAX                                                                         ; $02A815 | |
    LDA battle_menu_update_pointer_data.l,X                                     ; $02A816 | |
    STA <r_battle_generic_tmp_ptr                                               ; $02A81A | |
    TDC                                                                         ; $02A81C | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $02A81D |/
    JMP (r_battle_generic_tmp_ptr.w)                                            ; $02A81F | Jump to the pointer to handle the update.

; battle_menu_update_pointer_data ($02:A822)
;
; For each of the four possible values of the battle menu update mode variable,
; provides a pointer to the handler for that value.
battle_menu_update_pointer_data:
    .addr _battle_menu_no_action                                                ; $02A822.A823 | $00
    .addr _battle_menu_open_close                                               ; $02A824.A825 | $01
    .addr _battle_menu_scroll_down                                              ; $02A826.A827 | $02
    .addr _battle_menu_scroll_up                                                ; $02A828.A829 | $03

; _battle_menu_no_action ($02:A82A)
;
; A no-op function called to update the battle menu when no update is necessary.
_battle_menu_no_action:
    RTS                                                                         ; $02A82A

; _battle_menu_update_selected_cursor_visibility ($02:A82B)
;
; Given the current Y coordinate of the selected cursor in the X register, as
; well as its 8-bit hidden status in $EF73, updates the visibility of the second
; menu cursor.
_battle_menu_update_selected_cursor_visibility:
    LDA r_battle_menu_selected_cursor_hidden.w                                  ; $02A82B |\ If the selected cursor is currently hidden, skip this entire
    BNE ++                                                                      ; $02A82E |/ routine.
    STZ r_battle_menu_cursor_hidden.2.w                                         ; $02A830 | Unset the cursor's hidden flag.
    CPX #148.w                                                                  ; $02A833 |\
    BCC +                                                                       ; $02A836 | | Increment the hidden flag again unless the cursor's Y coordinate
    CPX #209.w                                                                  ; $02A838 | | is within the visible range.
    BCC ++                                                                      ; $02A83B | |
+   INC r_battle_menu_cursor_hidden.2.w                                         ; $02A83D |/
++  RTS                                                                         ; $02A840

; _battle_menu_scroll_down ($02:A841)
;
; Handles the state where the battle menu needs to be scrolled down. The routine
; actually executes twice.
_battle_menu_scroll_down:
    JSR +                                                                       ; $02A841 | Recursively call this routine an additional time.
+   LDX r_battle_menu_scroll_current.w                                          ; $02A844 |\
    INX                                                                         ; $02A847 | | Increment the current scroll value by one.
    STX r_battle_menu_scroll_current.w                                          ; $02A848 |/
    LDY r_battle_menu_scroll_next_line_offset.w                                 ; $02A84B |\
    DEY                                                                         ; $02A84E | | Decrement the next line offset to keep the gaps correct.
    STY r_battle_menu_scroll_next_line_offset.w                                 ; $02A84F |/
    BNE +                                                                       ; $02A852 |\
    LDY #12.w                                                                   ; $02A854 | | If the next line offset reaches zero, then an entirely line has
    STY r_battle_menu_scroll_next_line_offset.w                                 ; $02A857 | | been scrolled. Reset the next line offset to 12 and increment the
    LDX r_battle_menu_scroll_current.w                                          ; $02A85A | | current scroll value by four to skip the four skipped pixels.
    INX                                                                         ; $02A85D | |
    INX                                                                         ; $02A85E | |
    INX                                                                         ; $02A85F | |
    INX                                                                         ; $02A860 | |
    STX r_battle_menu_scroll_current.w                                          ; $02A861 |/
+   JSR _battle_dialog_inventory_set_scroll                                     ; $02A864 | Set the scroll value to the current value.
    DEC r_battle_menu_scroll_remaining.w                                        ; $02A867 | Decrement the number of remaining lines.
    BNE +                                                                       ; $02A86A |\
    STZ r_battle_menu_update_mode.w                                             ; $02A86C | | If it reaches zero, unset the battle menu update mode and return.
    RTS                                                                         ; $02A86F |/
+   LDX r_battle_menu_cursor_coordinates.2.y.w                                  ; $02A870 |\
    DEX                                                                         ; $02A873 | | Decrement the cursor Y coordinate, keeping it in the X register.
    STX r_battle_menu_cursor_coordinates.2.y.w                                  ; $02A874 |/
    JMP _battle_menu_update_selected_cursor_visibility                          ; $02A877 | Update the visibility of the selected cursor.

; _battle_menu_scroll_up ($02:A87A)
;
; Handles the state where the battle menu needs to be scrolled up. The routine
; actually executes twice.
_battle_menu_scroll_up:
    JSR +                                                                       ; $02A87A | Recursively call this routine an additional time.
+   LDX r_battle_menu_scroll_current.w                                          ; $02A87D |\
    DEX                                                                         ; $02A880 | | Decrement the current scroll value by one.
    STX r_battle_menu_scroll_current.w                                          ; $02A881 |/
    LDY r_battle_menu_scroll_next_line_offset.w                                 ; $02A884 |\
    INY                                                                         ; $02A887 | | Increment the next line offset to keep the gaps correct.
    STY r_battle_menu_scroll_next_line_offset.w                                 ; $02A888 |/
    CPY #13.w                                                                   ; $02A88B |\
    BNE +                                                                       ; $02A88E | | If the next line offset reaches 13, then an entire line has been
    LDY #1.w                                                                    ; $02A890 | | scrolled. Reset the next line offset to 1, and decrement the
    STY r_battle_menu_scroll_next_line_offset.w                                 ; $02A893 | | current scroll value by four to skip the four skipped pixels.
    LDX r_battle_menu_scroll_current.w                                          ; $02A896 | |
    DEX                                                                         ; $02A899 | |
    DEX                                                                         ; $02A89A | |
    DEX                                                                         ; $02A89B | |
    DEX                                                                         ; $02A89C | |
    STX r_battle_menu_scroll_current.w                                          ; $02A89D |/
+   JSR _battle_dialog_inventory_set_scroll                                     ; $02A8A0 | Set the scroll value to the current value.
    DEC r_battle_menu_scroll_remaining.w                                        ; $02A8A3 | Decrement the number of remaining lines.
    BNE +                                                                       ; $02A8A6 |\
    STZ r_battle_menu_update_mode.w                                             ; $02A8A8 | | If it reaches zero, unset the menu update mode and return.
    RTS                                                                         ; $02A8AB |/
+   LDX r_battle_menu_cursor_coordinates.2.y.w                                  ; $02A8AC |\
    INX                                                                         ; $02A8AF | | Increment the cursor Y coordinate, keeping it in the X register.
    STX r_battle_menu_cursor_coordinates.2.y.w                                  ; $02A8B0 |/
    JMP _battle_menu_update_selected_cursor_visibility                          ; $02A8B3 | Update the visibility of the selected cursor.

; _battle_menu_inventory_scroll_down ($02:A8B6)
;
; Updates parameters necessary to cause the inventory menu to be scrolled down
; by one row.
_battle_menu_inventory_scroll_down:
    LDX r_battle_menu_cursor_coordinates.2.y.w                                  ; $02A8B6 |\
    DEX                                                                         ; $02A8B9 | | Decrement the row of the second (selected item) cursor.
    STX r_battle_menu_cursor_coordinates.2.y.w                                  ; $02A8BA |/
    LDA #12.b                                                                   ; $02A8BD |\ Set the remaining scroll to 12 pixels.
    STA r_battle_menu_scroll_remaining.w                                        ; $02A8BF |/
    LDA #BATTLE_MENU_UPDATE_MODE_SCROLL_DOWN.b                                  ; $02A8C2 |\ Set the menu update mode to scroll down.
    STA r_battle_menu_update_mode.w                                             ; $02A8C4 |/
    RTS                                                                         ; $02A8C7

; _battle_menu_inventory_scroll_up ($02:A8C8)
;
; Updates parameters necessary to cause the inventory menu to be scrolled up by
; one row.
_battle_menu_inventory_scroll_up:
    LDX r_battle_menu_cursor_coordinates.2.y.w                                  ; $02A8C8 |\
    INX                                                                         ; $02A8CB | | Increment the row of the second (selected item) cursor.
    STX r_battle_menu_cursor_coordinates.2.y.w                                  ; $02A8CC |/
    LDA #12.b                                                                   ; $02A8CF |\ Set the remaining scroll to 12 pixels.
    STA r_battle_menu_scroll_remaining.w                                        ; $02A8D1 |/
    LDA #BATTLE_MENU_UPDATE_MODE_SCROLL_UP.b                                    ; $02A8D4 |\ Set the menu update mode to scroll up.
    STA r_battle_menu_update_mode.w                                             ; $02A8D6 |/
    RTS                                                                         ; $02A8D9

; _battle_menu_open_close ($02:A8DA)
;
; Given the configured open/close parameters in $183F to $1844, animates the
; opening or closing of a menu. Each call to this routine will do no more than
; one row of tiles. Note that the animation is done entirely via changing the
; HDMA table. No actual tile data is moved.
_battle_menu_open_close:
    LDA r_battle_dialog_update_pending.w                                        ; $02A8DA |\
    ORA r_battle_dialog_update_pending_2.w                                      ; $02A8DD | | If a battle dialog update is pending, return, doing nothing.
    BNE +                                                                       ; $02A8E0 |/
    LDA r_battle_menu_open_close_parameters.reverse.w                           ; $02A8E2 |\
    BEQ ++                                                                      ; $02A8E5 | | If reverse mode is set, jump to the reverse code.
    JMP @reverse                                                                ; $02A8E7 |/
+   RTS                                                                         ; $02A8EA | Return if a battle dialog update was pending.
++  REP #FLAG_P_ACCUMULATOR                                                     ; $02A8EB | Switch to 16-bit accumulator mode.
    LDA r_battle_menu_open_close_parameters.source_address.w                    ; $02A8ED |\ Copy the source address into a local variable.
    STA <r_battle_menu_open_close_source_ptr                                    ; $02A8F0 |/
    LDA r_battle_menu_open_close_parameters.target_address.w                    ; $02A8F2 |\
    STA <r_battle_menu_open_close_target_ptr                                    ; $02A8F5 |/
    LDY #0.w                                                                    ; $02A8F7 | Initialize the Y register to zero.
-   LDA (<r_battle_menu_open_close_source_ptr),Y                                ; $02A8FA |\
    STA <r_battle_menu_open_close_tmp                                           ; $02A8FC | | Swap the values between the source and target location. This
    LDA (<r_battle_menu_open_close_target_ptr),Y                                ; $02A8FE | | allows the source to serve as a backup of the original target
    STA (<r_battle_menu_open_close_source_ptr),Y                                ; $02A900 | | data.
    LDA <r_battle_menu_open_close_tmp                                           ; $02A902 | |
    STA (<r_battle_menu_open_close_target_ptr),Y                                ; $02A904 |/
    INY                                                                         ; $02A906 |\ Increment the Y register by two to move to the next two bytes.
    INY                                                                         ; $02A907 |/
    CPY #_sizeof_scroll_hdma_data_entry.w * 8                                   ; $02A908 |\ Loop until 8 lines worth of data have been swapped.
    BNE -                                                                       ; $02A90B |/
    LDA <r_battle_menu_open_close_source_ptr                                    ; $02A90D |\
    CLC                                                                         ; $02A90F | | Add 8 lines to the source address and save it back to the original
    ADC #_sizeof_scroll_hdma_data_entry.w * 8                                   ; $02A910 | | location.
    STA r_battle_menu_open_close_parameters.source_address.w                    ; $02A913 |/
    LDA <r_battle_menu_open_close_target_ptr                                    ; $02A916 |\
    CLC                                                                         ; $02A918 | | Add 8 lines to the target address and save it back to the original
    ADC #_sizeof_scroll_hdma_data_entry.w * 8                                   ; $02A919 | | location.
    STA r_battle_menu_open_close_parameters.target_address.w                    ; $02A91C |/
    TDC                                                                         ; $02A91F |\ Switch back to 8-bit accumulator mode.
    SEP #FLAG_P_ACCUMULATOR                                                     ; $02A920 |/
    DEC r_battle_menu_open_close_parameters.tiles.w                             ; $02A922 |\
    BNE +                                                                       ; $02A925 | | Decrement the number of remaining tiles, and if it reaches zero,
    STZ r_battle_menu_update_mode.w                                             ; $02A927 | | unset the update mode, as we're finished.
+   RTS                                                                         ; $02A92A |/
@reverse:
    REP #FLAG_P_ACCUMULATOR                                                     ; $02A92B | Switch to 16-bit accumulator mode.
    LDA r_battle_menu_open_close_parameters.source_address.w                    ; $02A92D |\ Copy the source address to a local variable.
    STA <r_battle_menu_open_close_source_ptr                                    ; $02A930 |/
    LDA r_battle_menu_open_close_parameters.target_address.w                    ; $02A932 |\ Copy the target address to a local variable.
    STA <r_battle_menu_open_close_target_ptr                                    ; $02A935 |/
    LDY #0.w                                                                    ; $02A937 | Initialize the Y register to zero.
-   LDA (<r_battle_menu_open_close_source_ptr),Y                                ; $02A93A |\
    PHA                                                                         ; $02A93C | | Swap the values at the source and target locations.
    LDA (<r_battle_menu_open_close_target_ptr),Y                                ; $02A93D | |
    STA (<r_battle_menu_open_close_source_ptr),Y                                ; $02A93F | |
    PLA                                                                         ; $02A941 | |
    STA (<r_battle_menu_open_close_target_ptr),Y                                ; $02A942 |/
    INY                                                                         ; $02A944 |\ Increment the Y register by two to move to the next two bytes.
    INY                                                                         ; $02A945 |/
    CPY #_sizeof_scroll_hdma_data_entry.w * 8                                   ; $02A946 |\ Loop until the 8 lines of the tile have been swapped.
    BNE -                                                                       ; $02A949 |/
    LDA <r_battle_menu_open_close_source_ptr                                    ; $02A94B |\
    SEC                                                                         ; $02A94D | | Subtract eight lines from the source address to move to the next
    SBC #_sizeof_scroll_hdma_data_entry.w * 8                                   ; $02A94E | | tile.
    STA r_battle_menu_open_close_parameters.source_address.w                    ; $02A951 |/
    LDA <r_battle_menu_open_close_target_ptr                                    ; $02A954 |\
    SEC                                                                         ; $02A956 | | Subtract eight lines from the target address.
    SBC #_sizeof_scroll_hdma_data_entry.w * 8                                   ; $02A957 | |
    STA r_battle_menu_open_close_parameters.target_address.w                    ; $02A95A |/
    TDC                                                                         ; $02A95D |\ Switch back to 8-bit accumulator mode.
    SEP #FLAG_P_ACCUMULATOR                                                     ; $02A95E |/
    DEC r_battle_menu_open_close_parameters.tiles.w                             ; $02A960 |\
    BNE +                                                                       ; $02A963 | | Decrement the number of remaining tiles, and if the value reaches
    STZ r_battle_menu_update_mode.w                                             ; $02A965 | | zero, unset the menu update mode.
+   RTS                                                                         ; $02A968 |/

; _battle_menu_prepare_open_close ($02:A969)
;
; Given a mode parameter in the accumulator, loads the parameters for that menu
; to open or close and sets the battle menu update mode to open/close so the
; menu will be opened or closed.
_battle_menu_prepare_open_close:
    STA <r_math_multiply_8bit_reg_arg_1                                         ; $02A969 |\
    LDA #_sizeof_battle_menu_open_close.b                                       ; $02A96B | | Set the X register to the parameter multiplied by the size of the
    STA <r_math_multiply_8bit_reg_arg_2                                         ; $02A96D | | parameters data, which is six bytes.
    JSR _math_multiply_8bit_reg                                                 ; $02A96F | |
    LDX <r_math_multiply_8bit_reg_result                                        ; $02A972 |/
    LDY #0.w                                                                    ; $02A974 | Initialize the Y register to zero.
-   LDA bank0D.battle_menu_open_close_parameters_data.l,X                       ; $02A977 |\
    STA r_battle_menu_open_close_parameters.w,Y                                 ; $02A97B | | Copy the menu open/close parameters associated with this parameter
    INX                                                                         ; $02A97E | | to RAM.
    INY                                                                         ; $02A97F | |
    CPY #_sizeof_battle_menu_open_close.w                                       ; $02A980 | |
    BNE -                                                                       ; $02A983 |/
    LDA #BATTLE_MENU_UPDATE_MODE_OPEN_CLOSE.b                                   ; $02A985 |\ Set the battle menu update mode to open/close.
    STA r_battle_menu_update_mode.w                                             ; $02A987 |/
    RTS                                                                         ; $02A98A

; _battle_menu_open_mp ($02:A98B)
;
; Sets parameters to open the MP menu.
_battle_menu_open_mp:
    LDX #0.w                                                                    ; $02A98B |\ Set the menu coordinates to zero.
    STX <r_battle_menu_coordinates                                              ; $02A98E |/
    STX r_battle_menu_inventory_rows.w                                          ; $02A990 | Set the inventory rows (Y coordinates) to zero.
    STZ <r_battle_menu_inventory_index                                          ; $02A993 | Set the inventory index to zero.
    LDA #BATTLE_MENU_FLAG_1_MP.b                                                ; $02A995 |\ Set the MP menu flag.
    TSB <r_battle_menu_flags.1                                                  ; $02A997 |/
    LDA #BATTLE_MENU_OPEN_MP.b                                                  ; $02A999 |\ Set the parameters to open the MP window.
    JSR _battle_menu_prepare_open_close                                         ; $02A99B |/
    LDA #BATTLE_DIALOG_UPDATE_MP.b                                              ; $02A99E |\ Update the MP window.
    STA r_battle_dialog_update_pending.w                                        ; $02A9A0 |/
    RTS                                                                         ; $02A9A3

; _battle_menu_close_mp ($02:A9A4)
;
; Sets parameters to close the MP menu.
_battle_menu_close_mp:
    LDA #BATTLE_MENU_FLAG_1_MP.b                                                ; $02A9A4 |\ Reset the flag for the needed MP menu.
    TRB <r_battle_menu_flags.1                                                  ; $02A9A6 |/
    LDA #BATTLE_MENU_CLOSE_MP.b                                                 ; $02A9A8 |\ Set parameters to close the MP window.
    JMP _battle_menu_prepare_open_close                                         ; $02A9AA |/

; _battle_menu_open_parry_1 ($02:A9AD)
;
; Sets parameters to open the top Parry menu.
_battle_menu_open_parry_1:
    LDA #BATTLE_MENU_FLAG_2_PARRY_1.b                                           ; $02A9AD |\ Set the flag for the top Parry menu.
    TSB <r_battle_menu_flags.2                                                  ; $02A9AF |/
    LDA #BATTLE_MENU_OPEN_PARRY_1.b                                             ; $02A9B1 |\ Set parameters to open the top Parry menu.
    JMP _battle_menu_prepare_open_close                                         ; $02A9B3 |/

; _battle_menu_close_parry_1 ($02:A9B6)
;
; Sets parameters to close the top Parry menu.
_battle_menu_close_parry_1:
    LDA #BATTLE_MENU_FLAG_2_PARRY_1.b                                           ; $02A9B6 |\ Reset the flag for the top Parry menu.
    TRB <r_battle_menu_flags.2                                                  ; $02A9B8 |/
    LDA #BATTLE_MENU_CLOSE_PARRY_1.b                                            ; $02A9BA |\ Set parameters to close the top Parry menu.
    JMP _battle_menu_prepare_open_close                                         ; $02A9BC |/

; _battle_menu_open_parry_2 ($02:A9BF)
;
; Sets parameters to open the top middle Parry menu.
_battle_menu_open_parry_2:
    LDA #BATTLE_MENU_FLAG_2_PARRY_2.b                                           ; $02A9BF |\ Set the flag for the top middle Parry menu.
    TSB <r_battle_menu_flags.2                                                  ; $02A9C1 |/
    LDA #BATTLE_MENU_OPEN_PARRY_2.b                                             ; $02A9C3 |\ Set parameters to open the top middle Parry menu.
    JMP _battle_menu_prepare_open_close                                         ; $02A9C5 |/

; _battle_menu_close_parry_2 ($02:A9C8)
;
; Sets parameters to close the top middle Parry menu.
_battle_menu_close_parry_2:
    LDA #BATTLE_MENU_FLAG_2_PARRY_2.b                                           ; $02A9C8 |\ Reset the flag for the top middle Parry menu.
    TRB <r_battle_menu_flags.2                                                  ; $02A9CA |/
    LDA #BATTLE_MENU_CLOSE_PARRY_2.b                                            ; $02A9CC |\ Set parameters to close the top middle Parry menu.
    JMP _battle_menu_prepare_open_close                                         ; $02A9CE |/

; _battle_menu_open_parry_3 ($02:A9D1)
;
; Sets parameters to open the middle Parry menu.
_battle_menu_open_parry_3:
    LDA #BATTLE_MENU_FLAG_2_PARRY_3.b                                           ; $02A9D1 |\ Set the flag for the middle Parry menu.
    TSB <r_battle_menu_flags.2                                                  ; $02A9D3 |/
    LDA #BATTLE_MENU_OPEN_PARRY_3.b                                             ; $02A9D5 |\ Set parameters to open the middle Parry menu.
    JMP _battle_menu_prepare_open_close                                         ; $02A9D7 |/

; _battle_menu_close_parry_3 ($02:A9DA)
;
; Sets parameters to close the middle Parry menu.
_battle_menu_close_parry_3:
    LDA #BATTLE_MENU_FLAG_2_PARRY_3.b                                           ; $02A9DA |\ Reset the flag for the middle Parry menu.
    TRB <r_battle_menu_flags.2                                                  ; $02A9DC |/
    LDA #BATTLE_MENU_CLOSE_PARRY_3.b                                            ; $02A9DE |\ Set parameters to close the middle Parry menu.
    JMP _battle_menu_prepare_open_close                                         ; $02A9E0 |/

; _battle_menu_open_parry_4 ($02:A9E3)
;
; Sets parameters to open the bottom middle Parry menu.
_battle_menu_open_parry_4:
    LDA #BATTLE_MENU_FLAG_2_PARRY_4.b                                           ; $02A9E3 |\ Set the flag for the bottom middle Parry menu.
    TSB <r_battle_menu_flags.2                                                  ; $02A9E5 |/
    LDA #BATTLE_MENU_OPEN_PARRY_4.b                                             ; $02A9E7 |\ Set parameters to open the bottom middle Parry menu.
    JMP _battle_menu_prepare_open_close                                         ; $02A9E9 |/

; _battle_menu_close_parry_4 ($02:A9EC)
;
; Sets parameters to close the bottom middle Parry menu.
_battle_menu_close_parry_4:
    LDA #BATTLE_MENU_FLAG_2_PARRY_4.b                                           ; $02A9EC |\ Reset the flag for the bottom middle Parry menu.
    TRB <r_battle_menu_flags.2                                                  ; $02A9EE |/
    LDA #BATTLE_MENU_CLOSE_PARRY_4.b                                            ; $02A9F0 |\ Set parameters to close the bottom middle Parry menu.
    JMP _battle_menu_prepare_open_close                                         ; $02A9F2 |/

; _battle_menu_open_parry_5 ($02:A9F5)
;
; Sets parmaeters to open the bottom Parry menu.
_battle_menu_open_parry_5:
    LDA #BATTLE_MENU_FLAG_2_PARRY_5.b                                           ; $02A9F5 |\ Set the flag for the bottom Parry menu.
    TSB <r_battle_menu_flags.2                                                  ; $02A9F7 |/
    LDA #BATTLE_MENU_OPEN_PARRY_5.b                                             ; $02A9F9 |\ Set parameters to open the bottom Parry menu.
    JMP _battle_menu_prepare_open_close                                         ; $02A9FB |/

; _battle_menu_close_parry_5 ($02:A9FE)
;
; Sets parameters to close the bottom Parry menu.
_battle_menu_close_parry_5:
    LDA #BATTLE_MENU_FLAG_2_PARRY_5.b                                           ; $02A9FE |\ Reset the flag for the bottom Parry menu.
    TRB <r_battle_menu_flags.2                                                  ; $02AA00 |/
    LDA #BATTLE_MENU_CLOSE_PARRY_5.b                                            ; $02AA02 |\ Set parameters to close the bottom Parry menu.
    JMP _battle_menu_prepare_open_close                                         ; $02AA04 |/

; _battle_menu_open_change_1 ($02:AA07)
;
; Sets parameters to open the top Change menu.
_battle_menu_open_change_1:
    LDA #BATTLE_MENU_FLAG_3_CHANGE_1.b                                          ; $02AA07 |\ Set the flag for the top Change menu.
    TSB <r_battle_menu_flags.3                                                  ; $02AA09 |/
    LDA #BATTLE_MENU_OPEN_CHANGE_1.b                                            ; $02AA0B |\ Set parameters to open the top Change menu.
    JMP _battle_menu_prepare_open_close                                         ; $02AA0D |/

; _battle_menu_close_change_1 ($02:AA10)
;
; Sets parameters to close the top Change menu.
_battle_menu_close_change_1:
    LDA #BATTLE_MENU_FLAG_3_CHANGE_1.b                                          ; $02AA10 |\ Reset the flag for the top Change menu.
    TRB <r_battle_menu_flags.3                                                  ; $02AA12 |/
    LDA #BATTLE_MENU_CLOSE_CHANGE_1.b                                           ; $02AA14 |\ Set parameters to close the top Change menu.
    JMP _battle_menu_prepare_open_close                                         ; $02AA16 |/

; _battle_menu_open_change_2 ($02:AA19)
;
; Sets parameters to open the top middle Change menu.
_battle_menu_open_change_2:
    LDA #BATTLE_MENU_FLAG_3_CHANGE_2.b                                          ; $02AA19 |\ Set the flag for the top middle Change menu.
    TSB <r_battle_menu_flags.3                                                  ; $02AA1B |/
    LDA #BATTLE_MENU_OPEN_CHANGE_2.b                                            ; $02AA1D |\ Set parameters to open the top middle Change menu.
    JMP _battle_menu_prepare_open_close                                         ; $02AA1F |/

; _battle_menu_close_change_2 ($02:AA22)
;
; Sets parameters to close the top middle Change menu.
_battle_menu_close_change_2:
    LDA #BATTLE_MENU_FLAG_3_CHANGE_2.b                                          ; $02AA22 |\ Reset the flag for the top middle Change menu.
    TRB <r_battle_menu_flags.3                                                  ; $02AA24 |/
    LDA #BATTLE_MENU_CLOSE_CHANGE_2.b                                           ; $02AA26 |\ Set parameters to close the top middle Change menu.
    JMP _battle_menu_prepare_open_close                                         ; $02AA28 |/

; _battle_menu_open_change_3 ($02:AA2B)
;
; Sets parameters to open the middle Change menu.
_battle_menu_open_change_3:
    LDA #BATTLE_MENU_FLAG_3_CHANGE_3.b                                          ; $02AA2B |\ Set the flag for the middle Change menu.
    TSB <r_battle_menu_flags.3                                                  ; $02AA2D |/
    LDA #BATTLE_MENU_OPEN_CHANGE_3.b                                            ; $02AA2F |\ Set parameters to open the middle Change menu.
    JMP _battle_menu_prepare_open_close                                         ; $02AA31 |/

; _battle_menu_close_change_3 ($02:AA34)
;
; Sets parameters to close the middle Change menu.
_battle_menu_close_change_3:
    LDA #BATTLE_MENU_FLAG_3_CHANGE_3.b                                          ; $02AA34 |\ Reset the flag for the middle Change menu.
    TRB <r_battle_menu_flags.3                                                  ; $02AA36 |/
    LDA #BATTLE_MENU_CLOSE_CHANGE_3.b                                           ; $02AA38 |\ Set parameters to close the middle Change menu.
    JMP _battle_menu_prepare_open_close                                         ; $02AA3A |/

; _battle_menu_open_change_4 ($02:AA3D)
;
; Sets parameters to open the bottom middle Change menu.
_battle_menu_open_change_4:
    LDA #BATTLE_MENU_FLAG_3_CHANGE_4.b                                          ; $02AA3D |\ Set the flag for the bottom middle Change menu.
    TSB <r_battle_menu_flags.3                                                  ; $02AA3F |/
    LDA #BATTLE_MENU_OPEN_CHANGE_4.b                                            ; $02AA41 |\ Set parameters to open the bottom middle Change menu.
    JMP _battle_menu_prepare_open_close                                         ; $02AA43 |/

; _battle_menu_close_change_4 ($02:AA46)
;
; Sets parameters to close the bottom middle Change menu.
_battle_menu_close_change_4:
    LDA #BATTLE_MENU_FLAG_3_CHANGE_4.b                                          ; $02AA46 |\ Reset the flag for the bottom middle Change menu.
    TRB <r_battle_menu_flags.3                                                  ; $02AA48 |/
    LDA #BATTLE_MENU_CLOSE_CHANGE_4.b                                           ; $02AA4A |\ Set parameters to close the bottom middle Change menu.
    JMP _battle_menu_prepare_open_close                                         ; $02AA4C |/

; _battle_menu_open_change_5 ($02:AA4F)
;
; Sets parameters to open the bottom Change menu.
_battle_menu_open_change_5:
    LDA #BATTLE_MENU_FLAG_3_CHANGE_5.b                                          ; $02AA4F |\ Set the flag for the bottom Change menu.
    TSB <r_battle_menu_flags.3                                                  ; $02AA51 |/
    LDA #BATTLE_MENU_OPEN_CHANGE_5.b                                            ; $02AA53 |\ Set parameters to open the bottom Change menu.
    JMP _battle_menu_prepare_open_close                                         ; $02AA55 |/

; _battle_menu_close_change_5 ($02:AA58)
;
; Sets parameters to close the bottom Change menu.
_battle_menu_close_change_5:
    LDA #BATTLE_MENU_FLAG_3_CHANGE_5.b                                          ; $02AA58 |\ Reset the flag for the bottom Change menu.
    TRB <r_battle_menu_flags.3                                                  ; $02AA5A |/
    LDA #BATTLE_MENU_CLOSE_CHANGE_5.b                                           ; $02AA5C |\ Set parameters to close the bottom Change menu.
    JMP _battle_menu_prepare_open_close                                         ; $02AA5E |/

; _battle_menu_open_main ($02:AA61)
;
; Sets flags and parameters to open the main battle menu, which contains the
; names of the monsters and characters, and the HP of the characters.
_battle_menu_open_main:
    LDA #BATTLE_MENU_FLAG_1_MAIN.b                                              ; $02AA61 |\ Set the main menu flag in the menu flags.
    TSB <r_battle_menu_flags.1                                                  ; $02AA63 |/
    TDC                                                                         ; $02AA65 |\ Prepare to open the main battle menu.
    JSR _battle_menu_prepare_open_close                                         ; $02AA66 |/
    LDA #BATTLE_DIALOG_UPDATE_MAIN.b                                            ; $02AA69 |\ Set the flag to update the contents of the main menu.
    STA r_battle_dialog_update_pending.w                                        ; $02AA6B |/
    RTS                                                                         ; $02AA6E

; _unused_battle_menu_close_main ($02:AA6F)
;
; This seemingly unused function is the counterpart to _battle_menu_open_main.
_unused_battle_menu_close_main:
    LDA #BATTLE_MENU_FLAG_1_MAIN.b                                              ; $02AA6F |\
    TRB <r_battle_menu_flags.1                                                  ; $02AA71 | | Reset the main menu flag in the menu flags.
    LDA #BATTLE_MENU_FLAG_1_MAIN.b                                              ; $02AA73 |/
    JMP _battle_menu_prepare_open_close                                         ; $02AA75 | Jump to prepare to close the menu.

; _battle_menu_open_command ($02:AA78)
;
; Sets flags and parameters to open a command menu for the currently active
; character.
_battle_menu_open_command:
    LDX #0.w                                                                    ; $02AA78 |\ Reset the menu coordinates to 0, 0.
    STX <r_battle_menu_coordinates                                              ; $02AA7B |/
    LDA #BATTLE_MENU_FLAG_1_COMMAND.b                                           ; $02AA7D |\ Set the command menu flag.
    TSB <r_battle_menu_flags.1                                                  ; $02AA7F |/
    LDA #BATTLE_MENU_OPEN_COMMAND.b                                             ; $02AA81 |\ Set the parameters to open the command menu.
    JSR _battle_menu_prepare_open_close                                         ; $02AA83 |/
    LDA #BATTLE_DIALOG_UPDATE_COMMAND.b                                         ; $02AA86 |\ Update the command menu dialog for the current character.
    STA r_battle_dialog_update_pending.w                                        ; $02AA88 |/
    LDA r_battle_song_change_pending.w                                          ; $02AA8B |\
    BNE +++                                                                     ; $02AA8E | | If a song change is not currently pending, play the menu opening
    LDA r_battle_last_active_character_slot.w                                   ; $02AA90 | | chime for this character.
    TAX                                                                         ; $02AA93 | |
    LDA r_config.multi.l & $FFFF,X                                              ; $02AA94 | | Each controller is given a different menu chime so the players can
    BEQ +                                                                       ; $02AA98 | | easily distinguish them.
    LDA #AUDIO_MODE_EFFECT_BATTLE_COMMAND_2.b                                   ; $02AA9A | |
    BRA ++                                                                      ; $02AA9C | |
+   LDA #AUDIO_MODE_EFFECT_BATTLE_COMMAND_1.b                                   ; $02AA9E | |
++  STA r_play_audio_arg_mode.w                                                 ; $02AAA0 | |
    JSL bank04.play_audio                                                       ; $02AAA3 |/
+++ LDA #BATTLE_MENU_COMMAND.b                                                  ; $02AAA7 |\ Set the currently active menu to the command menu.
    STA r_battle_current_menu.w                                                 ; $02AAA9 |/
    RTS                                                                         ; $02AAAC

; _battle_menu_close_command ($02:AAAD)
;
; Sets parameters to close the command menu.
_battle_menu_close_command:
    LDA #BATTLE_MENU_FLAG_1_COMMAND.b                                           ; $02AAAD |\ Reset the command menu flag.
    TRB <r_battle_menu_flags.1                                                  ; $02AAAF |/
    LDA #BATTLE_MENU_CLOSE_COMMAND.b                                            ; $02AAB1 |\ Set parameters to close the command menu.
    JMP _battle_menu_prepare_open_close                                         ; $02AAB3 |/

; _battle_menu_hdma_data_inventory_reset ($02:AAB6)
;
; Resets the HDMA data for the inventory to the default values. This is
; necessary because the data gets modified while it's the actual BG3 HDMA data,
; to allow for scrolling.
_battle_menu_hdma_data_inventory_reset:
    LDX #371.w                                                                  ; $02AAB6 |\ Set the menu scroll value to 371.
    STX r_battle_menu_scroll_current.w                                          ; $02AAB9 |/
    LDY #12.w                                                                   ; $02AABC |\ Set the pixels to the next line value to 12.
    STY r_battle_menu_scroll_next_line_offset.w                                 ; $02AABF |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $02AAC2 |\ Transfer the scroll value to the accumulator.
    TXA                                                                         ; $02AAC4 |/
    LDX #0.w                                                                    ; $02AAC5 | Initialize the X register to zero.
-   STA r_battle_menu_hdma_data_inventory.9.vertical.w,X                        ; $02AAC8 | Set the scroll value in the inventory HDMA data.
    DEY                                                                         ; $02AACB |\
    BNE +                                                                       ; $02AACC | | Decrement the pixels to next line counter and if it reaches zero,
    CLC                                                                         ; $02AACE | | reset it to 12 and add four to the scroll value skip the empty
    ADC #4.w                                                                    ; $02AACF | | rows.
    LDY #12.w                                                                   ; $02AAD2 |/
+   INX                                                                         ; $02AAD5 |\
    INX                                                                         ; $02AAD6 | | Increment the X register by four to move to the next line and
    INX                                                                         ; $02AAD7 | | loop until the five visible rows have been written.
    INX                                                                         ; $02AAD8 | |
    CPX #_sizeof_scroll_hdma_data_entry.w * 60                                  ; $02AAD9 | |
    BNE -                                                                       ; $02AADC |/
    TDC                                                                         ; $02AADE |\ Switch back to 8-bit accumulator mode.
    SEP #FLAG_P_ACCUMULATOR                                                     ; $02AADF |/
    RTS                                                                         ; $02AAE1

; _battle_menu_open_inventory ($02:AAE2)
;
; Sets parameters to open the inventory menu, used for both the Item and Dart
; commands.
_battle_menu_open_inventory:
    STZ r_unknown_ef75.w                                                        ; $02AAE2 | TODO
    JSR _battle_menu_hdma_data_inventory_reset                                  ; $02AAE5 | Reset the inventory HDMA values.
    LDX #0.w                                                                    ; $02AAE8 |\ Reset the menu coordinates to 0, 0.
    STX <r_battle_menu_coordinates                                              ; $02AAEB |/
    STX r_battle_menu_inventory_rows.w                                          ; $02AAED | Set the inventory menu Y coordinates to zero.
    STZ <r_battle_menu_inventory_index                                          ; $02AAF0 | Set the inventory index to zero.
    LDA #BATTLE_MENU_FLAG_1_INVENTORY.b                                         ; $02AAF2 |\ Set the inventory menu flag.
    TSB <r_battle_menu_flags.1                                                  ; $02AAF4 |/
    LDA #BATTLE_MENU_OPEN_INVENTORY.b                                           ; $02AAF6 |\ Set the parameters to open the inventory menu.
    JSR _battle_menu_prepare_open_close                                         ; $02AAF8 |/
    LDA #BATTLE_DIALOG_UPDATE_INVENTORY.b                                       ; $02AAFB |\ Update the inventory dialog.
    STA r_battle_dialog_update_pending.w                                        ; $02AAFD |/
    JMP _battle_atb_wait_start                                                  ; $02AB00 | Active ATB wait if ATB wait is enabled.

; _unused_battle_atb_wait_start_delay ($02:AB03)
;
; If the ATB system is configured to use unknown mode $02, sets the delay to
; activate ATB waiting mode.
;
; NOTE: This suggests a possible third ATB mode that didn't make it into the
;       final game.
_unused_battle_atb_wait_start_delay:
    LDA r_config.atb_active.w                                                   ; $02AB03 |\
    CMP #$02.b                                                                  ; $02AB06 | | If the ATB mode is set to $02, set the ATB wait delay to 9.
    BNE +                                                                       ; $02AB08 | |
    LDA #9.b                                                                    ; $02AB0A | |
    STA r_battle_atb_wait_delay.w                                               ; $02AB0C |/
+   RTS                                                                         ; $02AB0F

; _unused_battle_atb_wait_end_delay ($02:AB10)
;
; If the ATB system is configured to use unknown mode $02, resets the delay and
; resets the ATB waiting flag.
_unused_battle_atb_wait_end_delay:
    LDA r_config.atb_active.w                                                   ; $02AB10 |\
    CMP #$02.b                                                                  ; $02AB13 | | If the ATB mode is set to $02, reset the ATB wait delay and the
    BNE +                                                                       ; $02AB15 | | ATB waiting flag.
    STZ r_battle_atb_wait_delay.w                                               ; $02AB17 | |
    STZ r_battle_atb_waiting.w                                                  ; $02AB1A |/
+   RTS                                                                         ; $02AB1D

; _battle_atb_wait_start ($02:AB1E)
;
; If the ATB system is configured in wait mode, sets the ATB waiting flag.
_battle_atb_wait_start:
    LDA r_config.atb_active.w                                                   ; $02AB1E |\
    BNE +                                                                       ; $02AB21 | | Set the ATB wait flag if the ATB mode is set to wait.
    INC r_battle_atb_waiting.w                                                  ; $02AB23 |/
+   RTS                                                                         ; $02AB26

; _battle_atb_wait_end ($02:AB27)
;
; If the ATB system is configured in wait mode, resets the ATB waiting flag.
_battle_atb_wait_end:
    LDA r_config.atb_active.w                                                   ; $02AB27 |\
    BNE +                                                                       ; $02AB2A | | Clear the ATB wait flag if the ATB mode is set to wait.
    STZ r_battle_atb_waiting.w                                                  ; $02AB2C |/
+   RTS                                                                         ; $02AB2F

; _battle_menu_close_inventory ($02:AB30)
;
; Sets parameters to close the inventory menu.
_battle_menu_close_inventory:
    LDA #BATTLE_MENU_FLAG_1_INVENTORY.b                                         ; $02AB30 |\ Reset the inventory menu flag.
    TRB <r_battle_menu_flags.1                                                  ; $02AB32 |/
    JSR _battle_atb_wait_end                                                    ; $02AB34 | End the ATB wait mode.
    LDA #BATTLE_MENU_CLOSE_INVENTORY.b                                          ; $02AB37 |\ Set parameters to close the inventory window.
    JMP _battle_menu_prepare_open_close                                         ; $02AB39 |/

; _battle_menu_open_hand_inventory ($02:AB3C)
;
; Sets parameters to open the hand inventory menu.
_battle_menu_open_hand_inventory:
    LDA #BATTLE_MENU_FLAG_1_HAND_INVENTORY.b                                    ; $02AB3C |\ Set the hand inventory battle menu flag.
    TSB <r_battle_menu_flags.1                                                  ; $02AB3E |/
    LDA #BATTLE_MENU_OPEN_HAND_INVENTORY.b                                      ; $02AB40 |\ Set parameters to open the hand inventory menu.
    JSR _battle_menu_prepare_open_close                                         ; $02AB42 |/
    LDA #BATTLE_DIALOG_UPDATE_HAND_INVENTORY.b                                  ; $02AB45 |\ Update the hand inventory dialog.
    STA r_battle_dialog_update_pending.w                                        ; $02AB47 |/
    RTS                                                                         ; $02AB4A

; _battle_menu_close_hand_inventory ($02:AB4B)
;
; Sets parameters to close the hand inventory menu.
_battle_menu_close_hand_inventory:
    STZ r_unknown_ef74.w                                                        ; $02AB4B | TODO
    LDA #BATTLE_MENU_FLAG_1_HAND_INVENTORY.b                                    ; $02AB4E |\ Reset the hand inventory menu flag.
    TRB <r_battle_menu_flags.1                                                  ; $02AB50 |/
    LDA #BATTLE_MENU_CLOSE_HAND_INVENTORY.b                                     ; $02AB52 |\ Set parameters to close the hand inventory menu.
    JMP _battle_menu_prepare_open_close                                         ; $02AB54 |/

; _battle_menu_open_spell_list_1 ($02:AB57)
;
; Sets parameters to open the spell list 1 menu.
_battle_menu_open_spell_list_1:
    JSR _battle_menu_hdma_data_inventory_reset                                  ; $02AB57 | Reset the inventory HDMA values.
    LDA #BATTLE_MENU_FLAG_1_SPELL_LIST_1                                        ; $02AB5A |\ Set the first spell list menu flag.
    TSB <r_battle_menu_flags.1                                                  ; $02AB5C |/
    LDA #BATTLE_MENU_OPEN_INVENTORY.b                                           ; $02AB5E |\ Set parameters to open the inventory menu.
    JSR _battle_menu_prepare_open_close                                         ; $02AB60 |/
    LDA #BATTLE_DIALOG_UPDATE_SPELL_LIST_1.b                                    ; $02AB63 |\ Update the first spell list dialog.
    STA r_battle_dialog_update_pending.w                                        ; $02AB65 |/
    JMP _battle_atb_wait_start                                                  ; $02AB68 | Set the ATB mode to wait if configured.

; _battle_menu_close_spell_list_1 ($02:AB6B)
;
; Sets parameters to close the spell list 1 menu.
_battle_menu_close_spell_list_1:
    LDA #BATTLE_MENU_FLAG_1_SPELL_LIST_1.b                                      ; $02AB6B |\ Reset the spell list 1 menu flag.
    TRB <r_battle_menu_flags.1                                                  ; $02AB6D |/
    JSR _battle_atb_wait_end                                                    ; $02AB6F | Turn off ATB waiting mode.
    LDA #BATTLE_MENU_CLOSE_INVENTORY                                            ; $02AB72 |\ Set parameters to close the inventory menu.
    JMP _battle_menu_prepare_open_close                                         ; $02AB74 |/

; _battle_menu_open_spell_list_2 ($02:AB77)
;
; Sets parameters to open the spell list 2 menu.
_battle_menu_open_spell_list_2:
    JSR _battle_menu_hdma_data_inventory_reset                                  ; $02AB77 | Reset the inventory HDMA values.
    LDA #BATTLE_MENU_FLAG_1_SPELL_LIST_2.b                                      ; $02AB7A |\ Set the second spell list menu flag.
    TSB <r_battle_menu_flags.1                                                  ; $02AB7C |/
    LDA #BATTLE_MENU_OPEN_INVENTORY.b                                           ; $02AB7E |\ Set parameters to open the inventory menu.
    JSR _battle_menu_prepare_open_close                                         ; $02AB80 |/
    LDA #BATTLE_DIALOG_UPDATE_SPELL_LIST_2.b                                    ; $02AB83 |\ Update the second spell list dialog.
    STA r_battle_dialog_update_pending.w                                        ; $02AB85 |/
    JSR _battle_atb_wait_start                                                  ; $02AB88 | Set the ATB mode to wait if configured.
    RTS                                                                         ; $02AB8B

; _battle_menu_close_spell_list_2 ($02:AB8C)
;
; Sets parameters to close the spell list 2 menu.
_battle_menu_close_spell_list_2:
    LDA #BATTLE_MENU_FLAG_1_SPELL_LIST_2.b                                      ; $02AB8C |\ Reset the spell list 2 menu flag.
    TRB <r_battle_menu_flags.1                                                  ; $02AB8E |/
    JSR _battle_atb_wait_end                                                    ; $02AB90 | Turn off ATB waiting mode.
    LDA #BATTLE_MENU_CLOSE_INVENTORY.b                                          ; $02AB93 |\ Set parameters to close the inventory menu.
    JMP _battle_menu_prepare_open_close                                         ; $02AB95 |/

; _battle_menu_open_spell_list_3 ($02:AB98)
;
; Sets parameters to open the spell list 3 menu.
_battle_menu_open_spell_list_3:
    JSR _battle_menu_hdma_data_inventory_reset                                  ; $02AB98 | Reset the inventory HDMA values.
    LDA #BATTLE_MENU_FLAG_1_SPELL_LIST_3.b                                      ; $02AB9B |\ Set the third spell list menu flag.
    TSB <r_battle_menu_flags.1                                                  ; $02AB9D |/
    LDA #BATTLE_MENU_OPEN_INVENTORY.b                                           ; $02AB9F |\ Set parameters to open the inventory menu.
    JSR _battle_menu_prepare_open_close                                         ; $02ABA1 |/
    LDA #BATTLE_DIALOG_UPDATE_SPELL_LIST_3.b                                    ; $02ABA4 |\ Update the third spell list dialog.
    STA r_battle_dialog_update_pending.w                                        ; $02ABA6 |/
    JMP _battle_atb_wait_start                                                  ; $02ABA9 | Set the ATB mode to wait if configured and return.

; _battle_menu_close_spell_list_3 ($02:ABAC)
;
; Sets parameters to close the spell list 3 menu.
_battle_menu_close_spell_list_3:
    LDA #BATTLE_MENU_FLAG_1_SPELL_LIST_3.b                                      ; $02ABAC |\ Reset the spell list 3 menu flag.
    TRB <r_battle_menu_flags.1                                                  ; $02ABAE |/
    JSR _battle_atb_wait_end                                                    ; $02ABB0 | Turn off ATB waiting mode.
    LDA #BATTLE_MENU_CLOSE_INVENTORY.b                                          ; $02ABB3 |\ Close the inventory menu.
    JMP _battle_menu_prepare_open_close                                         ; $02ABB5 |/

; _battle_menu_open_hp_and_status ($02:ABB8)
;
; Sets parameters to open the HP and status menu.
_battle_menu_open_hp_and_status:
    LDA #BATTLE_MENU_FLAG_4_HP_AND_STATUS.b                                     ; $02ABB8 |\ Set the HP and status menu flag.
    TSB <r_battle_menu_flags.4                                                  ; $02ABBA |/
    LDA #BATTLE_MENU_OPEN_HP_AND_STATUS.b                                       ; $02ABBC |\ Set parameters to open the HP and status menu.
    JSR _battle_menu_prepare_open_close                                         ; $02ABBE |/
    LDA #BATTLE_DIALOG_UPDATE_HP_AND_STATUS.b                                   ; $02ABC1 |\ Update the HP and status dialog.
    STA r_battle_dialog_update_pending.w                                        ; $02ABC3 |/
    RTS                                                                         ; $02ABC6

; _battle_menu_close_hp_and_status ($02:ABC7)
;
; Sets parameters to close the HP and status menu.
_battle_menu_close_hp_and_status:
    LDA #BATTLE_MENU_FLAG_4_HP_AND_STATUS.b                                     ; $02ABC7 |\ Reset the flag for the HP and status menu.
    TRB <r_battle_menu_flags.4                                                  ; $02ABC9 |/
    LDA #BATTLE_MENU_CLOSE_HP_AND_STATUS.b                                      ; $02ABCB |\ Set the parameters to close the HP and status menu.
    JMP _battle_menu_prepare_open_close                                         ; $02ABCD |/

; _battle_update_command_menu_close ($02:ABD0)
;
; Sets variables to indicate that a command menu should be closed. This is not a
; generic routine to close the command menu, but rather a specific one to call
; if the menu is being closed for some other reason than the character selecting
; a command. In particular, it suppresses the setting of the character's pose
; after the closing of the command menu.
_battle_update_command_menu_close:
    LDA #1.b                                                                    ; $02ABD0 |\ Disable the setting of the character's pose after the menu is
    STA r_battle_disable_menu_command_pose.w                                    ; $02ABD2 |/ closed.
    LDA #COMMAND_MENU_STATUS_PENDING_CLOSE.b                                    ; $02ABD5 |\ Flag the menu closing animation to occur.
    STA r_battle_command_menu_status.w                                          ; $02ABD7 |/
    RTS                                                                         ; $02ABDA

; _battle_update_command_menu_open ($02:ABDB)
;
; Sets variables to indicate that a command menu should be opened.
_battle_update_command_menu_open:
    LDA #1.b                                                                    ; $02ABDB |\ Set the variable that indicates a manual menu action is pending.
    STA <r_battle_current_action.manual_pending                                 ; $02ABDD |/
    JSR _battle_update_dialog_character_names                                   ; $02ABDF | Update the character names dialog (to update name colors).
    STZ r_battle_disable_menu_command_pose.w                                    ; $02ABE2 | Ensure that command menu pose changes are enabled by default.
    LDA r_battle_last_active_character_slot.w                                   ; $02ABE5 |\
    TAX                                                                         ; $02ABE8 | | Set the character's pose to normal.
    STZ r_battle_character_pose.w,X                                             ; $02ABE9 |/
    LDA #COMMAND_MENU_STATUS_PENDING_OPEN.b                                     ; $02ABEC |\ Flag that the menu opening animation is pending.
    STA r_battle_command_menu_status.w                                          ; $02ABEE |/
    RTS                                                                         ; $02ABF1

; _battle_menu_command_status_dispatch ($02:ABF2)
;
; Handles the either opening or closing of a command menu based on the value of
; the byte at $F0B4.
_battle_menu_command_status_dispatch:
    LDA r_battle_dialog_update_pending.w                                        ; $02ABF2 |\
    ORA r_battle_dialog_update_pending_2.w                                      ; $02ABF5 | | Return if there are any pending dialog updates or battle menu
    ORA r_battle_menu_update_mode.w                                             ; $02ABF8 | | updates.
    BEQ +                                                                       ; $02ABFB | |
    RTS                                                                         ; $02ABFD |/
+   LDA r_battle_command_menu_status.w                                          ; $02ABFE |\
    ASL A                                                                       ; $02AC01 | | Load the current command menu status, and then depending on the
    TAX                                                                         ; $02AC02 | | value, jump to the correct handler for that status.
    LDA battle_menu_command_status_pointer_data.l + 0,X                         ; $02AC03 | |
    STA <r_battle_generic_tmp_ptr_lo                                            ; $02AC07 | |
    LDA battle_menu_command_status_pointer_data.l + 1,X                         ; $02AC09 | |
    STA <r_battle_generic_tmp_ptr_hi                                            ; $02AC0D | |
    STZ r_battle_command_menu_status.w                                          ; $02AC0F | |
    JMP (r_battle_generic_tmp_ptr.w)                                            ; $02AC12 |/

; battle_menu_command_status_pointer_data ($02:AC15)
;
; For each possible command menu status value, determines the routine to call to
; handle that status.
battle_menu_command_status_pointer_data:
    .addr _battle_menu_command_noop                                             ; $02AC15.AC16
    .addr _battle_menu_open_command                                             ; $02AC17.AC18
    .addr _battle_menu_close_all                                                ; $02AC19.AC1A

; _battle_menu_close_all ($02:AC1B)
;
; Sets the current menu to the closing menu, which will eventually result in all
; menus being closed.
_battle_menu_close_all:
    LDA #BATTLE_MENU_CLOSING.b                                                  ; $02AC1B |\ Set the current menu to the closing menu.
    STA r_battle_current_menu.w                                                 ; $02AC1D |/

; _battle_menu_command_noop ($02:AC20)
;
; This routine does nothing but return, and is called when a command menu has
; no update to perform.
_battle_menu_command_noop:
    RTS                                                                         ; $02AC20

; _battle_menu_dispatch ($02:AC21)
;
; Handles the current battle menu by calling the associated handler routine for
; the current menu.
_battle_menu_dispatch:
    JSR _battle_menu_command_status_dispatch                                    ; $02AC21 | Schedule the opening or closing of a command menu if configured.
    LDA r_battle_atb_wait_delay.w                                               ; $02AC24 |\
    BEQ +                                                                       ; $02AC27 | | If the wait delay is non-zero, decrement its value and if it
    DEC r_battle_atb_wait_delay.w                                               ; $02AC29 | | reaches zero, set the ATB waiting flag.
    BNE +                                                                       ; $02AC2C | |
    INC r_battle_atb_waiting.w                                                  ; $02AC2E |/
+   LDA r_battle_dialog_update_pending.w                                        ; $02AC31 |\
    ORA r_battle_dialog_update_pending_2.w                                      ; $02AC34 | | Skip to the end if there are currently any dialog updates pending
    ORA r_battle_menu_update_mode.w                                             ; $02AC37 | | or if the menu needs to be updated.
    BNE +                                                                       ; $02AC3A |/
    LDA r_battle_current_menu.w                                                 ; $02AC3C |\
    ASL A                                                                       ; $02AC3F | | Otherwise, load the pointer to the handler for the current menu
    TAX                                                                         ; $02AC40 | | and jump to it.
    LDA battle_menu_process_pointer_data.l + 0,X                                ; $02AC41 | |
    STA r_battle_generic_tmp_ptr_lo.w                                           ; $02AC45 | |
    LDA battle_menu_process_pointer_data.l + 1,X                                ; $02AC48 | |
    STA r_battle_generic_tmp_ptr_hi.w                                           ; $02AC4C | |
    JMP (r_battle_generic_tmp_ptr.w)                                            ; $02AC4F |/
+   RTS                                                                         ; $02AC52

; battle_menu_process_pointer_data ($02:AC53)
;
; For each of the 17 battle menu values, determines the handler for that menu.
battle_menu_process_pointer_data:
    .addr _battle_menu_process_none                                             ; $02AC53.AC54 | $00: <none>
    .addr _battle_menu_process_command                                          ; $02AC55.AC56 | $01: Command
    .addr _battle_menu_process_parry                                            ; $02AC57.AC58 | $02: Parry
    .addr _battle_menu_process_change                                           ; $02AC59.AC5A | $03: Change
    .addr _battle_menu_process_target                                           ; $02AC5B.AC5C | $04: Target (Fight)
    .addr _battle_menu_process_item                                             ; $02AC5D.AC5E | $05: Item
    .addr _battle_menu_process_magic                                            ; $02AC5F.AC60 | $06: Magic
    .addr _battle_menu_process_target                                           ; $02AC61.AC62 | $07: Target (Command)
    .addr _battle_menu_process_closing                                          ; $02AC63.AC64 | $08: Closing
    .addr _battle_menu_process_opening_magic                                    ; $02AC65.AC66 | $09: Opening Magic
    .addr _battle_menu_process_closing_magic                                    ; $02AC67.AC68 | $0A: Closing Magic
    .addr _battle_menu_process_hand_inventory                                   ; $02AC69.AC6A | $0B: Hand Inventory
    .addr _battle_menu_process_target                                           ; $02AC6B.AC6C | $0C: Target (Item/Magic/Dart)
    .addr _battle_menu_process_closing_inventory                                ; $02AC6D.AC6E | $0D: Closing Inventory
    .addr _battle_menu_process_closing_hp_and_status_magic                      ; $02AC6F.AC70 | $0E: Closing HP and Status (Magic)
    .addr _battle_menu_process_opening_hp_and_status                            ; $02AC71.AC72 | $0F: Opening HP and Status
    .addr _battle_menu_process_closing_hp_and_status_inventory                  ; $02AC73.AC74 | $10: Closing HP and Status (Item)

; _battle_menu_process_opening_hp_and_status ($02:AC75)
;
; Menu handler for the opening HP and status menu.
_battle_menu_process_opening_hp_and_status:
    JSR _battle_menu_open_hp_and_status                                         ; $02AC75 | Open the HP and status menu.
    LDA #BATTLE_MENU_TARGET_ITEM_MAGIC.b                                        ; $02AC78 |\ Set the current menu to item and magic targeting menu.
    STA r_battle_current_menu.w                                                 ; $02AC7A |/
    RTS                                                                         ; $02AC7D

; _battle_menu_process_closing_inventory ($02:AC7E)
;
; Menu handler for the closing inventory menu.
_battle_menu_process_closing_inventory:
    JSR _battle_menu_close_inventory                                            ; $02AC7E | Close the inventory menu.
    LDA #BATTLE_MENU_COMMAND.b                                                  ; $02AC81 |\ Set the current menu to the command menu.
    STA r_battle_current_menu.w                                                 ; $02AC83 |/
    RTS                                                                         ; $02AC86

; _battle_menu_process_closing_hp_and_status_magic ($02:AC87)
;
; Menu handler for the closing HP and status (magic) menu.
_battle_menu_process_closing_hp_and_status_magic:
    JSR _battle_menu_close_hp_and_status                                        ; $02AC87 | Close the HP and status menu.
    LDA #BATTLE_MENU_MAGIC.b                                                    ; $02AC8A |\ Set the current menu to the magic menu.
    STA r_battle_current_menu.w                                                 ; $02AC8C |/
    RTS                                                                         ; $02AC8F

; _battle_menu_process_closing_hp_and_status_inventory ($02:AC90)
;
; Menu handler for the closing HP and status (item) menu.
_battle_menu_process_closing_hp_and_status_inventory:
    JSR _battle_menu_close_hp_and_status                                        ; $02AC90 | Close the HP and status menu.
    LDA #BATTLE_MENU_INVENTORY.b                                                ; $02AC93 |\ Set the current menu to the inventory menu.
    STA r_battle_current_menu.w                                                 ; $02AC95 |/
    RTS                                                                         ; $02AC98

; _get_index_from_target ($02:AC99)
;
; Given a targeting value in the accumulator, returns the index of the
; corresponding monster or character, if it is the only one being targeted.
; Otherwise, it will return $FF.
_get_index_from_target:
    LDX #0.w                                                                    ; $02AC99 |\
-   CMP bank16.index_to_target_data.l,X                                         ; $02AC9C | | Loop through the index to target map, looking for the value given
    BEQ +                                                                       ; $02ACA0 | | in the accumulator.
    INX                                                                         ; $02ACA2 | |
    CPX #bank16._sizeof_index_to_target_data.w                                  ; $02ACA3 | |
    BNE -                                                                       ; $02ACA6 |/
    LDA #$FF.b                                                                  ; $02ACA8 |\ If not found, return $FF.
    RTS                                                                         ; $02ACAA |/
+   TXA                                                                         ; $02ACAB | Otherwise, return the index of the matching monster.
    RTS                                                                         ; $02ACAC

; _set_target_cursor_coordinates ($02:ACAD)
;
; Based on the currently targeted monsters or characters in $EF8F and $EF90,
; sets the coordinates and visibility of the four targeting cursors. The exact
; drawn cursors may vary from frame to frame if more than one target is
; selected.
_set_target_cursor_coordinates:
    LDX #$0101.w                                                                ; $02ACAD |\
    STX r_battle_target_cursor_hidden.1.w                                       ; $02ACB0 | | By default, all four targeting cursors are hidden.
    STX r_battle_target_cursor_hidden.3.w                                       ; $02ACB3 |/
    LDA r_battle_target_cursor_active.w                                         ; $02ACB6 |\ If the battle target cursor is not currently active, simply return
    BEQ @done                                                                   ; $02ACB9 |/ without doing anything else.
    LDA #128.b                                                                  ; $02ACBB |\
    STA r_battle_target_cursor_coordinates.1.x.w                                ; $02ACBD | | Set the X coordinate for each of the four cursors to 128.
    STA r_battle_target_cursor_coordinates.2.x.w                                ; $02ACC0 | |
    STA r_battle_target_cursor_coordinates.3.x.w                                ; $02ACC3 | |
    STA r_battle_target_cursor_coordinates.4.x.w                                ; $02ACC6 |/
    LDY #0.w                                                                    ; $02ACC9 |\
    LDA r_battle_targets.monster.w                                              ; $02ACCC | | Load the current monster target and save it to another location.
    STA <r_set_target_cursor_coordinates_tmp                                    ; $02ACCF |/
    BEQ @no_monsters                                                            ; $02ACD1 | If no monsters are targeted, skip ahead to a later section.
    JSR _get_index_from_target                                                  ; $02ACD3 |\
    CMP #$FF.b                                                                  ; $02ACD6 | | Otherwise, determine if a single monster is being targeted.
    BEQ +                                                                       ; $02ACD8 |/
    ASL A                                                                       ; $02ACDA |\
    TAY                                                                         ; $02ACDB | | If a single monster is being targeted, set the coordinates by
    LDA r_battle_monster_cursor_coordinates.1.x.w,Y                             ; $02ACDC | | looking them up in RAM, unhide the cursor and then return.
    STA r_battle_target_cursor_coordinates.1.x.w                                ; $02ACDF | |
    LDA r_battle_monster_cursor_coordinates.1.y.w,Y                             ; $02ACE2 | |
    STA r_battle_target_cursor_coordinates.1.y.w                                ; $02ACE5 | |
    TDC                                                                         ; $02ACE8 | |
    STA r_battle_target_cursor_hidden.1.w                                       ; $02ACE9 | |
    RTS                                                                         ; $02ACEC |/
+   LDA r_battle_frame_counter.w                                                ; $02ACED |\
    AND #%00000001.b                                                            ; $02ACF0 | | On odd frames, shift the target value by four bits to put the
    BEQ +                                                                       ; $02ACF2 | | cursor on the other set of monsters. Additionally, adjust the Y
    LDY #(4 * 2).w                                                              ; $02ACF4 | | register so coordinates are read from the proper monster.
    LDA r_battle_targets.monster.w                                              ; $02ACF7 | |
    ASL A                                                                       ; $02ACFA | |
    ASL A                                                                       ; $02ACFB | |
    ASL A                                                                       ; $02ACFC | |
    ASL A                                                                       ; $02ACFD | |
    STA <r_set_target_cursor_coordinates_tmp                                    ; $02ACFE |/
+   LDX #0.w                                                                    ; $02AD00 | Initialize the X register to zero.
-   ASL <r_set_target_cursor_coordinates_tmp                                    ; $02AD03 |\
    BCC +                                                                       ; $02AD05 | | Shift out the next targeting bit and unhide the cursor if this
    TDC                                                                         ; $02AD07 | | spot is being targeted.
    STA r_battle_target_cursor_hidden.1.w,X                                     ; $02AD08 |/
    PHX                                                                         ; $02AD0B |\
    TXA                                                                         ; $02AD0C | | Set the coordinates for the current cursor to the coordinates for
    ASL A                                                                       ; $02AD0D | | the cursor of the equivalent monster index.
    TAX                                                                         ; $02AD0E | |
    LDA r_battle_monster_cursor_coordinates.1.x.w,Y                             ; $02AD0F | |
    STA r_battle_target_cursor_coordinates.1.x.w,X                              ; $02AD12 | |
    LDA r_battle_monster_cursor_coordinates.1.y.w,Y                             ; $02AD15 | |
    STA r_battle_target_cursor_coordinates.1.y.w,X                              ; $02AD18 | |
    PLX                                                                         ; $02AD1B | |
    BRA ++                                                                      ; $02AD1C |/
+   LDA #1.b                                                                    ; $02AD1E |\ Hide the cursor if this monster is not being targeted.
    STA r_battle_target_cursor_hidden.1.w,X                                     ; $02AD20 |/
++  INY                                                                         ; $02AD23 |\
    INY                                                                         ; $02AD24 | | Increment the indexes and loop until all four potential cursors
    INX                                                                         ; $02AD25 | | have been set.
    CPX #4.w                                                                    ; $02AD26 | |
    BNE -                                                                       ; $02AD29 |/
@done:
    RTS                                                                         ; $02AD2B
@no_monsters:
    LDA r_battle_targets.party.w                                                ; $02AD2C |\ Load the targeted characters and save it for later use.
    STA <r_set_target_cursor_coordinates_tmp                                    ; $02AD2F |/
    JSR _get_index_from_target                                                  ; $02AD31 |\
    CMP #$FF.b                                                                  ; $02AD34 | | If only a single character is targeted, set the cursor coordinates
    BEQ +                                                                       ; $02AD36 | | accordingly, unhide the cursor and return.
    ASL A                                                                       ; $02AD38 | |
    TAY                                                                         ; $02AD39 | |
    LDA r_battle_character_cursor_coordinates.1.x.w,Y                           ; $02AD3A | |
    STA r_battle_target_cursor_coordinates.1.x.w                                ; $02AD3D | |
    LDA r_battle_character_cursor_coordinates.1.y.w,Y                           ; $02AD40 | |
    STA r_battle_target_cursor_coordinates.1.y.w                                ; $02AD43 | |
    TDC                                                                         ; $02AD46 | |
    STA r_battle_target_cursor_hidden.1.w                                       ; $02AD47 | |
    RTS                                                                         ; $02AD4A |/
+   LDA r_battle_frame_counter.w                                                ; $02AD4B |\
    AND #%00000001.b                                                            ; $02AD4E | | On odd frames, reset the variables to skip the first three
    BEQ +                                                                       ; $02AD50 | | characters, as they are drawn on even frames.
    LDY #(3 * 2).w                                                              ; $02AD52 | |
    LDA r_battle_targets.party.w                                                ; $02AD55 | |
    ASL A                                                                       ; $02AD58 | |
    ASL A                                                                       ; $02AD59 | |
    ASL A                                                                       ; $02AD5A | |
    STA <r_set_target_cursor_coordinates_tmp                                    ; $02AD5B |/
+   LDX #0.w                                                                    ; $02AD5D | Initialize the X register to zero.
-   ASL <r_set_target_cursor_coordinates_tmp                                    ; $02AD60 |\ Shift out the next targeting value and branch accordingly.
    BCC +                                                                       ; $02AD62 |/
    TDC                                                                         ; $02AD64 |\
    STA r_battle_target_cursor_hidden.1.w,X                                     ; $02AD65 | | If this character is being targeted, unhide the cursor, and set
    PHX                                                                         ; $02AD68 | | the coordinates accordingly.
    TXA                                                                         ; $02AD69 | |
    ASL A                                                                       ; $02AD6A | |
    TAX                                                                         ; $02AD6B | |
    LDA r_battle_character_cursor_coordinates.1.x.w,Y                           ; $02AD6C | |
    STA r_battle_target_cursor_coordinates.1.x.w,X                              ; $02AD6F | |
    LDA r_battle_character_cursor_coordinates.1.y.w,Y                           ; $02AD72 | |
    STA r_battle_target_cursor_coordinates.1.y.w,X                              ; $02AD75 | |
    PLX                                                                         ; $02AD78 | |
    BRA ++                                                                      ; $02AD79 |/
+   LDA #1.b                                                                    ; $02AD7B |\ Otherwise, hide the cursor.
    STA r_battle_target_cursor_hidden.1.w,X                                     ; $02AD7D |/
++  INY                                                                         ; $02AD80 |\
    INY                                                                         ; $02AD81 | | Increment the indexes and loop until three cursors have been set.
    INX                                                                         ; $02AD82 | |
    CPX #3.w                                                                    ; $02AD83 | |
    BNE -                                                                       ; $02AD86 |/
    RTS                                                                         ; $02AD88

; _battle_menu_set_default_target ($02:AD89)
;
; Sets the default target based on the flags passed in the accumulator and the
; reversed parameter in $0E (which controls whether monsters will be considered
; left-to-right or right-to-left). Sets the target value in $EF8D.
_battle_menu_set_default_target:
    AND #BATTLE_COMMAND_FLAG_DISABLED.b | BATTLE_COMMAND_FLAG_TARGETING         ; $02AD89 |\ Set the targeting flags after extracting them from the parameter.
    STA r_battle_menu_targeting_flags.w                                         ; $02AD8B |/ (In theory, the disabled flag is never set here.)
    AND #BATTLE_COMMAND_FLAG_TARGETING_MONSTER.b                                ; $02AD8E |\ If the monster targeting flag is not enabled, branch ahead.
    BEQ @party                                                                  ; $02AD90 |/
@monster:
    LDA <r_battle_menu_set_default_target_arg_reversed                          ; $02AD92 |\
    BEQ +                                                                       ; $02AD94 | | Load either the pointer to monsters sorted horizontally left to
    LDX #r_sorted_monsters_horizontal_reversed.w                                ; $02AD96 | | right (if the parameter isn't set) or right to left (if it is
    BRA ++                                                                      ; $02AD99 | | set).
+   LDX #r_sorted_monsters_horizontal.w                                         ; $02AD9B | |
++  STX <r_battle_generic_tmp_ptr                                               ; $02AD9E |/
    LDY #0.w                                                                    ; $02ADA0 | Initialize the Y register to zero.
-   LDA (<r_battle_generic_tmp_ptr),Y                                           ; $02ADA3 |\
    TAX                                                                         ; $02ADA5 | | Loop through the eight monster slots in the loaded array until
    LDA r_monster_slot_to_id_index_pre_action.w,X                               ; $02ADA6 | | a valid monster is found. Branch ahead when it is.
    CMP #$FF.b                                                                  ; $02ADA9 | |
    BNE +                                                                       ; $02ADAB | |
    INY                                                                         ; $02ADAD | |
    CPY #8.w                                                                    ; $02ADAE | |
    BNE -                                                                       ; $02ADB1 |/
    BRA @party                                                                  ; $02ADB3 | If none was found, skip to the character-specific code.
+   LDA (<r_battle_generic_tmp_ptr),Y                                           ; $02ADB5 |\
    STA r_battle_menu_target.w                                                  ; $02ADB7 | | Otherwise, set the target to the found monster and branch.
    BRA @common                                                                 ; $02ADBA |/
@party:
    LDA #BATTLE_MENU_TARGET_PARTY_BASE.b                                        ; $02ADBC |\ Set the target to the first party slot.
    STA r_battle_menu_target.w                                                  ; $02ADBE |/
    LDX #0.w                                                                    ; $02ADC1 | Initialize the current character slot to zero.
-   LDA bank16.battle_character_slot_to_slot_map_data.l,X                       ; $02ADC4 |\ Set the Y register to the character slot in a roundabout way using
    TAY                                                                         ; $02ADC8 |/ a pointless array in ROM. NOTE: May be vestigal.
    LDA r_battle_character_disable_automatic_movement.w,Y                       ; $02ADC9 |\
    BNE +                                                                       ; $02ADCC | | If this slot is valid as a target, branch ahead to the common
    LDA r_battle_character_slot_invisible.w,Y                                   ; $02ADCE | | code.
    BNE +                                                                       ; $02ADD1 | |
    LDA r_character_slot_if_active.w,Y                                          ; $02ADD3 | |
    CMP #$FF.b                                                                  ; $02ADD6 | |
    BNE @common                                                                 ; $02ADD8 |/
+   INC r_battle_menu_target.w                                                  ; $02ADDA |\
    INX                                                                         ; $02ADDD | | Otherwise, increment the target slot and loop until all five
    CPX #5.w                                                                    ; $02ADDE | | character slots have been considered.
    BNE -                                                                       ; $02ADE1 |/
    LDX #0.w                                                                    ; $02ADE3 |\
-   LDA r_monster_slot_to_id_index_pre_action.w,X                               ; $02ADE6 | | If not valid character was found, instead search for a valid
    CMP #$FF.b                                                                  ; $02ADE9 | | monster target. If none is found, simply return. Otherwise, branch
    BNE +                                                                       ; $02ADEB | | back to the monster code to find the correct one sorted in order.
    INX                                                                         ; $02ADED | |
    CPX #8.w                                                                    ; $02ADEE | |
    BNE -                                                                       ; $02ADF1 | |
    RTS                                                                         ; $02ADF3 | |
+   JMP @monster                                                                ; $02ADF4 |/
@common:
    LDA r_battle_menu_targeting_flags.w                                         ; $02ADF7 |\
    AND #BATTLE_COMMAND_FLAG_TARGETING_ALL.b                                    ; $02ADFA | | Determine if all targeting is enabled based on the flags set on
    BEQ +                                                                       ; $02ADFC | | the inventory item.
    LDA #1.b                                                                    ; $02ADFE | |
    BRA ++                                                                      ; $02AE00 | |
+   TDC                                                                         ; $02AE02 | |
++  STA r_battle_menu_target_all_enabled.w                                      ; $02AE03 |/
    STZ r_battle_target_cursor_active.w                                         ; $02AE06 | Make the target cursor inactive.
    STZ r_battle_targets.monster.w                                              ; $02AE09 |\ Zero out both the monster and party targets.
    STZ r_battle_targets.party.w                                                ; $02AE0C |/
    LDA r_battle_menu_targeting_flags.w                                         ; $02AE0F |\
    AND #BATTLE_COMMAND_FLAG_TARGETING.b                                        ; $02AE12 | | Set the target based on the previously set value and the targeting
    CMP #BATTLE_COMMAND_FLAG_TARGETING_MONSTER_ALL.b                            ; $02AE14 | | flags. If both the monster and all flags are set, set the target
    BEQ ++                                                                      ; $02AE16 | | to monster all. If just the all flag is set, set it to party all.
    CMP #BATTLE_COMMAND_FLAG_TARGETING_ALL.b                                    ; $02AE18 | | Otherwise, use the previously selected value.
    BNE +++                                                                     ; $02AE1A | |
    LDA #BATTLE_MENU_TARGET_PARTY_ALL.b                                         ; $02AE1C | |
    JMP +                                                                       ; $02AE1E | |
++  LDA #BATTLE_MENU_TARGET_MONSTER_ALL.b                                       ; $02AE21 | |
+   STA r_battle_menu_target.w                                                  ; $02AE23 |/
+++ RTS                                                                         ; $02AE26

; _battle_menu_target_update_dpad ($02:AE27)
;
; Within the targeting menu, reads the value of the d-pad and updates the
; current target based on the buttons being pressed.
_battle_menu_target_update_dpad:
    LDA r_formation_back_attack_copy.w                                          ; $02AE27 |\ Skip this next block if the encounter is not a back attack.
    BEQ +                                                                       ; $02AE2A |/
    LDA <r_battle_joypad_repeat_hi                                              ; $02AE2C |\
    AND #JOYPAD_H_LEFT.b | JOYPAD_H_RIGHT                                       ; $02AE2E | | If it is a back attack, load the replacement left/right d-pad
    TAX                                                                         ; $02AE30 | | bits based on their current value (to flip them) and then update
    LDA bank0D.battle_back_attack_joypad_flip_data.l,X                          ; $02AE31 | | the joypad value.
    STA <r_battle_menu_target_tmp_joypad                                        ; $02AE35 | |
    LDA <r_battle_joypad_repeat_hi                                              ; $02AE37 | |
    AND #~(JOYPAD_H_LEFT | JOYPAD_H_RIGHT).b                                    ; $02AE39 | |
    ORA <r_battle_menu_target_tmp_joypad                                        ; $02AE3B | |
    BRA ++                                                                      ; $02AE3D |/
+   LDA <r_battle_joypad_repeat_hi                                              ; $02AE3F | Otherwise, just load the actual joypad value.
++  STA <r_battle_menu_target_tmp_joypad                                        ; $02AE41 | Save the value, even though it's never used again.
    AND #JOYPAD_H_DPAD.b                                                        ; $02AE43 |\
    ASL A                                                                       ; $02AE45 | | Load the pointer based on the four d-pad bits, and then jump to
    TAX                                                                         ; $02AE46 | | it.
    LDA battle_menu_target_update_pointer_data.l + 0,X                          ; $02AE47 | |
    STA <r_battle_menu_target_tmp_ptr_addr_lo                                   ; $02AE4B | | NOTE: This clearly has some interesting issues. A bank variable is
    LDA battle_menu_target_update_pointer_data.l + 1,X                          ; $02AE4D | |       set but never used. The code also jumps pointlessly.
    STA <r_battle_menu_target_tmp_ptr_addr_hi                                   ; $02AE51 | |       Combined with the unused saved joypad value, it seems there
    STZ <r_battle_menu_target_tmp_ptr_bank                                      ; $02AE53 | |       was originally something else going on here.
    JMP +                                                                       ; $02AE55 | |
+   JMP (r_battle_menu_target_tmp_ptr_addr.w)                                   ; $02AE58 |/

; battle_menu_target_update_pointer_data ($02:AE5B)
;
; For each possible combination of d-pad button presses during the targeting
; menu, contains the pointer to the handler for those presses.
battle_menu_target_update_pointer_data:
    .addr _battle_menu_target_update_none                                       ; $02AE5B.AE5C | %0000: <none>
    .addr _battle_menu_target_update_right                                      ; $02AE5D.AE5E | %0001: Right
    .addr _battle_menu_target_update_left                                       ; $02AE5F.AE60 | %0010: Left
    .addr _battle_menu_target_update_none                                       ; $02AE61.AE62 | %0011: Left+Right
    .addr _battle_menu_target_update_down                                       ; $02AE63.AE64 | %0100: Down
    .addr _battle_menu_target_update_up_down_right                              ; $02AE65.AE66 | %0101: Down+Right
    .addr _battle_menu_target_update_up_down_left                               ; $02AE67.AE68 | %0110: Down+Left
    .addr _battle_menu_target_update_down                                       ; $02AE69.AE6A | %0111: Down+Left+Right
    .addr _battle_menu_target_update_up                                         ; $02AE6B.AE6C | %1000: Up
    .addr _battle_menu_target_update_up_down_right                              ; $02AE6D.AE6E | %1001: Up+Right
    .addr _battle_menu_target_update_up_down_left                               ; $02AE6F.AE70 | %1010: Up+Left
    .addr _battle_menu_target_update_up                                         ; $02AE71.AE72 | %1011: Up+Left+Right
    .addr _battle_menu_target_update_none                                       ; $02AE73.AE74 | %1100: Up+Down
    .addr _battle_menu_target_update_right                                      ; $02AE75.AE76 | %1101: Up+Down+Right
    .addr _battle_menu_target_update_left                                       ; $02AE77.AE78 | %1110: Up+Down+Left
    .addr _battle_menu_target_update_none                                       ; $02AE79.AE7A | %1111: Up+Down+Left+Right

; _battle_menu_target_update_none ($02:AE7B)
;
; Handles no button press in the targeting menu.
_battle_menu_target_update_none:
    RTS                                                                         ; $02AE7B

; _battle_menu_target_update_down ($02:AE7C)
;
; Handles pressing down in the targeting menu.
_battle_menu_target_update_down:
    LDA r_battle_menu_target.w                                                  ; $02AE7C |\
    CMP #BATTLE_MENU_TARGET_MONSTER_ALL.b                                       ; $02AE7F | | If the target is currently set to either party all or monster all,
    BEQ @done                                                                   ; $02AE81 | | simply return as there is nothing to do.
    CMP #BATTLE_MENU_TARGET_PARTY_ALL.b                                         ; $02AE83 | |
    BEQ @done                                                                   ; $02AE85 |/
    LDA r_battle_menu_target.w                                                  ; $02AE87 |\ Copy the current target slot to a temporary variable.
    STA <r_battle_menu_target_tmp_lo                                            ; $02AE8A |/
    CMP #BATTLE_MENU_TARGET_PARTY_BASE.b                                        ; $02AE8C |\ If the value is less than the base party value, branch to the
    BCC @monster                                                                ; $02AE8E |/ monster code.
-   LDA <r_battle_menu_target_tmp_lo                                            ; $02AE90 |\
    ASL A                                                                       ; $02AE92 | | Read the designated new target for a down press on this slot.
    TAX                                                                         ; $02AE93 | |
    LDA r_battle_menu_target_map.1.up_down.w,X                                  ; $02AE94 | |
    AND #TARGET_MAP_UP_DOWN_DOWN.b                                              ; $02AE97 |/
    CMP #TARGET_MAP_NONE.b                                                      ; $02AE99 |\
    BNE +                                                                       ; $02AE9B | | If no value is set, simply return.
    RTS                                                                         ; $02AE9D |/
+   STA <r_battle_menu_target_tmp_lo                                            ; $02AE9E |\
    SEC                                                                         ; $02AEA0 | | Set the X register to the potential target's actual slot number.
    SBC #BATTLE_MENU_TARGET_PARTY_BASE.b                                        ; $02AEA1 | |
    TAX                                                                         ; $02AEA3 |/
    LDA r_battle_character_disable_automatic_movement.w,X                       ; $02AEA4 |\
    BNE -                                                                       ; $02AEA7 | | If the new target has automatic movement disabled, is invisible or
    LDA r_battle_character_slot_invisible.w,X                                   ; $02AEA9 | | is not an active slot, loop back to pretend the down button was
    BNE -                                                                       ; $02AEAC | | pressed on this slot as well.
    LDA r_character_slot_if_active.w,X                                          ; $02AEAE | |
    CMP #$FF.b                                                                  ; $02AEB1 | |
    BEQ -                                                                       ; $02AEB3 |/
    LDA <r_battle_menu_target_tmp_lo                                            ; $02AEB5 |\
    STA r_battle_menu_target.w                                                  ; $02AEB7 | | Once a valid target is found, save as the new target and return.
    RTS                                                                         ; $02AEBA |/
@monster:
    LDA <r_battle_menu_target_tmp_lo                                            ; $02AEBB |\
    ASL A                                                                       ; $02AEBD | | Read the designated new target for a down press on this slot.
    TAX                                                                         ; $02AEBE | |
    LDA r_battle_menu_target_map.1.up_down.w,X                                  ; $02AEBF | |
    AND #TARGET_MAP_UP_DOWN_DOWN.b                                              ; $02AEC2 |/
    CMP #TARGET_MAP_NONE.b                                                      ; $02AEC4 |\ If a value is set, branch ahead to handle that case.
    BNE ++                                                                      ; $02AEC6 |/
    LDX #0.w                                                                    ; $02AEC8 |\
-   LDA r_sorted_monsters_vertical_reversed.w,X                                 ; $02AECB | | Otherwise, search for a valid target starting from the bottommost
    TAY                                                                         ; $02AECE | | monster and working our way up. A target is valid if it was alive
    LDA r_monster_slot_to_id_index_pre_action.w,Y                               ; $02AECF | | before any currently executing action.
    CMP #$FF.b                                                                  ; $02AED2 | |
    BNE +                                                                       ; $02AED4 | | NOTE: By choosing to use the pre_action variant, the life glitch
    INX                                                                         ; $02AED6 | |       was enabled. Was there a valid reason to prefer the pre-
    CPX #8.w                                                                    ; $02AED7 | |       action copy of the data?
    BNE -                                                                       ; $02AEDA |/
    RTS                                                                         ; $02AEDC |\
+   TYA                                                                         ; $02AEDD | | If a valid target was found, set it as the updated target. Either
    STA r_battle_menu_target.w                                                  ; $02AEDE | | way, return afterward.
    RTS                                                                         ; $02AEE1 |/
++  STA <r_battle_menu_target_tmp_lo                                            ; $02AEE2 |\
    TAX                                                                         ; $02AEE4 | | If the chosen target is not currently available, branch back to
    LDA r_monster_slot_to_id_index_pre_action.w,X                               ; $02AEE5 | | repeat the process as if down had been pressed on the new target.
    CMP #$FF.b                                                                  ; $02AEE8 | |
    BEQ @monster                                                                ; $02AEEA |/
    LDA <r_battle_menu_target_tmp_lo                                            ; $02AEEC |\ Save the updated target value.
    STA r_battle_menu_target.w                                                  ; $02AEEE |/
@done:
    RTS                                                                         ; $02AEF1

; _battle_menu_target_update_up ($02:AEF2)
;
; Handles pressing up in the targeting menu.
_battle_menu_target_update_up:
    LDA r_battle_menu_target.w                                                  ; $02AEF2 |\
    CMP #BATTLE_MENU_TARGET_MONSTER_ALL.b                                       ; $02AEF5 | | If the target is currently set to either party all or monster all,
    BEQ @done                                                                   ; $02AEF7 | | simply return as there is nothing to do.
    CMP #BATTLE_MENU_TARGET_PARTY_ALL.b                                         ; $02AEF9 | |
    BEQ @done                                                                   ; $02AEFB |/
    LDA r_battle_menu_target.w                                                  ; $02AEFD |\ Copy the current target slot to a temporary variable.
    STA <r_battle_menu_target_tmp_lo                                            ; $02AF00 |/
    CMP #BATTLE_MENU_TARGET_PARTY_BASE.b                                        ; $02AF02 |\ If the value is less than the base party value, branch to the
    BCC @monster                                                                ; $02AF04 |/ monster code.
-   LDA <r_battle_menu_target_tmp_lo                                            ; $02AF06 |\
    ASL A                                                                       ; $02AF08 | | Read the designated new target for an up press on this slot.
    TAX                                                                         ; $02AF09 | |
    LDA r_battle_menu_target_map.1.up_down.w,X                                  ; $02AF0A | |
    AND #TARGET_MAP_UP_DOWN_UP.b                                                ; $02AF0D |/
    CMP #TARGET_MAP_NONE.b << 4                                                 ; $02AF0F |\
    BNE +                                                                       ; $02AF11 | | If no value is set, simply return.
    RTS                                                                         ; $02AF13 |/
+   LSR A                                                                       ; $02AF14 |\
    LSR A                                                                       ; $02AF15 | | Set the X register to the potential target's actual slot number.
    LSR A                                                                       ; $02AF16 | |
    LSR A                                                                       ; $02AF17 | |
    STA <r_battle_menu_target_tmp_lo                                            ; $02AF18 | |
    SEC                                                                         ; $02AF1A | |
    SBC #BATTLE_MENU_TARGET_PARTY_BASE.b                                        ; $02AF1B | |
    TAX                                                                         ; $02AF1D |/
    LDA r_battle_character_disable_automatic_movement.w,X                       ; $02AF1E |\
    BNE -                                                                       ; $02AF21 | | If the new target has automatic movement disabled, is invisible or
    LDA r_battle_character_slot_invisible.w,X                                   ; $02AF23 | | is not an active slot, loop back to pretend the up button was
    BNE -                                                                       ; $02AF26 | | pressed on this slot as well.
    LDA r_character_slot_if_active.w,X                                          ; $02AF28 | |
    CMP #$FF.b                                                                  ; $02AF2B | |
    BEQ -                                                                       ; $02AF2D |/
    LDA <r_battle_menu_target_tmp_lo                                            ; $02AF2F |\
    STA r_battle_menu_target.w                                                  ; $02AF31 | | Once a valid target is found, save as the new target and return.
    RTS                                                                         ; $02AF34 |/
@monster:
    LDA <r_battle_menu_target_tmp_lo                                            ; $02AF35 |\
    ASL A                                                                       ; $02AF37 | | Read the designated new target for an up press on this slot.
    TAX                                                                         ; $02AF38 | |
    LDA r_battle_menu_target_map.1.up_down.w,X                                  ; $02AF39 | |
    AND #TARGET_MAP_UP_DOWN_UP.b                                                ; $02AF3C |/
    CMP #TARGET_MAP_NONE.b << 4                                                 ; $02AF3E |\ If a value is set, branch ahead to handle that case.
    BNE ++                                                                      ; $02AF40 |/
    LDX #0.w                                                                    ; $02AF42 |\
-   LDA r_sorted_monsters_vertical.w,X                                          ; $02AF45 | | Otherwise, search for a valid target starting from the topmost
    TAY                                                                         ; $02AF48 | | monster and working out way down. A target is valid if it was
    LDA r_monster_slot_to_id_index_pre_action.w,Y                               ; $02AF49 | | alive before any currently executing action.
    CMP #$FF.b                                                                  ; $02AF4C | |
    BNE +                                                                       ; $02AF4E | | NOTE: Similar to down, they explicitly chose to use the pre-action
    INX                                                                         ; $02AF50 | |       copy of the data.
    CPX #8.w                                                                    ; $02AF51 | |
    BNE -                                                                       ; $02AF54 |/
    RTS                                                                         ; $02AF56 |\
+   TYA                                                                         ; $02AF57 | | If a valid target was found, set it as the updated target. Either
    STA r_battle_menu_target.w                                                  ; $02AF58 | | way, return afterward.
    RTS                                                                         ; $02AF5B |/
++  LSR A                                                                       ; $02AF5C |\
    LSR A                                                                       ; $02AF5D | | If the chosen target is not currently available, branch back to
    LSR A                                                                       ; $02AF5E | | repeat the process as if up had been pressed on the new target.
    LSR A                                                                       ; $02AF5F | |
    STA <r_battle_menu_target_tmp_lo                                            ; $02AF60 | |
    TAX                                                                         ; $02AF62 | |
    LDA r_monster_slot_to_id_index_pre_action.w,X                               ; $02AF63 | |
    CMP #$FF.b                                                                  ; $02AF66 | |
    BEQ @monster                                                                ; $02AF68 |/
    LDA <r_battle_menu_target_tmp_lo                                            ; $02AF6A |\ Save the updated target value.
    STA r_battle_menu_target.w                                                  ; $02AF6C |/
@done:
    RTS                                                                         ; $02AF6F

; _battle_menu_target_update_left ($02:AF70)
;
; Handles pressing left in the targeting menu.
_battle_menu_target_update_left:
    LDA r_battle_menu_target.w                                                  ; $02AF70 |\
    CMP #BATTLE_MENU_TARGET_MONSTER_ALL.b                                       ; $02AF73 | | If the target is set to monster all, branch to the end.
    BEQ @done                                                                   ; $02AF75 |/
    LDA r_battle_menu_target.w                                                  ; $02AF77 |\ Copy the current target value to a temporary variable.
    STA <r_battle_menu_target_tmp_lo                                            ; $02AF7A |/
    CMP #BATTLE_MENU_TARGET_PARTY_BASE.b                                        ; $02AF7C |\ If the target is a monster, branch to the monster code.
    BCC @monster                                                                ; $02AF7E |/
    CMP #BATTLE_MENU_TARGET_PARTY_ALL.b                                         ; $02AF80 |\
    BNE +                                                                       ; $02AF82 | | If the target is currently party all, change the target to the
    LDA r_battle_menu_target_last_single_party.w                                ; $02AF84 | | last recorded single party target and return.
    STA r_battle_menu_target.w                                                  ; $02AF87 | |
    RTS                                                                         ; $02AF8A |/
+   LDX #0.w                                                                    ; $02AF8B |\
-   LDA r_sorted_monsters_horizontal_reversed.w,X                               ; $02AF8E | | Search through the monsters from right to left, searching for the
    TAY                                                                         ; $02AF91 | | first valid target.
    LDA r_monster_slot_to_id_index_pre_action.w,Y                               ; $02AF92 | |
    CMP #$FF.b                                                                  ; $02AF95 | |
    BNE +                                                                       ; $02AF97 | |
    INX                                                                         ; $02AF99 | |
    CPX #8.w                                                                    ; $02AF9A | |
    BNE -                                                                       ; $02AF9D |/
    LDA <r_battle_joypad_repeat_hi                                              ; $02AF9F |\
    ORA #JOYPAD_H_B.b                                                           ; $02AFA1 | | If none was found, add a B button press into the joypad variable
    STA <r_battle_joypad_repeat_hi                                              ; $02AFA3 | | and return.
    RTS                                                                         ; $02AFA5 |/
+   LDA r_sorted_monsters_horizontal_reversed.w,X                               ; $02AFA6 |\
    STA r_battle_menu_target.w                                                  ; $02AFA9 | | Otherwise, set the target to the found monster and return.
    RTS                                                                         ; $02AFAC |/
@monster:
    LDA <r_battle_menu_target_tmp_lo                                            ; $02AFAD |\
    ASL A                                                                       ; $02AFAF | | Read the desginated target for the left button on this slot.
    TAX                                                                         ; $02AFB0 | |
    LDA r_battle_menu_target_map.1.left_right.w,X                               ; $02AFB1 | |
    AND #TARGET_MAP_LEFT_RIGHT_LEFT.b                                           ; $02AFB4 |/
    CMP #TARGET_MAP_NONE.b << 4                                                 ; $02AFB6 |\ Branch ahead if a value was explicitly set.
    BNE +                                                                       ; $02AFB8 |/
    LDA r_battle_menu_target_all_enabled.w                                      ; $02AFBA |\ If targeting all is not enabled, return without setting a target.
    BEQ @done                                                                   ; $02AFBD |/
    LDA <r_battle_menu_target_tmp_lo                                            ; $02AFBF |\
    STA r_battle_menu_target_last_single_monster.w                              ; $02AFC1 | | Otherwise, save the current target value as the last targeted
    LDA #BATTLE_MENU_TARGET_MONSTER_ALL.b                                       ; $02AFC4 | | single monster and set the target to all monsters.
    STA r_battle_menu_target.w                                                  ; $02AFC6 | |
    RTS                                                                         ; $02AFC9 |/
+   LSR A                                                                       ; $02AFCA |\
    LSR A                                                                       ; $02AFCB | | Shift the explicitly set value to the correct bit locations.
    LSR A                                                                       ; $02AFCC | |
    LSR A                                                                       ; $02AFCD | |
    STA <r_battle_menu_target_tmp_lo                                            ; $02AFCE |/
    TAX                                                                         ; $02AFD0 |\
    LDA r_monster_slot_to_id_index_pre_action.w,X                               ; $02AFD1 | | If this monster is not a valid target, loop back to simulate
    CMP #$FF.b                                                                  ; $02AFD4 | | pressing left again.
    BEQ @monster                                                                ; $02AFD6 |/
    LDA <r_battle_menu_target_tmp_lo                                            ; $02AFD8 |\ Set the final value as the new target.
    STA r_battle_menu_target.w                                                  ; $02AFDA |/
@done:
    RTS                                                                         ; $02AFDD

; _battle_menu_target_update_right ($02:AFDE)
;
; Handles right button presses in the targeting menu.
_battle_menu_target_update_right:
    LDA r_battle_menu_target.w                                                  ; $02AFDE |\
    CMP #$13.b                                                                  ; $02AFE1 | | If the target is $13, return doing nothing.
    BEQ @done                                                                   ; $02AFE3 |/  NOTE: This will never happen, and probably was meant to be $0D.
    CMP #BATTLE_MENU_TARGET_MONSTER_ALL.b                                       ; $02AFE5 |\ Branch ahead unless the current target is all monsters.
    BNE ++                                                                      ; $02AFE7 |/
    LDX #0.w                                                                    ; $02AFE9 |\
-   LDA r_sorted_monsters_horizontal.w,X                                        ; $02AFEC | | Search for the leftmost monster that's a valid target.
    TAY                                                                         ; $02AFEF | |
    LDA r_monster_slot_to_id_index_pre_action.w,Y                               ; $02AFF0 | | NOTE: This effectively discards the saved last targeted single
    CMP #$FF.b                                                                  ; $02AFF3 | |       monster. That monster could have been killed since the
    BNE +                                                                       ; $02AFF5 | |       left button was pressed, meaning it would no longer be a
    INX                                                                         ; $02AFF7 | |       valid target, though they could have simply branched from
    CPX #8.w                                                                    ; $02AFF8 | |       there.
    BNE -                                                                       ; $02AFFB |/
    LDA <r_battle_joypad_repeat_hi                                              ; $02AFFD |\
    ORA #JOYPAD_H_B.b                                                           ; $02AFFF | | If nothing was found, fake a B button press and return.
    STA <r_battle_joypad_repeat_hi                                              ; $02B001 | | NOTE: This is really odd. Is this situation even possible?
    RTS                                                                         ; $02B003 |/
+   LDA r_sorted_monsters_horizontal.w,X                                        ; $02B004 |\
    STA r_battle_menu_target.w                                                  ; $02B007 | | Otherwise, save the found target as the new target.
    RTS                                                                         ; $02B00A |/
++  LDA r_battle_menu_target.w                                                  ; $02B00B |\
    STA <r_battle_menu_target_tmp_lo                                            ; $02B00E | | If the current target is a monster, branch forward to the monster
    CMP #BATTLE_MENU_TARGET_PARTY_BASE.b                                        ; $02B010 | | code.
    BCC @monster                                                                ; $02B012 |/
    CMP #BATTLE_MENU_TARGET_PARTY_ALL.b                                         ; $02B014 |\
    BNE +                                                                       ; $02B016 | | If currently targeting the whole party, return doing nothing.
    RTS                                                                         ; $02B018 |/
+   LDA r_battle_menu_target_all_enabled.w                                      ; $02B019 |\
    BEQ +                                                                       ; $02B01C | | If targeting all is enabled, save the current target as the
    LDA <r_battle_menu_target_tmp_lo                                            ; $02B01E | | last targeted single party member and set the target to party
    STA r_battle_menu_target_last_single_party.w                                ; $02B020 | | all. Either way, return.
    LDA #BATTLE_MENU_TARGET_PARTY_ALL.b                                         ; $02B023 | |
    STA r_battle_menu_target.w                                                  ; $02B025 | |
+   RTS                                                                         ; $02B028 |/
@monster:
    LDA <r_battle_menu_target_tmp_lo                                            ; $02B029 |\
    ASL A                                                                       ; $02B02B | | Load the designated target for a right button press on this
    TAX                                                                         ; $02B02C | | monster slot.
    LDA r_battle_menu_target_map.1.left_right.w,X                               ; $02B02D | |
    AND #TARGET_MAP_LEFT_RIGHT_RIGHT.b                                          ; $02B030 |/
    CMP #TARGET_MAP_NONE.b                                                      ; $02B032 |\
    BNE +                                                                       ; $02B034 | | If none is set, instead set the target to $0A (the bottom party
    LDA #$0A.b                                                                  ; $02B036 | | slot) and then fake a down press to find the first valid target.
    STA r_battle_menu_target.w                                                  ; $02B038 | | NOTE: If there are none, the game will softlock. This can't really
    JMP _battle_menu_target_update_down                                         ; $02B03B |/        happen without hacking, however.
+   STA <r_battle_menu_target_tmp_lo                                            ; $02B03E |\
    TAX                                                                         ; $02B040 | | If a desginated target is set, check to see if it's a valid
    LDA r_monster_slot_to_id_index_pre_action.w,X                               ; $02B041 | | target. If not, loop back and repeat the button press until a
    CMP #$FF.b                                                                  ; $02B044 | | valid target is found.
    BEQ @monster                                                                ; $02B046 |/
    LDA <r_battle_menu_target_tmp_lo                                            ; $02B048 |\ Save the target as the current target.
    STA r_battle_menu_target.w                                                  ; $02B04A |/
@done:
    RTS                                                                         ; $02B04D

; _battle_menu_target_update_up_down_left ($02:B04E)
;
; Handler for a down+left or up+left button press in the targeting menu, which
; discards the down or up portion and simply pretends left was pressed alone.
_battle_menu_target_update_up_down_left:
    JMP _battle_menu_target_update_left                                         ; $02B04E

; _battle_menu_target_update_up_down_right ($02:B051)
;
; Handler for a down+right or up+right button press in the targeting menu, which
; discards the down or up portion and simply pretends right was pressed alone.
_battle_menu_target_update_up_down_right:
    JMP _battle_menu_target_update_right                                        ; $02B051

; _battle_menu_process_target ($02:B054)
;
; Handler for the targeting menu.
_battle_menu_process_target:
    JSR _battle_play_dpad_menu_sound                                            ; $02B054 | Play the menu movement sound if a d-pad button is pressed.
    LDA r_battle_menu_targeting_flags.w                                         ; $02B057 |\
    AND #BATTLE_COMMAND_FLAG_TARGETING.b                                        ; $02B05A | | Skip this next block if any of the targeting flags is set.
    BNE +                                                                       ; $02B05C |/
    LDA r_battle_last_active_character_slot.w                                   ; $02B05E |\
    TAX                                                                         ; $02B061 | | Set the party target to the target mask matching the acting slot.
    LDA bank16.index_to_target_data.l,X                                         ; $02B062 | |
    STA r_battle_targets.party.w                                                ; $02B066 |/
    STZ r_battle_targets.monster.w                                              ; $02B069 | Set the monster target to zero.
    LDX r_battle_targets.w                                                      ; $02B06C |\ Transfer the target values to the current action.
    STX <r_battle_current_action.targets                                        ; $02B06F |/
    STZ r_battle_target_cursor_active.w                                         ; $02B071 | Set the target cursor as inactive.
    LDA #BATTLE_MENU_CLOSING.b                                                  ; $02B074 |\
    STA r_battle_current_menu.w                                                 ; $02B076 | | Set the current menu to closing and return.
    RTS                                                                         ; $02B079 |/
+   LDA #1.b                                                                    ; $02B07A |\ Flag the target cursor as active.
    STA r_battle_target_cursor_active.w                                         ; $02B07C |/
    LDA r_battle_menu_targeting_flags.w                                         ; $02B07F |\
    AND #BATTLE_COMMAND_FLAG_TARGETING_SINGLE.b                                 ; $02B082 | | If single targeting is enabled, check for and process any d-pad
    BEQ +                                                                       ; $02B084 | | presses being made.
    JSR _battle_menu_target_update_dpad                                         ; $02B086 |/
+   LDA r_battle_menu_target.w                                                  ; $02B089 |\
    CMP #BATTLE_MENU_TARGET_MONSTER_ALL.b                                       ; $02B08C | | Branch to either monster code or party all code if either is
    BEQ @monster                                                                ; $02B08E | | applicable to the current target.
    CMP #BATTLE_MENU_TARGET_PARTY_BASE.b                                        ; $02B090 | |
    BCC @monster                                                                ; $02B092 | |
    CMP #BATTLE_MENU_TARGET_PARTY_ALL.b                                         ; $02B094 | |
    BEQ @party_all                                                              ; $02B096 |/
    SEC                                                                         ; $02B098 |\
    SBC #8.b                                                                    ; $02B099 | | Set the X register to the target's actual slot number.
    TAX                                                                         ; $02B09B |/
    LDA r_battle_character_disable_automatic_movement.w,X                       ; $02B09C |\
    BNE +                                                                       ; $02B09F | | If the current target no longer valid (if they have had their
    LDA r_battle_character_slot_invisible.w,X                                   ; $02B0A1 | | automatic movement disabled as part of an animation, if they're
    BNE +                                                                       ; $02B0A4 | | invisible, or if they're not active), simulate a B button press
    LDA r_character_slot_if_active.w,X                                          ; $02B0A6 | | to close the targeting menu.
    CMP #$FF.b                                                                  ; $02B0A9 | |
    BNE ++                                                                      ; $02B0AB | |
+   LDA <r_battle_joypad_repeat_hi                                              ; $02B0AD | |
    ORA #JOYPAD_H_B.b                                                           ; $02B0AF | |
    STA <r_battle_joypad_repeat_hi                                              ; $02B0B1 |/
++  LDA bank16.index_to_target_data.l,X                                         ; $02B0B3 |\
    STA r_battle_targets.party.w                                                ; $02B0B7 | | Set the target mask to the mask matching the current target.
    STZ r_battle_targets.monster.w                                              ; $02B0BA |/
    JMP @finalize                                                               ; $02B0BD | Jump to finalize the target selection.
@party_all:
    LDX #0.w                                                                    ; $02B0C0 |\ Initialize the X register and the current targeting value to zero.
    STX <r_battle_menu_target_tmp                                               ; $02B0C3 |/
-   LDA r_battle_character_disable_automatic_movement.w,X                       ; $02B0C5 |\
    BNE +                                                                       ; $02B0C8 | | If the current slot is not a valid target, skip ahead past the
    LDA r_battle_character_slot_invisible.w,X                                   ; $02B0CA | | next section.
    BNE +                                                                       ; $02B0CD | |
    LDA r_character_slot_if_active.w,X                                          ; $02B0CF | |
    CMP #$FF.b                                                                  ; $02B0D2 | |
    BEQ +                                                                       ; $02B0D4 |/
    LDA bank16.index_to_target_data.l,X                                         ; $02B0D6 |\
    ORA <r_battle_menu_target_tmp_lo                                            ; $02B0DA | | If they are a valid target, add their target mask to the target.
    STA <r_battle_menu_target_tmp_lo                                            ; $02B0DC |/
+   INX                                                                         ; $02B0DE |\
    CPX #5.w                                                                    ; $02B0DF | | Loop until all five character slots have been checked.
    BNE -                                                                       ; $02B0E2 |/
    LDA <r_battle_menu_target_tmp_lo                                            ; $02B0E4 |\ Set the party target to the calculated value.
    STA r_battle_targets.party.w                                                ; $02B0E6 |/
    STZ r_battle_targets.monster.w                                              ; $02B0E9 | Set the monster target to zero.
    JMP @finalize                                                               ; $02B0EC | Jump to finalize the target selection.
@monster:
    LDA r_battle_menu_target.w                                                  ; $02B0EF |\
    CMP #BATTLE_MENU_TARGET_MONSTER_ALL.b                                       ; $02B0F2 | | Branch to the monster all code if set.
    BEQ @monster_all                                                            ; $02B0F4 |/
    TAX                                                                         ; $02B0F6 |\
    LDA r_monster_slot_to_id_index_pre_action.w,X                               ; $02B0F7 | | If the current target is not a valid target, simulate a B button
    CMP #$FF.b                                                                  ; $02B0FA | | press.
    BNE +                                                                       ; $02B0FC | |
    LDA <r_battle_joypad_repeat_hi                                              ; $02B0FE | |
    ORA #JOYPAD_H_B.b                                                           ; $02B100 | |
    STA <r_battle_joypad_repeat_hi                                              ; $02B102 |/
+   LDA bank16.index_to_target_data.l,X                                         ; $02B104 |\
    STA r_battle_targets.monster.w                                              ; $02B108 | | Set the monster target to the mask matching the slot.
    STZ r_battle_targets.party.w                                                ; $02B10B |/
    JMP @finalize                                                               ; $02B10E | Jump to finalize the target selection.
@monster_all:
    LDX #0.w                                                                    ; $02B111 |\ Initialize the X register and the target value to zero.
    STX <r_battle_menu_target_tmp                                               ; $02B114 |/
-   LDA r_monster_slot_to_id_index_pre_action.w,X                               ; $02B116 |\
    CMP #$FF.b                                                                  ; $02B119 | | If the monster in this slot is a valid target, add their target
    BEQ +                                                                       ; $02B11B | | mask into the overall target value.
    LDA bank16.index_to_target_data.l,X                                         ; $02B11D | |
    ORA <r_battle_menu_target_tmp_lo                                            ; $02B121 | |
    STA <r_battle_menu_target_tmp_lo                                            ; $02B123 |/
+   INX                                                                         ; $02B125 |\
    CPX #8.w                                                                    ; $02B126 | | Loop until all eight monster slots have been considered.
    BNE -                                                                       ; $02B129 |/
    LDA <r_battle_menu_target_tmp_lo                                            ; $02B12B |\
    STA r_battle_targets.monster.w                                              ; $02B12D | | Set the target to the calculated monsters.
    STZ r_battle_targets.party.w                                                ; $02B130 |/
@finalize:
    LDA <r_battle_joypad_repeat_lo                                              ; $02B133 |\ Skip this next block unless the A button is pressed.
    BPL +                                                                       ; $02B135 |/
    JSR _battle_play_menu_select_sound                                          ; $02B137 | Play the menu select sound.
    LDX r_battle_targets.w                                                      ; $02B13A |\ Set the current action targets from the set targets.
    STX <r_battle_current_action.targets                                        ; $02B13D |/
    STZ r_battle_target_cursor_active.w                                         ; $02B13F | Make the target cursor inactive.
    JSR _battle_hide_menu_cursors                                               ; $02B142 | Hide the menu cursors.
    JSR _battle_hide_target_cursors                                             ; $02B145 | Hide the target cursors.
    LDA #BATTLE_MENU_CLOSING.b                                                  ; $02B148 |\
    STA r_battle_current_menu.w                                                 ; $02B14A | | Set the menu to closing and return.
    RTS                                                                         ; $02B14D |/
+   LDA <r_battle_joypad_repeat_hi                                              ; $02B14E |\ Skip this next block unless the B button is pressed.
    BPL +                                                                       ; $02B150 |/
    JSR _battle_play_menu_select_sound                                          ; $02B152 | Play the menu select sound.
    JSR _battle_hide_menu_cursors                                               ; $02B155 | Hide the menu cursors.
    JSR _battle_hide_target_cursors                                             ; $02B158 | Hide the target cursors.
    STZ r_battle_target_cursor_active.w                                         ; $02B15B | Set the target cursor as inactive.
    LDA r_battle_previous_menu.w                                                ; $02B15E |\ Restore the current menu to whatever opened the targeting menu.
    STA r_battle_current_menu.w                                                 ; $02B161 |/
+   RTS                                                                         ; $02B164

; _battle_menu_process_opening_magic ($02:B165)
;
; Menu handler when the currently active menu is an opening magic menu.
_battle_menu_process_opening_magic:
    JSR _battle_menu_open_mp                                                    ; $02B165 | Open the needed MP menu.
    LDA #BATTLE_MENU_MAGIC.b                                                    ; $02B168 |\ Set the current menu to the magic selection menu.
    STA r_battle_current_menu.w                                                 ; $02B16A |/
    RTS                                                                         ; $02B16D

; _battle_menu_process_closing_magic ($02:B16E)
;
; Menu handler when the currently active menu is a closing magic menu.
_battle_menu_process_closing_magic:
    LDA <r_battle_menu_flags.1                                                  ; $02B16E |\
    AND #BATTLE_MENU_FLAG_1_SPELL_LIST_3.b                                      ; $02B170 | | If the third spell list menu is open, close that menu.
    BEQ +                                                                       ; $02B172 | |
    JSR _battle_menu_close_spell_list_3                                         ; $02B174 | |
    BRA ++                                                                      ; $02B177 |/
+   LDA <r_battle_menu_flags.1                                                  ; $02B179 |\
    AND #BATTLE_MENU_FLAG_1_SPELL_LIST_2.b                                      ; $02B17B | | If the second spell list menu is open, close that menu.
    BEQ +                                                                       ; $02B17D | |
    JSR _battle_menu_close_spell_list_2                                         ; $02B17F | |
    BRA ++                                                                      ; $02B182 |/
+   JSR _battle_menu_close_spell_list_1                                         ; $02B184 | Otherwise, close the first spell list menu.
++  LDA #BATTLE_MENU_COMMAND.b                                                  ; $02B187 |\ Set the current menu to the command menu.
    STA r_battle_current_menu.w                                                 ; $02B189 |/
    RTS                                                                         ; $02B18C

; _battle_menu_process_closing ($02:B18D)
;
; Menu handler for the closing menu, which ensures all menus are closed and sets
; the character's pose to the pose matching their command.
_battle_menu_process_closing:
    STZ r_battle_target_cursor_active.w                                         ; $02B18D | Unset the target cursor active flag.
    JSR _battle_hide_menu_cursors                                               ; $02B190 | Hide the menu cursors.
    JSR _battle_hide_target_cursors                                             ; $02B193 | Hide the target cursors.
    JSR _battle_hide_menu_up_down_arrows                                        ; $02B196 | Hide the menu up and down arrows.
    LDA <r_battle_menu_flags.4                                                  ; $02B199 |\
    AND #BATTLE_MENU_FLAG_4_HP_AND_STATUS.b                                     ; $02B19B | | If the HP and status menu flag is set, close the HP and status
    BEQ +                                                                       ; $02B19D | | menu.
    JMP _battle_menu_close_hp_and_status                                        ; $02B19F |/
+   LDA <r_battle_menu_flags.3                                                  ; $02B1A2 |\
    BEQ +                                                                       ; $02B1A4 | | Jump to close the Change menu if open.
    JMP _battle_menu_close_change                                               ; $02B1A6 |/
+   LDA <r_battle_menu_flags.2                                                  ; $02B1A9 |\
    BEQ +                                                                       ; $02B1AB | | Jump to close the Parry menu if open.
    JMP _battle_menu_close_parry                                                ; $02B1AD |/
+   LDA <r_battle_menu_flags.1                                                  ; $02B1B0 |\
    AND #BATTLE_MENU_FLAG_1_MP.b                                                ; $02B1B2 | | Jump to close the MP menu if open.
    BEQ +                                                                       ; $02B1B4 | |
    JMP _battle_menu_close_mp                                                   ; $02B1B6 |/
+   LDA <r_battle_menu_flags.1                                                  ; $02B1B9 |\
    AND #BATTLE_MENU_FLAG_1_SPELL_LIST_3.b                                      ; $02B1BB | | Jump to close the third spell list menu if open.
    BEQ +                                                                       ; $02B1BD | |
    JMP _battle_menu_close_spell_list_3                                         ; $02B1BF |/
+   LDA <r_battle_menu_flags.1                                                  ; $02B1C2 |\
    AND #BATTLE_MENU_FLAG_1_SPELL_LIST_2.b                                      ; $02B1C4 | | Jump to close the second spell list menu if open.
    BEQ +                                                                       ; $02B1C6 | |
    JMP _battle_menu_close_spell_list_2                                         ; $02B1C8 |/
+   LDA <r_battle_menu_flags.1                                                  ; $02B1CB |\
    AND #BATTLE_MENU_FLAG_1_SPELL_LIST_1.b                                      ; $02B1CD | | Jump to close the first spell list menu if open.
    BEQ +                                                                       ; $02B1CF | |
    JMP _battle_menu_close_spell_list_1                                         ; $02B1D1 |/
+   LDA <r_battle_menu_flags.1                                                  ; $02B1D4 |\
    AND #BATTLE_MENU_FLAG_1_HAND_INVENTORY.b                                    ; $02B1D6 | | Jump to close the hand inventory menu if open.
    BEQ +                                                                       ; $02B1D8 | |
    JMP _battle_menu_close_hand_inventory                                       ; $02B1DA |/
+   LDA <r_battle_menu_flags.1                                                  ; $02B1DD |\
    AND #BATTLE_MENU_FLAG_1_INVENTORY.b                                         ; $02B1DF | | Jump to close the inventory menu if open.
    BEQ +                                                                       ; $02B1E1 | |
    JMP _battle_menu_close_inventory                                            ; $02B1E3 |/
+   LDA <r_battle_menu_flags.1                                                  ; $02B1E6 |\
    AND #BATTLE_MENU_FLAG_1_COMMAND.b                                           ; $02B1E8 | | Jump to close the command menu if open.
    BEQ +                                                                       ; $02B1EA | |
    JMP _battle_menu_close_command                                              ; $02B1EC |/
+   STA r_battle_current_menu.w                                                 ; $02B1EF | Set the current menu to no menu.
    STA <r_battle_current_action.manual_pending                                 ; $02B1F2 | Unset the manual action pending flag.
    LDA r_battle_disable_menu_command_pose.w                                    ; $02B1F4 |\ If the menu command pose setting has been disabled, branch to the
    BNE +                                                                       ; $02B1F7 |/ end.
    LDA r_battle_last_active_character_slot.w                                   ; $02B1F9 |\
    TAY                                                                         ; $02B1FC | | Set the character's pose to the initial pose for the selected menu
    LDA r_battle_menu_selected_command.w                                        ; $02B1FD | | command.
    TAX                                                                         ; $02B200 | |
    LDA bank16.battle_command_initial_pose_data.l,X                             ; $02B201 | |
    STA r_battle_character_pose.w,Y                                             ; $02B205 | |
    STA r_battle_character_pose_backup.w,Y                                      ; $02B208 |/
+   RTS                                                                         ; $02B20B

; _battle_menu_inventory_configure_inventory_to_hand_swap ($02:B20C)
;
; Configures the parameters to swap inventory items when selecting the regular
; inventory first and the hand inventory second. Sets the carry flag upon
; success and clears the carry flag if failure.
_battle_menu_inventory_configure_inventory_to_hand_swap:
    LDA r_battle_menu_inventory_selected_target_index.w                         ; $02B20C |\
    AND #%00000001.b                                                            ; $02B20F | | Copy the previously calculated equipment type of the item in the
    EOR #%00000001.b                                                            ; $02B211 | | hand inventory slot being equipped to a temporary variable. The
    TAX                                                                         ; $02B213 | | bit must be flipped because this array is reversed compared to the
    LDA <r_battle_check_equipment_compatibility_types,X                         ; $02B214 | | others (left is the low byte).
    STA <r_battle_check_equipment_compatibility_types.left                      ; $02B216 |/
    LDA r_battle_menu_inventory_selected_target_index.w                         ; $02B218 |\
    AND #%00000001.b                                                            ; $02B21B | | Set the X register to the hand inventory offset for the spot
    TAY                                                                         ; $02B21D | | being equipped. NOTE: The TAY seems useless.
    JSR _battle_get_hand_inventory_offset                                       ; $02B21E |/
    LDA r_battle_menu_inventory_selected_index.w                                ; $02B221 |\
    ASL A                                                                       ; $02B224 | | Set the Y register to the inventory offset for the originally
    ASL A                                                                       ; $02B225 | | selected item.
    TAY                                                                         ; $02B226 |/
    LDA r_battle_inventory.1.id.w,Y                                             ; $02B227 |\ If the originally selected spot is empty, skip the next check.
    BEQ +                                                                       ; $02B22A |/
    LDA r_battle_inventory.1.flags.w,Y                                          ; $02B22C |\ If the originally selected spot is disabled, branch to the error
    BMI @error                                                                  ; $02B22F |/ code.
+   LDA r_battle_hand_inventory.1.id.w,X                                        ; $02B231 |\ If the target spot is empty, skip the next check.
    BEQ +                                                                       ; $02B234 |/
    LDA r_battle_hand_inventory.1.flags.w,X                                     ; $02B236 |\ If the target item is disabled, branch to the error code.
    BMI @error                                                                  ; $02B239 |/
+   LDA r_battle_hand_inventory.1.id.w,X                                        ; $02B23B |\
    CMP r_battle_inventory.1.id.w,Y                                             ; $02B23E | | If the two items are the same, branch to the same handling code.
    BEQ @same                                                                   ; $02B241 |/
    LDA r_battle_inventory.1.count.w,Y                                          ; $02B243 |\
    CMP #1.b                                                                    ; $02B246 | | If the source count is one, branch to do a direct swap.
    BEQ @direct_swap                                                            ; $02B248 |/
    LDA <r_battle_check_equipment_compatibility_types.left                      ; $02B24A |\
    AND #EQUIPMENT_TYPE_ARROW.b                                                 ; $02B24C | | If the item currently in the hand inventory is an arrow and if
    BEQ +                                                                       ; $02B24E | | the count of the item in the regular inventory is 20 or less,
    LDA r_battle_inventory.1.count.w,Y                                          ; $02B250 | | branch to do a direct swap.
    CMP #21.b                                                                   ; $02B253 | |
    BCC @direct_swap                                                            ; $02B255 |/
+   LDA r_battle_hand_inventory.1.id.w,X                                        ; $02B257 |\ If the hand inventory spot is empty, branch to the empty hand code.
    BEQ @empty_hand                                                             ; $02B25A |/
    LDA r_battle_swap_inventory_arg_inventory_target.w                          ; $02B25C |\
    CMP #$FF.b                                                                  ; $02B25F | | Branch to the error code if there is no spot for the equipped item
    BEQ @error                                                                  ; $02B261 |/  to move to.
    LDA #BATTLE_SWAP_INVENTORY_MODE_TO_DIFFERENT_HAND.b                         ; $02B263 |\
    STA r_battle_swap_inventory_arg_mode.w                                      ; $02B265 | | Set the swap mode to different hand, set the carry flag and
    SEC                                                                         ; $02B268 | | return.
    RTS                                                                         ; $02B269 |/
@direct_swap:
    TDC                                                                         ; $02B26A |\
    STA r_battle_swap_inventory_arg_mode.w                                      ; $02B26B | | Set the swap mode to direct swap, set the carry flag and return.
    SEC                                                                         ; $02B26E | |
    RTS                                                                         ; $02B26F |/
@same:
    LDA <r_battle_check_equipment_compatibility_types.left                      ; $02B270 |\
    AND #EQUIPMENT_TYPE_ARROW.b                                                 ; $02B272 | | If the items are not arrows, branch to the error code.
    BEQ @error                                                                  ; $02B274 |/
    LDA r_battle_hand_inventory.1.count.w,Y                                     ; $02B276 |\  If there are already 20 arrows in the hand, branch to error.
    CMP #20.b                                                                   ; $02B279 | | BUG: This should use X instead of Y. This checks either another
    BEQ @error                                                                  ; $02B27B |/       slot's hand or commands. The only end change is the sound.
    LDA #BATTLE_SWAP_INVENTORY_MODE_ARROW_TO_HAND.b                             ; $02B27D |\
    STA r_battle_swap_inventory_arg_mode.w                                      ; $02B27F | | Set the swap mode to arrow to hand, set the carry flag and return.
    SEC                                                                         ; $02B282 | |
    RTS                                                                         ; $02B283 |/
@error:
    CLC                                                                         ; $02B284 |\ If an error, clear the carry flag and return.
    RTS                                                                         ; $02B285 |/
@empty_hand:
    LDA #BATTLE_SWAP_INVENTORY_MODE_TO_EMPTY_HAND.b                             ; $02B286 |\
    STA r_battle_swap_inventory_arg_mode.w                                      ; $02B288 | | Set the swap mode to empty hand and set the carry flag.
    SEC                                                                         ; $02B28B |/
    RTS                                                                         ; $02B28C

; _battle_menu_inventory_configure_hand_to_inventory_swap ($02:B28D)
;
; Configures the parameters to swap inventory items when selecting the hand
; inventory first and the regular inventory second. Sets the carry flag upon
; success and clears the carry flag if failure.
_battle_menu_inventory_configure_hand_to_inventory_swap:
    LDA r_battle_menu_inventory_selected_index.w                                ; $02B28D |\
    AND #%00000001.b                                                            ; $02B290 | | Copy the previously calculated equipment type of the item in the
    EOR #%00000001.b                                                            ; $02B292 | | originally selected hand inventory location to a temporary
    TAX                                                                         ; $02B294 | | variable. The bit must be flipped because this array is reversed
    LDA <r_battle_check_equipment_compatibility_types,X                         ; $02B295 | | compared to the others (left is the low byte).
    STA <r_battle_check_equipment_compatibility_types.left                      ; $02B297 |/
    LDA r_battle_menu_inventory_selected_index.w                                ; $02B299 |\
    AND #%00000001.b                                                            ; $02B29C | | Set the X register to the hand inventory offset for the spot being
    JSR _battle_get_hand_inventory_offset                                       ; $02B29E |/  equipped.
    LDA r_battle_menu_inventory_selected_target_index.w                         ; $02B2A1 |\
    ASL A                                                                       ; $02B2A4 | | Set the Y register to the inventory offset for the target item.
    ASL A                                                                       ; $02B2A5 | |
    TAY                                                                         ; $02B2A6 |/
    LDA r_battle_inventory.1.id.w,Y                                             ; $02B2A7 |\ If the target inventory location is empty, branch to the direct
    BEQ @direct_swap                                                            ; $02B2AA |/ swap code.
    LDA r_battle_inventory.1.flags.w,Y                                          ; $02B2AC |\ If the target inventory item is disabled, branch to the failure
    BMI @failure                                                                ; $02B2AF |/ code.
    LDA r_battle_hand_inventory.1.id.w,X                                        ; $02B2B1 |\ If the hand inventory location is empty, skip the next check and
    BEQ +                                                                       ; $02B2B4 |/ prepare for the swap.
    LDA r_battle_hand_inventory.1.flags.w,X                                     ; $02B2B6 |\ If the hand inventory item is disabled, branch to the failure code.
    BMI @failure                                                                ; $02B2B9 |/
+   LDA r_battle_hand_inventory.1.id.w,X                                        ; $02B2BB |\
    CMP r_battle_inventory.1.id.w,Y                                             ; $02B2BE | | If the target item and the hand item are the same, branch.
    BEQ @same                                                                   ; $02B2C1 |/
    LDA r_battle_inventory.1.count.w,Y                                          ; $02B2C3 |\
    CMP #1.b                                                                    ; $02B2C6 | | If the target item's count is one, branch to the direct swap.
    BEQ @direct_swap                                                            ; $02B2C8 |/
    LDA <r_battle_check_equipment_compatibility_types.left                      ; $02B2CA |\
    AND #EQUIPMENT_TYPE_ARROW.b                                                 ; $02B2CC | | If the target item is an arrow and the count is 20 or less,
    BEQ +                                                                       ; $02B2CE | | branch to do a direct swap.
    LDA r_battle_inventory.1.count.w,Y                                          ; $02B2D0 | |
    CMP #21.b                                                                   ; $02B2D3 | |
    BCC @direct_swap                                                            ; $02B2D5 |/
+   LDA r_battle_hand_inventory.1.id.w,X                                        ; $02B2D7 |\ If the hand inventory location is empty, branch to the empty hand
    BEQ @empty_hand                                                             ; $02B2DA |/ code.
    LDA r_battle_swap_inventory_arg_inventory_target.w                          ; $02B2DC |\
    CMP #$FF.b                                                                  ; $02B2DF | | Branch to the failure code if there is no target location
    BEQ @failure                                                                ; $02B2E1 |/  for the existing item available.
    LDA #BATTLE_SWAP_INVENTORY_MODE_TO_DIFFERENT_HAND.b                         ; $02B2E3 |\
    STA r_battle_swap_inventory_arg_mode.w                                      ; $02B2E5 | | Set the inventory swap mode to different hand, set the carry flag
    SEC                                                                         ; $02B2E8 | | and return.
    RTS                                                                         ; $02B2E9 |/
@failure:
    CLC                                                                         ; $02B2EA |\ If failure, clear the carry flag and return.
    RTS                                                                         ; $02B2EB |/
@direct_swap:
    TDC                                                                         ; $02B2EC |\
    STA r_battle_swap_inventory_arg_mode.w                                      ; $02B2ED | | Set the inventory swap mode to direct swap, set the carry flag and
    SEC                                                                         ; $02B2F0 | | return.
    RTS                                                                         ; $02B2F1 |/
@same:
    LDA #BATTLE_SWAP_INVENTORY_MODE_FROM_HAND.b                                 ; $02B2F2 |\
    STA r_battle_swap_inventory_arg_mode.w                                      ; $02B2F4 | | Set the inventory swap mode to "from hand", set the carry flag and
    SEC                                                                         ; $02B2F7 | | return.
    RTS                                                                         ; $02B2F8 |/
@empty_hand:
    LDA #BATTLE_SWAP_INVENTORY_MODE_TO_EMPTY_HAND.b                             ; $02B2F9 |\
    STA r_battle_swap_inventory_arg_mode.w                                      ; $02B2FB | | Set the inventory swap mode to empty hand, set the carry flag and
    SEC                                                                         ; $02B2FE | | return.
    RTS                                                                         ; $02B2FF |/

; _battle_menu_process_hand_inventory ($02:B300)
;
; Menu handler for the hand inventory menu.
_battle_menu_process_hand_inventory:
    JSR _battle_play_dpad_menu_sound                                            ; $02B300 | Play the menu movement sound if a d-pad button is pressed.
    LDA <r_battle_joypad_repeat_hi                                              ; $02B303 |\
    AND #JOYPAD_H_DPAD.b                                                        ; $02B305 | | Skip this next block if the down d-pad button is pressed.
    CMP #JOYPAD_H_DOWN.b                                                        ; $02B307 | |
    BEQ ++                                                                      ; $02B309 |/
    CMP #JOYPAD_H_LEFT.b                                                        ; $02B30B |\ Skip this next block if the left d-pad button isn't pressed.
    BNE +                                                                       ; $02B30D |/
    LDA <r_battle_menu_coordinates.x                                            ; $02B30F |\ If the left d-pad button is pressed and the X coordinate is already
    BEQ @ignore                                                                 ; $02B311 |/ zero, skip to ignore the input.
    DEC <r_battle_menu_coordinates.x                                            ; $02B313 |\
    DEC <r_battle_menu_inventory_index                                          ; $02B315 | | Otherwise, decrement the coordinate and index and branch ahead.
    BRA @next                                                                   ; $02B317 |/
+   CMP #JOYPAD_H_RIGHT.b                                                       ; $02B319 |\ If the right button isn't pressed, branch to ignore (since up is
    BNE @ignore                                                                 ; $02B31B |/ not a valid input here).
    LDA <r_battle_menu_coordinates.x                                            ; $02B31D |\
    CMP #1.b                                                                    ; $02B31F | | If the X coordinate is not the rightmost coordinate, increment the
    BEQ +                                                                       ; $02B321 | | coordinate and the index, and then branch to the next section.
    INC <r_battle_menu_coordinates.x                                            ; $02B323 | |
    INC <r_battle_menu_inventory_index                                          ; $02B325 | |
    BRA @next                                                                   ; $02B327 |/
+   DEC <r_battle_menu_coordinates.x                                            ; $02B329 |\ Otherwise, decrement the coordinate and the index and then fall
    DEC <r_battle_menu_inventory_index                                          ; $02B32B |/ through to the code that handles down button pressed.
++  JSR _battle_menu_cursor_1_hide                                              ; $02B32D | Hide the first battle menu cursor.
    JSR _battle_menu_inventory_check_selected_cursor                            ; $02B330 | Make the second cursor visible or hidden as appropriate.
    JSR _battle_menu_close_hand_inventory                                       ; $02B333 | Close the hand inventory.
    LDA #BATTLE_MENU_INVENTORY                                                  ; $02B336 |\
    STA r_battle_current_menu.w                                                 ; $02B338 | | Set the current menu to the inventory menu and return.
    RTS                                                                         ; $02B33B |/
@ignore:
    STZ r_battle_play_audio_special_mode.w                                      ; $02B33C | If ignoring, unset the audio value to play.
@next:
    LDA <r_battle_menu_coordinates.x                                            ; $02B33F |\
    TAX                                                                         ; $02B341 | | Set the first X cursor coordinate by reading the appropriate value
    LDA bank16.battle_menu_inventory_cursor_x_coordinate_data.l,X               ; $02B342 | | from ROM. Also sets the following byte to zero.
    TAX                                                                         ; $02B346 | |
    STX r_battle_menu_cursor_coordinates.1.x.w                                  ; $02B347 |/
    LDA #172.b                                                                  ; $02B34A |\
    TAX                                                                         ; $02B34C | | Set the Y coordinate explicitly to 172.
    STX r_battle_menu_cursor_coordinates.1.y.w                                  ; $02B34D |/
    JSR _battle_menu_cursor_1_show                                              ; $02B350 | Show the first cursor.
    LDA <r_battle_joypad_repeat_lo                                              ; $02B353 |\
    BMI +                                                                       ; $02B355 | | Branch to non-confirm code if the A button isn't pressed.
    JMP @non_confirm                                                            ; $02B357 |/
+   JSR _battle_play_menu_select_sound                                          ; $02B35A | Play the menu select sound.
    LDA r_battle_menu_inventory_selected.w                                      ; $02B35D |\ Skip ahead if an item is already selected.
    BNE +                                                                       ; $02B360 |/
    INC r_battle_menu_inventory_selected.w                                      ; $02B362 | Increment the selected flag.
    LDA <r_battle_menu_inventory_index                                          ; $02B365 |\
    ORA #%10000000.b                                                            ; $02B367 | | Set the high bit on the selected index to flag as hand inventory.
    STA r_battle_menu_inventory_selected_index.w                                ; $02B369 |/
    LDX r_battle_menu_cursor_coordinates.1.x.w                                  ; $02B36C |\
    INX                                                                         ; $02B36F | | Set the second cursor X coordinate to the first cursor X
    INX                                                                         ; $02B370 | | coordinate plus four.
    INX                                                                         ; $02B371 | |
    INX                                                                         ; $02B372 | |
    STX r_battle_menu_cursor_coordinates.2.x.w                                  ; $02B373 |/
    LDX r_battle_menu_cursor_coordinates.1.y.w                                  ; $02B376 |\ Set the secont cursor Y coordinate to the same value as the first.
    STX r_battle_menu_cursor_coordinates.2.y.w                                  ; $02B379 |/
    JSR _battle_menu_cursor_2_show                                              ; $02B37C | Show the second cursor.
    LDA r_battle_menu_inventory_dart.w                                          ; $02B37F |\
    BNE +                                                                       ; $02B382 | | Branch to be done unless the this is the dart menu.
    JMP @done                                                                   ; $02B384 |/
+   LDA <r_battle_menu_inventory_index                                          ; $02B387 |\
    ORA #$80.b                                                                  ; $02B389 | | Set the high bit on the target index to flag as hand inventory.
    STA r_battle_menu_inventory_selected_target_index.w                         ; $02B38B |/
    CMP r_battle_menu_inventory_selected_index.w                                ; $02B38E |\ If the items are different, branch to the swap code.
    BNE @swap                                                                   ; $02B391 |/
    LDA <r_battle_menu_inventory_index                                          ; $02B393 |\ Set the X register to the offset to the hand inventory data.
    JSR _battle_get_hand_inventory_offset                                       ; $02B395 |/
    LDA r_battle_hand_inventory.1.id.w,X                                        ; $02B398 |\ Set the action command to the item ID.
    STA <r_battle_current_action.command                                        ; $02B39B |/
    LDA r_battle_menu_inventory_dart.w                                          ; $02B39D |\
    BEQ +                                                                       ; $02B3A0 | | If this is the dart menu, branch to either the targeting section
    LDA r_battle_hand_inventory.1.flags.w,X                                     ; $02B3A2 | | or to the error secton, depending on if the item in question has
    AND #BATTLE_INVENTORY_FLAG_DARTABLE.b                                       ; $02B3A5 | | the dartable flag set.
    BEQ ++                                                                      ; $02B3A7 | |
    LDA r_battle_hand_inventory.1.flags.w,X                                     ; $02B3A9 | |
    BRA +++                                                                     ; $02B3AC |/
+   LDA r_battle_hand_inventory.1.flags.w,X                                     ; $02B3AE |\ Otherwise, check the disabled flag to branch to the same locations.
    BPL +++                                                                     ; $02B3B1 |/
++  JSR _battle_menu_cursor_2_hide                                              ; $02B3B3 |\
    STZ r_battle_menu_inventory_selected.w                                      ; $02B3B6 | | If an error, hide the second cursor, unset the selected flag, play
    JSR _battle_play_menu_error_sound                                           ; $02B3B9 | | the error sound and branch to the end.
    JMP @done                                                                   ; $02B3BC |/
+++ STZ <r_battle_menu_set_default_target_arg_reversed                          ; $02B3BF |\ Set the default target by searching for the first monster from left
    JSR _battle_menu_set_default_target                                         ; $02B3C1 |/ to right.
    LDA #BATTLE_ACTION_FLAG_WEAPON.b                                            ; $02B3C4 |\
    ORA r_battle_menu_inventory_dart.w                                          ; $02B3C6 | | Set the action flags to weapon plus the dart flag if applicable.
    STA <r_battle_current_action.flags                                          ; $02B3C9 |/
    LDA <r_battle_menu_inventory_index                                          ; $02B3CB |\ Set the command index to the inventory index.
    STA <r_battle_current_action.command_index                                  ; $02B3CD |/
    LDA #BATTLE_MENU_HAND_INVENTORY.b                                           ; $02B3CF |\ Set the previous menu to the hand inventory.
    STA r_battle_previous_menu.w                                                ; $02B3D1 |/
    LDA #BATTLE_MENU_TARGET_ITEM_MAGIC.b                                        ; $02B3D4 |\ Set the current menu to the item/magic targeting menu.
    STA r_battle_current_menu.w                                                 ; $02B3D6 |/
    STZ r_battle_menu_inventory_selected.w                                      ; $02B3D9 | Unset the selected flag.
    JSR _battle_hide_menu_cursors                                               ; $02B3DC | Hide the menu cursors.
    JMP @done                                                                   ; $02B3DF | Jump to the end of the routine.
@swap:
    LDA r_battle_menu_inventory_selected_index.w                                ; $02B3E2 |\
    BPL +                                                                       ; $02B3E5 | | If the originally selected item is in the hand inventory, hide the
    JSR _battle_menu_cursor_2_hide                                              ; $02B3E7 | | second cursor, unset the selected item flag, play the error sound
    STZ r_battle_menu_inventory_selected.w                                      ; $02B3EA | | and jump to the end.
    JSR _battle_play_menu_error_sound                                           ; $02B3ED | |
    JMP @done                                                                   ; $02B3F0 |/
+   LDA r_battle_menu_inventory_selected_target_index.w                         ; $02B3F3 |\
    AND #%00000001.b                                                            ; $02B3F6 | | Set the Y register to the index for the target hand.
    TAY                                                                         ; $02B3F8 |/
    LDA r_battle_menu_inventory_selected_index.w                                ; $02B3F9 |\
    AND #%01111111.b                                                            ; $02B3FC | | Set the X register to the battle inventory offset for the
    ASL A                                                                       ; $02B3FE | | originally selected index.
    ASL A                                                                       ; $02B3FF | |
    TAX                                                                         ; $02B400 |/
    LDA r_battle_inventory.1.id.w,X                                             ; $02B401 |\ Set the provisional item for the target hand to the selected item
    STA r_battle_check_equipment_compatibility_args.w,Y                         ; $02B404 |/ in the inventory.
    LDA r_battle_menu_inventory_selected_target_index.w                         ; $02B407 |\
    AND #%00000001.b                                                            ; $02B40A | | Flip the bit on the index to point to the other hand.
    EOR #%00000001.b                                                            ; $02B40C | |
    TAY                                                                         ; $02B40E |/
    JSR _battle_get_hand_inventory_offset                                       ; $02B40F |\
    LDA r_battle_hand_inventory.1.id.w,X                                        ; $02B412 | | Transfer the current item in the other hand to the argument.
    STA r_battle_check_equipment_compatibility_args.w,Y                         ; $02B415 |/
    JSR _battle_check_equipment_compatibility                                   ; $02B418 | Check the equipment compatibility.
    LDA r_battle_check_equipment_compatibility_result.w                         ; $02B41B |\ If the combination is invalid, branch to the error code.
    BNE +                                                                       ; $02B41E |/
    JSR _battle_menu_inventory_configure_inventory_to_hand_swap                 ; $02B420 |\ Attempt to configure the swap, and if there is an error, branch to
    BCC +                                                                       ; $02B423 |/ the error code.
    LDA r_battle_last_active_character_slot.w                                   ; $02B425 |\ Set the swap character slot to the current character slot.
    STA r_battle_swap_inventory_arg_slot.w                                      ; $02B428 |/
    LDA r_battle_menu_inventory_selected_index.w                                ; $02B42B |\
    AND #%01111111.b                                                            ; $02B42E | | Set the second swap item to the inventory index.
    STA r_battle_swap_inventory_arg_items.2.w                                   ; $02B430 |/
    LDA r_battle_menu_inventory_selected_target_index.w                         ; $02B433 |\
    AND #%01111111.b                                                            ; $02B436 | | Set the first swap item to the hand inventory index.
    STA r_battle_swap_inventory_arg_items.1.w                                   ; $02B438 |/
    LDA #BATTLE_UPDATE_DIALOG_DISPATCH_MODE_SWAP_HAND_INVENTORY.b               ; $02B43B |\ Set the dialog update mode to swap hand inventory.
    STA r_battle_update_dialog_dispatch_arg_mode.w                              ; $02B43D |/
    LDA #BATTLE_DIALOG_UPDATE_HAND_INVENTORY.b                                  ; $02B440 |\ Set the flag to update the hand inventory dialog.
    STA r_battle_dialog_update_pending.w                                        ; $02B442 |/
    LDA #BATTLE_DIALOG_UPDATE_INVENTORY.b                                       ; $02B445 |\ Set the flag to update the regular inventory dialog.
    STA r_battle_dialog_update_pending_2.w                                      ; $02B447 |/
    JSR _battle_menu_cursor_2_hide                                              ; $02B44A | Hide the second cursor.
    STZ r_battle_menu_inventory_selected.w                                      ; $02B44D | Unset the selected flag.
    BRA @done                                                                   ; $02B450 | Branch to the end.
+   JSR _battle_menu_cursor_2_hide                                              ; $02B452 |\
    STZ r_battle_menu_inventory_selected.w                                      ; $02B455 | | If there was an error, hide the second cursor, unset the selected
    JSR _battle_play_menu_error_sound                                           ; $02B458 | | flag, set the sound to the error sound and branch to the end.
    BRA @done                                                                   ; $02B45B |/
@non_confirm:
    LDA <r_battle_joypad_repeat_hi                                              ; $02B45D |\ If the B button isn't pressed, branch to the end.
    BPL @done                                                                   ; $02B45F |/
    JSR _battle_play_menu_select_sound                                          ; $02B461 | Play the menu select sound.
    LDA r_battle_menu_inventory_selected.w                                      ; $02B464 |\
    BEQ +                                                                       ; $02B467 | | If an item is already selected, unset the selected flag, hide the
    STZ r_battle_menu_inventory_selected.w                                      ; $02B469 | | second cursor, and branch to the end.
    JSR _battle_menu_cursor_2_hide                                              ; $02B46C | |
    BRA @done                                                                   ; $02B46F |/
+   JSR _battle_menu_cursor_1_hide                                              ; $02B471 | Hide the first cursor.
    JSR _battle_hide_menu_up_down_arrows                                        ; $02B474 | Hide the menu up and down arrows.
    LDX <r_battle_menu_coordinates_backup                                       ; $02B477 |\ Restore the menu coordinates for the command menu.
    STX <r_battle_menu_coordinates                                              ; $02B479 |/
    JSR _battle_menu_close_hand_inventory                                       ; $02B47B | Close the hand inventory menu.
    LDA #BATTLE_MENU_CLOSING_INVENTORY.b                                        ; $02B47E |\ Set the current menu to the closing inventory menu.
    STA r_battle_current_menu.w                                                 ; $02B480 |/
@done:
    RTS                                                                         ; $02B483

; _battle_check_equipment_compatibility ($02:B484)
;
; Proxy function to call battle_check_equipment_compatibility in bank $03.
_battle_check_equipment_compatibility:
    JSL bank03.battle_check_equipment_compatibility                             ; $02B484
    RTS                                                                         ; $02B488

; _battle_get_hand_inventory_offset ($02:B489)
;
; Given a hand inventory index in the accumulator, and the last active character
; slot in $1822, sets the X register to the offset for that hand inventory entry
; within the hand inventory array at $32DA.
_battle_get_hand_inventory_offset:
    AND #%01111111.b                                                            ; $02B489 |\
    ASL A                                                                       ; $02B48B | | Multiply the index by four, since each entry gets four bytes.
    ASL A                                                                       ; $02B48C | |
    STA <r_battle_get_hand_inventory_offset_tmp                                 ; $02B48D |/
    LDA r_battle_last_active_character_slot.w                                   ; $02B48F |\
    ASL A                                                                       ; $02B492 | | Set the X register to the character slot times eight (as each
    ASL A                                                                       ; $02B493 | | character has two entries) and add the previously calculated
    ASL A                                                                       ; $02B494 | | entry offset.
    CLC                                                                         ; $02B495 | |
    ADC <r_battle_get_hand_inventory_offset_tmp                                 ; $02B496 | |
    TAX                                                                         ; $02B498 |/
    RTS                                                                         ; $02B499

; _battle_menu_inventory_check_selected_cursor ($02:B49A)
;
; Checks the location of the selected item index, and then depending on its
; value, makes the cursor either hidden or visible for the case of exiting the
; hand inventory into the regular inventory.
_battle_menu_inventory_check_selected_cursor:
    LDA r_battle_menu_inventory_selected.w                                      ; $02B49A |\ Skip this function if nothing is selected.
    BEQ +++                                                                     ; $02B49D |/
    LDA r_battle_menu_inventory_selected_index.w                                ; $02B49F |\ If the selected item is in the hand inventory, branch to hide the
    BMI ++                                                                      ; $02B4A2 |/ cursor.
    CMP #10.b                                                                   ; $02B4A4 |\
    BCS +                                                                       ; $02B4A6 | | If the selected index is less than 10, show the second cursor.
    JMP _battle_menu_cursor_2_show                                              ; $02B4A8 |/
+   INC r_battle_menu_cursor_hidden.2.w                                         ; $02B4AB |\ Otherwise, set the hidden flag on the cursor and return.
    RTS                                                                         ; $02B4AE |/
++  JMP _battle_menu_cursor_2_hide                                              ; $02B4AF | If in the hand inventory, hide the cursor.
+++ RTS                                                                         ; $02B4B2

; _battle_menu_hand_inventory_check_selected_cursor ($02:B4B3)
;
; Checks if the selected item index is either in the hand inventory or if it is
; in one of the four inventory spots that are visible with the hand inventory
; open. If so, shows the second cursor. Otherwise, hides it.
_battle_menu_hand_inventory_check_selected_cursor:
    LDA r_battle_menu_inventory_selected.w                                      ; $02B4B3 |\ Skip this function if nothing is selected.
    BEQ +++                                                                     ; $02B4B6 |/
    LDA r_battle_menu_inventory_selected_index.w                                ; $02B4B8 |\
    BMI +                                                                       ; $02B4BB | | If the selected item is in the hand inventory or if it is in one
    CMP #10.b                                                                   ; $02B4BD | | of the four inventory spots that is visible with the hand
    BCS ++                                                                      ; $02B4BF | | inventory open, show the second cursor.
    CMP #6.b                                                                    ; $02B4C1 | |
    BCC ++                                                                      ; $02B4C3 | |
+   JMP _battle_menu_cursor_2_show                                              ; $02B4C5 |/
++  INC r_battle_menu_cursor_hidden.2.w                                         ; $02B4C8 | Otherwise, hide the second cursor.
+++ RTS                                                                         ; $02B4CB

; _battle_menu_process_item ($02:B4CC)
;
; Handler for the Item menu.
_battle_menu_process_item:
    JSR _battle_play_dpad_menu_sound                                            ; $02B4CC | Play the menu movement sound if a d-pad button is pressed.
    LDA <r_battle_joypad_repeat_hi                                              ; $02B4CF |\
    AND #JOYPAD_H_DPAD.b                                                        ; $02B4D1 | | If the up button is not pressed, branch forward to the next
    CMP #JOYPAD_H_UP.b                                                          ; $02B4D3 | | section.
    BNE ++                                                                      ; $02B4D5 |/
@up_pressed:
    LDA r_battle_menu_inventory_rows.cursor.w                                   ; $02B4D7 |\ Branch ahead if the cursor is not on row zero.
    BNE +                                                                       ; $02B4DA |/
-   JSR _battle_menu_hide_arrow_up                                              ; $02B4DC | Hide the inventory up arrow.
    JSR _battle_menu_hand_inventory_check_selected_cursor                       ; $02B4DF | Update the selected cursor for an open hand inventory.
    JSR _battle_menu_open_hand_inventory                                        ; $02B4E2 | Open the hand inventory menu.
    LDA #BATTLE_MENU_HAND_INVENTORY.b                                           ; $02B4E5 |\
    STA r_battle_current_menu.w                                                 ; $02B4E7 | | Set the current menu to the hand inventory menu and return.
    RTS                                                                         ; $02B4EA |/
@left_at_zero:
    INC <r_battle_menu_coordinates.x                                            ; $02B4EB | Increment the X coordinate to move to the right side.
    INC <r_battle_menu_inventory_index                                          ; $02B4ED | Increment the inventory index to set hand inventory index 1.
    BRA -                                                                       ; $02B4EF | Loop back to open the hand inventory.
+   LDA <r_battle_menu_coordinates.y                                            ; $02B4F1 |\ Branch ahead if the cursor is not on the top row of the visible
    BNE +                                                                       ; $02B4F3 |/ menu.
    JSR _battle_menu_inventory_scroll_up                                        ; $02B4F5 | Scroll the menu upward by a row.
    DEC r_battle_menu_inventory_rows.first_visible.w                            ; $02B4F8 | Decrement the first visible row number.
    DEC r_battle_menu_inventory_rows.cursor.w                                   ; $02B4FB | Decrement the cursor row number.
    DEC <r_battle_menu_inventory_index                                          ; $02B4FE |\ Decrement the inventory index twice to account for moving an entire
    DEC <r_battle_menu_inventory_index                                          ; $02B500 |/ row.
    BRA @next                                                                   ; $02B502 | Branch ahead to the next section of the code.
+   DEC <r_battle_menu_coordinates.y                                            ; $02B504 | Decrement the visible row that the cursor is on.
    DEC <r_battle_menu_inventory_index                                          ; $02B506 |\ Decrement the inventory index twice.
    DEC <r_battle_menu_inventory_index                                          ; $02B508 |/
    DEC r_battle_menu_inventory_rows.cursor.w                                   ; $02B50A | Decrement the current row the cursor is on.
    BRA @next                                                                   ; $02B50D | Branch ahead to the next section of the code.
++  CMP #JOYPAD_H_DOWN.b                                                        ; $02B50F |\ Skip the next section unless the down button is pressed.
    BNE ++                                                                      ; $02B511 |/
@down_pressed:
    LDA r_battle_menu_inventory_rows.cursor.w                                   ; $02B513 |\
    CMP #23.b                                                                   ; $02B516 | | If the cursor is already on the last row, cancel any d-pad sound
    BNE +                                                                       ; $02B518 | | to be played and branch ahead to the next section.
    STZ r_battle_play_audio_special_mode.w                                      ; $02B51A | |
    BRA @next                                                                   ; $02B51D |/
+   LDA <r_battle_menu_coordinates.y                                            ; $02B51F |\
    CMP #4.b                                                                    ; $02B521 | | If the cursor is already on the last visible row, scroll the menu
    BNE +                                                                       ; $02B523 | | down a row, increment the first visible row and the cursor row,
    JSR _battle_menu_inventory_scroll_down                                      ; $02B525 | | increment the inventory index twice, and skip ahead to the next
    INC r_battle_menu_inventory_rows.first_visible.w                            ; $02B528 | | section.
    INC r_battle_menu_inventory_rows.cursor.w                                   ; $02B52B | |
    INC <r_battle_menu_inventory_index                                          ; $02B52E | |
    INC <r_battle_menu_inventory_index                                          ; $02B530 | |
    BRA @next                                                                   ; $02B532 |/
+   INC <r_battle_menu_coordinates.y                                            ; $02B534 |\
    INC <r_battle_menu_inventory_index                                          ; $02B536 | | Otherwise, increase the visible row the cursor is on, increment
    INC <r_battle_menu_inventory_index                                          ; $02B538 | | the inventory index twice, increment the cursor row and branch
    INC r_battle_menu_inventory_rows.cursor.w                                   ; $02B53A | | to the next section.
    BRA @next                                                                   ; $02B53D |/
++  CMP #JOYPAD_H_LEFT.b                                                        ; $02B53F |\ Skip ahead unless the left button is the only pressed button.
    BNE ++                                                                      ; $02B541 |/
    LDA <r_battle_menu_inventory_index                                          ; $02B543 |\ If pressing left on the first entry, branch back to the left at
    BEQ @left_at_zero                                                           ; $02B545 |/ zero code (which goes to the second hand inventory entry).
    LDA <r_battle_menu_coordinates.x                                            ; $02B547 |\
    BNE +                                                                       ; $02B549 | | If the cursor is in the first column, increment the X coordinate
    INC <r_battle_menu_coordinates.x                                            ; $02B54B | | and the inventory index, and then branch back to simulate an
    INC <r_battle_menu_inventory_index                                          ; $02B54D | | up button press to move up.
    JMP @up_pressed                                                             ; $02B54F |/
+   DEC <r_battle_menu_coordinates.x                                            ; $02B552 |\
    DEC <r_battle_menu_inventory_index                                          ; $02B554 | | Otherwise, decrease the column and inventory index and branch.
    BRA @next                                                                   ; $02B556 |/
++  CMP #JOYPAD_H_RIGHT.b                                                       ; $02B558 |\ Skip this next section unless the right button is the only pressed
    BNE @next                                                                   ; $02B55A |/ button.
    LDA <r_battle_menu_inventory_index                                          ; $02B55C |\
    CMP #47.b                                                                   ; $02B55E | | If currently on the very last entry, cancel any pending d-pad
    BNE +                                                                       ; $02B560 | | sound and branch ahead to the next section.
    STZ r_battle_play_audio_special_mode.w                                      ; $02B562 | |
    BRA @next                                                                   ; $02B565 |/
+   LDA <r_battle_menu_coordinates.x                                            ; $02B567 |\
    CMP #1.b                                                                    ; $02B569 | | If currently in the right column, decrement the column to zero,
    BNE +                                                                       ; $02B56B | | decrement the inventory index, and then branch back to simulate
    DEC <r_battle_menu_coordinates.x                                            ; $02B56D | | a down press.
    DEC <r_battle_menu_inventory_index                                          ; $02B56F | |
    BRA @down_pressed                                                           ; $02B571 |/
+   INC <r_battle_menu_coordinates.x                                            ; $02B573 |\ Otherwise, increment to the right column and increment the
    INC <r_battle_menu_inventory_index                                          ; $02B575 |/ inventory index.
@next:
    JSR _battle_show_menu_up_down_arrows                                        ; $02B577 | Show the up and down arrows.
    LDA r_battle_menu_inventory_rows.first_visible.w                            ; $02B57A |\
    CMP #19.b                                                                   ; $02B57D | | If the first visible row is row 19, hide the down arrow.
    BNE +                                                                       ; $02B57F | |
    JSR _battle_menu_hide_arrow_down                                            ; $02B581 |/
+   LDA <r_battle_menu_coordinates.x                                            ; $02B584 |\
    TAX                                                                         ; $02B586 | | Set the X coordinate for the first cursor by reading the value
    LDA bank16.battle_menu_inventory_cursor_x_coordinate_data.l,X               ; $02B587 | | for this column from ROM. This also implicitly sets the unused
    TAX                                                                         ; $02B58B | | high byte of the coordinate to zero.
    STX r_battle_menu_cursor_coordinates.1.x.w                                  ; $02B58C |/
    LDA <r_battle_menu_coordinates.y                                            ; $02B58F |\
    TAX                                                                         ; $02B591 | | Repeat the process with the Y coordinate. This implicitly sets the
    LDA bank16.battle_menu_inventory_cursor_y_coordinate_data.l,X               ; $02B592 | | second hidden flag for the cursor to zero.
    TAX                                                                         ; $02B596 | |
    STX r_battle_menu_cursor_coordinates.1.y.w                                  ; $02B597 |/
    JSR _battle_menu_cursor_1_show                                              ; $02B59A | Show the first cursor.
    LDA <r_battle_joypad_repeat_lo                                              ; $02B59D |\
    BMI +                                                                       ; $02B59F | | If the A button isn't pressed, jump to the no confirm code.
    JMP @no_confirm                                                             ; $02B5A1 |/
+   JSR _battle_play_menu_select_sound                                          ; $02B5A4 | Play the menu select sound.
    LDA r_battle_menu_inventory_selected.w                                      ; $02B5A7 |\ Branch ahead if an item is already selected.
    BNE +                                                                       ; $02B5AA |/
    INC r_battle_menu_inventory_selected.w                                      ; $02B5AC | Set the selected item flag.
    LDA <r_battle_menu_inventory_index                                          ; $02B5AF |\ Set the selected index to the current index.
    STA r_battle_menu_inventory_selected_index.w                                ; $02B5B1 |/
    LDX r_battle_menu_cursor_coordinates.1.x.w                                  ; $02B5B4 |\
    INX                                                                         ; $02B5B7 | | Increment the cursor X coordinate by four and save that as the
    INX                                                                         ; $02B5B8 | | second cursor X coordinate (to offset it slightly).
    INX                                                                         ; $02B5B9 | |
    INX                                                                         ; $02B5BA | |
    STX r_battle_menu_cursor_coordinates.2.x.w                                  ; $02B5BB |/
    LDX r_battle_menu_cursor_coordinates.1.y.w                                  ; $02B5BE |\ Copy the cursor Y coordinate and hidden flag directly to the second
    STX r_battle_menu_cursor_coordinates.2.y.w                                  ; $02B5C1 |/ cursor Y coordinate.
    JSR _battle_menu_cursor_2_show                                              ; $02B5C4 | Show the second menu cursor.
    LDA r_battle_menu_inventory_dart.w                                          ; $02B5C7 |\
    BNE +                                                                       ; $02B5CA | | If dart mode isn't configured, branch to the end.
    JMP @done                                                                   ; $02B5CC |/
+   LDA <r_battle_menu_inventory_index                                          ; $02B5CF |\ Set the selected target index to the current index. (We reach here if
    STA r_battle_menu_inventory_selected_target_index.w                         ; $02B5D1 |/ either dart mode is enabled or an item is already selected.)
    JSR _battle_menu_cursor_2_hide                                              ; $02B5D4 | Hide the second cursor.
    STZ r_battle_menu_inventory_selected.w                                      ; $02B5D7 | Unset selected mode.
    LDA r_battle_menu_inventory_selected_index.w                                ; $02B5DA |\
    CMP r_battle_menu_inventory_selected_target_index.w                         ; $02B5DD | | Branch ahead if the selected index doesn't match the target index.
    BNE @swap                                                                   ; $02B5E0 |/
    LDA <r_battle_menu_inventory_index                                          ; $02B5E2 |\
    ASL A                                                                       ; $02B5E4 | | Set the X register to the offset for the current inventory index.
    ASL A                                                                       ; $02B5E5 | |
    TAX                                                                         ; $02B5E6 |/
    LDA r_battle_inventory.1.id.w,X                                             ; $02B5E7 |\ Set the current action command to the ID of the item being darted.
    STA <r_battle_current_action.command.b                                      ; $02B5EA |/
    LDA r_battle_menu_inventory_dart.w                                          ; $02B5EC |\ If dart mode isn't enabled, skip ahead to other code.
    BEQ +                                                                       ; $02B5EF |/
    LDA r_battle_inventory.1.flags.w,X                                          ; $02B5F1 |\
    AND #BATTLE_INVENTORY_FLAG_DARTABLE.b                                       ; $02B5F4 | | If the item chosen isn't dartable, branch to the failure code.
    BEQ @fail                                                                   ; $02B5F6 |/
    LDA r_battle_inventory.1.flags.w,X                                          ; $02B5F8 |\
    ORA #BATTLE_INVENTORY_FLAG_TARGETING_MONSTER.b                              ; $02B5FB | | Load the item flags and add the ability to target monsters, and
    BRA @success                                                                ; $02B5FD |/  then branch to the success code.
+   LDA r_battle_inventory.1.id.w,X                                             ; $02B5FF |\
    CMP #ITEM_FIRST_BATTLE_ITEM.b                                               ; $02B602 | | For non-dart mode, check to see if the item is enabled and has an
    BCC @fail                                                                   ; $02B604 | | ID at or above the battle item range. If so, branch to the success
    LDA r_battle_inventory.1.flags.w,X                                          ; $02B606 | | code. Otherwise, go to the failure code.
    BPL @success                                                                ; $02B609 |/
@fail:
    JSR _battle_play_menu_error_sound                                           ; $02B60B | Play the menu error sound.
    STZ r_battle_menu_inventory_selected.w                                      ; $02B60E | Unset any selected item.
    JMP @done                                                                   ; $02B611 | Branch to the end.
@success:
    PHA                                                                         ; $02B614 | Preserve the flags of the relevant item.
    STZ <r_battle_menu_set_default_target_arg_reversed                          ; $02B615 |\ Set the default target for the item, considering monsters in the
    JSR _battle_menu_set_default_target                                         ; $02B617 |/ left-to-right order.
    LDA #BATTLE_ACTION_FLAG_ITEM.b                                              ; $02B61A |\
    ORA r_battle_menu_inventory_dart.w                                          ; $02B61C | | Set the action flags to item and dart (if darting).
    STA <r_battle_current_action.flags                                          ; $02B61F |/
    LDA <r_battle_menu_inventory_index                                          ; $02B621 |\ Set the action command index to the inventory index.
    STA <r_battle_current_action.command_index                                  ; $02B623 |/
    JSR _battle_menu_cursor_1_hide                                              ; $02B625 | Hide the first cursor.
    PLA                                                                         ; $02B628 | Restore the item flags to the accumulator.
    AND #BATTLE_INVENTORY_FLAG_TARGETING_MONSTER.b                              ; $02B629 |\
    BEQ +                                                                       ; $02B62B | | If the item is flagged as targeting monsters by default, set the
    LDA #BATTLE_MENU_INVENTORY.b                                                ; $02B62D | | previous menu to the inventory menu and the current menu to the
    STA r_battle_previous_menu.w                                                ; $02B62F | | item and magic targeting menu.
    LDA #BATTLE_MENU_TARGET_ITEM_MAGIC.b                                        ; $02B632 | |
    BRA ++                                                                      ; $02B634 |/
+   LDA #BATTLE_MENU_CLOSING_HP_AND_STATUS_ITEM.b                               ; $02B636 |\
    STA r_battle_previous_menu.w                                                ; $02B638 | | Otherwise, set the previous menu to the closing HP and status
    LDA #BATTLE_MENU_OPENING_HP_AND_STATUS.b                                    ; $02B63B | | menu and set the current menu to the opening HP and status menu.
++  STA r_battle_current_menu.w                                                 ; $02B63D |/
    RTS                                                                         ; $02B640 |\ Return after setting the menus.
    JMP @done                                                                   ; $02B641 |/
@swap:
    LDA r_battle_menu_inventory_selected_index.w                                ; $02B644 |\ If the first selected item is not from the hand inventory, branch
    BPL @non_hand                                                               ; $02B647 |/ ahead to the non-hand code. (The second item can never be.)
    LDA r_battle_menu_inventory_selected_index.w                                ; $02B649 |\
    AND #%00000001.b                                                            ; $02B64C | | Set the Y register to the hand inventory index.
    TAY                                                                         ; $02B64E |/
    LDA r_battle_menu_inventory_selected_target_index.w                         ; $02B64F |\
    AND #%01111111.b                                                            ; $02B652 | | Set the X register to the target index times four (ignoring the
    ASL A                                                                       ; $02B654 | | hand inventory flag).
    ASL A                                                                       ; $02B655 | |
    TAX                                                                         ; $02B656 |/
    LDA r_battle_inventory.1.id.w,X                                             ; $02B657 |\ Load that target item and save that as the potential equipment
    STA r_battle_check_equipment_compatibility_args.w,Y                         ; $02B65A |/ value for the appropriate hand.
    LDA r_battle_menu_inventory_selected_index.w                                ; $02B65D |\
    AND #%00000001.b                                                            ; $02B660 | | Flip the bit to now focus on the other hand and transfer that
    EOR #%00000001.b                                                            ; $02B662 | | value to the Y register.
    TAY                                                                         ; $02B664 |/
    JSR _battle_get_hand_inventory_offset                                       ; $02B665 | Get the character's hand inventory offset in the X register.
    LDA r_battle_hand_inventory.1.id.w,X                                        ; $02B668 |\ Copy the character's existing equipment in that hand to the
    STA r_battle_check_equipment_compatibility_args.w,Y                         ; $02B66B |/ compatibility check parameter.
    JSR _battle_check_equipment_compatibility                                   ; $02B66E | Check if the prospective equipment is a valid combination.
    LDA r_battle_check_equipment_compatibility_result.w                         ; $02B671 |\ If the result was not valid, branch to the failure code.
    BNE @failure                                                                ; $02B674 |/
    JSR _battle_menu_inventory_configure_hand_to_inventory_swap                 ; $02B676 |\ Attempt to configure the inventory swap. If it fails, branch to
    BCC @failure                                                                ; $02B679 |/ the failure code.
    LDA r_battle_last_active_character_slot.w                                   ; $02B67B |\ Set the inventory swap slot to the active character slot.
    STA r_battle_swap_inventory_arg_slot.w                                      ; $02B67E |/
    LDA r_battle_menu_inventory_selected_target_index.w                         ; $02B681 |\
    AND #%01111111.b                                                            ; $02B684 | | Set the inventory index to the target index.
    STA r_battle_swap_inventory_arg_items.2.w                                   ; $02B686 |/
    LDA r_battle_menu_inventory_selected_index.w                                ; $02B689 |\
    AND #%01111111.b                                                            ; $02B68C | | Set the hand index to the source index.
    STA r_battle_swap_inventory_arg_items.1.w                                   ; $02B68E |/
    LDA #BATTLE_UPDATE_DIALOG_DISPATCH_MODE_SWAP_HAND_INVENTORY.b               ; $02B691 |\ Configure the dialog system to execute the hand inventory swap.
    STA r_battle_update_dialog_dispatch_arg_mode.w                              ; $02B693 |/
    LDA #BATTLE_DIALOG_UPDATE_HAND_INVENTORY.b                                  ; $02B696 |\ Update the hand inventory dialog.
    STA r_battle_dialog_update_pending.w                                        ; $02B698 |/
    LDA #BATTLE_DIALOG_UPDATE_INVENTORY.b                                       ; $02B69B |\ Update the inventory dialog.
    STA r_battle_dialog_update_pending_2.w                                      ; $02B69D |/
    STZ r_battle_menu_inventory_selected.w                                      ; $02B6A0 | Unset the selected flag.
    JSR _battle_menu_cursor_2_hide                                              ; $02B6A3 | Hide the second cursor.
    BRA @done                                                                   ; $02B6A6 | Branch to the end.
@failure:
    STZ r_battle_menu_inventory_selected.w                                      ; $02B6A8 | Unset the selected flag.
    JSR _battle_play_menu_error_sound                                           ; $02B6AB | Play the menu error sound effect.
    BRA @done                                                                   ; $02B6AE | Branch to the end.
@non_hand:
    LDA r_battle_menu_inventory_selected_index.w                                ; $02B6B0 |\ Set the first swap item index to the first selected index.
    STA r_battle_swap_inventory_arg_items.1.w                                   ; $02B6B3 |/
    LDA r_battle_menu_inventory_selected_target_index.w                         ; $02B6B6 |\ Set the second index to the target index.
    STA r_battle_swap_inventory_arg_items.2.w                                   ; $02B6B9 |/
    LDA #BATTLE_UPDATE_DIALOG_DISPATCH_MODE_SWAP_INVENTORY.b                    ; $02B6BC |\ Configure to swap inventory items.
    STA r_battle_update_dialog_dispatch_arg_mode.w                              ; $02B6BE |/
    LDA #BATTLE_DIALOG_UPDATE_INVENTORY.b                                       ; $02B6C1 |\ Configure an update to the inventory dialog.
    STA r_battle_dialog_update_pending.w                                        ; $02B6C3 |/
    BRA @done                                                                   ; $02B6C6 | Branch to the end.
@no_confirm:
    LDA <r_battle_joypad_repeat_hi                                              ; $02B6C8 |\ Skip to the end unless the B button is pressed.
    BPL @done                                                                   ; $02B6CA |/
    JSR _battle_play_menu_select_sound                                          ; $02B6CC | Play the menu select sound.
    LDA r_battle_menu_inventory_selected.w                                      ; $02B6CF |\
    BEQ +                                                                       ; $02B6D2 | | If something was previously selected, unset the selected flag and
    STZ r_battle_menu_inventory_selected.w                                      ; $02B6D4 | | hide the second cursor, before branching to the end.
    JSR _battle_menu_cursor_2_hide                                              ; $02B6D7 | |
    BRA @done                                                                   ; $02B6DA |/
+   JSR _battle_menu_cursor_1_hide                                              ; $02B6DC | Otherwise, start by hiding the first cursor.
    JSR _battle_hide_menu_up_down_arrows                                        ; $02B6DF | Hide the up and down arrows.
    LDX <r_battle_menu_coordinates_backup                                       ; $02B6E2 |\ Restore the backed up menu coordinates from the calling menu.
    STX <r_battle_menu_coordinates                                              ; $02B6E4 |/
    JSR _battle_menu_close_inventory                                            ; $02B6E6 | Close the inventory menu.
    LDA #BATTLE_MENU_COMMAND.b                                                  ; $02B6E9 |\ Set the current menu to the command menu.
    STA r_battle_current_menu.w                                                 ; $02B6EB |/
@done:
    RTS                                                                         ; $02B6EE

; _battle_menu_process_magic ($02:B6EF)
;
; Menu handler for the magic selection menu in battle.
_battle_menu_process_magic:
    JSR _battle_play_dpad_menu_sound                                            ; $02B6EF | Play the menu movement sound if a D-pad button is pressed.
    LDA <r_battle_joypad_repeat_hi                                              ; $02B6F2 |\
    AND #JOYPAD_H_DPAD.b                                                        ; $02B6F4 | | Skip the next block unless the up button on the d-pad is being
    CMP #JOYPAD_H_UP.b                                                          ; $02B6F6 | | pressed.
    BNE ++                                                                      ; $02B6F8 |/
@up:
    LDA r_battle_menu_inventory_rows.cursor.w                                   ; $02B6FA |\ If the cursor is already on the first row, branch to ignore the
    BEQ @ignore                                                                 ; $02B6FD |/ input.
    LDA <r_battle_menu_coordinates.y                                            ; $02B6FF |\
    BNE +                                                                       ; $02B701 | | If the cursor is currently on the top row of the window, scroll
    JSR _battle_menu_inventory_scroll_up                                        ; $02B703 | | the window up by one row, decrement the first visible row,
    DEC r_battle_menu_inventory_rows.first_visible.w                            ; $02B706 | | decrement the current cursor row, and decrement the index by three
    DEC r_battle_menu_inventory_rows.cursor.w                                   ; $02B709 | | to move to the previous row (three spells per row) before
    DEC <r_battle_menu_inventory_index                                          ; $02B70C | | branching to the next section.
    DEC <r_battle_menu_inventory_index                                          ; $02B70E | |
    DEC <r_battle_menu_inventory_index                                          ; $02B710 | |
    BRA @next_proxy                                                             ; $02B712 |/
+   DEC <r_battle_menu_coordinates.y                                            ; $02B714 |\
    DEC <r_battle_menu_inventory_index                                          ; $02B716 | | Otherwise, simply decrement the row the cursor is on, the index
    DEC <r_battle_menu_inventory_index                                          ; $02B718 | | and the window row of the cursor before branching to the next
    DEC <r_battle_menu_inventory_index                                          ; $02B71A | | section.
    DEC r_battle_menu_inventory_rows.cursor.w                                   ; $02B71C | |
    JMP @next                                                                   ; $02B71F |/
++  CMP #JOYPAD_H_DOWN.b                                                        ; $02B722 |\ Skip this next block unless the down d-pad button is pressed.
    BNE ++                                                                      ; $02B724 |/
@down:
    LDA r_battle_menu_inventory_rows.cursor.w                                   ; $02B726 |\
    CMP #7.b                                                                    ; $02B729 | | If the cursor is on the last magic row, branch to ignore input.
    BEQ @ignore                                                                 ; $02B72B |/
    LDA <r_battle_menu_coordinates.y                                            ; $02B72D |\
    CMP #4.b                                                                    ; $02B72F | | If the cursor is currently on the last row of the window, scroll
    BNE +                                                                       ; $02B731 | | the menu down and increment the cursor rows and index. Otherwise,
    JSR _battle_menu_inventory_scroll_down                                      ; $02B733 | | branch ahead past the next couple of blocks.
    INC r_battle_menu_inventory_rows.first_visible.w                            ; $02B736 | |
    INC r_battle_menu_inventory_rows.cursor.w                                   ; $02B739 | |
    INC <r_battle_menu_inventory_index                                          ; $02B73C | |
    INC <r_battle_menu_inventory_index                                          ; $02B73E | |
    INC <r_battle_menu_inventory_index                                          ; $02B740 |/
@next_proxy:
    BRA @next                                                                   ; $02B742 | Branch to the next section of code.
@ignore:
    STZ r_battle_play_audio_special_mode.w                                      ; $02B744 |\ If ignoring input, unset any audio special mode and then branch to
    BRA @next                                                                   ; $02B747 |/ the next section.
+   INC <r_battle_menu_coordinates.y                                            ; $02B749 |\
    INC <r_battle_menu_inventory_index                                          ; $02B74B | | If down is being pressed and the cursor is not on the last menu
    INC <r_battle_menu_inventory_index                                          ; $02B74D | | row, increment the appropriate indexes and branch to the next
    INC <r_battle_menu_inventory_index                                          ; $02B74F | | section.
    INC r_battle_menu_inventory_rows.cursor.w                                   ; $02B751 | |
    BRA @next                                                                   ; $02B754 |/
++  CMP #JOYPAD_H_LEFT.b                                                        ; $02B756 |\ Skip this next block unless the left d-pad button is pressed.
    BNE ++                                                                      ; $02B758 |/
    LDA <r_battle_menu_inventory_index                                          ; $02B75A |\ If currently already pointing to the top-left item, branch to
    BEQ @ignore                                                                 ; $02B75C |/ ignore the input.
    LDA <r_battle_menu_coordinates.x                                            ; $02B75E |\
    BNE +                                                                       ; $02B760 | | If the cursor is pointing to the leftmost item, increment the
    INC <r_battle_menu_coordinates.x                                            ; $02B762 | | coordinates by two, and then jump to simulate an up button press.
    INC <r_battle_menu_coordinates.x                                            ; $02B764 | |
    INC <r_battle_menu_inventory_index                                          ; $02B766 | |
    INC <r_battle_menu_inventory_index                                          ; $02B768 | |
    JMP @up                                                                     ; $02B76A |/
+   DEC <r_battle_menu_coordinates.x                                            ; $02B76D |\
    DEC <r_battle_menu_inventory_index                                          ; $02B76F | | Otherwise, decrement the coordinates and jump to the next code.
    BRA @next                                                                   ; $02B771 |/
++  CMP #JOYPAD_H_RIGHT.b                                                       ; $02B773 |\ Skip this next section unless the right d-pad button is pressed.
    BNE @next                                                                   ; $02B775 |/
    LDA <r_battle_menu_inventory_index                                          ; $02B777 |\
    CMP #23.b                                                                   ; $02B779 | | If on the bottom right entry, branch to ignore the input.
    BEQ @ignore                                                                 ; $02B77B |/
    LDA <r_battle_menu_coordinates.x                                            ; $02B77D |\
    CMP #2.b                                                                    ; $02B77F | | If the cursor is on the rightmost item, decrement the coordinates
    BNE +                                                                       ; $02B781 | | by two and branch to simulate a down button press.
    DEC <r_battle_menu_coordinates.x                                            ; $02B783 | |
    DEC <r_battle_menu_coordinates.x                                            ; $02B785 | |
    DEC <r_battle_menu_inventory_index                                          ; $02B787 | |
    DEC <r_battle_menu_inventory_index                                          ; $02B789 | |
    BRA @down                                                                   ; $02B78B |/
+   INC <r_battle_menu_coordinates.x                                            ; $02B78D |\ Otherwise, increment the coordinate by one and fall through to the
    INC <r_battle_menu_inventory_index                                          ; $02B78F |/ next section.
@next:
    JSR _battle_show_menu_up_down_arrows                                        ; $02B791 | Show the menu up and down arrows.
    LDA r_battle_menu_inventory_rows.first_visible.w                            ; $02B794 |\
    BNE +                                                                       ; $02B797 | | If this is the first row, hide the up arrow.
    JSR _battle_menu_hide_arrow_up                                              ; $02B799 |/
+   LDA r_battle_menu_inventory_rows.first_visible.w                            ; $02B79C |\
    CMP #3.b                                                                    ; $02B79F | | If scrolled down three entries, hide the down arrow.
    BNE +                                                                       ; $02B7A1 | |
    JSR _battle_menu_hide_arrow_down                                            ; $02B7A3 |/
+   JSR _battle_update_needed_mp                                                ; $02B7A6 | Update the needed MP for the spell.
    LDA <r_battle_menu_coordinates.x                                            ; $02B7A9 |\
    TAX                                                                         ; $02B7AB | | Set the X coordinate for the cursor by reading the value from ROM.
    LDA bank16.battle_menu_magic_cursor_x_coordinate_data.l,X                   ; $02B7AC | |
    TAX                                                                         ; $02B7B0 | |
    STX r_battle_menu_cursor_coordinates.1.x.w                                  ; $02B7B1 |/
    LDA <r_battle_menu_coordinates.y                                            ; $02B7B4 |\
    TAX                                                                         ; $02B7B6 | | Set the Y coordinate for the cursor by reading the value from ROM.
    LDA bank16.battle_menu_inventory_cursor_y_coordinate_data.l,X               ; $02B7B7 | |
    TAX                                                                         ; $02B7BB | |
    STX r_battle_menu_cursor_coordinates.1.y.w                                  ; $02B7BC |/
    JSR _battle_menu_cursor_1_show                                              ; $02B7BF | Show the first cursor.
    LDA <r_battle_joypad_repeat_lo                                              ; $02B7C2 |\ Skip to nearly the end unless the A button is pressed.
    BPL @not_confirm                                                            ; $02B7C4 |/
    JSR _battle_play_menu_select_sound                                          ; $02B7C6 | Play the menu select sound.
    JSR _battle_menu_get_spell_offset                                           ; $02B7C9 |\
    LDA r_current_spell_lists.1.flags.w,X                                       ; $02B7CC | | If the currently selected spell is not enabled, change the sound
    BPL +                                                                       ; $02B7CF | | effect to play to the error sound and branch to the non-
    JSR _battle_play_menu_error_sound                                           ; $02B7D1 | | confirmation code.
    BRA @not_confirm                                                            ; $02B7D4 |/
+   JSR _battle_menu_cursor_1_hide                                              ; $02B7D6 | Hide the first cursor.
    LDA r_current_spell_lists.1.id.w,X                                          ; $02B7D9 |\ Transfer the spell ID to the action command variable.
    STA <r_battle_current_action.command                                        ; $02B7DC |/
    LDA r_current_spell_lists.1.flags.w,X                                       ; $02B7DE |\ Push the spell's flags to the stack.
    PHA                                                                         ; $02B7E1 |/
    STZ <r_battle_menu_set_default_target_arg_reversed                          ; $02B7E2 |\ Set the default target, setting the argument so they're chosen left
    JSR _battle_menu_set_default_target                                         ; $02B7E4 |/ to right.
    LDA #BATTLE_ACTION_FLAG_MAGIC.b                                             ; $02B7E7 |\ Flag the current action as a magic spell.
    STA <r_battle_current_action.flags                                          ; $02B7E9 |/
    LDA r_battle_menu_magic_spell_list_offset.w                                 ; $02B7EB |\
    LSR A                                                                       ; $02B7EE | | Set the command index to the selected spell index plus the base
    LSR A                                                                       ; $02B7EF | | index of the list (calculated by dividing the offset by 4).
    CLC                                                                         ; $02B7F0 | |
    ADC <r_battle_menu_inventory_index                                          ; $02B7F1 | |
    STA <r_battle_current_action.command_index                                  ; $02B7F3 |/
    PLA                                                                         ; $02B7F5 |\
    AND #BATTLE_COMMAND_FLAG_TARGETING_MONSTER.b                                ; $02B7F6 | | If the spell targets monsters by default, set the previous menu
    BEQ +                                                                       ; $02B7F8 | | to the magic menu and load the value for the target item/magic
    LDA #BATTLE_MENU_MAGIC.b                                                    ; $02B7FA | | menu into the accumulator.
    STA r_battle_previous_menu.w                                                ; $02B7FC | |
    LDA #BATTLE_MENU_TARGET_ITEM_MAGIC.b                                        ; $02B7FF | |
    BRA ++                                                                      ; $02B801 |/
+   LDA #BATTLE_MENU_CLOSING_HP_AND_STATUS_MAGIC.b                              ; $02B803 |\
    STA r_battle_previous_menu.w                                                ; $02B805 | | Otherwise, set the previous menu to closing the HP and status
    LDA #BATTLE_MENU_OPENING_HP_AND_STATUS.b                                    ; $02B808 |/  magic menu and put the HP and status value in the accumulator.
++  STA r_battle_current_menu.w                                                 ; $02B80A |\ Set the loaded value as the current menu and return.
    RTS                                                                         ; $02B80D |/
@not_confirm:
    LDA <r_battle_joypad_repeat_hi                                              ; $02B80E |\ Skip to the end unless the B button is pressed.
    BPL +                                                                       ; $02B810 |/
    JSR _battle_play_menu_select_sound                                          ; $02B812 | Play the menu select sound.
    JSR _battle_menu_cursor_1_hide                                              ; $02B815 | Hide the first cursor.
    JSR _battle_hide_menu_up_down_arrows                                        ; $02B818 | Hide the up and down arrows.
    LDX <r_battle_menu_coordinates_backup                                       ; $02B81B |\ Restore the backed up menu coordinates.
    STX <r_battle_menu_coordinates                                              ; $02B81D |/
    STZ r_battle_needed_mp_pending.w                                            ; $02B81F | Unset the needed MP update flag.
    JSR _battle_menu_close_mp                                                   ; $02B822 | Close the MP needed menu.
    LDA #BATTLE_MENU_CLOSING_MAGIC.b                                            ; $02B825 |\ Set the current menu to the closing magic menu.
    STA r_battle_current_menu.w                                                 ; $02B827 |/
+   RTS                                                                         ; $02B82A

; battle_character_slot_spell_list_offset_data ($02:B82B)
;
; For each character slot, provides the offset within the battle spell lists at
; $2C7A for the given slot.
battle_character_slot_spell_list_offset_data:
    .dw _sizeof_spell_entry * 24 * 3 * 0                                        ; $02B82B.B82C
    .dw _sizeof_spell_entry * 24 * 3 * 1                                        ; $02B82D.B82E
    .dw _sizeof_spell_entry * 24 * 3 * 2                                        ; $02B82F.B830
    .dw _sizeof_spell_entry * 24 * 3 * 3                                        ; $02B831.B832
    .dw _sizeof_spell_entry * 24 * 3 * 4                                        ; $02B833.B834

; _battle_menu_get_spell_offset ($02:B835)
;
; Given the currently active character slot in $1822, the current menu spell
; list in $EF93 and the currently pointed to spell index in $63, returns the
; offset for that spell in the battle spell lists at $2C7A in the X register.
_battle_menu_get_spell_offset:
    LDA r_battle_last_active_character_slot.w                                   ; $02B835 |\
    ASL A                                                                       ; $02B838 | | Load the spell list offset for the active character slot and save
    TAX                                                                         ; $02B839 | | it to a temporary variable.
    LDA battle_character_slot_spell_list_offset_data.l + 0,X                    ; $02B83A | |
    STA <r_battle_generic_tmp_ptr_lo                                            ; $02B83E | |
    LDA battle_character_slot_spell_list_offset_data.l + 1,X                    ; $02B840 | |
    STA <r_battle_generic_tmp_ptr_hi                                            ; $02B844 |/
    LDA <r_battle_generic_tmp_ptr_lo                                            ; $02B846 |\
    CLC                                                                         ; $02B848 | | Add the configured offset for the current spell list being
    ADC r_battle_menu_magic_spell_list_offset.w                                 ; $02B849 | | examined.
    STA <r_battle_generic_tmp_ptr_lo                                            ; $02B84C | |
    LDA <r_battle_generic_tmp_ptr_hi                                            ; $02B84E | |
    ADC #0.b                                                                    ; $02B850 | |
    STA <r_battle_generic_tmp_ptr_hi                                            ; $02B852 |/
    LDA <r_battle_menu_inventory_index                                          ; $02B854 |\
    ASL A                                                                       ; $02B856 | | Add the offset for the currently pointed to spell.
    ASL A                                                                       ; $02B857 | |
    CLC                                                                         ; $02B858 | |
    ADC <r_battle_generic_tmp_ptr_lo                                            ; $02B859 | |
    STA <r_battle_generic_tmp_ptr_lo                                            ; $02B85B | |
    LDA <r_battle_generic_tmp_ptr_hi                                            ; $02B85D | |
    ADC #$00.b                                                                  ; $02B85F | |
    STA <r_battle_generic_tmp_ptr_hi                                            ; $02B861 |/
    LDX <r_battle_generic_tmp_ptr                                               ; $02B863 | Load the calculated offset into the X register.
    RTS                                                                         ; $02B865

; _battle_update_needed_mp ($02:B866)
;
; Within a spell menu, updates the needed MP value for the currently selected
; spell.
_battle_update_needed_mp:
    JSR _battle_menu_get_spell_offset                                           ; $02B866 | Set the X register to the spell offset for the spell.
    LDA r_current_spell_lists.1.cost.w,X                                        ; $02B869 |\
    TAX                                                                         ; $02B86C | | Divide the spell's MP cost by 100.
    STX <r_math_divide_16bit_reg_arg_1                                          ; $02B86D | |
    LDX #100.w                                                                  ; $02B86F | |
    STX <r_math_divide_16bit_reg_arg_2                                          ; $02B872 | |
    JSR _math_divide_16bit_reg                                                  ; $02B874 |/
    LDA <r_math_divide_16bit_reg_result_lo                                      ; $02B877 |\
    CLC                                                                         ; $02B879 | | Set the first digit of the needed MP by adding the base tile
    ADC #$ED.b                                                                  ; $02B87A | | number to the quotient.
    STA r_battle_needed_mp_data.w                                               ; $02B87C |/
    LDX <r_math_divide_16bit_reg_remainder                                      ; $02B87F |\
    STX <r_math_divide_16bit_reg_arg_1                                          ; $02B881 | | Divide the remainder by 10.
    LDX #10.w                                                                   ; $02B883 | |
    STX <r_math_divide_16bit_reg_arg_2                                          ; $02B886 | |
    JSR _math_divide_16bit_reg                                                  ; $02B888 |/
    LDA <r_math_divide_16bit_reg_result_lo                                      ; $02B88B |\
    CLC                                                                         ; $02B88D | | Set the second needed MP digit by taking that quotient and adding
    ADC #$ED.b                                                                  ; $02B88E | | the base tile number.
    STA r_battle_needed_mp_data.w + 2                                           ; $02B890 |/
    LDA <r_math_divide_16bit_reg_remainder                                      ; $02B893 |\
    CLC                                                                         ; $02B895 | | Set the third needed MP digit by taking the remainder and adding
    ADC #$ED.b                                                                  ; $02B896 | | the base tile number.
    STA r_battle_needed_mp_data.w + 4                                           ; $02B898 |/
    INC r_battle_needed_mp_pending.w                                            ; $02B89B | Set the flag to indicate the needed MP dialog needs updating.
    RTS                                                                         ; $02B89E

; _battle_menu_process_none ($02:B89F)
;
; Menu handler for when no menu is open. Does nothing.
_battle_menu_process_none:
    RTS                                                                         ; $02B89F

; _battle_target_cursor_reset ($02:B8A0)
;
; Unsets the current target values in $EF8F, $EF90, $DA and $DB, and resets the
; flag that says the target cursor is active.
_battle_target_cursor_reset:
    LDX #0.w                                                                    ; $02B8A0 |\
    STX r_battle_targets.monster.w                                              ; $02B8A3 | | Reset the targeting values for monsters and characters to zero.
    STX <r_battle_current_action.targets.monster                                ; $02B8A6 |/
    STZ r_battle_target_cursor_active.w                                         ; $02B8A8 | Reset the target cursor active flag.
    RTS                                                                         ; $02B8AB

; _battle_menu_process_change ($02:B8AC)
;
; Menu handler for the Change menu.
_battle_menu_process_change:
    LDA <r_battle_joypad_repeat_lo                                              ; $02B8AC |\ Branch forward if the A button isn't being pressed.
    BPL +                                                                       ; $02B8AE |/
    LDA #BATTLE_COMMAND_CHANGE.b                                                ; $02B8B0 |\ Set the selected command to the Change command.
    STA r_battle_menu_selected_command.w                                        ; $02B8B2 |/
    JSR _battle_target_cursor_reset                                             ; $02B8B5 | Reset the targeting cursor.
    LDA #BATTLE_MENU_CLOSING.b                                                  ; $02B8B8 |\ Set the current menu to the closing menu.
    STA r_battle_current_menu.w                                                 ; $02B8BA |/
    JSR _battle_play_menu_select_sound                                          ; $02B8BD |\ Play the menu select sound and return.
    RTS                                                                         ; $02B8C0 |/
+   LDA <r_battle_joypad_repeat_hi                                              ; $02B8C1 |\ Skip to the last check unless the B button is pressed.
    BPL ++                                                                      ; $02B8C3 |/
    JSR _battle_play_menu_move_sound                                            ; $02B8C5 |\ BUG: Play the movement sound if the B button is pressed and then
    BRA +                                                                       ; $02B8C8 |/      branch to the next section (the sound effects are reversed).
-   JSR _battle_play_menu_select_sound                                          ; $02B8CA | Play the menu select sound (if right is being pressed).
+   JSR _battle_menu_close_change                                               ; $02B8CD | Close the Change menu.
    LDA #BATTLE_MENU_COMMAND.b                                                  ; $02B8D0 |\
    STA r_battle_current_menu.w                                                 ; $02B8D2 | | Set the current menu to the command menu and return.
    RTS                                                                         ; $02B8D5 |/
++  AND #JOYPAD_H_RIGHT.b                                                       ; $02B8D6 |\ Loop back to play a sound effect and close the menu if the right
    BNE -                                                                       ; $02B8D8 |/ button is being pressed.
    RTS                                                                         ; $02B8DA

; _battle_menu_process_parry ($02:B8DB)
;
; Menu handler for the Parry menu.
_battle_menu_process_parry:
    LDA <r_battle_joypad_repeat_lo                                              ; $02B8DB |\ Branch forward if the A button isn't being pressed.
    BPL +                                                                       ; $02B8DD |/
    LDA #BATTLE_COMMAND_PARRY.b                                                 ; $02B8DF |\ Set the selected command to the Parry command.
    STA r_battle_menu_selected_command.w                                        ; $02B8E1 |/
    JSR _battle_target_cursor_reset                                             ; $02B8E4 | Reset the targeting cursor.
    LDA #BATTLE_MENU_CLOSING.b                                                  ; $02B8E7 |\ Set the current menu to the closing menu.
    STA r_battle_current_menu.w                                                 ; $02B8E9 |/
    JSR _battle_play_menu_select_sound                                          ; $02B8EC |\ Play the menu select sound and return.
    RTS                                                                         ; $02B8EF |/
+   LDA <r_battle_joypad_repeat_hi                                              ; $02B8F0 |\ Skip to the last check unless the B button is pressed.
    BPL ++                                                                      ; $02B8F2 |/
    JSR _battle_play_menu_select_sound                                          ; $02B8F4 |\ Play the menu select sound if the B button is pressed and then
    BRA +                                                                       ; $02B8F7 |/ branch to the next section.
-   JSR _battle_play_menu_move_sound                                            ; $02B8F9 | If the left button is pressed, play the movement sound.
+   JSR _battle_menu_close_parry                                                ; $02B8FC | Close the Parry menu.
    LDA #BATTLE_MENU_COMMAND.b                                                  ; $02B8FF |\
    STA r_battle_current_menu.w                                                 ; $02B901 | | Set the current menu to the command menu and return.
    RTS                                                                         ; $02B904 |/
++  AND #JOYPAD_H_LEFT.b                                                        ; $02B905 |\ Loop back to play a sound effect and close the menu if the left
    BNE -                                                                       ; $02B907 |/ button is being pressed.
    RTS                                                                         ; $02B909

; _battle_play_dpad_menu_sound ($02:B90A)
;
; If a D-pad button is currently being pressed, play the menu sound effect.
_battle_play_dpad_menu_sound:
    LDA <r_battle_joypad_repeat_hi                                              ; $02B90A |\
    AND #JOYPAD_H_DPAD.b                                                        ; $02B90C | | Return unless one of the d-pad buttons is being pressed.
    BNE _battle_play_menu_move_sound                                            ; $02B90E | |
    RTS                                                                         ; $02B910 |/

; _battle_play_menu_move_sound ($02:B911)
;
; Plays the menu cursor movement sound.
_battle_play_menu_move_sound:
    LDA #AUDIO_SPECIAL_MENU_MOVE.b                                              ; $02B911 |\ Set the audio special mode to play the menu movement sound.
    STA r_battle_play_audio_special_mode.w                                      ; $02B913 |/
    RTS                                                                         ; $02B916

; _battle_play_menu_error_sound ($02:B917)
;
; Plays the menu error sound.
_battle_play_menu_error_sound:
    LDA #AUDIO_SPECIAL_MENU_ERROR.b                                             ; $02B917 |\ Set the audio special mode to play the menu error sound.
    STA r_battle_play_audio_special_mode.w                                      ; $02B919 |/
    RTS                                                                         ; $02B91C

; _battle_play_menu_select_sound ($02:B91D)
;
; Plays the menu select sound effect.
_battle_play_menu_select_sound:
    LDA #AUDIO_SPECIAL_MENU_SELECT.b                                            ; $02B91D |\ Set the audio special mode to play the menu select sound.
    STA r_battle_play_audio_special_mode.w                                      ; $02B91F |/
    RTS                                                                         ; $02B922

; _battle_menu_process_command ($02:B923)
;
; Handler for the command menu in battle.
_battle_menu_process_command:
    JSR _battle_play_dpad_menu_sound                                            ; $02B923 | Play the menu movement sound if a d-pad button is pressed.
    LDA <r_battle_joypad_repeat_hi                                              ; $02B926 |\
    AND #JOYPAD_H_DPAD.b                                                        ; $02B928 | | If the up button isn't the only pressed d-pad button, branch to
    CMP #JOYPAD_H_UP.b                                                          ; $02B92A | | the next section.
    BNE ++                                                                      ; $02B92C |/
-   LDA <r_battle_menu_coordinates.y                                            ; $02B92E |\
    BNE +                                                                       ; $02B930 | | If the current menu coordinate is zero, set it to five.
    LDA #5.b                                                                    ; $02B932 | |
    STA <r_battle_menu_coordinates.y                                            ; $02B934 |/
+   DEC <r_battle_menu_coordinates.y                                            ; $02B936 | Decrement the menu coordinate.
    JSR _battle_load_active_slot_commands_offset                                ; $02B938 |\
    LDA r_battle_commands.1.commands.1.flags.w,X                                ; $02B93B | | If the command in this row is disabled, branch to repeat.
    BMI -                                                                       ; $02B93E |/
    BRA @next                                                                   ; $02B940 | Branch to the next major section.
++  CMP #JOYPAD_H_DOWN.b                                                        ; $02B942 |\ If the down button isn't the only pressed button, branch to the
    BNE +++                                                                     ; $02B944 |/ next section.
@down:
    LDA <r_battle_menu_coordinates.y                                            ; $02B946 |\
    CMP #4.b                                                                    ; $02B948 | | If the current Y coordinate is already at the bottom, set the new
    BNE +                                                                       ; $02B94A | | coordinate to zero.
    STZ <r_battle_menu_coordinates.y                                            ; $02B94C | |
    BRA ++                                                                      ; $02B94E |/
+   INC <r_battle_menu_coordinates.y                                            ; $02B950 | Otherwise, increment it by one.
++  BRA @next                                                                   ; $02B952 | Branch to the next major section.
+++ CMP #JOYPAD_H_LEFT.b                                                        ; $02B954 |\ If the left d-pad button isn't the only pressed button, branch
    BNE +                                                                       ; $02B956 |/ ahead.
    LDA #BATTLE_ACTION_FLAG_COMMAND.b                                           ; $02B958 |\ Set the current action flag to command.
    STA <r_battle_current_action.flags                                          ; $02B95A |/
    LDA #5.b                                                                    ; $02B95C |\ Set the command index to 5 for Change.
    STA <r_battle_current_action.command_index                                  ; $02B95E |/
    JSR _battle_menu_open_change                                                ; $02B960 | Open the Change menu.
    LDA #BATTLE_MENU_CHANGE.b                                                   ; $02B963 |\ Set the current menu to Change.
    STA r_battle_current_menu.w                                                 ; $02B965 |/
    LDA #BATTLE_COORDINATE_X_CURSOR_CHANGE.b                                    ; $02B968 |\ Set the cursor X coordinate to 12 and the Y coordinate based on the
    JMP _battle_menu_cursor_1_set_coordinates                                   ; $02B96A |/ current row.
+   CMP #JOYPAD_H_RIGHT.b                                                       ; $02B96D |\ If the right button isn't the only pressed d-pad button, skip to
    BNE @next                                                                   ; $02B96F |/ the next section.
    LDA #BATTLE_ACTION_FLAG_COMMAND.b                                           ; $02B971 |\ Set the current action flag to command.
    STA <r_battle_current_action.flags                                          ; $02B973 |/
    LDA #6.b                                                                    ; $02B975 |\ Set the command index to 6 for Parry.
    STA <r_battle_current_action.command_index                                  ; $02B977 |/
    JSR _battle_menu_open_parry                                                 ; $02B979 | Open the Parry menu.
    LDA #BATTLE_MENU_PARRY.b                                                    ; $02B97C |\ Set the current menu to Parry.
    STA r_battle_current_menu.w                                                 ; $02B97E |/
    LDA #BATTLE_COORDINATE_X_CURSOR_PARRY.b                                     ; $02B981 |\ Set the cursor X coordinate to 76 and the Y coordinate based on the
    JMP _battle_menu_cursor_1_set_coordinates                                   ; $02B983 |/ current row.
@next:
    JSR _battle_load_active_slot_commands_offset                                ; $02B986 |\
    LDA r_battle_commands.1.commands.1.flags.w,X                                ; $02B989 | | If the current command is disabled, simulate a down press.
    BMI @down                                                                   ; $02B98C |/
    LDA #BATTLE_COORDINATE_X_CURSOR_COMMAND.b                                   ; $02B98E |\ Set the cursor X coordinate to 40 and the Y coordinate based on the
    JSR _battle_menu_cursor_1_set_coordinates                                   ; $02B990 |/ row.
    LDA <r_battle_joypad_repeat_lo                                              ; $02B993 |\ If the A button is not being pressed, branch to the end.
    BPL @done                                                                   ; $02B995 |/
    LDX <r_battle_menu_coordinates                                              ; $02B997 |\ Back up the menu coordinates so they can be restored if necessary.
    STX <r_battle_menu_coordinates_backup                                       ; $02B999 |/
    JSR _battle_menu_cursor_1_hide                                              ; $02B99B | Hide the first cursor.
    JSR _battle_load_active_slot_commands_offset                                ; $02B99E | Set the X register to the offset to the selected command.
    JSR _battle_play_menu_select_sound                                          ; $02B9A1 | Play the menu select sound.
    LDA r_battle_commands.1.commands.1.id.w,X                                   ; $02B9A4 |\
    STA <r_battle_current_action.command                                        ; $02B9A7 | | Set the current action command as the chosen command.
    STA r_battle_menu_selected_command.w                                        ; $02B9A9 |/
    LDA r_battle_commands.1.commands.1.flags.w,X                                ; $02B9AC | Load the command flags into the accumulator.
    PHX                                                                         ; $02B9AF | Preserve the X register value.
    PHA                                                                         ; $02B9B0 | Preserve the flags.
    LDA #1.b                                                                    ; $02B9B1 |\
    STA <r_battle_menu_set_default_target_arg_reversed                          ; $02B9B3 | | Set the defualt target, ordering monsters from right to left.
    PLA                                                                         ; $02B9B5 | |
    JSR _battle_menu_set_default_target                                         ; $02B9B6 |/
    PLX                                                                         ; $02B9B9 | Restore the X register.
    LDA r_battle_commands.1.commands.1.id.w,X                                   ; $02B9BA |\
    CMP #BATTLE_COMMAND_DART.b                                                  ; $02B9BD | | Handle the Dart command if chosen.
    BEQ _battle_menu_command_dart                                               ; $02B9BF |/
    CMP #BATTLE_COMMAND_NINJA.b                                                 ; $02B9C1 |\ Handle the Ninja command if chosen.
    BEQ _battle_menu_command_black_ninja                                        ; $02B9C3 |/
    CMP #BATTLE_COMMAND_DARK_WAVE.b                                             ; $02B9C5 |\
    BCC +                                                                       ; $02B9C7 | | Handle all commands with an index of $05 and greater.
    JMP _battle_menu_command_other                                              ; $02B9C9 |/
+   ASL A                                                                       ; $02B9CC |\
    TAX                                                                         ; $02B9CD | | For the remaining commands, load the pointer from ROM and jump to
    LDA battle_menu_command_pointer_data.l + 0,X                                ; $02B9CE | | the handling routine.
    STA <r_battle_generic_tmp_ptr_lo                                            ; $02B9D2 | |
    LDA battle_menu_command_pointer_data.l + 1,X                                ; $02B9D4 | |
    STA <r_battle_generic_tmp_ptr_hi                                            ; $02B9D8 | |
    JMP (r_battle_generic_tmp_ptr.w)                                            ; $02B9DA |/
@done:
    RTS                                                                         ; $02B9DD

; _battle_menu_command_dart ($02:B9DE)
;
; Handles the process of selecting the Dart command.
_battle_menu_command_dart:
    LDA #BATTLE_ACTION_FLAG_DART.b                                              ; $02B9DE |\ Set the dart inventory flag.
    STA r_battle_menu_inventory_dart.w                                          ; $02B9E0 |/
    JMP _battle_menu_command_inventory                                          ; $02B9E3 | Jump to the common portion of inventory menu commands.

; battle_menu_command_pointer_data ($02:B9E6)
;
; For each of the first five battle commands, contains pointers to the handler
; for choosing that menu command. There is a sixth pointer, but it is unused, as
; the calling routine automatically redirects that and higher numbers to that
; same routine.
battle_menu_command_pointer_data:
    .addr _battle_menu_command_fight                                            ; $02B9E6.B9E7 | $00: Fight
    .addr _battle_menu_command_item                                             ; $02B9E8.B9E9 | $01: Item
    .addr _battle_menu_command_white                                            ; $02B9EA.B9EB | $02: White
    .addr _battle_menu_command_black_ninja                                      ; $02B9EC.B9ED | $03: Black
    .addr _battle_menu_command_call                                             ; $02B9EE.B9EF | $04: Call
    .addr _battle_menu_command_other                                            ; $02B9F0.B9F1 | $05: Dark Wave (unused pointer)

; _battle_menu_command_fight ($02:B9F2)
;
; Handles the process of selecting the Fight command.
_battle_menu_command_fight:
    LDA #BATTLE_ACTION_FLAG_COMMAND.b                                           ; $02B9F2 |\ Set the current action flags to command.
    STA <r_battle_current_action.flags                                          ; $02B9F4 |/
    LDA <r_battle_menu_coordinates.y                                            ; $02B9F6 |\ Set the command index to the current menu Y coordinate.
    STA <r_battle_current_action.command_index                                  ; $02B9F8 |/
    LDA #BATTLE_MENU_COMMAND.b                                                  ; $02B9FA |\ Set the previous menu to the Command menu.
    STA r_battle_previous_menu.w                                                ; $02B9FC |/
    LDA #BATTLE_MENU_TARGET_FIGHT.b                                             ; $02B9FF |\ Set the current menu to the Fight targeting menu.
    STA r_battle_current_menu.w                                                 ; $02BA01 |/
    RTS                                                                         ; $02BA04

; _battle_menu_command_item ($02:BA05)
;
; Handles the process of selecting the Item command. Falls through to the next
; function, which handles most of the process.
_battle_menu_command_item:
    STZ r_battle_menu_inventory_dart.w                                          ; $02BA05 | Set the dart flag to zero, as this is not the Dart command.

; _battle_menu_command_inventory ($02:BA08)
;
; Routine to handle the common portion of routines that open the inventory menu.
_battle_menu_command_inventory:
    LDA #BATTLE_MENU_INVENTORY.b                                                ; $02BA08 |\ Set the current menu to the inventory menu.
    STA r_battle_current_menu.w                                                 ; $02BA0A |/
    STZ r_battle_menu_inventory_selected.w                                      ; $02BA0D | Unset the selected flag, as we start with no item selected.
    STZ r_unknown_ef97.w                                                        ; $02BA10 |\
    STZ r_unknown_ef98.w                                                        ; $02BA13 | | TODO
    STZ r_unknown_ef99.w                                                        ; $02BA16 |/
    JMP _battle_menu_open_inventory                                             ; $02BA19 | Open the item menu.

; _battle_menu_command_white ($02:BA1C)
;
; Handles the process of selecting the White command.
_battle_menu_command_white:
    LDA #_sizeof_spell_entry.b * 24 * 0                                         ; $02BA1C |\ Set the spell list offset to the offset for the first spell list.
    STA r_battle_menu_magic_spell_list_offset.w                                 ; $02BA1E |/
    LDA #BATTLE_MENU_OPENING_MAGIC.b                                            ; $02BA21 |\ Set the current menu to the opening magic menu.
    STA r_battle_current_menu.w                                                 ; $02BA23 |/
    JMP _battle_menu_open_spell_list_1                                          ; $02BA26 | Open the first spell list menu.

; _battle_menu_command_black_ninja ($02:BA29)
;
; Handles the process of selecting either the Black or Ninja command.
_battle_menu_command_black_ninja:
    LDA #_sizeof_spell_entry.b * 24 * 1                                         ; $02BA29 |\ Set the spell list offset to the offset for the second spell list.
    STA r_battle_menu_magic_spell_list_offset.w                                 ; $02BA2B |/
    LDA #BATTLE_MENU_OPENING_MAGIC.b                                            ; $02BA2E |\ Set the current menu to the opening magic menu.
    STA r_battle_current_menu.w                                                 ; $02BA30 |/
    JMP _battle_menu_open_spell_list_2                                          ; $02BA33 | Open the second spell list menu.

; _battle_menu_command_call ($02:BA36)
;
; Handles the process of selecting the Call command.
_battle_menu_command_call:
    LDA #_sizeof_spell_entry.b * 24 * 2                                         ; $02BA36 |\ Set the spell list offset to the offset for the third spell list.
    STA r_battle_menu_magic_spell_list_offset.w                                 ; $02BA38 |/
    LDA #BATTLE_MENU_OPENING_MAGIC.b                                            ; $02BA3B |\ Set the current menu to the opening magic menu.
    STA r_battle_current_menu.w                                                 ; $02BA3D |/
    JMP _battle_menu_open_spell_list_3                                          ; $02BA40 | Open the third spell list menu.

; _battle_menu_command_other ($02:BA43)
;
; Handles the process of choosing a command other than Fight, Item, Dart or any
; of the magic commands. These commands only open a targeting menu.
_battle_menu_command_other:
    LDA #BATTLE_ACTION_FLAG_COMMAND.b                                           ; $02BA43 |\ Set the action command flag.
    STA <r_battle_current_action.flags                                          ; $02BA45 |/
    LDA <r_battle_menu_coordinates.y                                            ; $02BA47 |\ Set the command index to the Y coordinate chosen in the menu.
    STA <r_battle_current_action.command_index                                  ; $02BA49 |/
    LDA #BATTLE_MENU_COMMAND.b                                                  ; $02BA4B |\ Set the previous menu to the command menu.
    STA r_battle_previous_menu.w                                                ; $02BA4D |/
    LDA #BATTLE_MENU_TARGET_COMMAND.b                                           ; $02BA50 |\ Set the current menu to the generic targeting menu for commands.
    STA r_battle_current_menu.w                                                 ; $02BA52 |/
    RTS                                                                         ; $02BA55

; _battle_menu_cursor_1_set_coordinates ($02:BA56)
;
; Sets the X coordinate of the first battle menu cursor to the value passed in
; the accumulator, and sets the Y coordinate to a value loaded in ROM
; corresponding to the current command menu row. Also unsets both of the hidden
; flags, making sure the cursor is visible.
_battle_menu_cursor_1_set_coordinates:
    STA r_battle_menu_cursor_coordinates.1.x.w                                  ; $02BA56 | Set the X coordinate to the value passed in the accumulator.
    LDA <r_battle_menu_coordinates.y                                            ; $02BA59 |\
    TAX                                                                         ; $02BA5B | | Set the Y coordinate to a value loaded from ROM. This also
    LDA bank16.battle_menu_command_row_cursor_y_coordinate_data.l,X             ; $02BA5C | | zeroes out the second hidden flag for the first cursor (as that
    TAX                                                                         ; $02BA60 | | byte follows the Y coordinate in RAM).
    STX r_battle_menu_cursor_coordinates.1.y.w                                  ; $02BA61 |/
    JMP _battle_menu_cursor_1_show                                              ; $02BA64

; _battle_menu_open_parry ($02:BA67)
;
; Given the current row of the command menu in $60, opens the Parry menu
; associated with that row.
_battle_menu_open_parry:
    LDA <r_battle_menu_coordinates.y                                            ; $02BA67 | Load the current menu Y coordinate as the parameter.
    JMP _battle_menu_open_close_parry_change                                    ; $02BA69 | Call to open the menu.

; _battle_menu_close_parry ($02:BA6C)
;
; Given the current row of the command menu in $60, closes the Parry menu
; associated with that row.
_battle_menu_close_parry:
    LDA <r_battle_menu_coordinates.y                                            ; $02BA6C |\
    CLC                                                                         ; $02BA6E | | Add 5 to the current menu Y coordinate to determine the index.
    ADC #$05.b                                                                  ; $02BA6F |/
    JMP _battle_menu_open_close_parry_change                                    ; $02BA71 | Call to close the menu.

; _battle_menu_open_change ($02:BA74)
;
; Given the curent row of the command menu in $60, opens the Change menu
; associated with that row.
_battle_menu_open_change:
    LDA <r_battle_menu_coordinates.y                                            ; $02BA74 |\
    CLC                                                                         ; $02BA76 | | Add 10 to the current menu Y coordinate to determine the index.
    ADC #$0A.b                                                                  ; $02BA77 |/
    JMP _battle_menu_open_close_parry_change                                    ; $02BA79 | Call to open the menu.

; _battle_menu_close_change ($02:BA7C)
;
; Given the current row of the command menu in $60, closes the Change menu
; associated with that row.
_battle_menu_close_change:
    LDA <r_battle_menu_coordinates.y                                            ; $02BA7C |\
    CLC                                                                         ; $02BA7E | | Add 15 to the current menu Y coordinate to determine the index.
    ADC #$0F.b                                                                  ; $02BA7F |/
    JMP _battle_menu_open_close_parry_change                                    ; $02BA81 | Call to close the menu.

; _battle_menu_open_close_parry_change ($02:BA84)
;
; Given an index in the accumulator, jumps to the associated handler which will
; either open or close a Parry or Change menu. In particular, values from 0 to 4
; will open a Parry menu, values from 5 to 9 will close a Parry menu, values
; from 10 to 14 will open a Change menu, and values from 15 to 19 will close a
; Change menu.
_battle_menu_open_close_parry_change:
    ASL A                                                                       ; $02BA84 |\
    TAX                                                                         ; $02BA85 | | Multiply the parameter by two and load the associated pointer into
    LDA battle_menu_open_close_parry_change_offset_data.l + 0,X                 ; $02BA86 | | a local variable.
    STA <r_battle_generic_tmp_ptr_lo                                            ; $02BA8A | |
    LDA battle_menu_open_close_parry_change_offset_data.l + 1,X                 ; $02BA8C | |
    STA <r_battle_generic_tmp_ptr_hi                                            ; $02BA90 |/
    JMP (r_battle_generic_tmp_ptr.w)                                            ; $02BA92 | Jump to the loaded pointer.

; battle_menu_open_close_parry_change_offset_data ($02:BA95)
;
; Contains pointers to the handlers for opening and closing the various Parry
; and Change menus.
battle_menu_open_close_parry_change_offset_data:
    .addr _battle_menu_open_parry_1                                             ; $02BA95.BA96 | $00: Open Parry (top)
    .addr _battle_menu_open_parry_2                                             ; $02BA97.BA98 | $01: Open Parry (top middle)
    .addr _battle_menu_open_parry_3                                             ; $02BA99.BA9A | $02: Open Parry (middle)
    .addr _battle_menu_open_parry_4                                             ; $02BA9B.BA9C | $03: Open Parry (bottom middle)
    .addr _battle_menu_open_parry_5                                             ; $02BA9D.BA9E | $04: Open Parry (bottom)
    .addr _battle_menu_close_parry_1                                            ; $02BA9F.BAA0 | $05: Close Parry (top)
    .addr _battle_menu_close_parry_2                                            ; $02BAA1.BAA2 | $06: Close Parry (top middle)
    .addr _battle_menu_close_parry_3                                            ; $02BAA3.BAA4 | $07: Close Parry (middle)
    .addr _battle_menu_close_parry_4                                            ; $02BAA5.BAA6 | $08: Close Parry (bottom middle)
    .addr _battle_menu_close_parry_5                                            ; $02BAA7.BAA8 | $09: Close Parry (bottom)
    .addr _battle_menu_open_change_1                                            ; $02BAA9.BAAA | $0A: Open Change (top)
    .addr _battle_menu_open_change_2                                            ; $02BAAB.BAAC | $0B: Open Change (top middle)
    .addr _battle_menu_open_change_3                                            ; $02BAAD.BAAE | $0C: Open Change (middle)
    .addr _battle_menu_open_change_4                                            ; $02BAAF.BAB0 | $0D: Open Change (bottom middle)
    .addr _battle_menu_open_change_5                                            ; $02BAB1.BAB2 | $0E: Open Change (bottom)
    .addr _battle_menu_close_change_1                                           ; $02BAB3.BAB4 | $0F: Close Change (top)
    .addr _battle_menu_close_change_2                                           ; $02BAB5.BAB6 | $10: Close Change (top middle)
    .addr _battle_menu_close_change_3                                           ; $02BAB7.BAB8 | $11: Close Change (middle)
    .addr _battle_menu_close_change_4                                           ; $02BAB9.BABA | $12: Close Change (bottom middle)
    .addr _battle_menu_close_change_5                                           ; $02BABB.BABC | $13: Close Change (bottom)

; _battle_load_active_slot_commands_offset ($02:BABD)
;
; Loads the offset to the last active character slot's command data and returns
; it in the X register.
_battle_load_active_slot_commands_offset:
    LDA r_battle_last_active_character_slot.w                                   ; $02BABD |\
    TAX                                                                         ; $02BAC0 | | Load the base offset for this character slot's command data and
    LDA bank0D.battle_character_command_offset_data.l,X                         ; $02BAC1 | | save it to a local variable.
    STA <r_battle_generic_tmp_ptr_lo                                            ; $02BAC5 |/
    LDA <r_battle_menu_coordinates.y                                            ; $02BAC7 |\
    ASL A                                                                       ; $02BAC9 | | Multiply the current menu Y coordinate by four and add that to the
    ASL A                                                                       ; $02BACA | | offset, transferring the result to the X register.
    CLC                                                                         ; $02BACB | |
    ADC <r_battle_generic_tmp_ptr_lo                                            ; $02BACC | |
    TAX                                                                         ; $02BACE |/
    RTS                                                                         ; $02BACF

; _draw_battle_arrows ($02:BAD0)
;
; Sets data in the OAM tables in RAM necessary to draw the up and down arrows
; used on the item and magic selection menus.
_draw_battle_arrows:
    LDX #0.w                                                                    ; $02BAD0 |\
-   LDA bank16.battle_arrow_oam_data.l,X                                        ; $02BAD3 | | Copy the data about the arrows from ROM into the OAM staging area.
    STA r_oam.7.w,X                                                             ; $02BAD7 | |
    INX                                                                         ; $02BADA | |
    CPX #bank16._sizeof_battle_arrow_oam_data.w                                 ; $02BADB | |
    BNE -                                                                       ; $02BADE |/
    LDA r_battle_hide_arrows.up.w                                               ; $02BAE0 |\
    BEQ +                                                                       ; $02BAE3 | | If the up arrow is supposed to be hidden, set the high bit of the
    LDA r_oam_hi.w + 1                                                          ; $02BAE5 | | X coordinate of the two sprites to move them off screen.
    ORA #%01010000.b                                                            ; $02BAE8 | |
    BRA ++                                                                      ; $02BAEA |/
+   LDA r_oam_hi.w + 1                                                          ; $02BAEC |\ Otherwise, unset the high bits (and make sure the sprites are set
    AND #%00001111.b                                                            ; $02BAEF |/ to 8x8).
++  STA r_oam_hi.w + 1                                                          ; $02BAF1 | Save the value back to the high OAM table.
    LDA r_battle_hide_arrows.down.w                                             ; $02BAF4 |\
    BEQ +                                                                       ; $02BAF7 | | Repeat similar logic for the down arrow.
    LDA r_oam_hi.w + 2                                                          ; $02BAF9 | |
    ORA #%00000101.b                                                            ; $02BAFC | |
    BRA ++                                                                      ; $02BAFE | |
+   LDA r_oam_hi.w + 2                                                          ; $02BB00 | |
    AND #%11110000.b                                                            ; $02BB03 | |
++  STA r_oam_hi.w + 2                                                          ; $02BB05 |/
    RTS                                                                         ; $02BB08

; _mirror_character_sprite_coordinate_if_back_attack ($02:BB09)
;
; If the current battle is a back attack (determined by reading $6CC0), the
; given coordinate in the accumulator is mirrored by flipping its bits and then
; subtracting the width of the tile (8 pixels).
_mirror_character_sprite_coordinate_if_back_attack:
    PHA                                                                         ; $02BB09 |\
    LDA r_formation_back_attack_copy.w                                          ; $02BB0A | | If the battle is a back attack, adjust the coordinate in the
    BEQ +                                                                       ; $02BB0D | | accumulator by flipping the bits (to mirror it to the other side)
    PLA                                                                         ; $02BB0F | | and then subtracting 8 (the width of the tile).
    EOR #%11111111.b                                                            ; $02BB10 | |
    SEC                                                                         ; $02BB12 | |
    SBC #8.b                                                                    ; $02BB13 | |
    RTS                                                                         ; $02BB15 | |
+   PLA                                                                         ; $02BB16 |/
    RTS                                                                         ; $02BB17

; _mirror_hand_coordinate_if_back_attack ($02:BB18)
;
; If the current battle is a back attack (determined by reading $6CC0), the
; given coordinate in the accumulator is mirrored by flipping its bits and then
; subtracting the width of the sprite (16 pixels).
_mirror_hand_coordinate_if_back_attack:
    PHA                                                                         ; $02BB18 |\
    LDA r_formation_back_attack_copy.w                                          ; $02BB19 | | If the battle is a back attack, adjust the coordinate in the
    BEQ +                                                                       ; $02BB1C | | accumulator by flipping the bits (to mirror it to the other side)
    PLA                                                                         ; $02BB1E | | and then subtracting 16 (the width of the sprite).
    EOR #%11111111.b                                                            ; $02BB1F | |
    SEC                                                                         ; $02BB21 | |
    SBC #16.b                                                                   ; $02BB22 | |
    RTS                                                                         ; $02BB24 | |
+   PLA                                                                         ; $02BB25 |/
    RTS                                                                         ; $02BB26

; _draw_battle_target_cursors ($02:BB27)
;
; Sets the correct properties in the OAM staging area in RAM to draw the
; targeting cursors used during battle. Up to four cursors are supported on any
; given frame, defined by the values in $EF76 to $EF81.
_draw_battle_target_cursors:
    LDA r_formation_back_attack_copy.w                                          ; $02BB27 |\
    BEQ +                                                                       ; $02BB2A | | If this is a back attack, set the tile number to $14A and set the
    LDX #$714A.w                                                                ; $02BB2C | | flags to priority 3 and horizontal flip.
    STX <r_draw_target_cursors_tile_flags                                       ; $02BB2F | |
    BRA ++                                                                      ; $02BB31 |/
+   LDX #$314A.w                                                                ; $02BB33 |\ Otherwise, set the tile number to $14A and set the flags to
    STX <r_draw_target_cursors_tile_flags                                       ; $02BB36 |/ priority 3.
++  LDA r_battle_target_cursor_coordinates.1.x.w                                ; $02BB38 |\
    JSR _mirror_hand_coordinate_if_back_attack                                  ; $02BB3B | | Set the coordinates and properties of the first cursor.
    STA r_oam.3.x.w                                                             ; $02BB3E | |
    LDA r_battle_target_cursor_coordinates.1.y.w                                ; $02BB41 | |
    STA r_oam.3.y.w                                                             ; $02BB44 | |
    LDX <r_draw_target_cursors_tile_flags                                       ; $02BB47 | |
    STX r_oam.3.tile.w                                                          ; $02BB49 |/
    LDA r_battle_target_cursor_coordinates.2.x.w                                ; $02BB4C |\
    JSR _mirror_hand_coordinate_if_back_attack                                  ; $02BB4F | | Set the coordinates and properties of the second cursor.
    STA r_oam.4.x.w                                                             ; $02BB52 | |
    LDA r_battle_target_cursor_coordinates.2.y.w                                ; $02BB55 | |
    STA r_oam.4.y.w                                                             ; $02BB58 | |
    LDX <r_draw_target_cursors_tile_flags                                       ; $02BB5B | |
    STX r_oam.4.tile.w                                                          ; $02BB5D |/
    LDA r_battle_target_cursor_coordinates.3.x.w                                ; $02BB60 |\
    JSR _mirror_hand_coordinate_if_back_attack                                  ; $02BB63 | | Set the coordinates and properties of the third cursor.
    STA r_oam.5.x.w                                                             ; $02BB66 | |
    LDA r_battle_target_cursor_coordinates.3.y.w                                ; $02BB69 | |
    STA r_oam.5.y.w                                                             ; $02BB6C | |
    LDX <r_draw_target_cursors_tile_flags                                       ; $02BB6F | |
    STX r_oam.5.tile.w                                                          ; $02BB71 |/
    LDA r_battle_target_cursor_coordinates.4.x.w                                ; $02BB74 |\
    JSR _mirror_hand_coordinate_if_back_attack                                  ; $02BB77 | | Set the coordinates and properties of the fourth cursor.
    STA r_oam.6.x.w                                                             ; $02BB7A | |
    LDA r_battle_target_cursor_coordinates.4.y.w                                ; $02BB7D | |
    STA r_oam.6.y.w                                                             ; $02BB80 | |
    LDX <r_draw_target_cursors_tile_flags                                       ; $02BB83 | |
    STX r_oam.6.tile.w                                                          ; $02BB85 |/
    LDA r_battle_target_cursor_hidden.1.w                                       ; $02BB88 |\
    BEQ +                                                                       ; $02BB8B | | If the first cursor is supposed to be hidden, set the high bit in
    LDA r_oam_hi.w                                                              ; $02BB8D | | the high OAM table to draw it off screen.
    ORA #%00010000.b                                                            ; $02BB90 | |
    BRA ++                                                                      ; $02BB92 |/
+   LDA r_oam_hi.w                                                              ; $02BB94 |\
    AND #%11001111.b                                                            ; $02BB97 | | Otherwise, reset the bit in the high OAM table, but ensure the
    ORA #%00100000.b                                                            ; $02BB99 | | size flag is reset to 16x16.
++  STA r_oam_hi.w                                                              ; $02BB9B |/
    LDA r_battle_target_cursor_hidden.2.w                                       ; $02BB9E |\
    BEQ +                                                                       ; $02BBA1 | | Repeat for the second cursor.
    LDA r_oam_hi.w                                                              ; $02BBA3 | |
    ORA #%01000000.b                                                            ; $02BBA6 | |
    BRA ++                                                                      ; $02BBA8 | |
+   LDA r_oam_hi.w                                                              ; $02BBAA | |
    AND #%00111111.b                                                            ; $02BBAD | |
    ORA #%10000000.b                                                            ; $02BBAF | |
++  STA r_oam_hi.w                                                              ; $02BBB1 |/
    LDA r_battle_target_cursor_hidden.3.w                                       ; $02BBB4 |\
    BEQ +                                                                       ; $02BBB7 | | Repeat for the third cursor.
    LDA r_oam_hi.w + 1                                                          ; $02BBB9 | |
    ORA #%00000001.b                                                            ; $02BBBC | |
    BRA ++                                                                      ; $02BBBE | |
+   LDA r_oam_hi.w + 1                                                          ; $02BBC0 | |
    AND #%11111100.b                                                            ; $02BBC3 | |
    ORA #%00000010.b                                                            ; $02BBC5 | |
++  STA r_oam_hi.w + 1                                                          ; $02BBC7 |/
    LDA r_battle_target_cursor_hidden.4.w                                       ; $02BBCA |\
    BEQ +                                                                       ; $02BBCD | | Repeat for the fourth cursor.
    LDA r_oam_hi.w + 1                                                          ; $02BBCF | |
    ORA #%00000100.b                                                            ; $02BBD2 | |
    BRA ++                                                                      ; $02BBD4 | |
+   LDA r_oam_hi.w + 1                                                          ; $02BBD6 | |
    AND #%11110011.b                                                            ; $02BBD9 | |
    ORA #%00001000.b                                                            ; $02BBDB | |
++  STA r_oam_hi.w + 1                                                          ; $02BBDD |/
    RTS                                                                         ; $02BBE0

; _draw_battle_menu_cursors ($02:BBE1)
;
; Sets values in the OAM staging area to draw the battle menu cursors on screen.
_draw_battle_menu_cursors:
    LDA r_battle_menu_cursor_coordinates.1.x.w                                  ; $02BBE1 |\
    STA r_oam.1.x.w                                                             ; $02BBE4 | | Set the coordinates of the two battle menu cursors.
    LDA r_battle_menu_cursor_coordinates.1.y.w                                  ; $02BBE7 | |
    STA r_oam.1.y.w                                                             ; $02BBEA | |
    LDA r_battle_menu_cursor_coordinates.2.x.w                                  ; $02BBED | |
    STA r_oam.2.x.w                                                             ; $02BBF0 | |
    LDA r_battle_menu_cursor_coordinates.2.y.w                                  ; $02BBF3 | |
    STA r_oam.2.y.w                                                             ; $02BBF6 |/
    LDX #$314A.w                                                                ; $02BBF9 |\
    STX r_oam.1.tile.w                                                          ; $02BBFC | | Set the two cursors to tile $14A at the highest priority.
    STX r_oam.2.tile.w                                                          ; $02BBFF |/
    LDA r_battle_menu_cursor_hidden.1.w                                         ; $02BC02 |\
    ORA r_battle_menu_cursor_hidden_2.1.w                                       ; $02BC05 | | If either of the high bytes is set for the first cursor, set the
    BEQ +                                                                       ; $02BC08 | | high bit for that cursor in the high OAM table.
    LDA r_oam_hi.w                                                              ; $02BC0A | |
    ORA #%00000011.b                                                            ; $02BC0D | | TODO: Why are there two values to set the high bit?
    BRA ++                                                                      ; $02BC0F | |
+   LDA r_oam_hi.w                                                              ; $02BC11 | |
    AND #%11111100.b                                                            ; $02BC14 | |
    ORA #%00000010.b                                                            ; $02BC16 | |
++  STA r_oam_hi.w                                                              ; $02BC18 |/
    LDA r_battle_menu_cursor_hidden.2.w                                         ; $02BC1B |\
    ORA r_battle_menu_cursor_hidden_2.2.w                                       ; $02BC1E | | Repeat the above logic, except for the second cursor.
    BEQ +                                                                       ; $02BC21 | |
    LDA r_oam_hi.w                                                              ; $02BC23 | |
    ORA #%00001100.b                                                            ; $02BC26 | |
    STA r_oam_hi.w                                                              ; $02BC28 | |
    BRA ++                                                                      ; $02BC2B | |
+   LDA r_oam_hi.w                                                              ; $02BC2D | |
    AND #%11110011.b                                                            ; $02BC30 | |
    ORA #%00001000.b                                                            ; $02BC32 | |
++  STA r_oam_hi.w                                                              ; $02BC34 |/
    RTS                                                                         ; $02BC37

; _unused_battle_menu_show_arrow_up ($02:BC38)
;
; Shows the up arrow normally visible in the inventory menu.
_unused_battle_menu_show_arrow_up:
    STZ r_battle_hide_arrows.up.w                                               ; $02BC38
    RTS                                                                         ; $02BC3B

; _unused_battle_menu_show_arrow_down ($02:BC3C)
;
; Shows the down arrow normally visible in the inventory menu.
_unused_battle_menu_show_arrow_down:
    STZ r_battle_hide_arrows.down.w                                             ; $02BC3C
    RTS                                                                         ; $02BC3F

; _battle_menu_hide_arrow_up ($02:BC40)
;
; Hides the up arrow normally visible in the inventory menu.
_battle_menu_hide_arrow_up:
    LDA #1.b                                                                    ; $02BC40 |\ Hide the up arrow in the menu.
    STA r_battle_hide_arrows.up.w                                               ; $02BC42 |/
    RTS                                                                         ; $02BC45

; _battle_menu_hide_arrow_down ($02:BC46)
;
; Hides the down arrow normally visible in the inventory menu.
_battle_menu_hide_arrow_down:
    LDA #1.b                                                                    ; $02BC46 |\ Hide the down arrow in the menu.
    STA r_battle_hide_arrows.down.w                                             ; $02BC48 |/
    RTS                                                                         ; $02BC4B

; _battle_hide_menu_up_down_arrows ($02:BC4C)
;
; Sets flags to hide the up and down arrows that are part of the battle menu.
_battle_hide_menu_up_down_arrows:
    LDA #1.b                                                                    ; $02BC4C |\
    STA r_battle_hide_arrows.up.w                                               ; $02BC4E | | Hide the up and down arrows from the battle menu.
    STA r_battle_hide_arrows.down.w                                             ; $02BC51 |/
    RTS                                                                         ; $02BC54

; _battle_show_menu_up_down_arrows ($02:BC55)
;
; Sets flags to show the up and down arrows that are part of the battle menu.
_battle_show_menu_up_down_arrows:
    STZ r_battle_hide_arrows.up.w                                               ; $02BC55 |\ Show the up and down arrows from the battle menu.
    STZ r_battle_hide_arrows.down.w                                             ; $02BC58 |/
    RTS                                                                         ; $02BC5B

; _battle_menu_cursor_1_hide ($02:BC5C)
;
; Sets the flag that hides the first battle menu cursor.
_battle_menu_cursor_1_hide:
    LDA #1.b                                                                    ; $02BC5C |\ Set the hidden flag for menu cursor 1.
    STA r_battle_menu_cursor_hidden.1.w                                         ; $02BC5E |/
    RTS                                                                         ; $02BC61

; _battle_menu_cursor_1_show ($02:BC62)
;
; Unsets the flag that hides the first battle menu cursor.
_battle_menu_cursor_1_show:
    STZ r_battle_menu_cursor_hidden.1.w                                         ; $02BC62 | Reset the hidden flag for cursor 1.
    RTS                                                                         ; $02BC65

; _battle_menu_cursor_2_show ($02:BC66)
;
; Unsets the flags that hide the second battle menu cursor and the selected
; cursor.
_battle_menu_cursor_2_show:
    STZ r_battle_menu_cursor_hidden.2.w                                         ; $02BC66
    STZ r_battle_menu_selected_cursor_hidden.w                                  ; $02BC69
    RTS                                                                         ; $02BC6C

; _battle_menu_cursor_2_hide ($02:BC6D)
;
; Sets the flags that hide the second battle menu cursor and the selected
; cursor.
_battle_menu_cursor_2_hide:
    LDA #1.b                                                                    ; $02BC6D
    STA r_battle_menu_cursor_hidden.2.w                                         ; $02BC6F
    STA r_battle_menu_selected_cursor_hidden.w                                  ; $02BC72
    RTS                                                                         ; $02BC75

; _unused_battle_show_menu_cursors ($02:BC76)
;
; Unused function that sets the flags to show the battle menu cursors.
_unused_battle_show_menu_cursors:
    STZ r_battle_menu_cursor_hidden.1.w                                         ; $02BC76 |\
    STZ r_battle_menu_cursor_hidden.2.w                                         ; $02BC79 | | Show the battle menu cursors.
    STZ r_battle_menu_selected_cursor_hidden.w                                  ; $02BC7C |/
    RTS                                                                         ; $02BC7F

; _battle_hide_menu_cursors ($02:BC80)
;
; Sets the flags to hide the battle menu cursors.
_battle_hide_menu_cursors:
    LDA #1.b                                                                    ; $02BC80 |\
    STA r_battle_menu_cursor_hidden.1.w                                         ; $02BC82 | | Hide the battle menu cursors.
    STA r_battle_menu_cursor_hidden.2.w                                         ; $02BC85 | |
    STA r_battle_menu_selected_cursor_hidden.w                                  ; $02BC88 |/
    RTS                                                                         ; $02BC8B

; _battle_hide_target_cursors ($02:BC8C)
;
; Sets the flags to hide the four target cursors in battle.
_battle_hide_target_cursors:
    LDA #1.b                                                                    ; $02BC8C |\
    STA r_battle_target_cursor_hidden.1.w                                       ; $02BC8E | | Hide the four target cursors.
    STA r_battle_target_cursor_hidden.2.w                                       ; $02BC91 | |
    STA r_battle_target_cursor_hidden.3.w                                       ; $02BC94 | |
    STA r_battle_target_cursor_hidden.4.w                                       ; $02BC97 |/
    RTS                                                                         ; $02BC9A

; _monster_spell_audiovisual_dispatch ($02:BC9B)
;
; Proxy function call the dispatch function in another bank.
_monster_spell_audiovisual_dispatch:
    JSL bank01.monster_spell_audiovisual_dispatch                               ; $02BC9B | Call the function in another bank.
    RTS                                                                         ; $02BC9F

; _battle_draw_battle_message_party ($02:BCA0)
;
; Draws a small battle message dialog box above the party. The data to place
; in the dialog box should already be in $74FD. The dialog is left-aligned if
; this is a back attack. Otherwise, it is right-aligned.
_battle_draw_battle_message_party:
    LDA r_formation_back_attack_copy.w                                          ; $02BCA0 |\
    BEQ +                                                                       ; $02BCA3 | | If this is a back attack, draw the message on the left.
    JMP _battle_draw_battle_message_left                                        ; $02BCA5 |/
+   JMP _battle_draw_battle_message_right                                       ; $02BCA8 | Otherwise, draw it on the right.

; _copy_battle_tilemap_bg1_x_to_vram ($02:BCAB)
;
; Depending on the entry point, copies 18 rows from the battle tilemap area in
; RAM at $6CFD to VRAM on BG1 on either the left or right side. The transfer
; will take 9 frames.
_copy_battle_tilemap_bg1_left_to_vram:
    LDY #$6000.w                                                                ; $02BCAB
    BRA _copy_battle_bg1_tilemap_x_to_vram                                      ; $02BCAE
_copy_battle_tilemap_bg1_right_to_vram:
    LDY #$6400.w                                                                ; $02BCB0
_copy_battle_bg1_tilemap_x_to_vram:
    LDX #(64 * 18).w                                                            ; $02BCB3 |\
    STX <r_battle_copy_to_vram_arg_bytes                                        ; $02BCB6 | | Set arguments to transfer 18 rows of tilemap data from RAM to
    LDA #:r_battle_tilemap_data.b                                               ; $02BCB8 | | VRAM.
    LDX #r_battle_tilemap_data.w                                                ; $02BCBA |/
    JMP _battle_copy_to_vram                                                    ; $02BCBD | Execute the transfer (which will take 9 frames).

; _battle_set_bg1_horizontal_hi_scroll ($02:BCC0)
;
; Given a value in the accumulator, sets the value of the high byte of the
; horizontal scroll values for BG1.
_battle_set_bg1_horizontal_hi_scroll:
    LDX #0.w                                                                    ; $02BCC0 | Initialize the X register to zero.
-   STA r_battle_bg1_hdma_data.1.horizontal_hi.w,X                              ; $02BCC3 | Write the passed value to the high byte of the horizontal scroll.
    INX                                                                         ; $02BCC6 |\
    INX                                                                         ; $02BCC7 | | Increment the X register by four to move to the next entry.
    INX                                                                         ; $02BCC8 | |
    INX                                                                         ; $02BCC9 |/
    CPX #(140 * _sizeof_scroll_hdma_data_entry).w                               ; $02BCCA |\ Loop until 140 lines of data have been written.
    BNE -                                                                       ; $02BCCD |/
    RTS                                                                         ; $02BCCF

; _battle_init_flash_palette ($02:BCD0)
;
; Initializes the eighth palette in the battle CG-RAM mirror to be almost
; entirely black, with the exception of the second color, which is white.
_battle_init_flash_palette:
    TDC                                                                         ; $02BCD0 |\ Initialize the Y register to zero.
    TAY                                                                         ; $02BCD1 |/
-   TDC                                                                         ; $02BCD2 |\
    STA r_battle_cgram_data.8.w,Y                                               ; $02BCD3 | | Set the entirety of the eighth palette to black.
    INX                                                                         ; $02BCD6 | |
    INY                                                                         ; $02BCD7 | |
    CPY #_sizeof_palette.w                                                      ; $02BCD8 | |
    BNE -                                                                       ; $02BCDB |/
    LDX #$7FFF.w                                                                ; $02BCDD |\ Set the second color of the eighth palette to white.
    STX r_battle_cgram_data.8.color2.w                                          ; $02BCE0 |/
    RTS                                                                         ; $02BCE3

; _battle_animate_monster_flash ($02:BCE4)
;
; Animates a monster flash by alternating back and forth between the left and
; right halves of BG1 for 16 frames.
_battle_animate_monster_flash:
    STZ <r_battle_monster_effect_counter                                        ; $02BCE4 | Initialize the counter to zero.
    LDA #$01.b                                                                  ; $02BCE6 |\ Switch to the right half of BG1.
    JSR _battle_set_bg1_horizontal_hi_scroll                                    ; $02BCE8 |/
-   JSR _battle_wait_next_frame_preserve_x_y                                    ; $02BCEB | Wait for the next frame.
    LDA <r_battle_monster_effect_counter                                        ; $02BCEE |\
    AND #%00000100.b                                                            ; $02BCF0 | | Alternate between the left half of BG1 and the right half every
    LSR A                                                                       ; $02BCF2 | | four frames.
    LSR A                                                                       ; $02BCF3 | |
    EOR #%00000001.b                                                            ; $02BCF4 | |
    JSR _battle_set_bg1_horizontal_hi_scroll                                    ; $02BCF6 |/
    INC <r_battle_monster_effect_counter                                        ; $02BCF9 |\
    LDA <r_battle_monster_effect_counter                                        ; $02BCFB | | Repeat for 16 frames.
    CMP #16.b                                                                   ; $02BCFD | |
    BNE -                                                                       ; $02BCFF |/
    TDC                                                                         ; $02BD01 |\ Switch to the left half of BG1.
    JMP _battle_set_bg1_horizontal_hi_scroll                                    ; $02BD02 |/

; _unused_battle_fade_color_up ($02:BD05)
;
; This unused function fades a color toward white by incrementing any channels
; that are not already at maximum by one. The color should be passed in $00.
_unused_battle_fade_color_up:
    REP #FLAG_P_ACCUMULATOR                                                     ; $02BD05 |\
    LDA <r_battle_fade_color_arg_color                                          ; $02BD07 | | If the red channel is not already at maximum, increment it by one.
    AND #%0000000000011111.w                                                    ; $02BD09 | |
    CMP #%0000000000011111.w                                                    ; $02BD0C | |
    BEQ +                                                                       ; $02BD0F | |
    LDA <r_battle_fade_color_arg_color                                          ; $02BD11 | |
    CLC                                                                         ; $02BD13 | |
    ADC #1.w                                                                    ; $02BD14 | |
    STA <r_battle_fade_color_arg_color                                          ; $02BD17 |/
+   LDA <r_battle_fade_color_arg_color                                          ; $02BD19 |\
    AND #%0000001111100000.w                                                    ; $02BD1B | | If the green channel is not already at maximum, increment it by
    CMP #%0000001111100000.w                                                    ; $02BD1E | | one.
    BEQ +                                                                       ; $02BD21 | |
    LDA <r_battle_fade_color_arg_color                                          ; $02BD23 | |
    CLC                                                                         ; $02BD25 | |
    ADC #1.w << 5                                                               ; $02BD26 | |
    STA <r_battle_fade_color_arg_color                                          ; $02BD29 |/
+   LDA <r_battle_fade_color_arg_color                                          ; $02BD2B |\
    AND #%0111110000000000.w                                                    ; $02BD2D | | If the blue channel is not already at maximum, increment it by
    CMP #%0111110000000000.w                                                    ; $02BD30 | | one.
    BEQ +                                                                       ; $02BD33 | |
    LDA <r_battle_fade_color_arg_color                                          ; $02BD35 | |
    CLC                                                                         ; $02BD37 | |
    ADC #1.w << 10                                                              ; $02BD38 | |
    STA <r_battle_fade_color_arg_color                                          ; $02BD3B | |
+   TDC                                                                         ; $02BD3D | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $02BD3E |/
    RTS                                                                         ; $02BD40

; _battle_fade_color ($02:BD41)
;
; Given a 16-bit color value in $00 and an 8-bit delta value in the accumulator,
; subtracts the given delta value from each color component of the color. If the
; result for any component would overflow, the component is instead set to zero.
; The result is modified in place and returned in $00.
;
; This function has a potential bug in rare cases if the green value is less
; than the delta and the blue value is greater than 15 (or if the green value is
; less than the delta and the value and delta are greater than 15).
_battle_fade_color:
    STA <r_battle_fade_color_red_delta_lo                                       ; $02BD41 |\ Initialize the red delta value to the value passed in the
    STZ <r_battle_fade_color_red_delta_hi                                       ; $02BD43 |/ accumulator.
    REP #FLAG_P_ACCUMULATOR                                                     ; $02BD45 |\
    LDA <r_battle_fade_color_red_delta                                          ; $02BD47 | | Set the green delta value by shifting the red delta value to the
    ASL A                                                                       ; $02BD49 | | left five times (to align the bits with the green bits in a color
    ASL A                                                                       ; $02BD4A | | value).
    ASL A                                                                       ; $02BD4B | |
    ASL A                                                                       ; $02BD4C | |
    ASL A                                                                       ; $02BD4D | |
    STA <r_battle_fade_color_green_delta                                        ; $02BD4E |/
    ASL A                                                                       ; $02BD50 |\
    ASL A                                                                       ; $02BD51 | | Repeat the process once more to obtain the blue delta value.
    ASL A                                                                       ; $02BD52 | |
    ASL A                                                                       ; $02BD53 | |
    ASL A                                                                       ; $02BD54 | |
    STA <r_battle_fade_color_blue_delta                                         ; $02BD55 |/
    LDA <r_battle_fade_color_arg_color                                          ; $02BD57 |\
    AND #COLOR_MASK_RED.w                                                       ; $02BD59 | | If the red component of the color is greater than or equal to the
    BEQ ++                                                                      ; $02BD5C | | red delta value, subtract the delta value and save the color back
    CMP <r_battle_fade_color_red_delta                                          ; $02BD5E | | to memory.
    BCC +                                                                       ; $02BD60 | |
    LDA <r_battle_fade_color_arg_color                                          ; $02BD62 | |
    SEC                                                                         ; $02BD64 | |
    SBC <r_battle_fade_color_red_delta                                          ; $02BD65 | |
    STA <r_battle_fade_color_arg_color                                          ; $02BD67 | |
    BRA ++                                                                      ; $02BD69 |/
+   LDA <r_battle_fade_color_arg_color                                          ; $02BD6B |\
    AND #(COLOR_MASK_RED ~ $7FFF).w                                             ; $02BD6D | | Otherwise, mask out the red bits to see the red value to zero.
    STA <r_battle_fade_color_arg_color                                          ; $02BD70 |/
++  LDA <r_battle_fade_color_arg_color                                          ; $02BD72 |\
    AND #COLOR_MASK_GREEN.w                                                     ; $02BD74 | | Repeat the process with the green values to fade the green
    BEQ ++                                                                      ; $02BD77 | | component of the color.
    CMP <r_battle_fade_color_green_delta                                        ; $02BD79 | |
    BCC +                                                                       ; $02BD7B | | BUG: For some reason, the mask that masks out the green bits if
    LDA <r_battle_fade_color_arg_color                                          ; $02BD7D | |      the value is less than the delta has the blue component
    SEC                                                                         ; $02BD7F | |      shifted to the right. In rare situations (if the initial
    SBC <r_battle_fade_color_green_delta                                        ; $02BD80 | |      green component is less than the delta and the blue value is
    STA <r_battle_fade_color_arg_color                                          ; $02BD82 | |      greater than 15) the blue component will end up decreasing
    BRA ++                                                                      ; $02BD84 | |      far more than expected.
+   LDA <r_battle_fade_color_arg_color                                          ; $02BD86 | |
    AND #%0011111000011111.w                                                    ; $02BD88 | |
    STA <r_battle_fade_color_arg_color                                          ; $02BD8B |/
++  LDA <r_battle_fade_color_arg_color                                          ; $02BD8D |\
    AND #COLOR_MASK_BLUE.w                                                      ; $02BD8F | | Repeat with the blue component of the color.
    BEQ ++                                                                      ; $02BD92 | |
    CMP <r_battle_fade_color_blue_delta                                         ; $02BD94 | |
    BCC +                                                                       ; $02BD96 | |
    LDA <r_battle_fade_color_arg_color                                          ; $02BD98 | |
    SEC                                                                         ; $02BD9A | |
    SBC <r_battle_fade_color_blue_delta                                         ; $02BD9B | |
    STA <r_battle_fade_color_arg_color                                          ; $02BD9D | |
    BRA ++                                                                      ; $02BD9F | |
+   LDA <r_battle_fade_color_arg_color                                          ; $02BDA1 | |
    AND #(COLOR_MASK_BLUE ~ $7FFF).w                                            ; $02BDA3 | |
    STA <r_battle_fade_color_arg_color                                          ; $02BDA6 | |
++  TDC                                                                         ; $02BDA8 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $02BDA9 |/
    RTS                                                                         ; $02BDAB

; _battle_move_character_acting ($02:BDAC)
;
; Used as part of the battle audiovisual system, this routine moves the current
; character from their base position to the acting position, and waits until
; that movement is complete.
_battle_move_character_acting:
    LDA r_battle_current_action_details.actor_flags.w                           ; $02BDAC |\ Skip this function if the actor is a monster.
    BMI +                                                                       ; $02BDAF |/
    LDA r_unknown_3529.w                                                        ; $02BDB1 |\ TODO: Skip this function if an unknown variable is non-zero.
    BNE +                                                                       ; $02BDB4 |/
    LDA <r_battle_current_actor_slot                                            ; $02BDB6 |\
    TAX                                                                         ; $02BDB8 | | Set the flag that says this character is moving, which will move
    LDA #1.b                                                                    ; $02BDB9 | | them to the acting position.
    STA r_battle_character_moving.w,X                                           ; $02BDBB |/
    STZ r_battle_character_pose.w,X                                             ; $02BDBE | Set the pose to default.
    JSR _battle_get_current_actor_visual_properties_offset                      ; $02BDC1 | Set the X register to the offset to the visual properties.
-   PHX                                                                         ; $02BDC4 |\
    JSR _battle_wait_next_frame_preserve_x_y                                    ; $02BDC5 | | Wait for the next frame.
    PLX                                                                         ; $02BDC8 |/
    LDA r_battle_character_visual_properties.1.x.w,X                            ; $02BDC9 |\
    CMP #BATTLE_COORDINATE_X_PARTY_ACTING.b                                     ; $02BDCC | | Loop until the character reaches the acting position.
    BNE -                                                                       ; $02BDCE |/
+   RTS                                                                         ; $02BDD0

; _battle_animate_monster_status_transition ($02:BDD1)
;
; Checks each of the eight monster slots for changed status bits that would
; cause a sprite change, and animates the transition if appropriate. The checked
; bits are egg, toad, small and pig. (Technically, stone is checked as well, but
; that should never actually be set.)
_battle_animate_monster_status_transition:
    TDC                                                                         ; $02BDD1 |\
    TAX                                                                         ; $02BDD2 | | Initialize the X and Y registers to zero.
    TAY                                                                         ; $02BDD3 |/
-   REP #FLAG_P_ACCUMULATOR                                                     ; $02BDD4 |\
    LDA r_battle_monster_previous_status.1.1.status_1.w,Y                       ; $02BDD6 | | Copy the first previous status into the second previous status
    STA r_battle_monster_previous_status.2.1.status_1.w,Y                       ; $02BDD9 | | location.
    LDA r_battle_monster_previous_status.1.1.status_3.w,Y                       ; $02BDDC | |
    STA r_battle_monster_previous_status.2.1.status_3.w,Y                       ; $02BDDF |/
    LDA r_character_battle.6.status_1.w,X                                       ; $02BDE2 |\
    STA r_battle_monster_previous_status.1.1.status_1.w,Y                       ; $02BDE5 | | Copy the current status into the first previous status location.
    LDA r_character_battle.6.status_3.w,X                                       ; $02BDE8 | |
    STA r_battle_monster_previous_status.1.1.status_3.w,Y                       ; $02BDEB |/
    TXA                                                                         ; $02BDEE |\
    CLC                                                                         ; $02BDEF | | Increment the X register to check the next record.
    ADC #_sizeof_character_battle                                               ; $02BDF0 | |
    TAX                                                                         ; $02BDF3 | |
    TDC                                                                         ; $02BDF4 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $02BDF5 |/
    INY                                                                         ; $02BDF7 |\
    INY                                                                         ; $02BDF8 | | Loop until all eight monster slots have been copied.
    INY                                                                         ; $02BDF9 | |
    INY                                                                         ; $02BDFA | |
    CPX #_sizeof_character_battle.w * 8                                         ; $02BDFB | |
    BNE -                                                                       ; $02BDFE |/
    TDC                                                                         ; $02BE00 |\ Initialize the X register to zero.
    TAX                                                                         ; $02BE01 |/
--  LDA r_battle_monster_previous_status.1.1.status_1.w,X                       ; $02BE02 |\
    AND #%11111000.b                                                            ; $02BE05 | | Extract the stone, toad, small and pig status bits from the first
    ASL A                                                                       ; $02BE07 | | status byte.
    STA <r_battle_generic_tmp_index_lo                                          ; $02BE08 |/
    LDA r_battle_monster_previous_status.1.1.status_3.w,X                       ; $02BE0A |\
    ASL A                                                                       ; $02BE0D | | Extract the egg status bit, though it will overlap with the stone
    ASL A                                                                       ; $02BE0E | | bit. Combine the results into the temporary variable.
    AND #%10000000.b                                                            ; $02BE0F | |
    ORA <r_battle_generic_tmp_index_lo                                          ; $02BE11 | |
    STA <r_battle_generic_tmp_index_lo                                          ; $02BE13 |/
    LDA r_battle_monster_previous_status.2.1.status_1.w,X                       ; $02BE15 |\
    AND #%11111000.b                                                            ; $02BE18 | | Repeat the process with the second previous status bytes, except
    ASL A                                                                       ; $02BE1A | | storing the ultimate result in a different variable.
    STA <r_battle_generic_tmp_index_hi                                          ; $02BE1B | |
    LDA r_battle_monster_previous_status.2.1.status_3.w,X                       ; $02BE1D | |
    ASL A                                                                       ; $02BE20 | |
    ASL A                                                                       ; $02BE21 | |
    AND #%10000000.b                                                            ; $02BE22 | |
    ORA <r_battle_generic_tmp_index_hi                                          ; $02BE24 | |
    STA <r_battle_generic_tmp_index_hi                                          ; $02BE26 |/
    CMP <r_battle_generic_tmp_index_lo                                          ; $02BE28 |\ If nothing in those bits changed, skip this monster.
    BEQ ++                                                                      ; $02BE2A |/
    LDA <r_battle_generic_tmp_index_lo                                          ; $02BE2C |\
    EOR <r_battle_generic_tmp_index_hi                                          ; $02BE2E | | Set a variable to the bits that changed.
    STA <r_battle_generic_tmp_index_2_hi                                        ; $02BE30 |/
    LDA <r_battle_generic_tmp_index_lo                                          ; $02BE32 |\
    AND <r_battle_generic_tmp_index_hi                                          ; $02BE34 | | Set a variable to the bits that are set in both.
    STA <r_battle_generic_tmp_index_2_lo                                        ; $02BE36 |/
    TDC                                                                         ; $02BE38 |\ Initialize the Y register to zero.
    TAY                                                                         ; $02BE39 |/
-   ASL <r_battle_generic_tmp_index_2_hi                                        ; $02BE3A |\ If this bit changed, branch to animate the strobe transition.
    BCS +                                                                       ; $02BE3C |/
    ASL <r_battle_generic_tmp_index_2_lo                                        ; $02BE3E |\ If this bit is set in both bytes, skip this monster.
    BCS ++                                                                      ; $02BE40 |/
    INY                                                                         ; $02BE42 |\
    CPY #4.w                                                                    ; $02BE43 | | Loop until the four bits have been checked.
    BNE -                                                                       ; $02BE46 |/
+   BRA _battle_animate_monster_strobe_transition                               ; $02BE48 | Animate the strobe transition.
++  INX                                                                         ; $02BE4A |\
    INX                                                                         ; $02BE4B | | Loop until all eight monster slots have been checked.
    INX                                                                         ; $02BE4C | |
    INX                                                                         ; $02BE4D | |
    CPX #_sizeof_character_status.w * 8                                         ; $02BE4E | |
    BNE --                                                                      ; $02BE51 |/
    RTS                                                                         ; $02BE53

; _battle_animate_monster_strobe_transition ($02:BE54)
;
; Animates the strobe transition effect from one monster sprite to another.
; Technically, does nothing more than alternate between the left and right sides
; of BG1 according to the following pattern: the first cycle will do 7 frames of
; the left side and 1 frame of the right side. Each successive cycle will
; transfer one from from the left side to the right side, resulting in the
; eventual left side with one frame and right side with 7 frames. At that point,
; the animation will conclude. The entire sequence takes 56 frames.
_battle_animate_monster_strobe_transition:
    PHX                                                                         ; $02BE54 | Preserve the value of the X register.
    LDA #7.b                                                                    ; $02BE55 |\ Initialize the primary counter to 7.
    STA r_battle_monster_swap_counter_1.w                                       ; $02BE57 |/
--  LDA r_battle_monster_swap_counter_1.w                                       ; $02BE5A |\ Initialize the secondary counter to the current value of the
    STA r_battle_monster_swap_counter_2.w                                       ; $02BE5D |/ primary counter.
-   JSR _battle_wait_next_frame_preserve_x_y                                    ; $02BE60 |\
    TDC                                                                         ; $02BE63 | | Show the left side of BG1 for the number of frames specified by
    JSR _battle_set_bg1_horizontal_hi_scroll                                    ; $02BE64 | | the counter.
    DEC r_battle_monster_swap_counter_2.w                                       ; $02BE67 | |
    BNE -                                                                       ; $02BE6A |/
    LDA #8.b                                                                    ; $02BE6C |\
    SEC                                                                         ; $02BE6E | | Set the secondary counter to eight minus the value of the primary
    SBC r_battle_monster_swap_counter_1.w                                       ; $02BE6F | | counter.
    STA r_battle_monster_swap_counter_2.w                                       ; $02BE72 |/
-   JSR _battle_wait_next_frame_preserve_x_y                                    ; $02BE75 |\
    LDA #1.b                                                                    ; $02BE78 | | Show the right side of BG1 for the number of frames specified by
    JSR _battle_set_bg1_horizontal_hi_scroll                                    ; $02BE7A | | the counter.
    DEC r_battle_monster_swap_counter_2.w                                       ; $02BE7D | |
    BNE -                                                                       ; $02BE80 |/
    DEC r_battle_monster_swap_counter_1.w                                       ; $02BE82 |\ Loop until the primary counter reaches zero.
    BNE --                                                                      ; $02BE85 |/
    PLX                                                                         ; $02BE87 | Restore the X register.
    RTS                                                                         ; $02BE88

; _battle_animate_call_finish ($02:BE89)
;
; Animates the end of a Call spell, by restoring the character sprites to full
; visibility.
_battle_animate_call_finish:
    JSR _battle_reset_effect_oam_large                                          ; $02BE89 | Reset the effect OAM.
    LDA r_battle_character_sprites_hidden.w                                     ; $02BE8C |\ Skip this function unless character sprites are hidden.
    BEQ +                                                                       ; $02BE8F |/
    LDA #ALTERNATE_PARTY_SPRITE_MODE_INVISIBLE.b                                ; $02BE91 |\ Set the alternate party sprite mode to invisible.
    STA r_battle_alternate_party_sprite_mode.w                                  ; $02BE93 |/
    JSR _battle_deactivate_battle_background_fade                               ; $02BE96 | Disable the background darkening effect.
    JSR _battle_wait_next_frame_preserve_x_y                                    ; $02BE99 | Wait for the next frame.
    JSR _battle_load_first_two_character_sprites                                ; $02BE9C | Reload the first two character sprites.
    STZ r_battle_character_sprites_hidden.w                                     ; $02BE9F | Clear the character sprites hidden flag.
    STZ r_battle_alternate_party_sprite_mode.w                                  ; $02BEA2 | Once again make the character sprites visible.
    JSR _battle_flash_character_sprites                                         ; $02BEA5 | Animate a flashing of the character sprites.
+   RTS                                                                         ; $02BEA8

; battle_update_audiovisual ($02:BEA9)
;
; Proxy function to call _battle_update_audiovisual from another bank.
battle_update_audiovisual:
    JSR _battle_update_audiovisual                                              ; $02BEA9
    RTL                                                                         ; $02BEAC

; _battle_update_audiovisual_and_check_caller ($02:BEAD)
;
; Executes any pending audiovisual scripts and if the caller read flag at $F474
; is set, animates the Mist attack on Golbez.
_battle_update_audiovisual_and_check_caller:
    JSR _battle_update_info_areas_tilemap_data                                  ; $02BEAD | Update the info areas tilemap data.
    JSR _battle_update_audiovisual                                              ; $02BEB0 | Execute any pending audiovisual scripts.
    LDA r_battle_caller_ready.w                                                 ; $02BEB3 |\
    BEQ +                                                                       ; $02BEB6 | | If the caller is flagged as ready, animate the Mist attack on
    JSL bank01.battle_animate_mist_golbez                                       ; $02BEB8 | | Golbez.
    STZ r_battle_caller_ready.w                                                 ; $02BEBC |/
+   RTS                                                                         ; $02BEBF

; _battle_load_pointers ($02:BEC0)
;
; Loads four pointers into memory used during various functions.
_battle_load_pointers:
    LDX #r_battle_script_audiovisual.w                                          ; $02BEC0 |\ Set the pointer to the audiovisual script data.
    STX <r_battle_script_audiovisual_ptr                                        ; $02BEC3 |/
    LDX #r_battle_command_wall_sources.w                                        ; $02BEC5 |\ Set the pointer to the wall sources data.
    STX <r_battle_command_wall_sources_ptr                                      ; $02BEC8 |/
    LDX #r_battle_slot_damage.w                                                 ; $02BECA |\ Set the pointer to the battle slot damage data.
    STX <r_battle_slot_damage_ptr                                               ; $02BECD |/
    LDX #r_battle_alert_queue.w                                                 ; $02BECF |\ Set the pointer to the battle alert queue.
    STX <r_battle_alert_queue_ptr                                               ; $02BED2 |/
    RTS                                                                         ; $02BED4

; _battle_update_animate_damage ($02:BED5)
;
; Ultimately calls the function which animates the damage effect.
_battle_update_animate_damage:
    JSR _battle_load_pointers                                                   ; $02BED5 | Load some pointers, one of which is used by the next function.
    JMP _battle_animate_damage_loop                                             ; $02BED8 | Prepare the actual animation data and activate it.

; battle_animate_monster_transition_if_status ($02:BEDB)
;
; Animates the transition to the new tilemaps if the monster had a status change
; that would require a transition.
battle_animate_monster_transition_if_status:
    JSR _copy_battle_tilemap_bg1_right_to_vram                                  ; $02BEDB | Copy the tilemap to the right half of BG1.
    LDA #1.b                                                                    ; $02BEDE |\ Show the right side of BG1.
    JSR _battle_set_bg1_horizontal_hi_scroll                                    ; $02BEE0 |/
    JSR _battle_animate_monster_status_transition                               ; $02BEE3 | Animates a status transition if appropriate.
    JSR _copy_battle_tilemap_bg1_left_to_vram                                   ; $02BEE6 | Copy the tilemap to the left half of BG1.
    TDC                                                                         ; $02BEE9 |\ Show the left side of BG1.
    JSR _battle_set_bg1_horizontal_hi_scroll                                    ; $02BEEA |/
    RTL                                                                         ; $02BEED

; _battle_update_audiovisual ($02:BEEE)
;
; Executes any pending audiovisual script, updates character sprites in certain
; instances (switching to and from pig).
_battle_update_audiovisual:
    LDA r_battle_suspend_animation.w                                            ; $02BEEE |\
    BEQ +                                                                       ; $02BEF1 | | Skip this function if animation is suspended.
    RTS                                                                         ; $02BEF3 |/
+   STZ r_battle_character_sprites_hidden.w                                     ; $02BEF4 | Initialize the character sprites hidden flag to zero.
    JSR _battle_wait_next_frame_preserve_x_y                                    ; $02BEF7 | Wait for the next frame.
    JSR _battle_load_pointers                                                   ; $02BEFA | Load pointers to certain areas of memory.
    LDA r_battle_current_action_details.actor.w                                 ; $02BEFD |\ Copy the current actor slot to a local variable.
    STA <r_battle_current_actor_slot                                            ; $02BF00 |/
    TDC                                                                         ; $02BF02 |\
    TAX                                                                         ; $02BF03 | | Search for the slot matching the target value. This will only do
-   LDA bank16.index_to_target_data.l,X                                         ; $02BF04 | | anything if there is a single target. Otherwise, it'll simply exit
    CMP r_battle_current_action_details.target.w                                ; $02BF08 | | the loop once it reaches the eighth slot.
    BEQ +                                                                       ; $02BF0B | |
    INX                                                                         ; $02BF0D | |
    CPX #8.w                                                                    ; $02BF0E | |
    BNE -                                                                       ; $02BF11 |/
    TDC                                                                         ; $02BF13 |\ In that case, explicitly set the slot number to zero.
    TAX                                                                         ; $02BF14 |/
+   TXA                                                                         ; $02BF15 |\ Transfer the determined value to a local variable.
    STA <r_battle_effect_target_slot                                            ; $02BF16 |/
    LDA r_battle_current_action_details.actor_flags.w                           ; $02BF18 |\ Skip this next block if the actor is a character.
    BPL @start                                                                  ; $02BF1B |/
    LDA r_formation_flags2_copy_2.w                                             ; $02BF1D |\
    AND #FORMATION_FLAGS_2_CHARACTER_SPRITE.b                                   ; $02BF20 | | Skip this next block if the monster is a character sprite.
    BNE @start                                                                  ; $02BF22 |/
    LDA r_battle_current_action_details.actor_flags.w                           ; $02BF24 |\
    AND #BATTLE_ACTION_DETAILS_ACTOR_FLAG_SILENT.b                              ; $02BF27 | | Skip this next block if the silent actor flag is set.
    BNE @start                                                                  ; $02BF29 |/
    JSR _battle_monster_slot_map_enable_pre_action                              ; $02BF2B | Switch to the pre-action slot map.
    JSR _battle_load_monster_tilemaps                                           ; $02BF2E | Load the monster tilemaps.
    JSR _battle_monster_slot_map_disable_pre_action                             ; $02BF31 | Switch back to the regular slot map.
    LDA <r_battle_current_actor_slot                                            ; $02BF34 |\
    STA r_battle_update_monster_palette_arg_slot.w                              ; $02BF36 | | Set the acting monster to use the flash palette.
    LDA #BATTLE_PALETTE_FLASH                                                   ; $02BF39 | |
    STA r_battle_update_monster_palette_arg_palette.w                           ; $02BF3B | |
    JSR _battle_update_monster_palette                                          ; $02BF3E |/
    JSR _flip_battle_monster_tilemap                                            ; $02BF41 | Flip the tilemap if appropriate for a back attack.
    JSR _battle_init_flash_palette                                              ; $02BF44 | Initialize the flash palette.
    JSR _copy_battle_tilemap_bg1_right_to_vram                                  ; $02BF47 | Copy the BG1 right tilemap to VRAM.
    JSR _battle_animate_monster_flash                                           ; $02BF4A | Animate the actual flash effect.
@start:
    LDA (<r_battle_script_audiovisual_ptr)                                      ; $02BF4D |\
    CMP #MONSTER_COMMAND_AUDIOVISUAL_BASE.b                                     ; $02BF4F | | Read the next byte and dispatch to the appropriate code, depending
    BCC @spell                                                                  ; $02BF51 | | on the exact command being executed.
    CMP #MONSTER_COMMAND_COMMAND_BASE.b                                         ; $02BF53 | |
    BCC @audiovisual                                                            ; $02BF55 | |
    CMP #MONSTER_COMMAND_STAT_BASE.b                                            ; $02BF57 | |
    BCC @command                                                                ; $02BF59 | |
    CMP #MONSTER_COMMAND_END.b                                                  ; $02BF5B | |
    BEQ @end                                                                    ; $02BF5D | |
    CMP #MONSTER_COMMAND_SCRIPT_BASE.b                                          ; $02BF5F | |
    BCC +                                                                       ; $02BF61 |/
    JSR _battle_script_audiovisual_dispatch                                     ; $02BF63 |\ Handle script commands ($F0 to $FE) and then branch to the next
    BRA @next                                                                   ; $02BF66 |/ section.
+   JSR _battle_script_audiovisual_double_byte_noop                             ; $02BF68 |\ Handle stat commands ($E8 to $EF), where no actual animation is
    BRA @next                                                                   ; $02BF6B |/ necessary and then branch to the next section.
@audiovisual:
    JSR _monster_spell_audiovisual_dispatch                                     ; $02BF6D |\
    JSR _battle_script_audiovisual_get_next                                     ; $02BF70 | | Handle audiovisual spells ($A9 to $BF) and then branch to next.
    BRA @start                                                                  ; $02BF73 |/
@command:
    JSR _battle_command_audiovisual_dispatch                                    ; $02BF75 |\
    JSR _battle_reset_effect_oam_large                                          ; $02BF78 | | Handle commands ($C0 to $E7) and then branch to the next.
    BRA @next                                                                   ; $02BF7B |/
@spell:
    JSR _battle_script_audiovisual_animate_spell                                ; $02BF7D | Animate spells ($00 to $A8).
@next:
    JSR _battle_script_audiovisual_get_next                                     ; $02BF80 |\ Prepare for the next byte and then branch to read that next byte.
    BRA @start                                                                  ; $02BF83 |/
@end:
    TDC                                                                         ; $02BF85 |\ Initialize the X register to zero.
    TAX                                                                         ; $02BF86 |/
-   STZ r_battle_character_moving.w,X                                           ; $02BF87 |\
    INX                                                                         ; $02BF8A | | Ensure that no characters are flagged as moving, so they'll return
    CPX #5.w                                                                    ; $02BF8B | | to their normal position.
    BNE -                                                                       ; $02BF8E |/
    JSR _battle_animate_monster_death                                           ; $02BF90 | Animate any monster deaths.
    JSR _battle_prepare_monster_tilemap                                         ; $02BF93 | Load the current monster tilemap.
    JSL battle_animate_monster_transition_if_status                             ; $02BF96 | Animate a transition if the monster's status bits changed.
    TDC                                                                         ; $02BF9A |\
    TAX                                                                         ; $02BF9B | | Initialize the sprite VRAM address to zero.
    STX <r_battle_load_character_sprites_vram_address                           ; $02BF9C |/
-   PHX                                                                         ; $02BF9E | Preserve the current value of the X register.
    TXA                                                                         ; $02BF9F |\ Transfer the slot from the X register to the Y register.
    TAY                                                                         ; $02BFA0 |/
    JSR _multiply_x_by_128                                                      ; $02BFA1 | Multiply the slot by 128.
    LDA r_character_battle.1.status_1.w,X                                       ; $02BFA4 |\
    AND #STATUS_1_PIG.b                                                         ; $02BFA7 | | If the character in this slot currently has the pig status, check
    BEQ +                                                                       ; $02BFA9 | | if their sprite is currently the pig sprite, and branch
    LDA r_battle_character_sprite.w,Y                                           ; $02BFAB | | accordingly.
    CMP #CLASS_PIG.b                                                            ; $02BFAE | |
    BEQ +++                                                                     ; $02BFB0 | |
    LDA #CLASS_PIG.b                                                            ; $02BFB2 | |
    BRA ++                                                                      ; $02BFB4 |/
+   LDA r_battle_character_sprite.w,Y                                           ; $02BFB6 |\
    CMP #CLASS_PIG.b                                                            ; $02BFB9 | | Otherwise, check if the character has the pig sprite when they
    BNE +++                                                                     ; $02BFBB | | shouldn't and branch acoordingly.
    LDA r_character_battle.1.sprite_class.w,X                                   ; $02BFBD | |
    AND #SPRITE_CLASS_CLASS.b                                                   ; $02BFC0 |/
++  STA r_battle_character_sprite.w,Y                                           ; $02BFC2 | If changing, save the loaded value as the character's sprite.
    PHA                                                                         ; $02BFC5 | Preserve the sprite value.
    TYA                                                                         ; $02BFC6 |\
    ASL A                                                                       ; $02BFC7 | | Multiply the slot number by four to index the visual status data.
    ASL A                                                                       ; $02BFC8 | |
    TAY                                                                         ; $02BFC9 |/
    LDA r_character_visual_status.1.status_1.w,Y                                ; $02BFCA |\
    AND #(STATUS_1_TOAD | STATUS_1_SMALL | STATUS_1_PIG).b ~ $FF                ; $02BFCD | | Update the character's visual status byte to match their actual
    STA <r_battle_generic_tmp_index_lo                                          ; $02BFCF | | status regarding the toad, small and pig statuses.
    LDA r_character_battle.1.status_1.w,X                                       ; $02BFD1 | |
    AND #(STATUS_1_TOAD | STATUS_1_SMALL | STATUS_1_PIG).b                      ; $02BFD4 | |
    ORA <r_battle_generic_tmp_index_lo                                          ; $02BFD6 | |
    STA r_character_visual_status.1.status_1.w,Y                                ; $02BFD8 |/
    PLA                                                                         ; $02BFDB |\ Load the character's new sprite.
    JSR _battle_load_character_sprite                                           ; $02BFDC |/
+++ REP #FLAG_P_ACCUMULATOR                                                     ; $02BFDF |\
    LDA <r_battle_load_character_sprites_vram_address                           ; $02BFE1 | | Update the current character sprite VRAM address for the next
    CLC                                                                         ; $02BFE3 | | slot.
    ADC #bank1A._sizeof_battle_sprite_character_cecil_dknight_data.w / 2        ; $02BFE4 | |
    STA <r_battle_load_character_sprites_vram_address                           ; $02BFE7 | |
    TDC                                                                         ; $02BFE9 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $02BFEA |/
    PLX                                                                         ; $02BFEC |\
    INX                                                                         ; $02BFED | | Loop until all five character slots have been updated.
    CPX #5.w                                                                    ; $02BFEE | |
    BNE -                                                                       ; $02BFF1 |/
    JSR _battle_wait_menu_dma_pending_clear                                     ; $02BFF3 | Wait for all pending menu DMAs to be clear.
    JMP _battle_close_battle_message                                            ; $02BFF6 | Close any open battle message and return.

; _battle_load_character_sprite ($02:BFF9)
;
; Loads the character sprite passed in the accumulator. The target VRAM address
; should be passed in $0A.
_battle_load_character_sprite:
    PHX                                                                         ; $02BFF9 | Preserve the value of the X register.
    CMP #CLASS_GOLBEZ.b                                                         ; $02BFFA |\
    BCC +                                                                       ; $02BFFC | | If the sprite is Golbez or higher, call the function to get the
    JSR _battle_load_character_sprite_get_special_offset                        ; $02BFFE | | special offset.
    JMP ++                                                                      ; $02C001 |/
+   TAX                                                                         ; $02C004 |\
    STX <r_math_multiply_16bit_arg_1                                            ; $02C005 | | Otherwise, simply multiply the sprite value by the size of the
    LDX #bank1A._sizeof_battle_sprite_character_cecil_dknight_data.w            ; $02C007 | | standard sprite set.
    STX <r_math_multiply_16bit_arg_2                                            ; $02C00A | |
    JSR _math_multiply_16bit                                                    ; $02C00C |/
++  REP #FLAG_P_ACCUMULATOR                                                     ; $02C00F |\
    LDA <r_math_multiply_16bit_result_lo                                        ; $02C011 | | Add the result to the base sprite offset and transfer it to the X
    CLC                                                                         ; $02C013 | | register.
    ADC #bank1A.battle_sprite_character_cecil_dknight_data.w                    ; $02C014 | |
    TAX                                                                         ; $02C017 |/
    LDA #bank1A._sizeof_battle_sprite_character_cecil_dknight_data.w            ; $02C018 |\ Write the number of bytes to read.
    STA <r_battle_copy_to_vram_arg_bytes                                        ; $02C01B |/
    TDC                                                                         ; $02C01D |\ Switch back to 8-bit accumulator mode.
    SEP #FLAG_P_ACCUMULATOR                                                     ; $02C01E |/
    LDY <r_battle_load_character_sprites_vram_address                           ; $02C020 | Load the destination VRAM address into the Y register.
    LDA #:bank1A.battle_sprite_character_cecil_dknight_data.b                   ; $02C022 | Load the source bank nubmer into the accumulator.
    JSR _battle_copy_to_vram                                                    ; $02C024 | Copy the sprite data to VRAM.
    PLX                                                                         ; $02C027 | Restore the value of the X register.
    RTS                                                                         ; $02C028

; _battle_script_audiovisual_get_next ($02:C029)
;
; Reads the next value from the audiovisual script and returns it in the
; accumulator.
_battle_script_audiovisual_get_next:
    LDX <r_battle_script_audiovisual_ptr                                        ; $02C029 |\
    INX                                                                         ; $02C02B | | Increment the pointer to the next value.
    STX <r_battle_script_audiovisual_ptr                                        ; $02C02C |/
    LDA (<r_battle_script_audiovisual_ptr)                                      ; $02C02E | Read the value.
    RTS                                                                         ; $02C030

; _battle_command_audiovisual_dispatch ($02:C031)
;
; Given an audiovisual script value in the accumulator, treats it as a command
; and executes the appropriate handler. The only values that make sense are $C0
; through $E7.
_battle_command_audiovisual_dispatch:
    SEC                                                                         ; $02C031 |\
    SBC #MONSTER_COMMAND_FIGHT.b                                                ; $02C032 | | Subtract the base command value from the argument, multiply by two
    ASL A                                                                       ; $02C034 | | and place that value in the X register.
    TAX                                                                         ; $02C035 |/
    LDA r_battle_current_action_details.target_flags.w                          ; $02C036 |\ Set the audio to pan to the actor.
    STA r_battle_play_audio_pan_monster.w                                       ; $02C039 |/
    LDA battle_script_audiovisual_command_handler_data.l + 0,X                  ; $02C03C |\
    STA <r_battle_generic_tmp_ptr_2_addr_lo                                     ; $02C040 | | Load the pointer to the handler and jump to it.
    LDA battle_script_audiovisual_command_handler_data.l + 1,X                  ; $02C042 | |
    STA <r_battle_generic_tmp_ptr_2_addr_hi                                     ; $02C046 | |
    JMP (r_battle_generic_tmp_ptr_2_addr.w)                                     ; $02C048 |/

; battle_script_audiovisual_command_handler_data ($02:C04B)
;
; For each audiovisual command in the range $C0 to $E7, provides a pointer to
; the handler for that command.
battle_script_audiovisual_command_handler_data:
    .addr _battle_script_audiovisual_command_fight                              ; $02C04B.C04C | $C0: Fight
    .addr _battle_script_audiovisual_command_item                               ; $02C04D.C04E | $C1: Item
    .addr _battle_script_audiovisual_command_white                              ; $02C04F.C050 | $C2: White
    .addr _battle_script_audiovisual_command_black                              ; $02C051.C052 | $C3: Black
    .addr _battle_script_audiovisual_command_call                               ; $02C053.C054 | $C4: Call
    .addr _battle_script_audiovisual_command_dark_wave                          ; $02C055.C056 | $C5: Dark Wave
    .addr _battle_script_audiovisual_command_jump                               ; $02C057.C058 | $C6: Jump
    .addr _battle_script_audiovisual_command_special_30_frames                  ; $02C059.C05A | $C7: Recall
    .addr _battle_script_audiovisual_command_sing                               ; $02C05B.C05C | $C8: Sing
    .addr _battle_character_special_pose_exit_right                             ; $02C05D.C05E | $C9: Hide
    .addr _battle_script_audiovisual_command_raised_left_30_frames              ; $02C05F.C060 | $CA: Heal
    .addr _battle_script_audiovisual_command_raised_left_30_frames              ; $02C061.C062 | $CB: Pray
    .addr _battle_script_audiovisual_command_aim                                ; $02C063.C064 | $CC: Aim
    .addr _battle_script_audiovisual_command_noop                               ; $02C065.C066 | $CD: Build Up
    .addr _battle_script_audiovisual_command_kick                               ; $02C067.C068 | $CE: Kick
    .addr _battle_script_audiovisual_command_sing                               ; $02C069.C06A | $CF: Endure
    .addr _battle_script_audiovisual_command_twin                               ; $02C06B.C06C | $D0: Twin
    .addr _battle_script_audiovisual_command_bluff                              ; $02C06D.C06E | $D1: Bluff
    .addr _battle_script_audiovisual_command_cry                                ; $02C06F.C070 | $D2: Cry
    .addr _battle_script_audiovisual_command_raised_left_30_frames              ; $02C071.C072 | $D3: Cover
    .addr _battle_script_audiovisual_command_special_30_frames                  ; $02C073.C074 | $D4: Peep
    .addr _battle_script_audiovisual_command_noop                               ; $02C075.C076 | $D5: <unused>
    .addr _battle_script_audiovisual_command_dart                               ; $02C077.C078 | $D6: Dart
    .addr _battle_script_audiovisual_command_raised_left_30_frames              ; $02C079.C07A | $D7: Sneak
    .addr _battle_script_audiovisual_command_raised_left_30_frames              ; $02C07B.C07C | $D8: Ninja
    .addr _battle_script_audiovisual_command_bless                              ; $02C07D.C07E | $D9: Bless
    .addr _battle_script_audiovisual_command_change                             ; $02C07F.C080 | $DA: Change
    .addr _battle_script_audiovisual_command_parry                              ; $02C081.C082 | $DB: Parry
    .addr _battle_character_enter_from_right                                    ; $02C083.C084 | $DC: Show
    .addr _battle_script_audiovisual_command_noop                               ; $02C085.C086 | $DD: Off
    .addr _battle_script_audiovisual_command_land                               ; $02C087.C088 | $DE: <unnamed> (Land)
    .addr _battle_script_audiovisual_command_fight                              ; $02C089.C08A | $DF: <unnamed> (Release)
    .addr _battle_script_audiovisual_command_twin_cast                          ; $02C08B.C08C | $E0: <unnamed> (Twin Cast)
    .addr _battle_script_audiovisual_command_noop                               ; $02C08D.C08E | $E1: <unnamed> (Wait)
    .addr _battle_script_audiovisual_command_noop                               ; $02C08F.C090 | $E2: <unnamed> (Bless off)
    .addr _battle_script_audiovisual_command_noop                               ; $02C091.C092 | $E3: <unused>
    .addr _battle_script_audiovisual_command_noop                               ; $02C093.C094 | $E4: <unnamed> (Flee)
    .addr _battle_script_audiovisual_command_vanish                             ; $02C095.C096 | $E5: <unnamed> (Vanish: Grimoire)
    .addr _battle_script_audiovisual_command_noop                               ; $02C097.C098 | $E6: TODO
    .addr _battle_script_audiovisual_command_noop                               ; $02C099.C09A | $E7: TODO

; _battle_script_audiovisual_command_twin ($02:C09B)
;
; Animation handler for the Twin command.
_battle_script_audiovisual_command_twin:
    LDA r_battle_twin_slots.w + 0                                               ; $02C09B |\
    AND #%01111111.b                                                            ; $02C09E | | Change the pose of the first twin to animated casting.
    TAX                                                                         ; $02C0A0 | |
    LDA #BATTLE_POSE_CASTING_ANIMATED.b                                         ; $02C0A1 | |
    STA r_battle_character_pose.w,X                                             ; $02C0A3 |/
    LDA r_battle_twin_slots.w + 1                                               ; $02C0A6 |\
    AND #%01111111.b                                                            ; $02C0A9 | | Change the pose of the second twin to animated casting.
    TAX                                                                         ; $02C0AB | |
    LDA #BATTLE_POSE_CASTING_ANIMATED.b                                         ; $02C0AC | |
    STA r_battle_character_pose.w,X                                             ; $02C0AE |/
    RTS                                                                         ; $02C0B1

; _battle_script_audiovisual_command_noop ($02:C0B2)
;
; Animation handler for commands that need no animation.
_battle_script_audiovisual_command_noop:
    RTS                                                                         ; $02C0B2

; _battle_character_set_moving_unset_pose ($02:C0B3)
;
; Given an 8-bit character slot in the accumulator, flags that character as
; moving and unsets their pose override.
_battle_character_set_moving_unset_pose:
    AND #%01111111.b                                                            ; $02C0B3 |\ Mask out the high bit and transfer the result to the X register.
    TAX                                                                         ; $02C0B5 |/
    LDA #1.b                                                                    ; $02C0B6 |\ Flag the character as moving.
    STA r_battle_character_moving.w,X                                           ; $02C0B8 |/
    STZ r_battle_character_pose.w,X                                             ; $02C0BB | Disable pose override for that character.
    RTS                                                                         ; $02C0BE

; _battle_script_audiovisual_command_twin_cast ($02:C0BF)
;
; Animation handler for the unnamed twin cast command, which handles the actual
; casting after the charging of Twin.
;
; TODO: Does this still operate if the spell actually works, or is that done
;       only by the code for that particular spell?
_battle_script_audiovisual_command_twin_cast:
    LDA r_unknown_3529.w                                                        ; $02C0BF |\ TODO: Skip this function if an unknown variable is set.
    BNE @done                                                                   ; $02C0C2 |/
    LDA r_battle_twin_slots.w + 0                                               ; $02C0C4 |\
    BMI +                                                                       ; $02C0C7 | | Prepare the first twin character if set.
    JSR _battle_character_set_moving_unset_pose                                 ; $02C0C9 |/
+   LDA r_battle_twin_slots.w + 1                                               ; $02C0CC |\
    BMI +                                                                       ; $02C0CF | | Prepare the second twin character if set.
    JSR _battle_character_set_moving_unset_pose                                 ; $02C0D1 |/
+   LDA r_battle_twin_slots.w + 0                                               ; $02C0D4 |\
    BMI +                                                                       ; $02C0D7 | | If there is a first twin, wait frames until they have reached the
    ASL A                                                                       ; $02C0D9 | | acting position.
    ASL A                                                                       ; $02C0DA | |
    ASL A                                                                       ; $02C0DB | |
    ASL A                                                                       ; $02C0DC | |
    TAX                                                                         ; $02C0DD | |
-   PHX                                                                         ; $02C0DE | |
    JSR _battle_wait_next_frame_preserve_x_y                                    ; $02C0DF | |
    PLX                                                                         ; $02C0E2 | |
    LDA r_battle_character_visual_properties.1.x.w,X                            ; $02C0E3 | |
    CMP #BATTLE_COORDINATE_X_PARTY_ACTING.b                                     ; $02C0E6 | |
    BNE -                                                                       ; $02C0E8 |/
+   LDA r_battle_twin_slots.w + 1                                               ; $02C0EA |\
    BMI @done                                                                   ; $02C0ED | | If there is a second twin, wait frames until they have reached the
    ASL A                                                                       ; $02C0EF | | acting position.
    ASL A                                                                       ; $02C0F0 | |
    ASL A                                                                       ; $02C0F1 | |
    ASL A                                                                       ; $02C0F2 | |
    TAX                                                                         ; $02C0F3 | |
-   PHX                                                                         ; $02C0F4 | |
    JSR _battle_wait_next_frame_preserve_x_y                                    ; $02C0F5 | |
    PLX                                                                         ; $02C0F8 | |
    LDA r_battle_character_visual_properties.1.x.w,X                            ; $02C0F9 | |
    CMP #BATTLE_COORDINATE_X_PARTY_ACTING.b                                     ; $02C0FC | |
    BNE -                                                                       ; $02C0FE |/
@done:
    TDC                                                                         ; $02C100 |\
    TAY                                                                         ; $02C101 | | Loop through the two characters, unsetting their pose override.
-   LDA r_battle_twin_slots.w,Y                                                 ; $02C102 | |
    AND #%01111111.b                                                            ; $02C105 | |
    STA r_battle_twin_slots.w,Y                                                 ; $02C107 | |
    TAX                                                                         ; $02C10A | |
    STZ r_battle_character_pose.w,X                                             ; $02C10B | |
    INY                                                                         ; $02C10E | |
    CPY #2.w                                                                    ; $02C10F | |
    BNE -                                                                       ; $02C112 |/
    RTS                                                                         ; $02C114

; _battle_script_audiovisual_command_dart ($02:C115)
;
; Animation handler for the Dart command.
_battle_script_audiovisual_command_dart:
    JSR _battle_move_character_acting                                           ; $02C115 | Move the character to the acting position.
    LDA r_battle_effect_dart_weapon.w                                           ; $02C118 |\
    CMP #ITEM_NINJA.b                                                           ; $02C11B | | If the item being thrown is either the Ninja shuriken or the
    BEQ +                                                                       ; $02C11D | | Shuriken, set the right hand weapon ID to the Shuriken and then
    CMP #ITEM_SHURIKEN.b                                                        ; $02C11F | | call the standard physical attack animation code instead of this
    BNE ++                                                                      ; $02C121 | | function.
+   LDA #ITEM_SHURIKEN.b                                                        ; $02C123 | |
    STA <r_battle_weapon_effect_right_hand                                      ; $02C125 | |
    STZ <r_battle_weapon_effect_left_hand                                       ; $02C127 | |
    JMP _battle_animate_physical_attack_special                                 ; $02C129 |/
++  LDA #BATTLE_WEAPON_SPRITE_FULLMOON.b                                        ; $02C12C |\ Otherwise, load the FullMoon sprite and continue.
    JSR _battle_load_weapon_sprite                                              ; $02C12E |/
    LDA r_battle_effect_dart_weapon.w                                           ; $02C131 |\
    REP #FLAG_P_ACCUMULATOR                                                     ; $02C134 | | Set the X register to the weapon ID times four, in order to index
    ASL A                                                                       ; $02C136 | | the weapon visual properties data.
    ASL A                                                                       ; $02C137 | |
    TAX                                                                         ; $02C138 | |
    TDC                                                                         ; $02C139 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $02C13A |/
    LDA bank0F.battle_weapon_visual_data.l + weapon_visual.palette,X            ; $02C13C |\ Load the weapon's palette.
    JSR _battle_load_effect_palette                                             ; $02C140 |/
    LDA bank0F.battle_weapon_visual_data.l + weapon_visual.weapon_sprite,X      ; $02C143 |\ Save the weapon sprite ID on the stack.
    PHA                                                                         ; $02C147 |/
    JSR _battle_wait_actor_pending_steps_zero                                   ; $02C148 | Wait for the actor to stop moving.
    LDA #BATTLE_POSE_SPECIAL_2.b                                                ; $02C14B |\ Set the character's pose to the special pose.
    JSR _battle_update_character_pose                                           ; $02C14D |/
    JSR _battle_get_current_actor_visual_properties_offset                      ; $02C150 |\
    LDA r_battle_character_visual_properties.1.x.w,X                            ; $02C153 | | Set the projectile source coordinates to the actor's current
    STA r_battle_effect_projectile_source_coordinates.x.w                       ; $02C156 | | coordinates.
    LDA r_battle_character_visual_properties.1.y.w,X                            ; $02C159 | |
    STA r_battle_effect_projectile_source_coordinates.y.w                       ; $02C15C |/
    LDA <r_battle_effect_target_slot                                            ; $02C15F |\
    ASL A                                                                       ; $02C161 | | Set the projectile target X coordinate to the target's X
    TAX                                                                         ; $02C162 | | coordinate, truncated to be a multiple of eight.
    LDA r_battle_monster_coordinates_center.1.x.w,X                             ; $02C163 | |
    AND #%11111000.b                                                            ; $02C166 | |
    STA r_battle_effect_projectile_target_coordinates.x.w                       ; $02C168 |/
    LDA r_battle_monster_coordinates_center.1.y.w,X                             ; $02C16B |\
    AND #%11111000.b                                                            ; $02C16E | | Repeat the same process with the Y coordinate.
    STA r_battle_effect_projectile_target_coordinates.y.w                       ; $02C170 |/
    LDA #8.b                                                                    ; $02C173 |\ Set the projectile horizontal rate to eight pixels per frame.
    STA r_battle_effect_projectile_horizontal_rate.w                            ; $02C175 |/
    JSR _battle_effect_projectile_initialize                                    ; $02C178 | Initialize the projectile variables.
    LDA r_battle_effect_projectile_x_delta.w                                    ; $02C17B |\
    LSR A                                                                       ; $02C17E | | Set the X register to the total X distance divided by eight (the
    LSR A                                                                       ; $02C17F | | total number of frames).
    LSR A                                                                       ; $02C180 | |
    TAX                                                                         ; $02C181 |/
    LSR A                                                                       ; $02C182 |\ Set the midpoint counter to the total X distance divided by 16
    STA r_battle_effect_dart_midpoint_counter.w                                 ; $02C183 |/ (half the total number of frames).
    STX <r_math_divide_16bit_arg_2                                              ; $02C186 |\
    LDX #0.w                                                                    ; $02C188 | | Set the sine delta to zero divided by the number of frames.
    STX <r_math_divide_16bit_arg_1                                              ; $02C18B | |
    JSR _math_divide_16bit                                                      ; $02C18D | | NOTE: This effectively disabled code would allow the dart to have
    LDX <r_math_divide_16bit_result                                             ; $02C190 | |       an arc.
    STX r_battle_effect_dart_sine_delta.w                                       ; $02C192 |/
    STZ r_battle_effect_dart_sine_index_lo.w                                    ; $02C195 |\ Initialize the sine index to zero.
    STZ r_battle_effect_dart_sine_index_hi.w                                    ; $02C198 |/
    STZ r_battle_effect_dart_frame_counter.w                                    ; $02C19B | Initialize the frame counter to zero.
    INC r_battle_effect_dart_midpoint_counter.w                                 ; $02C19E | Increment the midpoint counter by one.
    LDA #AUDIO_EFFECT_DART.b                                                    ; $02C1A1 |\ Play the Dart sound effect.
    JSR _battle_play_sound_effect                                               ; $02C1A3 |/
@start:
    JSR _battle_wait_next_frame_preserve_x_y                                    ; $02C1A6 | Wait for the next frame.
    INC r_battle_effect_dart_frame_counter.w                                    ; $02C1A9 | Increment the frame counter.
    JSR _battle_effect_projectile_update_coordinates                            ; $02C1AC |\ Update the projectile coordinates, and branch to the end if the
    BCS @next                                                                   ; $02C1AF |/ last frame has been reached.
    DEC r_battle_effect_dart_midpoint_counter.w                                 ; $02C1B1 | Decrement the midpoint counter.
    BMI +                                                                       ; $02C1B4 |\
    LDA r_battle_effect_dart_sine_index_lo.w                                    ; $02C1B6 | | If the midpoint counter is still positive, add the sine delta to
    CLC                                                                         ; $02C1B9 | | the sine index.
    ADC r_battle_effect_dart_sine_delta_lo.w                                    ; $02C1BA | |
    STA r_battle_effect_dart_sine_index_lo.w                                    ; $02C1BD | |
    JMP ++                                                                      ; $02C1C0 |/
+   LDA r_battle_effect_dart_sine_index_lo.w                                    ; $02C1C3 |\
    SEC                                                                         ; $02C1C6 | | Otherwise, subtract the sine delta from the sine index.
    SBC r_battle_effect_dart_sine_delta_lo.w                                    ; $02C1C7 | |
    STA r_battle_effect_dart_sine_index_lo.w                                    ; $02C1CA |/
++  LDA r_battle_effect_dart_sine_index_lo.w                                    ; $02C1CD |\
    TAX                                                                         ; $02C1D0 | | Calculate the current arc offset by reading the current sine value
    LDA bank1C.sine_data.l,X                                                    ; $02C1D1 | | and multiplying by half the total X delta (gives a total maximum
    STA <r_math_multiply_8bit_arg_1                                             ; $02C1D5 | | of 1/4 the total X delta).
    LDA r_battle_effect_projectile_x_delta.w                                    ; $02C1D7 | |
    LSR A                                                                       ; $02C1DA | |
    STA <r_math_multiply_8bit_arg_2                                             ; $02C1DB | |
    JSR _math_multiply_8bit                                                     ; $02C1DD |/
    LDA <r_battle_current_actor_slot                                            ; $02C1E0 |\
    TAX                                                                         ; $02C1E2 | | Set the weapon OAM index to the base OAM index for the acting
    LDA bank16.battle_character_slot_oam_index_data.l,X                         ; $02C1E3 | | character.
    STA r_battle_weapon_sprite_oam_index.w                                      ; $02C1E7 |/
    LDA r_battle_effect_dart_frame_counter.w                                    ; $02C1EA |\
    AND #%00001000.b                                                            ; $02C1ED | | Set the X register such that it alternates between 0 and 4 every
    LSR A                                                                       ; $02C1EF | | eight frames.
    TAX                                                                         ; $02C1F0 |/
    LDA bank16.battle_weapon_sprite_dart_data.l + 0,X                           ; $02C1F1 |\ Read the correct tile number from ROM.
    STA r_battle_weapon_sprite_tile.w                                           ; $02C1F5 |/
    LDA bank16.battle_weapon_sprite_dart_data.l + 1,X                           ; $02C1F8 |\
    CLC                                                                         ; $02C1FC | | Set the X coordinate to the projectile X coordinate plus the
    ADC r_battle_effect_projectile_coordinates.x.w                              ; $02C1FD | | offset from ROM.
    STA r_battle_weapon_sprite_coordinates.x.w                                  ; $02C200 |/
    LDA bank16.battle_weapon_sprite_dart_data.l + 2,X                           ; $02C203 |\
    CLC                                                                         ; $02C207 | | Set the Y coordinate to the projecitle Y coordinate plus the
    ADC r_battle_effect_projectile_coordinates.y.w                              ; $02C208 | | offset from ROM, and then subtract the sine value.
    SEC                                                                         ; $02C20B | |
    SBC <r_math_multiply_8bit_result_hi                                         ; $02C20C | |
    STA r_battle_weapon_sprite_coordinates.y.w                                  ; $02C20E |/
    LDA bank16.battle_weapon_sprite_dart_data.l + 3,X                           ; $02C211 |\ Set the tile flags to the value read from ROM.
    STA r_battle_weapon_sprite_tile_flags.w                                     ; $02C215 |/
    LDA #1.b                                                                    ; $02C218 |\ Make the weapon sprite visible.
    STA r_battle_weapon_sprite_visible.w                                        ; $02C21A |/
    JMP @start                                                                  ; $02C21D | Jump to the next iteration of the loop.
@next:
    LDA <r_battle_effect_target_slot                                            ; $02C220 |\
    ASL A                                                                       ; $02C222 | | Set the X coordinate for the sprite to the target center X
    TAX                                                                         ; $02C223 | | coordinate minus eight.
    LDA r_battle_monster_coordinates_center.1.x.w,X                             ; $02C224 | |
    SEC                                                                         ; $02C227 | |
    SBC #8.b                                                                    ; $02C228 | |
    STA r_battle_weapon_sprite_coordinates.x.w                                  ; $02C22A |/
    LDA r_battle_monster_coordinates_center.1.y.w,X                             ; $02C22D |\
    SEC                                                                         ; $02C230 | | Repeat with the Y coordinate.
    SBC #8.b                                                                    ; $02C231 | |
    STA r_battle_weapon_sprite_coordinates.y.w                                  ; $02C233 |/
    TDC                                                                         ; $02C236 |\
    TAX                                                                         ; $02C237 | | Load the tile number from ROM.
    LDA bank16.battle_weapon_sprite_dart_data.l + 0,X                           ; $02C238 | |
    STA r_battle_weapon_sprite_tile.w                                           ; $02C23C |/
    LDA #1.b                                                                    ; $02C23F |\ Set the weapon sprite as visible.
    STA r_battle_weapon_sprite_visible.w                                        ; $02C241 |/
    PLA                                                                         ; $02C244 | Load the weapon sprite ID from the stack.
    JSR _battle_load_weapon_sprite                                              ; $02C245 | Load the sprite for the darted weapon.
    LDA #AUDIO_EFFECT_DART_HIT.b                                                ; $02C248 |\ Play the Dart hit sound effect.
    JSR _battle_play_sound_effect                                               ; $02C24A |/
    LDX #20.w                                                                   ; $02C24D | Initialize the X register to twenty. NOTE: This is pointless.
    STZ r_battle_effect_projectile_source_coordinates.x.w                       ; $02C250 | Set the frame counter to zero (reusing a variable).
-   JSR _battle_wait_next_frame_preserve_x_y                                    ; $02C253 | Wait for the next frame.
    INC r_battle_effect_projectile_source_coordinates.x.w                       ; $02C256 |\
    LDA r_battle_effect_projectile_source_coordinates.x.w                       ; $02C259 | | Increment the frame counter and if it's been sixteen frames,
    CMP #16.b                                                                   ; $02C25C | | branch to the end.
    BEQ +                                                                       ; $02C25E |/
    TAX                                                                         ; $02C260 |\
    LDA bank16.battle_weapon_sprite_dart_offset_data.l,X                        ; $02C261 | | Update the Y coordinate by reading the offset from ROM.
    CLC                                                                         ; $02C265 | |
    ADC r_battle_weapon_sprite_coordinates.y.w                                  ; $02C266 | |
    STA r_battle_weapon_sprite_coordinates.y.w                                  ; $02C269 |/
    LDA #1.b                                                                    ; $02C26C |\ Make sure the weapon sprite is visible.
    STA r_battle_weapon_sprite_visible.w                                        ; $02C26E |/
    JMP -                                                                       ; $02C271 | Loop to the next iteration.
+   STZ r_battle_weapon_sprite_visible.w                                        ; $02C274 | Make the weapon sprite not visible.

; _battle_character_finalize_manual_movement ($02:C277)
;
; Given a slot number in $48, enables automatic movement for that character and
; resets their pose to normal.
_battle_character_finalize_manual_movement:
    JSR _battle_character_enable_automatic_movement                             ; $02C277 | Enable automatic movement for the character.
    TDC                                                                         ; $02C27A |\ Set the pose of the character to zero, which disables pose
    JMP _battle_update_character_pose                                           ; $02C27B |/ override.

; _battle_hold_character_pose_for_30_frames ($02:C27E)
;
; Given a pose number in the accumulator, sets the current actor's pose to that
; value and then waits 30 frames before setting it back to normal.
_battle_hold_character_pose_for_30_frames:
    JSR _battle_update_character_pose                                           ; $02C27E
    LDX #30.w                                                                   ; $02C281
    JSR _battle_wait_x_frames                                                   ; $02C284
    TDC                                                                         ; $02C287
    JMP _battle_update_character_pose                                           ; $02C288

; _battle_wait_actor_pending_steps_zero ($02:C28B)
;
; Given a slot in $48, waits until the character in question has no pending
; steps left to execute. This routine only makes sense to call if the actor is
; a character (and not a monster).
_battle_wait_actor_pending_steps_zero:
    LDA <r_battle_current_actor_slot                                            ; $02C28B |\ Load the current actor slot into the X register.
    TAX                                                                         ; $02C28D |/
    LDA #1.b                                                                    ; $02C28E |\ Disable automatic movement of the character.
    STA r_battle_character_disable_automatic_movement.w,X                       ; $02C290 |/
-   JSR _battle_wait_next_frame_preserve_x_y                                    ; $02C293 | Wait for the next frame.
    JSR _battle_get_current_actor_visual_properties_offset                      ; $02C296 |\
    LDA r_battle_character_visual_properties.1.pending_steps.w,X                ; $02C299 | | Loop until the character has no pending steps.
    BNE -                                                                       ; $02C29C |/
    RTS                                                                         ; $02C29E

; _battle_character_enable_automatic_movement ($02:C29F)
;
; Given a character slot in $48, resets the flag that disables automatic
; movement of that character.
_battle_character_enable_automatic_movement:
    LDA <r_battle_current_actor_slot                                            ; $02C29F |\
    TAX                                                                         ; $02C2A1 | | Enable automatic movement for the character.
    TDC                                                                         ; $02C2A2 | |
    STA r_battle_character_disable_automatic_movement.w,X                       ; $02C2A3 |/
    RTS                                                                         ; $02C2A6

; _battle_script_audiovisual_command_parry ($02:C2A7)
;
; Animation handler for the Parry command.
_battle_script_audiovisual_command_parry:
    LDA #BATTLE_POSE_PARRYING.b                                                 ; $02C2A7 |\ Change the character pose to parrying.
    JMP _battle_update_character_pose                                           ; $02C2A9 |/

; _battle_set_current_actor_visual_id ($02:C2AC)
;
; Makes the current actor visible, by restoring their visual ID from their
; battle record. This only makes sense if the actor is a character.
_battle_set_current_actor_visual_id:
    PHX                                                                         ; $02C2AC | Preserve the value of the X register.
    LDA <r_battle_current_actor_slot                                            ; $02C2AD |\
    TAX                                                                         ; $02C2AF | | Set the X register to the offset to the actor's visual properties.
    JSR _multiply_x_by_128                                                      ; $02C2B0 |/
    LDA <r_battle_current_actor_slot                                            ; $02C2B3 |\
    ASL A                                                                       ; $02C2B5 | | Set the Y register to the offset to the actor's battle record.
    ASL A                                                                       ; $02C2B6 | |
    ASL A                                                                       ; $02C2B7 | |
    ASL A                                                                       ; $02C2B8 | |
    TAY                                                                         ; $02C2B9 |/
    LDA r_character_battle.1.id.w,X                                             ; $02C2BA |\
    AND #%00111111.b                                                            ; $02C2BD | | Restore the character's visual ID, making them visible.
    STA r_battle_character_visual_properties.1.id.w,Y                           ; $02C2BF |/
    PLX                                                                         ; $02C2C2 | restore the value of the X register.
    RTS                                                                         ; $02C2C3

; _battle_kick_prepare_palette_cycle ($02:C2C4)
;
; Given a value in the accumulator which is non-zero if the palette cycling is
; intended to affect monsters, sets up some of the variables needed for the
; palette cycling effect and loads the red palette.
_battle_kick_prepare_palette_cycle:
    STA r_battle_effect_target_palette_cycling_monster.w                        ; $02C2C4 | Set the palette cycle monster value to the passed value.
    LDA r_battle_current_action_details.target.w                                ; $02C2C7 |\ Copy the targets to the argument for the function that sets the
    STA r_battle_monster_set_palette_cycle_arg_targets.w                        ; $02C2CA |/ cycling palette on monsters.
    STA r_battle_effect_target_palette_cycling_target.w                         ; $02C2CD | Set the palette cycle target variable.
    STA r_battle_effect_target_palette_cycling_party_active.w                   ; $02C2D0 | Set the second palette cycle active flag.
    TDC                                                                         ; $02C2D3 |\ Load the first palette cycle palette (red).
    JMP _battle_palette_cycle_load_palette                                      ; $02C2D4 |/

; _battle_script_audiovisual_command_kick ($02:C2D7)
;
; Animates the Kick command, either by a monster or by a character.
_battle_script_audiovisual_command_kick:
    LDA #AUDIO_EFFECT_KICK.b                                                    ; $02C2D7 |\ Play the Kick sound effect.
    JSR _battle_play_sound_effect                                               ; $02C2D9 |/
    LDA r_battle_current_action_details.actor_flags.w                           ; $02C2DC |\ Branch to separate code if the actor is a character.
    BPL @character                                                              ; $02C2DF |/
    LDA #BATTLE_POSE_MONSTER_SPECIAL.b                                          ; $02C2E1 |\ Change the monster's pose to the special pose.
    JSR _battle_update_monster_character_tilemap_pose                           ; $02C2E3 |/
    TDC                                                                         ; $02C2E6 |\ Configure the palette cycling effect to affect the targeted
    JSR _battle_kick_prepare_palette_cycle                                      ; $02C2E7 |/ characters.
    LDA #TARGET_PALETTE_CYCLING_MODE_CYCLE.b                                    ; $02C2EA |\ Set the target palette cycling mode to cycle colors.
    STA r_battle_effect_target_palette_cycling_mode.w                           ; $02C2EC |/
    INC r_battle_effect_target_palette_cycling_active.w                         ; $02C2EF |\ Enable automatic target palette cycling.
    INC r_battle_effect_target_palette_cycling_automatic.w                      ; $02C2F2 |/
    JSL bank01.battle_animate_monster_kick_forward                              ; $02C2F5 | Animate the forward portion of the kick.
    TDC                                                                         ; $02C2F9 |\
    STA r_battle_effect_target_palette_cycling_active.w                         ; $02C2FA | | Disable the palette cycling effect.
    STA r_battle_effect_target_palette_cycling_automatic.w                      ; $02C2FD | |
    STA r_battle_effect_target_palette_cycling_party_active.w                   ; $02C300 |/
    INC r_battle_load_monster_character_reverse.w                               ; $02C303 |\
    LDA #BATTLE_POSE_MONSTER_SPECIAL_2.b                                        ; $02C306 | | Load a reversed special pose.
    JSR _battle_update_monster_character_tilemap_pose                           ; $02C308 |/
    JSL bank01.battle_animate_monster_kick_reverse                              ; $02C30B | Animate the reverse portion of the kick.
    TDC                                                                         ; $02C30F |\
    STA r_battle_load_monster_character_reverse.w                               ; $02C310 | | Set the monster's pose back to normal and return.
    JMP _battle_update_monster_character_tilemap_pose                           ; $02C313 |/
@character:
    JSR _battle_wait_actor_pending_steps_zero                                   ; $02C316 | Wait until the actor is no longer moving.
    JSR _battle_current_actor_disable_status_pose                               ; $02C319 | Disable any automatic status poses for the actor.
    LDA #BATTLE_POSE_SPECIAL_2.b                                                ; $02C31C |\ Set the character's pose to the special pose.
    JSR _battle_update_character_pose                                           ; $02C31E |/
    LDA #16.b                                                                   ; $02C321 |\
    STA r_battle_effect_projectile_target_coordinates.x.w                       ; $02C323 | | Set the target coordinates to 14,76, which is roughly on the far
    LDA #76.b                                                                   ; $02C326 | | left of the screen in the middle.
    STA r_battle_effect_projectile_target_coordinates.y.w                       ; $02C328 |/
    JSR _battle_get_current_actor_visual_properties_offset                      ; $02C32B |\
    LDA r_battle_character_visual_properties.1.x.w,X                            ; $02C32E | | Set the source coordinates to the character's current location.
    STA r_battle_effect_projectile_source_coordinates.x.w                       ; $02C331 | |
    LDA r_battle_character_visual_properties.1.y.w,X                            ; $02C334 | |
    STA r_battle_effect_projectile_source_coordinates.y.w                       ; $02C337 |/
    LDA #8.b                                                                    ; $02C33A |\ Set the projectile horizontal rate to eight pixels per frame.
    STA r_battle_effect_projectile_horizontal_rate.w                            ; $02C33C |/
    JSR _battle_effect_projectile_initialize                                    ; $02C33F | Initialize the projectile variables.
    LDA #1.b                                                                    ; $02C342 |\ Prepare the palette cycling effect to affect monsters.
    JSR _battle_kick_prepare_palette_cycle                                      ; $02C344 |/
    JSR _battle_monster_set_palette_cycle                                       ; $02C347 | Set the cycled palette on the monster targets.
    LDA #1.b                                                                    ; $02C34A |\ Switch to the right side of BG1.
    JSR _battle_set_bg1_horizontal_hi_scroll                                    ; $02C34C |/
    LDA #TARGET_PALETTE_CYCLING_MODE_CYCLE.b                                    ; $02C34F |\ Set the target palette cycling mode to cycle.
    STA r_battle_effect_target_palette_cycling_mode.w                           ; $02C351 |/
    LDA #1.b                                                                    ; $02C354 |\
    STA r_battle_effect_target_palette_cycling_party_active.w                   ; $02C356 | | Activate the target palette cycling effect.
    INC r_battle_effect_target_palette_cycling_active.w                         ; $02C359 | |
    INC r_battle_effect_target_palette_cycling_automatic.w                      ; $02C35C |/
    JSR _battle_animate_character_kick                                          ; $02C35F | Animate the forward portion of the kick.
    JSR _battle_get_current_actor_visual_properties_offset                      ; $02C362 | Set the X register to the visual properties offset for the actor.
    LDA r_battle_character_visual_properties.1.flags.w,X                        ; $02C365 |\
    EOR #CHARACTER_VISUAL_FLAG_REVERSE.b                                        ; $02C368 | | Flip the reverse flag on the character.
    STA r_battle_character_visual_properties.1.flags.w,X                        ; $02C36A |/
    LDA r_battle_character_visual_properties.1.x.w,X                            ; $02C36D |\
    STA r_battle_effect_projectile_source_coordinates.x.w                       ; $02C370 | | Set the projectile source coordinates to the character's current
    LDA r_battle_character_visual_properties.1.y.w,X                            ; $02C373 | | coordinates.
    STA r_battle_effect_projectile_source_coordinates.y.w                       ; $02C376 |/
    LDA r_battle_party_formation_two_front.w                                    ; $02C379 |\
    BNE +                                                                       ; $02C37C | | Set the projectile target X coordinate to the correct X coordinate
    PHX                                                                         ; $02C37E | | for that slot, depending on the current party formation.
    LDA <r_battle_current_actor_slot                                            ; $02C37F | |
    TAX                                                                         ; $02C381 | |
    LDA bank16.battle_party_three_front_slot_x_coordinate_data.l,X              ; $02C382 | |
    PLX                                                                         ; $02C386 | |
    BRA ++                                                                      ; $02C387 | |
+   PHX                                                                         ; $02C389 | |
    LDA <r_battle_current_actor_slot                                            ; $02C38A | |
    TAX                                                                         ; $02C38C | |
    LDA bank16.battle_party_two_front_slot_x_coordinate_data.l,X                ; $02C38D | |
    PLX                                                                         ; $02C391 | |
++  STA r_battle_effect_projectile_target_coordinates.x.w                       ; $02C392 |/
    LDA <r_battle_current_actor_slot                                            ; $02C395 |\
    TAX                                                                         ; $02C397 | | Set the projectile target Y coordinate to the correct value for
    LDA bank16.battle_character_slot_y_coordinate_data.l,X                      ; $02C398 | | that slot.
    STA r_battle_effect_projectile_target_coordinates.y.w                       ; $02C39C |/
    LDA #8.b                                                                    ; $02C39F |\ Set the projectile horizontal rate to eight pixels per frame.
    STA r_battle_effect_projectile_horizontal_rate.w                            ; $02C3A1 |/
    JSR _battle_effect_projectile_initialize                                    ; $02C3A4 | Initialize the projectile variables.
    TDC                                                                         ; $02C3A7 |\
    STA r_battle_effect_target_palette_cycling_automatic.w                      ; $02C3A8 | | Disable palette cycling.
    STA r_battle_effect_target_palette_cycling_active.w                         ; $02C3AB | |
    STA r_battle_effect_target_palette_cycling_party_active.w                   ; $02C3AE |/
    JSR _battle_set_bg1_horizontal_hi_scroll                                    ; $02C3B1 | Switch back to the left side of BG1.
    JSR _battle_animate_character_kick                                          ; $02C3B4 | Animate the reverse portion of the kick.
    LDA r_battle_character_visual_properties.1.flags.w,X                        ; $02C3B7 |\
    EOR #CHARACTER_VISUAL_FLAG_REVERSE.b                                        ; $02C3BA | | Flip the reverse flag on the character again.
    STA r_battle_character_visual_properties.1.flags.w,X                        ; $02C3BC |/
    JSR _battle_current_actor_enable_status_pose                                ; $02C3BF | Enable automatic status poses for the character.
    JMP _battle_character_finalize_manual_movement                              ; $02C3C2 | Enable automatic movement and disable pose override.

; _battle_animate_character_kick ($02:C3C5)
;
; Animates the actual movement of the character during a Kick command. Only
; updates coordinates. Everything should have been preconfigured. Returns when
; the character reaches the configured target.
_battle_animate_character_kick:
-   JSR _battle_wait_next_frame_preserve_x_y                                    ; $02C3C5 | Wait for the next frame.
    JSR _battle_effect_projectile_update_coordinates                            ; $02C3C8 |\ Update the projectile coordinates and return if the last frame has
    BCS +                                                                       ; $02C3CB |/ been reached.
    JSR _battle_get_current_actor_visual_properties_offset                      ; $02C3CD |\
    LDA r_battle_effect_projectile_coordinates.x.w                              ; $02C3D0 | | Update the character's coordinates to the calculated projectile
    STA r_battle_character_visual_properties.1.x.w,X                            ; $02C3D3 | | coordinates.
    LDA r_battle_effect_projectile_coordinates.y.w                              ; $02C3D6 | |
    STA r_battle_character_visual_properties.1.y.w,X                            ; $02C3D9 |/
    BRA -                                                                       ; $02C3DC | Go to the next iteration of the loop.
+   RTS                                                                         ; $02C3DE

; battle_weapon_effect_boomerang_initialize ($02:C3DF)
;
; Initializes some variables used by the boomerang weapon effect.
battle_weapon_effect_boomerang_initialize:
    LDA r_battle_effect_projectile_x_delta.w                                    ; $02C3DF |\
    LSR A                                                                       ; $02C3E2 | | Divide the total X delta by 8 and save the result for later
    LSR A                                                                       ; $02C3E3 | | division.
    LSR A                                                                       ; $02C3E4 | |
    TAX                                                                         ; $02C3E5 |/
    LSR A                                                                       ; $02C3E6 |\ Set the boomerang frame counter to the total X delta divided by 16.
    STA r_battle_effect_boomerang_frame_counter.w                               ; $02C3E7 |/
    STX <r_math_divide_16bit_arg_2                                              ; $02C3EA |\
    LDX #128.w                                                                  ; $02C3EC | | Set the sine delta to 128 divided by the X delta divided by eight.
    STX <r_math_divide_16bit_arg_1                                              ; $02C3EF | | This is added/subtracted to the sine index each frame.
    JSR _math_divide_16bit                                                      ; $02C3F1 | |
    LDX <r_math_divide_16bit_result                                             ; $02C3F4 | | TODO: This overwrites the value at $F134. Does that matter?
    STX r_battle_effect_boomerang_sine_delta.w                                  ; $02C3F6 |/
    TDC                                                                         ; $02C3F9 |\
    TAX                                                                         ; $02C3FA | | Initialize the sine index to zero.
    STX r_battle_effect_boomerang_sine_index.w                                  ; $02C3FB |/
    INC r_battle_effect_boomerang_frame_counter.w                               ; $02C3FE | Add one to the boomerang frame counter to ensure it's always >= 1.
    RTL                                                                         ; $02C401

; battle_weapon_effect_boomerang_calculate_vertical_offset ($02:C402)
;
; Based on the current value of the boomerang sine index and the boomerang
; frame counter, determines the current value of the vertical offset to create
; the boomerang effect. The result is returned in $2B.
battle_weapon_effect_boomerang_calculate_vertical_offset:
    DEC r_battle_effect_boomerang_frame_counter.w                               ; $02C402 | Decrement the boomerang frame counter.
    BMI +                                                                       ; $02C405 |\
    LDA r_battle_effect_boomerang_sine_index.w                                  ; $02C407 | | If the result is positive, add the sine delta to the sine index.
    CLC                                                                         ; $02C40A | |
    ADC r_battle_effect_boomerang_sine_delta.w                                  ; $02C40B | |
    STA r_battle_effect_boomerang_sine_index.w                                  ; $02C40E | |
    BRA ++                                                                      ; $02C411 |/
+   LDA r_battle_effect_boomerang_sine_index.w                                  ; $02C413 |\
    SEC                                                                         ; $02C416 | | Otherwise, subtract the delta from the sine index.
    SBC r_battle_effect_boomerang_sine_delta.w                                  ; $02C417 | |
    STA r_battle_effect_boomerang_sine_index.w                                  ; $02C41A |/
++  LDA r_battle_effect_boomerang_sine_index.w                                  ; $02C41D |\
    TAX                                                                         ; $02C420 | | Multiply the corresponding value in the actual sine data by half
    LDA bank1C.sine_data.l,X                                                    ; $02C421 | | the total X delta. The result is that the high byte of the result
    STA <r_math_multiply_8bit_arg_1                                             ; $02C425 | | will range from zero to one quarter the total X delta.
    LDA r_battle_effect_projectile_x_delta.w                                    ; $02C427 | |
    LSR A                                                                       ; $02C42A | |
    STA <r_math_multiply_8bit_arg_2                                             ; $02C42B | |
    JSR _math_multiply_8bit                                                     ; $02C42D |/
    RTL                                                                         ; $02C430

; _battle_animate_land_return_character ($02:C431)
;
; Animates the part of the Land effect that sees the character return in an arc
; from their landing point to their starting point. Used as part of the overall
; Land animation, and doesn't make sense in other contexts as it makes too many
; assumptions.
_battle_animate_land_return_character:
    JSL battle_weapon_effect_boomerang_initialize                               ; $02C431 | Initialize the boomerang effect variables.
-   JSR _battle_wait_next_frame_preserve_x_y                                    ; $02C435 | Wait for the next frame.
    JSR _battle_effect_projectile_update_coordinates                            ; $02C438 |\ Update the projectile coordinates and branch to the end once the
    BCS +                                                                       ; $02C43B |/ last frame is complete.
    JSL battle_weapon_effect_boomerang_calculate_vertical_offset                ; $02C43D | Calculate the boomerang vertical offset (ends up in math result).
    JSR _battle_get_current_actor_visual_properties_offset                      ; $02C441 | Set the X register to the offset to the visual properties.
    LDA r_battle_effect_projectile_coordinates.x.w                              ; $02C444 |\
    STA r_battle_effect_boomerang_coordinates.x.w                               ; $02C447 | | Update the character's X coordinate.
    STA r_battle_character_visual_properties.1.x.w,X                            ; $02C44A |/
    LDA r_battle_effect_projectile_coordinates.y.w                              ; $02C44D |\
    STA r_battle_effect_boomerang_coordinates.y.w                               ; $02C450 | | Update the Y coordinate, subtracting the vertical offset to create
    SEC                                                                         ; $02C453 | | the rising and falling part of the effect.
    SBC <r_math_multiply_8bit_result_hi                                         ; $02C454 | |
    STA r_battle_character_visual_properties.1.y.w,X                            ; $02C456 |/
    BRA -                                                                       ; $02C459 | Branch to the next iteration.
+   JSR _battle_get_current_actor_visual_properties_offset                      ; $02C45B |\
    LDA r_battle_effect_boomerang_coordinates.x.w                               ; $02C45E | | Set the character's coordinates to the final calculated projectile
    STA r_battle_character_visual_properties.1.x.w,X                            ; $02C461 | | coordinates.
    LDA r_battle_effect_boomerang_coordinates.y.w                               ; $02C464 | |
    STA r_battle_character_visual_properties.1.y.w,X                            ; $02C467 |/
    RTS                                                                         ; $02C46A

; _battle_clear_bg1_right ($02:C46B)
;
; Clears the right half of BG1 during battle.
_battle_clear_bg1_right:
    PHX                                                                         ; $02C46B | Preserve the value of the X register.
    JSR _init_battle_tilemap                                                    ; $02C46C | Clear the battle tilemap.
    JSR _copy_battle_tilemap_bg1_right_to_vram                                  ; $02C46F | Transfer the battle tilemap to the right half of BG1.
    PLX                                                                         ; $02C472 | Restore the value of the X register.
    RTS                                                                         ; $02C473

; _battle_script_audiovisual_command_land ($02:C474)
;
; Animation handler for the unnamed land command, which is the second half of
; the Jump command.
_battle_script_audiovisual_command_land:
    LDA r_battle_current_action_details.actor_flags.w                           ; $02C474 |\ Branch to separate code if the actor is a character.
    BPL +                                                                       ; $02C477 |/
    JSR _battle_clear_bg1_right                                                 ; $02C479 | Clear the right half of BG1.
    LDA #1.b                                                                    ; $02C47C |\
    STA r_battle_load_monster_character_reverse.w                               ; $02C47E | | Load the reversed special pose for the monster.
    LDA #BATTLE_POSE_MONSTER_SPECIAL_2.b                                        ; $02C481 | |
    JSR _battle_update_monster_character_tilemap_pose                           ; $02C483 |/
    JSL bank01.battle_animate_land_monster                                      ; $02C486 | Animate the landing effect.
    TDC                                                                         ; $02C48A |\
    STA r_battle_load_monster_character_reverse.w                               ; $02C48B | | Set the monster's pose back to normal.
    JSR _battle_update_monster_character_tilemap_pose                           ; $02C48E |/
    RTS                                                                         ; $02C491 | Return to the caller.
+   JSR _battle_wait_actor_pending_steps_zero                                   ; $02C492 | Wait for the actor to stop moving.
    LDA <r_battle_effect_target_slot                                            ; $02C495 |\
    ASL A                                                                       ; $02C497 | | Set the X register to index coordinates.
    TAX                                                                         ; $02C498 |/
    LDA r_battle_monster_coordinates_bottom_center.1.x.w,X                      ; $02C499 |\
    AND #%11111000.b                                                            ; $02C49C | | Save the bottom center X coordinate of the target (truncated to a
    STA <r_battle_generic_tmp_index_lo                                          ; $02C49E | | multiple of eight) to a temporary variable and a TODO variable.
    STA r_battle_animate_land_unused_1_lo.w                                     ; $02C4A0 |/
    LDA r_battle_monster_coordinates_bottom_center.1.y.w,X                      ; $02C4A3 |\
    SEC                                                                         ; $02C4A6 | | Save the bottom center Y coordinate of the target (truncated to a
    SBC #24.b                                                                   ; $02C4A7 | | multiple of eight) to a temporary variable and to the counter.
    AND #%11111000.b                                                            ; $02C4A9 | |
    STA r_battle_animate_land_tmp_counter.w                                     ; $02C4AB | |
    STA <r_battle_generic_tmp_index_hi                                          ; $02C4AE |/
    JSR _battle_get_current_actor_visual_properties_offset                      ; $02C4B0 | Set the X register to the actor's visual properties offset.
    TDC                                                                         ; $02C4B3 |\ Set the actor's Y coordinate to zero.
    STA r_battle_character_visual_properties.1.y.w,X                            ; $02C4B4 |/
    LDA <r_battle_generic_tmp_index_lo                                          ; $02C4B7 |\
    SEC                                                                         ; $02C4B9 | | Set the actor's X coordinate to the target's X coordinate minus
    SBC <r_battle_generic_tmp_index_hi                                          ; $02C4BA | | the Y coordinate (so the landing can be diagonal).
    STA r_battle_character_visual_properties.1.x.w,X                            ; $02C4BC |/
    BCC +                                                                       ; $02C4BF |\ If the X coordinate is not negative, set the actor's visual ID so
    JSR _battle_set_current_actor_visual_id                                     ; $02C4C1 |/ they are visible.
+   LDA r_battle_character_visual_properties.1.flags.w,X                        ; $02C4C4 |\
    EOR #CHARACTER_VISUAL_FLAG_REVERSE.b                                        ; $02C4C7 | | Toggle the reverse flag on the actor's visual properties.
    STA r_battle_character_visual_properties.1.flags.w,X                        ; $02C4C9 |/
    LDA #BATTLE_POSE_SPECIAL_2.b                                                ; $02C4CC |\ Set the actor's pose to the second special pose.
    JSR _battle_update_character_pose                                           ; $02C4CE |/
-   JSR _battle_wait_next_frame_preserve_x_y                                    ; $02C4D1 | Wait for the next frame.
    JSR _battle_get_current_actor_visual_properties_offset                      ; $02C4D4 | Set the X register to the actor's visual properties offset.
    LDA r_battle_character_visual_properties.1.x.w,X                            ; $02C4D7 |\
    CLC                                                                         ; $02C4DA | | Add eight to the actor's X coordinate.
    ADC #8.b                                                                    ; $02C4DB | |
    STA r_battle_character_visual_properties.1.x.w,X                            ; $02C4DD |/
    BCC +                                                                       ; $02C4E0 |\ If the new coordinate is zero or greater, make the actor visible.
    JSR _battle_set_current_actor_visual_id                                     ; $02C4E2 |/
+   LDA r_battle_character_visual_properties.1.y.w,X                            ; $02C4E5 |\
    CLC                                                                         ; $02C4E8 | | Add eight to the actor's Y coordinate.
    ADC #8.b                                                                    ; $02C4E9 | |
    STA r_battle_character_visual_properties.1.y.w,X                            ; $02C4EB |/
    LDA r_battle_animate_land_tmp_counter.w                                     ; $02C4EE |\
    SEC                                                                         ; $02C4F1 | | Subtract eight from the counter and loop until it reaches zero.
    SBC #8.b                                                                    ; $02C4F2 | |
    STA r_battle_animate_land_tmp_counter.w                                     ; $02C4F4 | |
    BNE -                                                                       ; $02C4F7 |/
    LDA r_battle_character_visual_properties.1.x.w,X                            ; $02C4F9 |\
    STA r_battle_effect_projectile_source_coordinates.x.w                       ; $02C4FC | | Set the projectile source coordinates to the actor's current
    LDA r_battle_character_visual_properties.1.y.w,X                            ; $02C4FF | | coordinates (at the target).
    STA r_battle_effect_projectile_source_coordinates.y.w                       ; $02C502 |/
    LDA r_battle_party_formation_two_front.w                                    ; $02C505 |\
    BNE +                                                                       ; $02C508 | | If the party formation has three characters in front, load the
    PHX                                                                         ; $02C50A | | relevant home X coordinate into the accumulator.
    LDA <r_battle_current_actor_slot                                            ; $02C50B | |
    TAX                                                                         ; $02C50D | |
    LDA bank16.battle_party_three_front_slot_x_coordinate_data.l,X              ; $02C50E | |
    PLX                                                                         ; $02C512 | |
    BRA ++                                                                      ; $02C513 |/
+   PHX                                                                         ; $02C515 |\
    LDA <r_battle_current_actor_slot                                            ; $02C516 | | Do the same for the two character in front formation.
    TAX                                                                         ; $02C518 | |
    LDA bank16.battle_party_two_front_slot_x_coordinate_data.l,X                ; $02C519 | |
    PLX                                                                         ; $02C51D |/
++  STA r_battle_effect_projectile_target_coordinates.x.w                       ; $02C51E | Save the loaded value as the target projectile X coordinate.
    PHA                                                                         ; $02C521 |\
    LDA <r_battle_current_actor_slot                                            ; $02C522 | | Load the destination Y coordinate for this slot and save that as
    TAX                                                                         ; $02C524 | | the target projectile Y coordinate.
    LDA bank16.battle_character_slot_y_coordinate_data.l,X                      ; $02C525 | |
    PHA                                                                         ; $02C529 | |
    STA r_battle_effect_projectile_target_coordinates.y.w                       ; $02C52A |/
    LDA #8.b                                                                    ; $02C52D |\ Set the horizontal rate to eight pixels per frame.
    STA r_battle_effect_projectile_horizontal_rate.w                            ; $02C52F |/
    JSR _battle_effect_projectile_initialize                                    ; $02C532 | Initialize the projectile variables.
    LDA #AUDIO_EFFECT_DART_HIT.b                                                ; $02C535 |\ Play the Dart hit sound effect.
    JSR _battle_play_sound_effect                                               ; $02C537 |/
    JSR _battle_animate_land_return_character                                   ; $02C53A | Animate the return of the character to their home location.
    JSR _battle_get_current_actor_visual_properties_offset                      ; $02C53D |\
    PLA                                                                         ; $02C540 | | Explicitly set the actor's coordinates to the loaded values.
    STA r_battle_character_visual_properties.1.y.w,X                            ; $02C541 | |
    PLA                                                                         ; $02C544 | |
    STA r_battle_character_visual_properties.1.x.w,X                            ; $02C545 |/
    LDA r_battle_character_visual_properties.1.flags.w,X                        ; $02C548 |\
    EOR #CHARACTER_VISUAL_FLAG_REVERSE.b                                        ; $02C54B | | Toggle the reverse flag again.
    STA r_battle_character_visual_properties.1.flags.w,X                        ; $02C54D |/
    JMP _battle_character_finalize_manual_movement                              ; $02C550 | Enable automatic movement and disable pose override.

; _battle_character_enter_from_right ($02:C553)
;
; Given the current actor slot in $48, goes through the process of having the
; character enter the battle from the right side of the screen.
_battle_character_enter_from_right:
    JSR _battle_wait_actor_pending_steps_zero                                   ; $02C553 | Wait until the character stops moving.
    JSR _battle_get_current_actor_visual_properties_offset                      ; $02C556 |\
    TXA                                                                         ; $02C559 | | Set the Y register to the visual properties offset.
    TAY                                                                         ; $02C55A |/
    LDA r_battle_character_visual_properties.1.flags.w,Y                        ; $02C55B |\
    AND #CHARACTER_VISUAL_FLAG_REVERSE.b ~ $FF                                  ; $02C55E | | Unset any reverse flag set on the character.
    STA r_battle_character_visual_properties.1.flags.w,Y                        ; $02C560 |/
    LDA <r_battle_current_actor_slot                                            ; $02C563 |\
    TAX                                                                         ; $02C565 | | Set the X register to the stat record offset.
    JSR _multiply_x_by_128                                                      ; $02C566 |/
    LDA r_character_battle.1.id.w,X                                             ; $02C569 |\
    AND #%00111111.b                                                            ; $02C56C | | Set the character's ID in the visual properties array.
    STA r_battle_character_visual_properties.1.id.w,Y                           ; $02C56E |/
    TDC                                                                         ; $02C571 |\
    STA r_battle_character_visual_properties.1.frame_counter.w,Y                ; $02C572 | | Reset the frame counter, the pose frame counter, and the Y offset.
    STA r_battle_character_visual_properties.1.pose_frame_counter.w,Y           ; $02C575 | |
    STA r_battle_character_visual_properties.1.y_offset.w,Y                     ; $02C578 |/
    LDA <r_battle_current_actor_slot                                            ; $02C57B |\
    TAX                                                                         ; $02C57D | | Flag the character as moving.
    LDA #1.b                                                                    ; $02C57E | |
    STA r_battle_character_moving.w,X                                           ; $02C580 |/
    LDA #BATTLE_POSE_WALKING.b                                                  ; $02C583 |\ Set the character's pose to walking.
    JSR _battle_update_character_pose                                           ; $02C585 |/
-   JSR _battle_wait_next_frame_preserve_x_y                                    ; $02C588 | Wait for the next frame.
    LDA <r_battle_current_actor_slot                                            ; $02C58B |\
    TAX                                                                         ; $02C58D | | Load the character's base X coordinate into the accumulator.
    LDA r_battle_party_formation_two_front.w                                    ; $02C58E | |
    BNE +                                                                       ; $02C591 | |
    LDA bank16.battle_party_three_front_slot_x_coordinate_data.l,X              ; $02C593 | |
    BRA ++                                                                      ; $02C597 | |
+   LDA bank16.battle_party_two_front_slot_x_coordinate_data.l,X                ; $02C599 |/
++  STA <r_battle_generic_tmp_index_3_lo                                        ; $02C59D | Save it to a temporary variable.
    JSR _battle_get_current_actor_visual_properties_offset                      ; $02C59F |\
    JSR _battle_update_coordinates_walk_left                                    ; $02C5A2 | | Have the character walk left a step and loop until their X
    LDA r_battle_character_visual_properties.1.x.w,X                            ; $02C5A5 | | coordinate matches their base coordinate.
    CMP <r_battle_generic_tmp_index_3_lo                                        ; $02C5A8 | |
    BNE -                                                                       ; $02C5AA |/
    LDA <r_battle_current_actor_slot                                            ; $02C5AC |\
    TAX                                                                         ; $02C5AE | | Flag the character as no longer moving.
    TDC                                                                         ; $02C5AF | |
    STA r_battle_character_moving.w,X                                           ; $02C5B0 |/
    JMP _battle_character_finalize_manual_movement                              ; $02C5B3 | Enable automatic movement and disable pose override.

; _battle_get_current_actor_visual_properties_offset ($02:C5B6)
;
; Reads the current actor slot in $48 and multiplies that value by 16 to
; determine that slot's offset into the visual properties array. This only makes
; sense if a character is acting.
;
; There is another entry point that does not load a value in the accumulator,
; but instead expects the slot number in the accumulator.
_battle_get_current_actor_visual_properties_offset:
    LDA <r_battle_current_actor_slot                                            ; $02C5B6
_battle_get_visual_properties_offset:
    ASL A                                                                       ; $02C5B8
    ASL A                                                                       ; $02C5B9
    ASL A                                                                       ; $02C5BA
    ASL A                                                                       ; $02C5BB
    TAX                                                                         ; $02C5BC
    RTS                                                                         ; $02C5BD

; _battle_get_effect_target_visual_properties_offset ($02:C5BE)
;
; Reads the effect target slot in $49 and multiplies that value by 16 to
; determine that slot's offset into the visual properties array.
_battle_get_effect_target_visual_properties_offset:
    LDA <r_battle_effect_target_slot                                            ; $02C5BE
    BRA _battle_get_visual_properties_offset                                    ; $02C5C0

; battle_character_special_pose_exit_right ($02:C5C2)
;
; Proxy function to call the _battle_character_special_pose_exit_right function
; from another bank.
battle_character_special_pose_exit_right:
    JSR _battle_character_special_pose_exit_right                               ; $02C5C2 | Call the function.
    RTL                                                                         ; $02C5C5

; battle_character_enter_from_right ($02:C5C6)
;
; Proxy function to call the _battle_character_enter_from_right function from
; another bank.
battle_character_enter_from_right:
    JSR _battle_character_enter_from_right                                      ; $02C5C6 | Call the enter from right function.
    RTL                                                                         ; $02C5C9

; _battle_character_special_pose_exit_right ($02:C5CA)
;
; For the character in the slot in $48, sets the pose to the second special
; pose, and then ultimate has the character exit on the right side of the
; screen.
_battle_character_special_pose_exit_right:
    LDA #BATTLE_POSE_SPECIAL_2.b                                                ; $02C5CA |\ Set the character's pose to the second special pose.
    JSR _battle_update_character_pose                                           ; $02C5CC |/
    LDX #10.w                                                                   ; $02C5CF |\ Wait ten frames.
    JSR _battle_wait_x_frames                                                   ; $02C5D2 |/
    LDA #BATTLE_POSE_WALKING.b                                                  ; $02C5D5 |\ Set the character's pose to walking.
    JSR _battle_update_character_pose                                           ; $02C5D7 |/
    JSR _battle_wait_actor_pending_steps_zero                                   ; $02C5DA | Wait until the character has no pending steps.
    JSR _battle_get_current_actor_visual_properties_offset                      ; $02C5DD | Set the X register to this slot's visual properties offset.
    LDA r_battle_character_visual_properties.1.flags.w,X                        ; $02C5E0 |\
    ORA #CHARACTER_VISUAL_FLAG_REVERSE.b                                        ; $02C5E3 | | Set the reverse flag on the character.
    STA r_battle_character_visual_properties.1.flags.w,X                        ; $02C5E5 |/
    STZ r_battle_character_visual_properties.1.frame_counter.w,X                ; $02C5E8 | Zero out the frame counter.
    STZ r_battle_character_visual_properties.1.pose_frame_counter.w,X           ; $02C5EB | Zero out the pose frame counter.
    STZ r_battle_character_visual_properties.1.y_offset.w,X                     ; $02C5EE | Zero out the Y offset.
    LDA <r_battle_current_actor_slot                                            ; $02C5F1 |\
    TAX                                                                         ; $02C5F3 | | Flag the character as moving.
    LDA #1.b                                                                    ; $02C5F4 | |
    STA r_battle_character_moving.w,X                                           ; $02C5F6 |/
-   JSR _battle_wait_next_frame_preserve_x_y                                    ; $02C5F9 | Wait a frame.
    JSR _battle_get_current_actor_visual_properties_offset                      ; $02C5FC |\
    TAX                                                                         ; $02C5FF | | Have the character walk right until they reach an X coordinate of
    JSR _battle_update_coordinates_walk_right                                   ; $02C600 | | 240.
    LDA r_battle_character_visual_properties.1.x.w,X                            ; $02C603 | |
    CMP #BATTLE_COORDINATE_X_PARTY_RIGHT_EXIT.b                                 ; $02C606 | |
    BCC -                                                                       ; $02C608 |/
    TDC                                                                         ; $02C60A |\ Zero out the character's ID.
    STA r_battle_character_visual_properties.1.id.w,X                           ; $02C60B |/
    LDA r_battle_character_visual_properties.1.flags.w,X                        ; $02C60E |\
    AND #CHARACTER_VISUAL_FLAG_REVERSE.b ~ $FF                                  ; $02C611 | | Unset the character's reverse flag.
    STA r_battle_character_visual_properties.1.flags.w,X                        ; $02C613 |/
    RTS                                                                         ; $02C616

; _battle_script_audiovisual_command_jump ($02:C617)
;
; Animates the Jump command.
_battle_script_audiovisual_command_jump:
    LDA #AUDIO_EFFECT_JUMP.b                                                    ; $02C617 |\ Play the Jump sound effect, panned to the actor.
    JSR _battle_play_sound_effect_actor_panned                                  ; $02C619 |/
    LDA r_battle_current_action_details.actor_flags.w                           ; $02C61C |\ Branch to separate code if the actor is a monster.
    BMI +                                                                       ; $02C61F |/
    JSR _battle_current_actor_disable_status_pose                               ; $02C621 | Disable any automatic status pose for the actor.
    JSR _battle_move_character_acting                                           ; $02C624 | Move the actor to the acting position.
    LDA #BATTLE_POSE_CROUCHING.b                                                ; $02C627 |\ Set the actor's pose to crouching.
    JSR _battle_update_character_pose                                           ; $02C629 |/
    LDX #10.w                                                                   ; $02C62C |\ Wait ten frames.
    JSR _battle_wait_x_frames                                                   ; $02C62F |/
    LDA #BATTLE_POSE_RAISED_LEFT_ARM.b                                          ; $02C632 |\ Change the actor's pose to a raised left arm.
    JSR _battle_update_character_pose                                           ; $02C634 |/
    JSR _battle_wait_actor_pending_steps_zero                                   ; $02C637 | Wait for the character to stop moving.
-   JSR _battle_wait_next_frame_preserve_x_y                                    ; $02C63A | Wait a frame.
    JSR _battle_get_current_actor_visual_properties_offset                      ; $02C63D | Set the X register to the actor's visual properties offset.
    LDA r_battle_character_visual_properties.1.x.w,X                            ; $02C640 |\
    SEC                                                                         ; $02C643 | | Subtract two from the actor's X coordinate.
    SBC #2.b                                                                    ; $02C644 | |
    STA r_battle_character_visual_properties.1.x.w,X                            ; $02C646 |/
    LDA r_battle_character_visual_properties.1.y.w,X                            ; $02C649 |\
    SEC                                                                         ; $02C64C | | Subtract eight from the actor's Y coordinate.
    SBC #8.b                                                                    ; $02C64D | |
    STA r_battle_character_visual_properties.1.y.w,X                            ; $02C64F |/
    CMP #248.b                                                                  ; $02C652 |\ Loop until the Y coordinate loops back around to 248.
    BCC -                                                                       ; $02C654 |/
    TDC                                                                         ; $02C656 |\ Set the visual character ID to zero to make them invisible.
    STA r_battle_character_visual_properties.1.id.w,X                           ; $02C657 |/
    JMP _battle_current_actor_enable_status_pose                                ; $02C65A | Enable automatic status poses and return.
+   LDA #BATTLE_POSE_MONSTER_CROUCHING.b                                        ; $02C65D |\ Update the monster's pose to crouching.
    JSR _battle_update_monster_character_tilemap_pose                           ; $02C65F |/
    LDX #10.w                                                                   ; $02C662 |\ Wait ten frames.
    JSR _battle_wait_x_frames                                                   ; $02C665 |/
    LDA #BATTLE_POSE_MONSTER_CHEERING.b                                         ; $02C668 | \ Change the monster's pose to cheering.
    JSR _battle_update_monster_character_tilemap_pose                           ; $02C66A |/
    TDC                                                                         ; $02C66D |\
    TAX                                                                         ; $02C66E | | Initialize the BG1 scroll values and the X register to zero.
    STX r_battle_set_bg1_scroll_arg_horizontal.w                                ; $02C66F | |
    STX r_battle_set_bg1_scroll_arg_vertical.w                                  ; $02C672 |/
-   JSR _battle_wait_next_frame_preserve_x_y                                    ; $02C675 | Wait a frame.
    JSL bank01.battle_set_bg1_scroll                                            ; $02C678 | Set the BG1 scroll with the current parameters.
    REP #FLAG_P_ACCUMULATOR                                                     ; $02C67C |\
    LDA r_battle_set_bg1_scroll_arg_horizontal.w                                ; $02C67E | | Update the BG1 scroll parameters to effectively move the monster
    SEC                                                                         ; $02C681 | | to the right by two pixels and upward by eight pixels.
    SBC #2.w                                                                    ; $02C682 | |
    STA r_battle_set_bg1_scroll_arg_horizontal.w                                ; $02C685 | |
    LDA r_battle_set_bg1_scroll_arg_vertical.w                                  ; $02C688 | |
    CLC                                                                         ; $02C68B | |
    ADC #8.w                                                                    ; $02C68C | |
    STA r_battle_set_bg1_scroll_arg_vertical.w                                  ; $02C68F | |
    TDC                                                                         ; $02C692 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $02C693 |/
    INX                                                                         ; $02C695 |\
    CPX #16.w                                                                   ; $02C696 | | Increment the X register and loop until it reaches 16.
    BNE -                                                                       ; $02C699 |/
    LDA #BATTLE_POSE_MONSTER_INVISIBLE.b                                        ; $02C69B |\ Set the monster's pose to invisible.
    JMP _battle_update_monster_character_tilemap_pose                           ; $02C69D |/

; _battle_update_monster_character_tilemap_pose ($02:C6A0)
;
; For monsters who are rendered using a character sprite, this routine updates
; the pose for that monster with the value passed in the accumulator.
_battle_update_monster_character_tilemap_pose:
    STA r_battle_load_monster_character_sprite_tilemap_pose.w                   ; $02C6A0 |\ Load the sprite for the pose passed in the accumulator.
    JSR _battle_prepare_monster_tilemap                                         ; $02C6A3 |/
    LDY #$6140.w                                                                ; $02C6A6 | Set the VRAM address to the 11th line on the left side of BG1.
    LDX #(64 * 4).w                                                             ; $02C6A9 |\ Set the number of bytes to load to four lines of tiles.
    STX <r_battle_copy_to_vram_arg_bytes                                        ; $02C6AC |/
    LDA #:r_battle_tilemap_data.b                                               ; $02C6AE |\ Set the source address to the 11th line of the tilemap data.
    LDX #r_battle_tilemap_data.w + (64 * 10)                                    ; $02C6B0 |/
    JMP _battle_copy_to_vram                                                    ; $02C6B3 | Copy the data to VRAM.

; _battle_script_audiovisual_command_change ($02:C6B6)
;
; Animation handler for the Change command.
_battle_script_audiovisual_command_change:
    JSR _battle_update_change_rows                                              ; $02C6B6 | Execute the row change.
    TDC                                                                         ; $02C6B9 |\ Set the character's pose to normal.
    JMP _battle_update_character_pose                                           ; $02C6BA |/

; _battle_script_audiovisual_command_fight ($02:C6BD)
;
; Handles the Fight audiovisual script command.
_battle_script_audiovisual_command_fight:
    JSR _battle_move_character_acting                                           ; $02C6BD | Move the character to the acting position.
    JMP _battle_animate_physical_attack                                         ; $02C6C0 | Animate the physical attack.

; _battle_script_audiovisual_command_sing ($02:C6C3)
;
; Handles the Sing (and technically Endure) audiovisual script command.
_battle_script_audiovisual_command_sing:
    JSR _battle_move_character_acting                                           ; $02C6C3 | Move the character to the acting position.
    LDA #BATTLE_POSE_CASTING.b                                                  ; $02C6C6 |\ Set the character's pose to casting.
    JSR _battle_update_character_pose                                           ; $02C6C8 |/
    LDA #SPELL_AUDIOVISUAL_CAST_WHITE.b                                         ; $02C6CB |\ Animate the white magic cast effect.
    JMP _battle_animate_cast_effect                                             ; $02C6CD |/

; _battle_script_audiovisual_command_white ($02:C6D0)
;
; Handles the White audiovisual script command.
_battle_script_audiovisual_command_white:
    JSR _battle_move_character_acting                                           ; $02C6D0 | Move the character to the acting position.
    LDA #BATTLE_POSE_RAISED_LEFT_ARM.b                                          ; $02C6D3 |\ Set the character's pose to a raised left arm.
    JSR _battle_update_character_pose                                           ; $02C6D5 |/
    LDA #SPELL_AUDIOVISUAL_CAST_WHITE.b                                         ; $02C6D8 |\ Animate the white magic cast effect.
    JMP _battle_animate_cast_effect                                             ; $02C6DA |/

; _battle_script_audiovisual_command_black ($02:C6DD)
;
; Handles the Black audiovisual script command.
_battle_script_audiovisual_command_black:
    JSR _battle_move_character_acting                                           ; $02C6DD | Move the character to the acitng position.
    LDA #BATTLE_POSE_RAISED_LEFT_ARM.b                                          ; $02C6E0 |\ Set the character's pose to a raised left arm.
    JSR _battle_update_character_pose                                           ; $02C6E2 |/
    TDC                                                                         ; $02C6E5 |\ Animate the black magic cast effect.
    JMP _battle_animate_cast_effect                                             ; $02C6E6 |/

; _battle_character_set_all_visible ($02:C6E9)
;
; Loops through the five character slots, restoring their visual IDs from the
; backup array. This function will probably not function as expected unless the
; party was made invisible with the _set_all_invisible counterpart.
_battle_character_set_all_visible:
    TDC                                                                         ; $02C6E9 |\
    TAX                                                                         ; $02C6EA | | Initialize the X and Y registers to zero.
    TAY                                                                         ; $02C6EB |/
-   LDA r_battle_character_visual_id_backup.w,Y                                 ; $02C6EC |\ Restore the slot's visual ID from the backup.
    STA r_battle_character_visual_properties.1.id.w,X                           ; $02C6EF |/
    INY                                                                         ; $02C6F2 | Increment the Y register to move to the next slot.
    TXA                                                                         ; $02C6F3 |\
    CLC                                                                         ; $02C6F4 | | Increment the visual properties offset to move to the next slot.
    ADC #_sizeof_character_visual.b                                             ; $02C6F5 | |
    TAX                                                                         ; $02C6F7 |/
    CPY #5.w                                                                    ; $02C6F8 |\ Loop until all five slots have been restored.
    BNE -                                                                       ; $02C6FB |/
    RTS                                                                         ; $02C6FD

; _battle_character_set_all_invisible ($02:C6FE)
;
; Loops through the five character slots, making them all invisible by setting
; their visual ID to zero. The existing ID is backed up for later restoration.
_battle_character_set_all_invisible:
    TDC                                                                         ; $02C6FE |\
    TAX                                                                         ; $02C6FF | | Initialize the X and Y registers to zero.
    TAY                                                                         ; $02C700 |/
-   LDA r_battle_character_visual_properties.1.id.w,X                           ; $02C701 |\ Copy the slot's visual ID to the backup array.
    STA r_battle_character_visual_id_backup.w,Y                                 ; $02C704 |/
    STZ r_battle_character_visual_properties.1.id.w,X                           ; $02C707 | Set the visual ID to zero to make the character invisible.
    INY                                                                         ; $02C70A | Increment the Y register to move to the next slot.
    TXA                                                                         ; $02C70B |\
    CLC                                                                         ; $02C70C | | Increment the visual properties offset to the next slot.
    ADC #_sizeof_character_visual.b                                             ; $02C70D | |
    TAX                                                                         ; $02C70F |/
    CPY #5.w                                                                    ; $02C710 |\ Loop until all five characters have been backed up.
    BNE -                                                                       ; $02C713 |/
    RTS                                                                         ; $02C715

; _battle_script_audiovisual_command_call ($02:C716)
;
; Handles the animation for the Call command.
_battle_script_audiovisual_command_call:
    JSR _battle_move_character_acting                                           ; $02C716 | Move the character to the acting position.
    LDA #BATTLE_POSE_SPECIAL_2.b                                                ; $02C719 |\ Set the character's pose to their special pose.
    JSR _battle_update_character_pose                                           ; $02C71B |/
    LDA r_battle_caller_ready.w                                                 ; $02C71E |\ If the caller has been flagged as ready, skip the magic cast effect
    BNE _battle_script_audiovisual_command_vanish                               ; $02C721 |/ and jump immediately to making the party vanish.
    LDA #SPELL_AUDIOVISUAL_CAST_CALL.b                                          ; $02C723 |\ Otherwise, animate the call magic cast effect and then fall through
    JSR _battle_animate_cast_effect                                             ; $02C725 |/ to the next function.

; _battle_script_audiovisual_command_vanish ($02:C728)
;
; Handles the unnamed Vanish command, which is a special command used by the
; Grimoire item to make the party disappear. This code is also used by the
; standard Call routine for the second part of its animation.
_battle_script_audiovisual_command_vanish:
    JSR _battle_flash_character_sprites                                         ; $02C728 | Flash the character sprites.
    LDA #ALTERNATE_PARTY_SPRITE_MODE_INVISIBLE.b                                ; $02C72B |\ Set a flag to inhibit the drawing of the party sprites.
    STA r_battle_alternate_party_sprite_mode.w                                  ; $02C72D |/
    INC r_battle_character_sprites_hidden.w                                     ; $02C730 | Flag that the character sprites are currently hidden.
    RTS                                                                         ; $02C733

; _battle_load_first_two_character_sprites ($02:C734)
;
; Loads the character sprites for the first two slots, to restore any damage
; done by certain effect routines.
_battle_load_first_two_character_sprites:
    TDC                                                                         ; $02C734 |\ Initialize the X register to zero.
    TAX                                                                         ; $02C735 |/
    STX <r_battle_load_character_sprites_vram_address                           ; $02C736 | Initialize the VRAM address to zero.
-   LDA r_battle_character_sprite.w,X                                           ; $02C738 |\ Load the character sprite for this slot.
    JSR _battle_load_character_sprite                                           ; $02C73B |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $02C73E |\
    LDA <r_battle_load_character_sprites_vram_address                           ; $02C740 | | Increment the VRAM address by $400 to move to the next character.
    CLC                                                                         ; $02C742 | |
    ADC #$0400.w                                                                ; $02C743 | |
    STA <r_battle_load_character_sprites_vram_address                           ; $02C746 | |
    TDC                                                                         ; $02C748 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $02C749 |/
    INX                                                                         ; $02C74B |\
    CPX #2.w                                                                    ; $02C74C | | Loop until the first two characters have been reloaded.
    BNE -                                                                       ; $02C74F |/
    RTS                                                                         ; $02C751

; _battle_flash_character_sprites ($02:C752)
;
; Flashes the character sprites by making them rapidly invisible and visible
; again over a 32 frame period.
_battle_flash_character_sprites:
    STZ r_battle_flash_character_sprites_tmp.w                                  ; $02C752 | Initialize the frame counter to zero.
-   JSR _battle_wait_for_nmi                                                    ; $02C755 | Wait for the next frame.
    LDA r_battle_flash_character_sprites_tmp.w                                  ; $02C758 |\
    AND #%00000011.b                                                            ; $02C75B | | If the frame counter mod 4 is equal to zero, make the characters
    BEQ +                                                                       ; $02C75D | | all invisible. It the value is instead two, make them all visible.
    CMP #2.b                                                                    ; $02C75F | |
    BNE ++                                                                      ; $02C761 | |
    JSR _battle_character_set_all_visible                                       ; $02C763 | |
    JMP ++                                                                      ; $02C766 | |
+   JSR _battle_character_set_all_invisible                                     ; $02C769 |/
++  INC r_battle_flash_character_sprites_tmp.w                                  ; $02C76C | Increment the frame counter.
    LDA r_battle_flash_character_sprites_tmp.w                                  ; $02C76F |\
    CMP #32.b                                                                   ; $02C772 | | Loop until the frame counter reaches 32 (eight cycles).
    BNE -                                                                       ; $02C774 |/
    RTS                                                                         ; $02C776

; _battle_animate_cast_effect ($02:C777)
;
; Given a value in the accumulator from 0 to 2, animates that cast effect on the
; current actor.
_battle_animate_cast_effect:
    PHA                                                                         ; $02C777 |\
    LDA #1.b                                                                    ; $02C778 | | Set the OAM reset inhibit counter to 1, and set the sprite
    STA r_battle_effect_oam_reset_inhibit_counter_base.w                        ; $02C77A | | pattern to fixed.
    STA r_battle_effect_oam_reset_inhibit_counter.w                             ; $02C77D | |
    STZ r_battle_effect_spell_sprite_pattern.w                                  ; $02C780 | |
    PLA                                                                         ; $02C783 |/
    PHA                                                                         ; $02C784 |\
    JSR _battle_animate_cast_effect_generic                                     ; $02C785 | | Animate the cast effect for black magic (and play sound for all).
    PLA                                                                         ; $02C788 |/
    JSL bank01.battle_animate_cast_effect_white_call                            ; $02C789 | Animate the cast effect for white and call magic.
    TDC                                                                         ; $02C78D |\ Reset the character pose to normal.
    JMP _battle_update_character_pose                                           ; $02C78E |/

; _battle_script_audiovisual_command_cry ($02:C791)
;
; Animation handler for the Cry command.
_battle_script_audiovisual_command_cry:
    LDA #AUDIO_EFFECT_CRY.b                                                     ; $02C791 |\ Play the Cry sound effect, panned to the actor.
    JSR _battle_play_sound_effect_actor_panned                                  ; $02C793 |/
    BRA _battle_script_audiovisual_command_special_30_frames                    ; $02C796 | Switch to the special pose for 30 frames.

; _battle_script_audiovisual_command_bluff ($02:C798)
;
; Animation handler for the Bluff command.
_battle_script_audiovisual_command_bluff:
    LDA #AUDIO_EFFECT_BLUFF.b                                                   ; $02C798 |\ Play the Bluff sound effect, panned to the actor.
    JSR _battle_play_sound_effect_actor_panned                                  ; $02C79A |/
    BRA _battle_script_audiovisual_command_special_30_frames                    ; $02C79D | Switch to the special pose for 30 frames.

; _battle_script_audiovisual_command_bless ($02:C79F)
;
; Animation handler for the Bless command.
_battle_script_audiovisual_command_bless:
    JSR _battle_move_character_acting                                           ; $02C79F | Move the character to the acting position.
    LDA #AUDIO_EFFECT_CHIME.b                                                   ; $02C7A2 |\ Play the chime sound effect.
    JSR _battle_play_sound_effect                                               ; $02C7A4 |/

; _battle_script_audiovisual_command_special_30_frames ($02:C7A7)
;
; A generic command animation that moves the character to the acting position
; and holds the special pose for 30 frames.
_battle_script_audiovisual_command_special_30_frames:
    JSR _battle_move_character_acting                                           ; $02C7A7 | Move the character to the acting position.
    LDA #BATTLE_POSE_SPECIAL_2.b                                                ; $02C7AA |\ Hold the special pose for 30 frames.
    JMP _battle_hold_character_pose_for_30_frames                               ; $02C7AC |/

; _battle_script_audiovisual_command_item ($02:C7AF)
;
; Handles the animation of the Item command. This largely defers to the magic
; animation code, but the Rod and Dancing weapons spell effects are actually
; variations on the projectile physical attack code.
_battle_script_audiovisual_command_item:
    JSR _battle_move_character_acting                                           ; $02C7AF | Move the character to the acting position.
    LDA #BATTLE_POSE_RAISED_LEFT_ARM.b                                          ; $02C7B2 |\ Hold the character's pose with a raised arm for 30 frames.
    JSR _battle_hold_character_pose_for_30_frames                               ; $02C7B4 |/
    JSR _battle_script_audiovisual_get_next                                     ; $02C7B7 |\ Get the next byte and transfer it to the X register.
    TAX                                                                         ; $02C7BA |/
    LDA bank0F.battle_item_audiovisual_spell_data.l,X                           ; $02C7BB | Load the item ID being used.
    CMP #SPELL_WEAPON_ROD.b                                                     ; $02C7BF |\
    BNE +                                                                       ; $02C7C1 | | If the item is the Rod, set the parameters for the Rod special
    LDA #ITEM_SPECIAL_EFFECT_ROD.b                                              ; $02C7C3 | | effect and jump to the special physical attack animation.
    STA <r_battle_weapon_effect_right_hand                                      ; $02C7C5 | |
    INC A                                                                       ; $02C7C7 | |
    STA <r_battle_weapon_effect_left_hand                                       ; $02C7C8 | |
    LDA #BATTLE_ANIMATE_PHYSICAL_SPECIAL_ROD.b                                  ; $02C7CA | |
    STA r_battle_animate_physical_special_mode.w                                ; $02C7CC | |
    JMP _battle_animate_physical_attack_special                                 ; $02C7CF |/
+   CMP #SPELL_WEAPON_DANCING.b                                                 ; $02C7D2 |\
    BNE +                                                                       ; $02C7D4 | | If the item is Dancing, set the parameters for the Dancing special
    LDA #ITEM_SPECIAL_EFFECT_DANCING.b                                          ; $02C7D6 | | effect and jump to the special physical attack animation.
    STA <r_battle_weapon_effect_right_hand                                      ; $02C7D8 | |
    INC A                                                                       ; $02C7DA | |
    STA <r_battle_weapon_effect_left_hand                                       ; $02C7DB | |
    LDA #BATTLE_ANIMATE_PHYSICAL_SPECIAL_DANCING.b                              ; $02C7DD | |
    STA r_battle_animate_physical_special_mode.w                                ; $02C7DF | |
    JMP _battle_animate_physical_attack_special                                 ; $02C7E2 |/
+   LDA bank0F.battle_item_audiovisual_spell_data.l,X                           ; $02C7E5 | Determine which spell animation is associated with this item.
    BEQ +                                                                       ; $02C7E9 |\ If it's non-zero, call the spell animation routine for this spell.
    JSR _battle_effect_animate_spell                                            ; $02C7EB |/
+   RTS                                                                         ; $02C7EE

; _battle_script_audiovisual_command_raised_left_30_frames ($02:C7EF)
;
; Generic command animation that shows the character with a raised left arm (or
; whatever that pose does for them) for 30 frames.
_battle_script_audiovisual_command_raised_left_30_frames:
    JSR _battle_move_character_acting                                           ; $02C7EF
    LDA #BATTLE_POSE_RAISED_LEFT_ARM.b                                          ; $02C7F2
    JMP _battle_hold_character_pose_for_30_frames                               ; $02C7F4

; _battle_update_character_pose ($02:C7F7)
;
; Updates the pose of the character slot passed in $48 to the value passed in
; the accumulator.
_battle_update_character_pose:
    PHA                                                                         ; $02C7F7 |\
    LDA <r_battle_current_actor_slot                                            ; $02C7F8 | | Load the actor slot into the X register.
    TAX                                                                         ; $02C7FA | |
    PLA                                                                         ; $02C7FB |/
    STA r_battle_character_pose.w,X                                             ; $02C7FC | Update the pose of that slot to the value in the accumulator.
    RTS                                                                         ; $02C7FF

; _battle_play_sound_effect_actor_panned ($02:C800)
;
; Given the current actor flags in $34C2 and a sound effect ID in the
; accumulator, plays that sound effect, panned to the monster side if the actor
; is a monster, and panned to the character side otherwise.
_battle_play_sound_effect_actor_panned:
    PHA                                                                         ; $02C800 |\
    LDA r_battle_current_action_details.actor_flags.w                           ; $02C801 | | Set the pan value, while preserving the sound effect ID.
    STA r_battle_play_audio_pan_monster.w                                       ; $02C804 | |
    PLA                                                                         ; $02C807 |/
    JMP _battle_play_sound_effect                                               ; $02C808 | Play the sound effect.

; _battle_effect_dark_wave_prepare ($02:C80B)
;
; Prepares for the Dark Wave effect by loading the correct palette and tiles.
_battle_effect_dark_wave_prepare:
    LDA #8.b                                                                    ; $02C80B |\
    LDX #15.w                                                                   ; $02C80D | | Load miscellaneous palette 8 into the last palette.
    STA r_battle_effect_load_palette_arg_palette.w                              ; $02C810 | | TODO: Why is the variable set? This controls what palette is loaded
    JSR _battle_load_miscellaneous_palette                                      ; $02C813 |/        at the end of the Dark Wave animation.
    LDA #BATTLE_SPELL_BLOCK_UNKNOWN_14.b                                        ; $02C816 |\ Load spell effect tiles block $14, which contains the Dark Wave
    JMP _battle_load_spell_tiles_single_block                                   ; $02C818 |/ tiles.

; _battle_script_audiovisual_command_dark_wave ($02:C81B)
;
; Handles the animation for the Dark Wave command.
_battle_script_audiovisual_command_dark_wave:
    INC r_battle_effect_disable_effect_sprites.w                                ; $02C81B | Disable effect sprite transfers. (TODO: This is odd, affects only weapon code?)
    LDA r_battle_current_action_details.actor_flags.w                           ; $02C81E |\ Branch to separate code if the actor is a character (instead of a monster).
    BPL +                                                                       ; $02C821 |/
    LDA #ITEM_SWORD_BLACK.b                                                     ; $02C823 |\ Load the weapon sprites for the Black sword.
    JSR _battle_load_weapon_visual                                              ; $02C825 |/
    LDA #BATTLE_POSE_MONSTER_CASTING.b                                          ; $02C828 |\ Set the pose to casting.
    JSR _battle_update_monster_character_tilemap_pose                           ; $02C82A |/
    LDX #60.w                                                                   ; $02C82D |\ Wait 60 frames.
    JSR _battle_wait_x_frames                                                   ; $02C830 |/
    LDA #AUDIO_EFFECT_ODIN_MONSTER.b                                            ; $02C833 |\ Play a metallic unsheathing sound, panned to the actor.
    JSR _battle_play_sound_effect_actor_panned                                  ; $02C835 |/
    LDA #BATTLE_POSE_MONSTER_SPECIAL.b                                          ; $02C838 |\ Update the pose to the special pose.
    JSR _battle_update_monster_character_tilemap_pose                           ; $02C83A |/
    JSR _battle_effect_dark_wave_prepare                                        ; $02C83D | Load the palette and effect tiles.
    JSL bank01.battle_effect_animate_dark_wave                                  ; $02C840 | Animate the actual effect.
    STZ r_battle_effect_disable_effect_sprites.w                                ; $02C844 | Enable effect sprite transfers.
    TDC                                                                         ; $02C847 |\ Reset the pose back to normal and returan.
    JMP _battle_update_monster_character_tilemap_pose                           ; $02C848 |/
+   JSR _battle_current_actor_disable_status_pose                               ; $02C84B | Disable automatic status poses for the character.
    LDA #BATTLE_POSE_CASTING.b                                                  ; $02C84E |\ Set the pose to non-animated casting.
    JSR _battle_update_character_pose                                           ; $02C850 |/
    LDX #30.w                                                                   ; $02C853 |\ Wait 30 frames.
    JSR _battle_wait_x_frames                                                   ; $02C856 |/
    LDA #AUDIO_EFFECT_ODIN_MONSTER.b                                            ; $02C859 |\ Play a metallic unsheathing sound, panned to the actor.
    JSR _battle_play_sound_effect_actor_panned                                  ; $02C85B |/
    LDA #BATTLE_POSE_SPECIAL_2                                                  ; $02C85E |\ Set the pose to the second value for the special pose.
    JSR _battle_update_character_pose                                           ; $02C860 |/
    LDX #60.w                                                                   ; $02C863 |\ Wait 60 frames.
    JSR _battle_wait_x_frames                                                   ; $02C866 |/
    JSR _battle_effect_dark_wave_prepare                                        ; $02C869 | Load the palette and effect tiles.
    JSL bank01.battle_effect_animate_dark_wave                                  ; $02C86C | Animate the actual effect.
    STZ r_battle_effect_disable_effect_sprites.w                                ; $02C870 | Enable effect sprite transfers.
    JSR _battle_current_actor_enable_status_pose                                ; $02C873 | Enable automatic status poses.
    JMP _battle_reset_character_pose_override                                   ; $02C876 | Reset the character's pose to normal and return.

; _battle_current_actor_disable_status_pose ($02:C879)
;
; Disables the automatic status pose handling for the current actor.
_battle_current_actor_disable_status_pose:
    LDA r_battle_current_actor_slot.w                                           ; $02C879 |\
    TAX                                                                         ; $02C87C | | Disable status pose handling for the actor slot.
    INC r_battle_disable_status_pose.w,X                                        ; $02C87D |/
    RTS                                                                         ; $02C880

; _battle_current_actor_enable_status_pose ($02:C881)
;
; Enables the automatic status pose handling for the current actor.
_battle_current_actor_enable_status_pose:
    LDA r_battle_current_actor_slot.w                                           ; $02C881 |\
    TAX                                                                         ; $02C884 | | Enable status pose handling for the actor slot.
    STZ r_battle_disable_status_pose.w,X                                        ; $02C885 |/
    RTS                                                                         ; $02C888

; _battle_script_audiovisual_command_aim ($02:C889)
;
; Animates the Aim command. Falls through to the next function to clear any
; pose overrides.
_battle_script_audiovisual_command_aim:
    LDA #BATTLE_POSE_SPECIAL_2.b                                                ; $02C889 |\ Set the actor's pose to their second special pose.
    JSR _battle_update_character_pose                                           ; $02C88B |/
    LDX #30.w                                                                   ; $02C88E |\ Wait 30 frames.
    JSR _battle_wait_x_frames                                                   ; $02C891 |/
    JSR _battle_move_character_acting                                           ; $02C894 | Move the character to the acting position.
    JSR _battle_animate_physical_attack                                         ; $02C897 | Animate a standard physical attack.

; _battle_reset_character_pose_override ($02:C89A)
;
; Resets the character pose override for the current actor by setting their pose
; override value to zero.
_battle_reset_character_pose_override:
    TDC                                                                         ; $02C89A |\ Set the current actor's character pose to zero.
    JMP _battle_update_character_pose                                           ; $02C89B |/

; _battle_wait_x_frames ($02:C89E)
;
; Waits for the number of frames specified in the X register.
_battle_wait_x_frames:
-   JSR _battle_wait_next_frame_preserve_x_y                                    ; $02C89E | Wait for the next frame.
    DEX                                                                         ; $02C8A1 |\ Loop until the X register reaches zero.
    BNE -                                                                       ; $02C8A2 |/
    RTS                                                                         ; $02C8A4

; _battle_script_audiovisual_dispatch ($02:C8A5)
;
; Given a command byte in the accumulator, dispatches to the correct handler for
; that command. This routine specifically handles commands $F0 through $FF.
_battle_script_audiovisual_dispatch:
    SEC                                                                         ; $02C8A5 |\
    SBC #MONSTER_COMMAND_SET_MONSTER_SPRITE.b                                   ; $02C8A6 | | Subtract $F0 from the command and multiply by two to determine the
    ASL A                                                                       ; $02C8A8 | | index into the pointer table.
    TAX                                                                         ; $02C8A9 |/
    LDA battle_script_audiovisual_pointer_data.l + 0,X                          ; $02C8AA |\
    STA <r_battle_generic_tmp_ptr_2_addr_lo                                     ; $02C8AE | | Load the pointer and jump to it.
    LDA battle_script_audiovisual_pointer_data.l + 1,X                          ; $02C8B0 | |
    STA <r_battle_generic_tmp_ptr_2_addr_hi                                     ; $02C8B4 | |
    JMP (r_battle_generic_tmp_ptr_2_addr.w)                                     ; $02C8B6 |/

; battle_script_audiovisual_pointer_data ($02:C8B9)
;
; For each opcode of the script system, contains a pointer to the handler for
; the audiovisual portion of that opcode. Several of the opcodes effectively do
; nothing in this part of the code.
battle_script_audiovisual_pointer_data:
    .addr _battle_script_audiovisual_monster_transition                         ; $02C8B9.C8BA | $F0: Change monster sprite
    .addr _battle_script_audiovisual_display_message_slow                       ; $02C8BB.C8BC | $F1: Display message (slow speed)
    .addr _battle_script_audiovisual_display_message                            ; $02C8BD.C8BE | $F2: Display message
    .addr _battle_script_audiovisual_play_song                                  ; $02C8BF.C8C0 | $F3: Play music
    .addr _battle_script_audiovisual_double_byte_noop                           ; $02C8C1.C8C2 | $F4
    .addr _battle_script_audiovisual_double_byte_noop                           ; $02C8C3.C8C4 | $F5
    .addr _battle_script_audiovisual_double_byte_noop                           ; $02C8C5.C8C6 | $F6
    .addr _battle_script_audiovisual_set_background_fade                        ; $02C8C7.C8C8 | $F7: Set background fade
    .addr _battle_script_audiovisual_display_dialog                             ; $02C8C9.C8CA | $F8: Display dialog or damage
    .addr _battle_script_audiovisual_double_byte_noop                           ; $02C8CB.C8CC | $F9
    .addr _battle_script_audiovisual_single_byte_noop                           ; $02C8CD.C8CE | $FA
    .addr _battle_script_audiovisual_single_byte_noop                           ; $02C8CF.C8D0 | $FB
    .addr _battle_script_audiovisual_single_byte_noop                           ; $02C8D1.C8D2 | $FC
    .addr _battle_script_audiovisual_single_byte_noop                           ; $02C8D3.C8D4 | $FD
    .addr _battle_script_audiovisual_single_byte_noop                           ; $02C8D5.C8D6 | $FE
    .addr _battle_script_audiovisual_single_byte_noop                           ; $02C8D7.C8D8 | $FF

; _battle_script_audiovisual_set_background_fade ($02:C8D9)
;
; This battle script routine enables or disables the battle background fade
; effect, depending on if the high bit of the parameter byte is set or not.
; Specifically, if the high bit is set, the effect will be deactivated.
; Otherwise, it will be activated.
_battle_script_audiovisual_set_background_fade:
    JSR _battle_script_audiovisual_get_next                                     ; $02C8D9
    AND #%10000000.b                                                            ; $02C8DC
    BEQ +                                                                       ; $02C8DE
    JMP _battle_deactivate_battle_background_fade                               ; $02C8E0
+   JSR _battle_activate_battle_background_fade                                 ; $02C8E3
    RTS                                                                         ; $02C8E6

; _battle_script_audiovisual_*_byte_noop ($02:C8E7)
;
; This battle script handler simply fetches the next byte and returns,
; effectively serving as a no-op. The opcodes that use this handler may have
; functionality not in the audiovisual section.
;
; The single byte variant simply returns.
_battle_script_audiovisual_double_byte_noop:
    JSR _battle_script_audiovisual_get_next                                     ; $02C8E7 | Fetch the next byte (but do nothing with it).
_battle_script_audiovisual_single_byte_noop:
    RTS                                                                         ; $02C8EA

; _battle_script_audiovisual_display_message(_slow) ($02:C8EB)
;
; Displays the battle message indicated by the number passed in the next byte.
; The _slow variant forces the game to assume a battle message speed of 6 (the
; slowest), while the other variant simply uses the battle message speed as
; configured by the user.
_battle_script_audiovisual_display_message_slow:
    LDA #1.b                                                                    ; $02C8EB |\
    STA r_battle_message_force_slowest_speed.w                                  ; $02C8ED | | Force the slowest battle message speed and branch forward.
    BRA +                                                                       ; $02C8F0 |/
_battle_script_audiovisual_display_message:
    STZ r_battle_message_force_slowest_speed.w                                  ; $02C8F2 | Do not force the slowest battle message speed.
+   JSR _battle_script_audiovisual_get_next                                     ; $02C8F5 | Get the next byte, which contains the battle message to load.
    JSR _battle_wait_menu_dma_pending_clear                                     ; $02C8F8 | Wait until pending DMA menu changes are clear.
    JSR _battle_close_battle_message                                            ; $02C8FB | Close any already existing battle message.
    JSR _battle_wait_menu_dma_pending_clear                                     ; $02C8FE | Again wait until pending menu DMA is done.
    LDA (<r_battle_script_audiovisual_ptr)                                      ; $02C901 | Load the message number byte again.
    REP #FLAG_P_ACCUMULATOR                                                     ; $02C903 |\
    ASL A                                                                       ; $02C905 | | Set the offset to the battle message data by reading the offset
    TAX                                                                         ; $02C906 | | from ROM and storing it to a variable.
    LDA bank0E.battle_message_offset_data.l + 0,X                               ; $02C907 | |
    STA <r_battle_generic_tmp_ptr_2_addr_lo                                     ; $02C90B | |
    LDA bank0E.battle_message_offset_data.l + 1,X                               ; $02C90D | |
    STA <r_battle_generic_tmp_ptr_2_addr_hi                                     ; $02C911 | |
    LDA #$000E.w                                                                ; $02C913 | |
    STA <r_battle_generic_tmp_ptr_2_bank                                        ; $02C916 | |
    TDC                                                                         ; $02C918 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $02C919 |/
    TAY                                                                         ; $02C91B | Initialize the Y register to zero.
-   LDA [<r_battle_generic_tmp_ptr_2],Y                                         ; $02C91C |\
    STA r_battle_update_dialog_data.w,Y                                         ; $02C91E | | Copy 128 bytes of data from the battle message data in ROM to the
    INY                                                                         ; $02C921 | | battle dialog data in RAM.
    CPY #128.w                                                                  ; $02C922 | |
    BNE -                                                                       ; $02C925 |/
    LDX #r_battle_update_dialog_data.w                                          ; $02C927 |\ Set the dialog update function to read from the array just written
    STX r_battle_update_dialog_arg_source.w                                     ; $02C92A |/ to.
    JSR _battle_draw_battle_message                                             ; $02C92D | Draw the battle message.
    JSR _battle_message_wait                                                    ; $02C930 | Wait for a number of frames determined by battle message speed.
    JSR _battle_close_battle_message                                            ; $02C933 | Close the battle message window.
    JMP _battle_wait_menu_dma_pending_clear                                     ; $02C936 | Wait until any menu DMA is complete.

; _battle_alert_wait ($02:C939)
;
; Waits until a battle alert should be closed. Always waits at least 16 frames.
; If the battle alert requires input to proceed, it will branch to later code
; that will wait for input. Otherwise, it falls through to the next function
; which will wait a number of frames depending on the battle speed and the last
; used message display opcode.
_battle_alert_wait:
    PHA                                                                         ; $02C939 |\
    LDX #16.w                                                                   ; $02C93A | | Display the message for at least 16 frames.
    JSR _battle_wait_x_frames                                                   ; $02C93D | |
    PLA                                                                         ; $02C940 |/
    TAX                                                                         ; $02C941 |\
    LDA bank16.battle_alert_input_required_data.l,X                             ; $02C942 | | If this alert requires input to proceed, skip to that code.
    BNE __battle_message_wait_input_required                                    ; $02C946 |/

; _battle_message_wait ($02:C948)
;
; If $F49C is non-zero, assumes a battle message speed of 6 ($05). Otherwise,
; loads the configured battle message speed from RAM, and uses that to determine
; the number of frames to wait.
_battle_message_wait:
    LDA r_battle_message_force_slowest_speed.w                                  ; $02C948 |\
    BEQ +                                                                       ; $02C94B | | If configured to force the slowest message speed, set the
    LDA #5.b                                                                    ; $02C94D | | accumulator to 5. Otherwise, load the actual configured battle
    BRA ++                                                                      ; $02C94F | | message speed.
+   LDA r_battle_message_speed.w                                                ; $02C951 |/
++  ASL A                                                                       ; $02C954 |\
    TAX                                                                         ; $02C955 | | Load the number of frames to wait from ROM.
    REP #FLAG_P_ACCUMULATOR                                                     ; $02C956 | |
    LDA bank0D.battle_message_speed_data.l,X                                    ; $02C958 | |
    TAX                                                                         ; $02C95C | |
    TDC                                                                         ; $02C95D | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $02C95E |/
    JMP _battle_wait_x_frames.w                                                 ; $02C960 | Wait the loaded number of frames.
__battle_message_wait_input_required:
    INC r_battle_dialog_waiting_input.w                                         ; $02C963 | Flag that input is being waited for.
-   JSR _battle_wait_for_nmi                                                    ; $02C966 |\
    JSR _battle_update_float_scroll                                             ; $02C969 | | Loop until input has been detected and then return.
    LDA r_battle_dialog_waiting_input.w                                         ; $02C96C | |
    BNE -                                                                       ; $02C96F |/
    RTS                                                                         ; $02C971

; _battle_wait_menu_dma_pending_clear ($02:C972)
;
; Waits frames until there is no menu DMA pending.
_battle_wait_menu_dma_pending_clear:
-   LDA r_battle_menu_dma_pending.w                                             ; $02C972
    BEQ +                                                                       ; $02C975
    JSR _battle_wait_next_frame_preserve_x_y                                    ; $02C977
    BRA -                                                                       ; $02C97A
+   RTS                                                                         ; $02C97C

; _battle_script_audiovisual_display_dialog ($02:C97D)
;
; This opcode handler has multiple modes depending on the value of its single
; parameter. It is capable of displaying the name of the current spell, item
; or command, displaying pending battle alerts, or animating the damage effect.
; Additionally, it has two unused modes that are somewhat broken and probably
; a leftover legacy of earlier stages of development.
_battle_script_audiovisual_display_dialog:
    JSR _battle_wait_menu_dma_pending_clear                                     ; $02C97D | Wait until any menu DMA transfers are complete.
    LDX #r_battle_update_dialog_data.w                                          ; $02C980 |\ Set the battle update dialog source to the dialog data array.
    STX r_battle_update_dialog_arg_source.w                                     ; $02C983 |/
    JSR _battle_script_audiovisual_get_next                                     ; $02C986 |\
    ASL A                                                                       ; $02C989 | | Load the parameter byte and execute the correct handler for that
    TAX                                                                         ; $02C98A | | value.
    LDA battle_script_dialog_pointer_data.l + 0,X                               ; $02C98B | |
    STA <r_battle_generic_tmp_ptr_2_addr_lo                                     ; $02C98F | |
    LDA battle_script_dialog_pointer_data.l + 1,X                               ; $02C991 | |
    STA <r_battle_generic_tmp_ptr_2_addr_hi                                     ; $02C995 | |
    JMP (r_battle_generic_tmp_ptr_2_addr.w)                                     ; $02C997 |/

; battle_script_dialog_pointer_data ($02:C99A)
;
; For each of the possible parameters to the $F8 script opcode, contains a
; pointer to the handle for that parameter.
battle_script_dialog_pointer_data:
    .addr _battle_script_dialog_draw_actor_name                                 ; $02C99A.C99B | $00: Draw acting character or monster name
    .addr _battle_script_dialog_draw_target_name                                ; $02C99C.C99D | $01: Draw target character or monster name
    .addr _battle_script_dialog_draw_action_name                                ; $02C99E.C99F | $02: Draw action name
    .addr _battle_script_dialog_display_alerts                                  ; $02C9A0.C9A1 | $03: Displays alerts
    .addr _battle_animate_damage_loop                                           ; $02C9A2.C9A3 | $04: Displays damage

; _battle_animate_damage_loop ($02:C9A4)
;
; Prepares the damage animation display by converting the damage values into
; decimal numbers and writing the tiles to memory. Activates the animation and
; waits until it completes.
_battle_animate_damage_loop:
    TDC                                                                         ; $02C9A4 |\ Initialize the X register to zero.
    TAX                                                                         ; $02C9A5 |/
-   LDA r_battle_slot_damage.w,X                                                ; $02C9A6 |\
    STA r_battle_damage_sprites.w + 16,X                                        ; $02C9A9 | | Copy the damage for the five character slots to a temporary area
    INX                                                                         ; $02C9AC | | in memory.
    CPX #(5 * 2).w                                                              ; $02C9AD | |
    BNE -                                                                       ; $02C9B0 |/
    TDC                                                                         ; $02C9B2 |\ Reinitialize the X register to zero.
    TAX                                                                         ; $02C9B3 |/
-   LDA r_battle_slot_damage.w + 10.w,X                                         ; $02C9B4 |\
    STA r_battle_damage_sprites.w,X                                             ; $02C9B7 | | Copy the damage for the eight monster slots to another temporary
    INX                                                                         ; $02C9BA | | area in memory.
    CPX #(8 * 2).w                                                              ; $02C9BB | |
    BNE -                                                                       ; $02C9BE |/
    STZ <r_battle_generic_tmp_index_lo                                          ; $02C9C0 | Initialize the test variable to zero.
    TDC                                                                         ; $02C9C2 |\ Initialize the X register to zero.
    TAX                                                                         ; $02C9C3 |/
-   LDA r_battle_damage_sprites.w,X                                             ; $02C9C4 |\
    STA r_battle_slot_damage.w,X                                                ; $02C9C7 | | Loop through the 8 monster slots and 5 character slots, copying
    ORA <r_battle_generic_tmp_index_lo                                          ; $02C9CA | | the data back to the main battle damage area (having reversed the
    STA <r_battle_generic_tmp_index_lo                                          ; $02C9CC | | order of the monster and character slots). Or the data into the
    INX                                                                         ; $02C9CE | | test variable.
    CPX #_sizeof_r_battle_slot_damage.w                                         ; $02C9CF | |
    BNE -                                                                       ; $02C9D2 |/
    LDA <r_battle_generic_tmp_index_lo                                          ; $02C9D4 |\
    BNE +                                                                       ; $02C9D6 | | If no slots had non-zero damage, simply return.
    RTS                                                                         ; $02C9D8 |/
+   TDC                                                                         ; $02C9D9 |\ Initialize the X register to zero.
    TAX                                                                         ; $02C9DA |/
    DEC A                                                                       ; $02C9DB |\
-   STA r_battle_damage_sprites.w,X                                             ; $02C9DC | | Fill the damage sprite area with $FF, which corresponds to a blank
    INX                                                                         ; $02C9DF | | tile.
    CPX #_sizeof_r_battle_damage_sprites.w                                      ; $02C9E0 | |
    BNE -                                                                       ; $02C9E3 |/
    TDC                                                                         ; $02C9E5 |\ Initialize the X register to zero again.
    TAX                                                                         ; $02C9E6 |/
-   TDC                                                                         ; $02C9E7 |\ Set this damage entry as visible.
    STA r_battle_damage_invisible.w,X                                           ; $02C9E8 |/
    LDA #%00110001.b                                                            ; $02C9EB |\ Set the flags to use palette 0 (white) with the highest priority
    STA r_battle_damage_oam_flags.w,X                                           ; $02C9ED |/ and set the base tile number to $100.
    INX                                                                         ; $02C9F0 |\
    CPX #(5 + 8).w                                                              ; $02C9F1 | | Loop until all monster and character slots are done.
    BNE -                                                                       ; $02C9F4 |/
    TDC                                                                         ; $02C9F6 |\
    TAX                                                                         ; $02C9F7 | | Initialize the X and Y registers to zero.
    TAY                                                                         ; $02C9F8 |/
    STX <r_battle_generic_tmp_index_2                                           ; $02C9F9 | Initialize the index to zero.
@start:
    REP #FLAG_P_ACCUMULATOR                                                     ; $02C9FB |\
    LDA (<r_battle_slot_damage_ptr),Y                                           ; $02C9FD | | Read the damage value for this slot, mask out the non-damage bits,
    STA <r_battle_generic_tmp_index                                             ; $02C9FF | | and transfer the result to the X register as an argument to the
    AND #BATTLE_DAMAGE_VALUE.w                                                  ; $02CA01 | | number formatting routine.
    TAX                                                                         ; $02CA04 |/
    TDC                                                                         ; $02CA05 |\
    SEP #FLAG_P_ACCUMULATOR                                                     ; $02CA06 | | Format and render the number for display.
    JSR _battle_format_number                                                   ; $02CA08 | |
    JSR _battle_render_number                                                   ; $02CA0B |/
    PHY                                                                         ; $02CA0E |\
    INY                                                                         ; $02CA0F | | Read the high byte of the value, and if the miss bit isn't set,
    LDA (<r_battle_slot_damage_ptr),Y                                           ; $02CA10 | | branch forward past the miss code.
    AND #(BATTLE_DAMAGE_MISS >> 8).b                                            ; $02CA12 |/
.if FF4_REGION == "JAPAN"
    BEQ +                                                                       ; $02CA16 |\
    LDA #TEXT_SPACE.b                                                           ; $02CA18 | | If the miss bit was set, replace the values of the formatted
    STA r_battle_format_number_result.w + 0                                     ; $02CA1A | | number with the tiles needed to draw "".
    STA r_battle_format_number_result.w + 3                                     ; $02CA1D | |
    LDA #$6C.b                                                                  ; $02CA20 | |
    STA r_battle_format_number_result.w + 1                                     ; $02CA22 | |
    LDA #$6D.b                                                                  ; $02CA25 | |
    STA r_battle_format_number_result.w + 2                                     ; $02CA27 |/
.else
    BEQ +                                                                       ; $02CA14 |\
    LDA #$6C.b                                                                  ; $02CA16 | | If the miss bit was set, replace the values of the formatted
    STA r_battle_format_number_result.w + 0                                     ; $02CA18 | | number with the tiles needed to draw "Miss".
    INC A                                                                       ; $02CA1B | |
    STA r_battle_format_number_result.w + 1                                     ; $02CA1C | |
    INC A                                                                       ; $02CA1F | |
    STA r_battle_format_number_result.w + 2                                     ; $02CA20 | |
    INC A                                                                       ; $02CA23 | |
    STA r_battle_format_number_result.w + 3                                     ; $02CA24 |/
.endif
+   TDC                                                                         ; $02CA27 |\ Initialize the X register to zero.
    TAX                                                                         ; $02CA28 |/
    LDY <r_battle_generic_tmp_index_2                                           ; $02CA29 | Load the damage index into the Y register.
-   LDA r_battle_format_number_result.w,X                                       ; $02CA2B |\
    CMP #$FF.b                                                                  ; $02CA2E | | Read the next tile number. If the value is not $FF (blank),
    BEQ +                                                                       ; $02CA30 | | subtract $10 to conver the tile number into a sprite number.
    SEC                                                                         ; $02CA32 | | (Numbers normally start at $80, but they start at $70 as sprites.)
    SBC #$10.b                                                                  ; $02CA33 |/
+   STA r_battle_damage_sprites.w + 1,Y                                         ; $02CA35 |/
    INY                                                                         ; $02CA38 |\
    INX                                                                         ; $02CA39 | | Loop until the four tiles are set.
    CPX #4.w                                                                    ; $02CA3A | |
    BNE -                                                                       ; $02CA3D |/
    PLY                                                                         ; $02CA3F |\ Restore the Y register to the original value for reading the
    REP #FLAG_P_ACCUMULATOR                                                     ; $02CA40 |/ damage bytes.
    LDA <r_battle_generic_tmp_index_2                                           ; $02CA42 |\
    CLC                                                                         ; $02CA44 | | Add five to the index to move to the next entry.
    ADC #5.w                                                                    ; $02CA45 | |
    STA <r_battle_generic_tmp_index_2                                           ; $02CA48 |/
    LDA (<r_battle_slot_damage_ptr),Y                                           ; $02CA4A |\
    BNE +                                                                       ; $02CA4C | | If the damage value was equal to zero (which means there was no
    TYA                                                                         ; $02CA4E | | damage whatsoever, not even a miss), set the damage invisibility
    LSR A                                                                       ; $02CA4F | | flag for this slot.
    TAX                                                                         ; $02CA50 | |
    TDC                                                                         ; $02CA51 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $02CA52 | |
    INC r_battle_damage_invisible.w,X                                           ; $02CA54 | |
    BRA ++                                                                      ; $02CA57 |/
+   TDC                                                                         ; $02CA59 |\ Otherwise, reset the accumulator to zero.
    SEP #FLAG_P_ACCUMULATOR                                                     ; $02CA5A |/
++  INY                                                                         ; $02CA5C |\
    LDA (<r_battle_slot_damage_ptr),Y                                           ; $02CA5D | | If the miss bit is set, set the invisibility flag to $FF, which
    AND #(BATTLE_DAMAGE_MISS >> 8).b                                            ; $02CA5F | | signals a miss.
    BEQ +                                                                       ; $02CA61 | |
    TYA                                                                         ; $02CA63 | |
    DEC A                                                                       ; $02CA64 | |
    LSR A                                                                       ; $02CA65 | |
    TAX                                                                         ; $02CA66 | |
    LDA #$FF.b                                                                  ; $02CA67 | |
    STA r_battle_damage_invisible.w,X                                           ; $02CA69 |/
+   LDA (<r_battle_slot_damage_ptr),Y                                           ; $02CA6C |\
    BPL +                                                                       ; $02CA6E | | If the restore bit is set, update the flags for this slot to use
    TYA                                                                         ; $02CA70 | | palette six (green) instead.
    DEC A                                                                       ; $02CA71 | |
    LSR A                                                                       ; $02CA72 | |
    TAX                                                                         ; $02CA73 | |
    LDA #%00111101.b                                                            ; $02CA74 | |
    STA r_battle_damage_oam_flags.w,X                                           ; $02CA76 |/
+   INY                                                                         ; $02CA79 |\
    CPY #_sizeof_r_battle_slot_damage.w                                         ; $02CA7A | | Increment Y and loop until all slots have been examined.
    BEQ +                                                                       ; $02CA7D | |
    JMP @start                                                                  ; $02CA7F |/
+   TDC                                                                         ; $02CA82 |\
    TAX                                                                         ; $02CA83 | | Initialize the X and Y registers to zero.
    TAY                                                                         ; $02CA84 |/
-   LDA r_battle_monster_coordinates_bottom_center.w,X                          ; $02CA85 |\
    STA r_battle_damage_x_coordinates.w,Y                                       ; $02CA88 | | Loop through the eight monster slots, copying the coordinates for
    INX                                                                         ; $02CA8B | | the bottom center of the monster into the damage coordinates
    LDA r_battle_monster_coordinates_bottom_center.w,X                          ; $02CA8C | | values.
    STA r_battle_damage_y_coordinates.w,Y                                       ; $02CA8F | |
    INX                                                                         ; $02CA92 | |
    INY                                                                         ; $02CA93 | |
    CPY #8.w                                                                    ; $02CA94 | |
    BNE -                                                                       ; $02CA97 |/
    TDC                                                                         ; $02CA99 |\
    TAX                                                                         ; $02CA9A | | Reset the X and Y registers to zero.
    TAY                                                                         ; $02CA9B |/
-   LDA r_battle_character_visual_properties.1.x.w,X                            ; $02CA9C |\
    CLC                                                                         ; $02CA9F | | Set the X coordinate to the character's X coordinate plus their X
    ADC r_battle_character_visual_properties.1.x_offset.w,X                     ; $02CAA0 | | offset.
    STA r_battle_damage_x_coordinates.w + 8,Y                                   ; $02CAA3 |/
    LDA r_battle_character_visual_properties.1.y.w,X                            ; $02CAA6 |\
    CLC                                                                         ; $02CAA9 | | Set the Y coordinate to the character's Y coordinate plus their Y
    ADC r_battle_character_visual_properties.1.y_offset.w,X                     ; $02CAAA | | offset plus 24.
    ADC #24.b                                                                   ; $02CAAD | |
    STA r_battle_damage_y_coordinates.w + 8,Y                                   ; $02CAAF |/
    TXA                                                                         ; $02CAB2 |\
    CLC                                                                         ; $02CAB3 | | Increment the indexes and loop until all five character slots have
    ADC #_sizeof_character_visual.b                                             ; $02CAB4 | | been handled.
    TAX                                                                         ; $02CAB6 | |
    INY                                                                         ; $02CAB7 | |
    CPY #5.w                                                                    ; $02CAB8 | |
    BNE -                                                                       ; $02CABB |/
    STZ r_battle_damage_counter.w                                               ; $02CABD | Initialize the counter to zero.
    REP #FLAG_P_ACCUMULATOR                                                     ; $02CAC0 |\
    LDA r_battle_slot_damage_ptr.w                                              ; $02CAC2 | | TODO: Adjust the pointer at $41 to point beyond the slot damage
    CLC                                                                         ; $02CAC5 | |       area. What purpose does this serve?
    ADC #_sizeof_r_battle_slot_damage.w                                         ; $02CAC6 | |
    STA r_battle_slot_damage_ptr.w                                              ; $02CAC9 | |
    TDC                                                                         ; $02CACC | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $02CACD |/
    INC r_battle_damage_active.w                                                ; $02CACF | Flag the damage animation as being active.
-   JSR _battle_wait_next_frame_preserve_x_y                                    ; $02CAD2 |\
    LDA r_battle_damage_active.w                                                ; $02CAD5 | | Wait frames until the animation is over.
    BNE -                                                                       ; $02CAD8 |/
    RTS                                                                         ; $02CADA

; _battle_script_dialog_draw_actor_name ($02:CADB)
;
; This routine draws the name of the currently acting monster or character. It
; does not appear to be actually used.
_battle_script_dialog_draw_actor_name:
    LDA r_battle_current_action_details.actor_flags.w                           ; $02CADB |\
    BMI +                                                                       ; $02CADE | | If a character is the one acting, write the opcode to write the
    LDA #BATTLE_DIALOG_OPCODE_CHARACTER_SLOT_NAME.b                             ; $02CAE0 | | name of the character in a slot.
    STA r_battle_update_dialog_data.w + 0                                       ; $02CAE2 |/
    BRA ++                                                                      ; $02CAE5 |\
+   LDA #BATTLE_DIALOG_OPCODE_MONSTER_NAME.b                                    ; $02CAE7 | | Otherwise, write the opcode to write a monster name.
    STA r_battle_update_dialog_data.w + 0                                       ; $02CAE9 |/
++  LDA r_battle_current_actor_slot.b                                           ; $02CAEC |\ Write the current actor slot to the next byte.
    STA r_battle_update_dialog_data.w + 1                                       ; $02CAEE |/
    STZ r_battle_update_dialog_data.w + 2                                       ; $02CAF1 | Write a zero to end the dialog update sequence.
    JMP _battle_draw_battle_message_left                                        ; $02CAF4 | Draw the actual message.

; _battle_script_dialog_draw_target_name ($02:CAF7)
;
; This routine supposedly draws the name of the monster or character being
; targeted. However, it is buggy and never actually used.
_battle_script_dialog_draw_target_name:
    LDA r_battle_current_action_details.target_flags.w                          ; $02CAF7 |\
    AND #BATTLE_ACTION_DETAILS_TARGET_FLAG_ALL.b                                ; $02CAFA | | If the all target flag is set, copy four bytes directly from ROM
    BEQ +                                                                       ; $02CAFC | | to the dialog area and then branch to the end.
    TDC                                                                         ; $02CAFE | |
    TAX                                                                         ; $02CAFF | | NOTE: The text here is "", a Japanese word for "All". It has
-   LDA bank16.text_all_data.l,X                                                ; $02CB00 | |       not been translated into English.
    STA r_battle_update_dialog_data.w,X                                         ; $02CB04 | |
    INX                                                                         ; $02CB07 | |
    CPX #4.w                                                                    ; $02CB08 | |
    BNE -                                                                       ; $02CB0B | |
    BRA +++                                                                     ; $02CB0D |/
+   LDA r_battle_current_action_details.target_flags.w                          ; $02CB0F |\
    BMI +                                                                       ; $02CB12 | | If the target is a character, set the opcode to draw a character
    LDA #BATTLE_DIALOG_OPCODE_CHARACTER_SLOT_NAME.b                             ; $02CB14 | | name.
    STA r_battle_update_dialog_data.w                                           ; $02CB16 | |
    BRA ++                                                                      ; $02CB19 |/
+   LDA #BATTLE_DIALOG_OPCODE_MONSTER_NAME.b                                    ; $02CB1B |\ Otherwise, set the opcode to draw a monster name.
    STA r_battle_update_dialog_data.w                                           ; $02CB1D |/
++  LDA <r_battle_effect_target_slot                                            ; $02CB20 |\
    TAX                                                                         ; $02CB22 | | Read the effect target and use that to determine the monster type.
    LDA r_monster_slot_to_id_index_initial.w,X                                  ; $02CB23 | | (This makes no sense if working on a character, but this function
    STA r_battle_update_dialog_data.w + 1                                       ; $02CB26 |/  is abandoned anyway.)
    STZ r_battle_update_dialog_data.w + 2                                       ; $02CB29 | Write a zero to end the dialog.
+++ JMP _battle_draw_battle_message_center                                      ; $02CB2C | Draw the actual message.

; _battle_script_dialog_draw_action_name ($02:CB2F)
;
; Draws the name of the currently executing action. Notably, only spells, items
; and commands will have anything drawn. Anything else will result in no dialog
; box.
_battle_script_dialog_draw_action_name:
    LDA r_battle_current_action_details.action_flags.w                          ; $02CB2F |\
    AND #%01110000.b                                                            ; $02CB32 | | If the action is a spell, item, or command, branch to the
    CMP #BATTLE_ACTION_DETAILS_ACTION_FLAG_SPELL.b                              ; $02CB34 | | appropriate handler. Otherwise, return, as there is no dialog to
    BEQ +++                                                                     ; $02CB36 | | be drawn.
    CMP #BATTLE_ACTION_DETAILS_ACTION_FLAG_ITEM.b                               ; $02CB38 | |
    BEQ ++                                                                      ; $02CB3A | |
    CMP #BATTLE_ACTION_DETAILS_ACTION_FLAG_COMMAND.b                            ; $02CB3C | |
    BEQ +                                                                       ; $02CB3E | |
    RTS                                                                         ; $02CB40 |/
+   LDA r_battle_current_action_details.action.w                                ; $02CB41 |\
    STA <r_math_multiply_8bit_arg_1                                             ; $02CB44 | | If it was a command, multiply the action index by five to index
    LDA #5.b                                                                    ; $02CB46 | | the command name data. Load the index into the X register and
    STA <r_math_multiply_8bit_arg_2                                             ; $02CB48 | | initialize the Y register to zero.
    JSR _math_multiply_8bit                                                     ; $02CB4A | |
    TDC                                                                         ; $02CB4D | |
    TAY                                                                         ; $02CB4E | |
    LDX <r_math_multiply_8bit_result                                            ; $02CB4F |/
-   LDA bank0F.battle_command_name_data.l,X                                     ; $02CB51 |\
    STA r_battle_update_dialog_data.w,Y                                         ; $02CB55 | | Copy the five bytes of the command name from ROM to the dialog
    INX                                                                         ; $02CB58 | | data.
    INY                                                                         ; $02CB59 | |
    CPY #5.w                                                                    ; $02CB5A | |
    BNE -                                                                       ; $02CB5D |/
    TDC                                                                         ; $02CB5F |\ Write a zero to end the dialog command.
    STA r_battle_update_dialog_data.w,Y                                         ; $02CB60 |/
    JMP _battle_draw_battle_message_party                                       ; $02CB63 | Draw a party-aligned dialog box with the command name.
++  JMP _battle_script_dialog_helper_item_name                                  ; $02CB66 | If it was an item, draw the item name dialog box.
+++ JMP _battle_script_dialog_helper_spell_name                                 ; $02CB69 | If it was a spell, draw the spell name dialog box.

; _battle_script_dialog_helper_item_name ($02:CB6C)
;
; Reads the action index from $34C7 and if it's non-zero, draws a party-aligned
; dialog box that displays the last eight characters of the item's name.
_battle_script_dialog_helper_item_name:
    LDA r_battle_current_action_details.action.w                                ; $02CB6C |\
    BNE +                                                                       ; $02CB6F | | If the action is a zero, simply return.
    RTS                                                                         ; $02CB71 |/
+   STA <r_math_multiply_8bit_arg_1                                             ; $02CB72 |\
    LDA #9.b                                                                    ; $02CB74 | | Otherwise, multiply the action index by 9 to index the item name
    STA <r_math_multiply_8bit_arg_2                                             ; $02CB76 | | data.
    JSR _math_multiply_8bit                                                     ; $02CB78 |/
    TDC                                                                         ; $02CB7B |\ Initialize the Y register to zero.
    TAY                                                                         ; $02CB7C |/
    LDX <r_math_multiply_8bit_result                                            ; $02CB7D | Load the X register with the item name index.
    INX                                                                         ; $02CB7F | Increment the X register to skip the icon character.
-   LDA bank0F.item_name_data.l,X                                               ; $02CB80 |\
    STA r_battle_update_dialog_data.w,Y                                         ; $02CB84 | | Copy the remaining eight bytes into the dialog data.
    INY                                                                         ; $02CB87 | |
    INX                                                                         ; $02CB88 | |
    CPY #8.w                                                                    ; $02CB89 | |
    BNE -                                                                       ; $02CB8C |/
    TDC                                                                         ; $02CB8E |\ Write a zero to end the dialog command.
    STA r_battle_update_dialog_data.w,Y                                         ; $02CB8F |/
    JMP _battle_draw_battle_message_party                                       ; $02CB92 | Draw a party-aligned dialog box.

; _battle_script_dialog_helper_spell_name ($02:CB95)
;
; Reads the action index from $34C7 and if it's non-zero, draws a party-aligned
; dialog box that displays the name of the spell being used. Automatically
; handles both short spell names and long spell names.
_battle_script_dialog_helper_spell_name:
    LDA r_battle_current_action_details.action.w                                ; $02CB95 |\
    BNE +                                                                       ; $02CB98 | | If the action index is zero, simply return.
    RTS                                                                         ; $02CB9A |/
+   CMP #SPELL_FIRST_LONG_NAME.b                                                ; $02CB9B |\ If the spell has a short name, branch to the handling code.
    BCC ++                                                                      ; $02CB9D |/
    SEC                                                                         ; $02CB9F |\ Otherwise, subtract the base index to determine the true index.
    SBC #SPELL_FIRST_LONG_NAME.b                                                ; $02CBA0 |/
    STA <r_math_multiply_8bit_arg_1                                             ; $02CBA2 |\
    LDA #8.b                                                                    ; $02CBA4 | | Set the X register to the long name spell index times eight.
    STA <r_math_multiply_8bit_arg_2                                             ; $02CBA6 | |
    JSR _math_multiply_8bit                                                     ; $02CBA8 | |
    LDX <r_math_multiply_8bit_result                                            ; $02CBAB |/
    TDC                                                                         ; $02CBAD |\ Initialize the Y register to zero.
    TAY                                                                         ; $02CBAE |/
-   LDA bank0F.spell_name_long_data.l,X                                         ; $02CBAF |\
    STA r_battle_update_dialog_data.w,Y                                         ; $02CBB3 | | Copy the eight characters of the spell name to the dialog update
    INY                                                                         ; $02CBB6 | | area.
    INX                                                                         ; $02CBB7 | |
    CPY #8.w                                                                    ; $02CBB8 | |
    BNE -                                                                       ; $02CBBB |/
    TDC                                                                         ; $02CBBD |\ Write a zero to end the dialog instructions.
    STA r_battle_update_dialog_data.w,Y                                         ; $02CBBE |/
    JMP _battle_draw_battle_message_party                                       ; $02CBC1 | Draw a party-aligned dialog box and return.
++  LDA r_battle_current_action_details.action.w                                ; $02CBC4 |\
    STA <r_math_multiply_8bit_arg_1                                             ; $02CBC7 | | For a short-named spell, instead multiply the index by six.
    LDA #6.b                                                                    ; $02CBC9 | |
    STA <r_math_multiply_8bit_arg_2                                             ; $02CBCB | |
    JSR _math_multiply_8bit                                                     ; $02CBCD |/
    TDC                                                                         ; $02CBD0 |\ Initialize the Y register to zero.
    TAY                                                                         ; $02CBD1 |/
    LDX <r_math_multiply_8bit_result                                            ; $02CBD2 | Set the X register to the spell name index.
    LDA #BATTLE_DIALOG_OPCODE_TILE.b                                            ; $02CBD4 |\ Write a tile opcode so the next byte will be passed directly as a
    STA r_battle_update_dialog_data.w,Y                                         ; $02CBD6 |/ tile, instead of processed as an opcode.
    INY                                                                         ; $02CBD9 |\
-   LDA bank0F.spell_name_short_data.l,X                                        ; $02CBDA | | Copy the six characters of the spell name to the dialog update
    STA r_battle_update_dialog_data.w,Y                                         ; $02CBDE | | area.
    INY                                                                         ; $02CBE1 | |
    INX                                                                         ; $02CBE2 | |
    CPY #7.w                                                                    ; $02CBE3 | |
    BNE -                                                                       ; $02CBE6 |/
    TDC                                                                         ; $02CBE8 |\ Write a zero to end the dialog instruction.
    STA r_battle_update_dialog_data.w,Y                                         ; $02CBE9 |/
    JMP _battle_draw_battle_message_party                                       ; $02CBEC | Draw a party-aligned dialog box and return.

; _battle_script_dialog_display_alerts ($02:CBEF)
;
; Loops through the battle alert queue at $34CA, displaying each of the alerts
; in turn.
_battle_script_dialog_display_alerts:
--  JSR _battle_wait_menu_dma_pending_clear                                     ; $02CBEF |\
    JSR _battle_close_battle_message                                            ; $02CBF2 | | Close any open battle message dialogs.
    JSR _battle_wait_menu_dma_pending_clear                                     ; $02CBF5 |/
    LDA (<r_battle_alert_queue_ptr)                                             ; $02CBF8 | Load the first alert in the queue.
    CMP #BATTLE_ALERT_NONE.b                                                    ; $02CBFA |\
    BNE +                                                                       ; $02CBFC | | If none, return.
    RTS                                                                         ; $02CBFE |/
+   PHA                                                                         ; $02CBFF | Push the value to the stack.
    REP #FLAG_P_ACCUMULATOR                                                     ; $02CC00 |\
    ASL A                                                                       ; $02CC02 | | Load the offset to the desired alert data and save it to $00.
    TAX                                                                         ; $02CC03 | |
    LDA bank0F.battle_alert_offset_data.l,X                                     ; $02CC04 | |
    STA <r_battle_generic_tmp_ptr_2_addr                                        ; $02CC08 | |
    TDC                                                                         ; $02CC0A | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $02CC0B | |
    LDA #:bank0F.battle_alert_offset_data.b                                     ; $02CC0D | |
    STA <r_battle_generic_tmp_ptr_2_bank                                        ; $02CC0F |/
    LDX <r_battle_alert_queue_ptr                                               ; $02CC11 |\
    INX                                                                         ; $02CC13 | | Increment the queue pointer value.
    STX <r_battle_alert_queue_ptr                                               ; $02CC14 |/
    TDC                                                                         ; $02CC16 |\
    TAY                                                                         ; $02CC17 | | Initialize the X and Y registers to zero.
    TAX                                                                         ; $02CC18 |/
-   LDA [<r_battle_generic_tmp_ptr_2],Y                                         ; $02CC19 |\
    STA r_battle_update_dialog_data.w,Y                                         ; $02CC1B | | Copy 128 bytes from ROM to the dialog update area to get the alert
    INY                                                                         ; $02CC1E | | dialog data in memory.
    INX                                                                         ; $02CC1F | |
    CPX #128.w                                                                  ; $02CC20 | | NOTE: This is way more bytes than will ever be needed.
    BNE -                                                                       ; $02CC23 |/
    JSR _battle_draw_battle_message                                             ; $02CC25 | Draw the message.
    PLA                                                                         ; $02CC28 |\ Wait the appropriate amount of time (and possibly for input) for
    JSR _battle_alert_wait                                                      ; $02CC29 |/ this alert.
    JMP --                                                                      ; $02CC2C | Loop back to the start until done with the queue.

; _battle_script_audiovisual_play_song ($02:CC2F)
;
; This battle script opcode, given a single byte parameter, changes the playing
; music to the track indicated by the parameter.
_battle_script_audiovisual_play_song:
    JSR _battle_script_audiovisual_get_next                                     ; $02CC2F |\ Read the next byte and set that as the pending track.
    STA r_battle_song_change_track.w                                            ; $02CC32 |/
    INC r_battle_song_change_pending.w                                          ; $02CC35 | Flag that a song change is pending.
    RTS                                                                         ; $02CC38

; battle_character_apparition_animate_strobe ($02:CC39)
;
; Animates a strobe transition between two battle tilemaps. Used to animate the
; appearance or disappearance of character apparitions.
battle_character_apparition_animate_strobe:
    JSR _copy_battle_tilemap_bg1_right_to_vram                                  ; $02CC39 | Transfer to the current battle tilemap to the right side of BG1.
    STZ <r_battle_monster_effect_counter                                        ; $02CC3C | Initialize the effect counter to zero.
-   JSR _battle_wait_next_frame_preserve_x_y                                    ; $02CC3E | Wait for the next frame.
    LDA <r_battle_monster_effect_counter                                        ; $02CC41 |\
    AND #1.b                                                                    ; $02CC43 | | Alternate the displayed side of BG1.
    JSR _battle_set_bg1_horizontal_hi_scroll                                    ; $02CC45 |/
    INC r_battle_monster_effect_counter.w                                       ; $02CC48 |\
    LDA r_battle_monster_effect_counter.w                                       ; $02CC4B | | Increment the effect counter and loop until it reaches 96.
    CMP #96.b                                                                   ; $02CC4E | |
    BNE -                                                                       ; $02CC50 |/
    JSR _copy_battle_tilemap_bg1_left_to_vram                                   ; $02CC52 | Copy the current tilemap to the left side of BG1.
    LDA #1.b                                                                    ; $02CC55 |\ Set the final display value to the right side of BG1.
    JSR _battle_set_bg1_horizontal_hi_scroll                                    ; $02CC57 |/
    RTL                                                                         ; $02CC5A

; battle_load_monster_variable_sprite_to_bg1_left ($02:CC5B)
;
; Loads the variable sprite passed in the low 6 bits of the accumulator to the
; monster specified in the upper two bits of the accumulator, and places it on
; the left side of BG1.
battle_load_monster_variable_sprite_to_bg1_left:
    PHA                                                                         ; $02CC5B |\
    LDA #1.b                                                                    ; $02CC5C | | Set the flag that directs the next routine to copy the monster
    STA r_battle_monster_transition_copy_to_left_only.w                         ; $02CC5E | | tilemap to the left side of BG1 only and return.
    PLA                                                                         ; $02CC61 |/
    JSR _battle_script_audiovisual_monster_transition_custom                    ; $02CC62 | Load the monster tilemap.
    RTL                                                                         ; $02CC65

; _battle_animate_monster_jump_transition ($02:CC66)
;
; Animates a transition between monster sprites wherein the monster jumps out of
; view, switches sprites, and then jumps back down.
_battle_animate_monster_jump_transition:
    LDX #0.w                                                                    ; $02CC66 | Initialize the X register to zero.
-   JSR _battle_wait_next_frame_preserve_x_y                                    ; $02CC69 | Wait for the next frame.
    PHX                                                                         ; $02CC6C |\
    TXA                                                                         ; $02CC6D | | Update the vertical scroll value to the current value of the X
    JSR _battle_set_bg1_vertical_scroll                                         ; $02CC6E | | register.
    PLX                                                                         ; $02CC71 |/
    TXA                                                                         ; $02CC72 |\
    CLC                                                                         ; $02CC73 | | Add 16 to the X register for the next frame.
    ADC #16.b                                                                   ; $02CC74 | |
    TAX                                                                         ; $02CC76 |/
    CPX #(16 * 9).w                                                             ; $02CC77 |\ Loop until the value reaches 144 pixels.
    BNE -                                                                       ; $02CC7A |/
    JSL battle_animate_monster_transition_if_status                             ; $02CC7C | Animate a strobe transition if there is a status change.
    LDX #(16 * 9).w                                                             ; $02CC80 | Initialize the X register to 144.
-   JSR _battle_wait_next_frame_preserve_x_y                                    ; $02CC83 | Wait for the next frame.
    PHX                                                                         ; $02CC86 |\
    TXA                                                                         ; $02CC87 | | Update the vertical scroll value to the current value of the X
    JSR _battle_set_bg1_vertical_scroll                                         ; $02CC88 | | register.
    PLX                                                                         ; $02CC8B |/
    TXA                                                                         ; $02CC8C |\
    SEC                                                                         ; $02CC8D | | Subtract 16 from the X register for the next frame.
    SBC #16.b                                                                   ; $02CC8E | |
    TAX                                                                         ; $02CC90 |/
    CMP #-16.b                                                                  ; $02CC91 |\ Loop until it reaches -16 (the last set value was actually zero).
    BNE -                                                                       ; $02CC93 |/
    RTS                                                                         ; $02CC95

; battle_script_audiovisual_transition_fixed_type ($02:CC96)
;
; Copies the current battle tilemap to the right side of BG1 and then calls the
; code that animates a monster transition, using the transition type passed in
; the accumulator.
battle_script_audiovisual_transition_fixed_type:
    PHA                                                                         ; $02CC96
    JSR _copy_battle_tilemap_bg1_right_to_vram                                  ; $02CC97
    PLA                                                                         ; $02CC9A
    JSR _battle_script_audiovisual_monster_transition_fixed_type                ; $02CC9B
    RTL                                                                         ; $02CC9E

; _battle_script_audiovisual_monster_transition ($02:CC9F)
;
; This battle script code, given a single byte parameter, changes the sprite for
; the monster in the slot specified by the upper two bits of the parameter to
; the variable sprite specified by the low six bits of the parameter.
;
; The _fixed_type entry point allows the caller to explicitly set the transition
; type by passing the appropriate value in the accumulator.
;
; The _custom entry point allows the caller to specify the parameter directly in
; the accumulator, rather than being read from the script.
_battle_script_audiovisual_monster_transition:
    STZ r_battle_monster_transition_copy_to_left_only.w                         ; $02CC9F | Unset the left side only flag.
    JSR _battle_script_audiovisual_get_next                                     ; $02CCA2 | Fetch the next audiovisual byte, which is the parameter.
_battle_script_audiovisual_monster_transition_custom:
    PHA                                                                         ; $02CCA5 |\
    LSR A                                                                       ; $02CCA6 | | Shift the parameter right six bits to obtain which monster slot
    LSR A                                                                       ; $02CCA7 | | this should apply to.
    LSR A                                                                       ; $02CCA8 | |
    LSR A                                                                       ; $02CCA9 | |
    LSR A                                                                       ; $02CCAA | |
    LSR A                                                                       ; $02CCAB | |
    TAY                                                                         ; $02CCAC | |
    PLA                                                                         ; $02CCAD |/
    AND #%00111111.b                                                            ; $02CCAE |\ Use the other six bits to set the new variable sprite index for
    STA r_monster_variable_sprite_index.w,Y                                     ; $02CCB0 |/ this slot.
    JSR _battle_load_monster_variable_tilemap                                   ; $02CCB3 | Load the new monster tilemap.
    JSR _flip_battle_monster_tilemap                                            ; $02CCB6 | Flip the tilemap as appropriate for a back attack.
    LDA r_battle_monster_transition_copy_to_left_only.w                         ; $02CCB9 |\
    BEQ +                                                                       ; $02CCBC | | Copy the tilemap to BG1 left and return if the flag is set.
    JMP _copy_battle_tilemap_bg1_left_to_vram                                   ; $02CCBE |/
+   JSR _copy_battle_tilemap_bg1_right_to_vram                                  ; $02CCC1 | Otherwise, copy the new tilemap to BG1 right.
    LDA r_variable_sprite_properties.type_transition.w                          ; $02CCC4 |\
_battle_script_audiovisual_monster_transition_fixed_type:
    AND #MONSTER_VARIABLE_SPRITE_TYPE_TRANSITION_TRANSITION.b                   ; $02CCC7 | | Based on the type of transition, branch to the appropriate
    BEQ @none                                                                   ; $02CCC9 | | handling code.
    CMP #MONSTER_TRANSITION_MOSAIC.b                                            ; $02CCCB | |
    BEQ @mosaic                                                                 ; $02CCCD | |
    CMP #MONSTER_TRANSITION_STROBE.b                                            ; $02CCCF | |
    BEQ @strobe                                                                 ; $02CCD1 | |
    CMP #MONSTER_TRANSITION_LINE_DISSOLVE.b                                     ; $02CCD3 | |
    BEQ @dissolve                                                               ; $02CCD5 | |
    CMP #MONSTER_TRANSITION_SHAKE.b                                             ; $02CCD7 | |
    BEQ @shake                                                                  ; $02CCD9 |/
    JMP _battle_animate_monster_jump_transition                                 ; $02CCDB | If no value matched, use the jump transition.
@shake:
    JSL bank03.battle_animate_monster_horizontal_shake                          ; $02CCDE | Animate the shake, and then fall through to no transition.
@none:
    LDA #1.b                                                                    ; $02CCE2 |\ Display the right half of BG1.
    JSR _battle_set_bg1_horizontal_hi_scroll                                    ; $02CCE4 |/
    JSR _copy_battle_tilemap_bg1_left_to_vram                                   ; $02CCE7 | Copy the new tilemap to the left half of BG1.
    TDC                                                                         ; $02CCEA |\ Display the left half of BG1 and return.
    JMP _battle_set_bg1_horizontal_hi_scroll                                    ; $02CCEB |/
@dissolve:
    LDA #48.b                                                                   ; $02CCEE |\ Initialize the effect frame counter to 48.
    STA <r_battle_monster_effect_counter                                        ; $02CCF0 |/
-   JSR _battle_wait_next_frame_preserve_x_y                                    ; $02CCF2 | Wait for the next frame.
    STZ r_battle_monster_special_transition.w                                   ; $02CCF5 | Don't set a special transition effect.
    JSL bank03.battle_update_monster_dissolve                                   ; $02CCF8 | Update the monster dissolve for this frame.
    DEC <r_battle_monster_effect_counter                                        ; $02CCFC |\ Decrement the counter and loop until it reaches zero.
    BNE -                                                                       ; $02CCFE |/
    JMP @none                                                                   ; $02CD00 | Wrap up with the no transition code.
@strobe:
    LDA #AUDIO_EFFECT_MONSTER_TRANSFORM.b                                       ; $02CD03 |\ Play the transformation sound effect.
    JSR _battle_play_sound_effect                                               ; $02CD05 |/
    JSR _battle_animate_monster_strobe_transition                               ; $02CD08 | Animate the strobe transition effect.
    JMP @none                                                                   ; $02CD0B | Finish with the no transition code.
@mosaic:
    STZ <r_battle_monster_effect_counter                                        ; $02CD0E | Initialize the effect counter to zero.
-   LDX #8.w                                                                    ; $02CD10 |\ Wait for eight frames.
    JSR _battle_wait_x_frames                                                   ; $02CD13 |/
    JSR _battle_update_monster_mosaic                                           ; $02CD16 | Update the monster mosaic for this frame.
    INC <r_battle_monster_effect_counter                                        ; $02CD19 |\
    LDA <r_battle_monster_effect_counter                                        ; $02CD1B | | Increment the counter and loop until it reaches 7.
    CMP #7.b                                                                    ; $02CD1D | |
    BNE -                                                                       ; $02CD1F |/
    JSR _copy_battle_tilemap_bg1_left_to_vram                                   ; $02CD21 | Copy the new tilemap to the left side of BG1.
-   LDX #8.w                                                                    ; $02CD24 |\ Wait for eight frames.
    JSR _battle_wait_x_frames                                                   ; $02CD27 |/
    JSR _battle_update_monster_mosaic                                           ; $02CD2A | Update the monster mosaic for this frame.
    DEC <r_battle_monster_effect_counter                                        ; $02CD2D |\ Loop until the counter reaches zero.
    BNE -                                                                       ; $02CD2F |/

; _battle_update_monster_mosaic ($02:CD31)
;
; Given a value in the frame counter at $4E, updates the mosaic value for that
; frame.
_battle_update_monster_mosaic:
    LDA <r_battle_monster_effect_counter                                        ; $02CD31 |\
    ASL A                                                                       ; $02CD33 | | Update the mosaic value by taking the current effect counter, and
    ASL A                                                                       ; $02CD34 | | shifting left four times to put it in the right bit location. Mask
    ASL A                                                                       ; $02CD35 | | out only those bits, set the lowest bit to enable the mosaic on
    ASL A                                                                       ; $02CD36 | | BG1, and then store the value to the mosaic variable.
    AND #%11110000.b                                                            ; $02CD37 | |
    ORA #%00000001.b                                                            ; $02CD39 | |
    STA r_battle_ppu_mosaic.w                                                   ; $02CD3B |/
    RTS                                                                         ; $02CD3E

; _battle_weapon_effect_whip ($02:CD3F)
;
; Implements the whip weapon effect.
_battle_weapon_effect_whip:
    LDA #1.b                                                                    ; $02CD3F |\ Enable the double sprite mode.
    STA r_battle_weapon_effect_double_sprite.w                                  ; $02CD41 |/
    BRA _battle_weapon_effect_slash_whip_common                                 ; $02CD44 | Branch to the common code.

; _battle_weapon_effect_slash ($02:CD46)
;
; Implements the slashing weapon effect, wherein the character strikes with
; their weapon, producing a slashing effect. Falls through to the next function.
_battle_weapon_effect_slash:
    STZ r_battle_weapon_effect_double_sprite.w                                  ; $02CD46 | Disable double sprite handling.

; _battle_weapon_effect_slash_whip_common ($02:CD49)
;
; Common code for both the slash and whip weapon effects.
_battle_weapon_effect_slash_whip_common:
    LDA <r_battle_weapon_effect_hand                                            ; $02CD49 |\
    BNE +                                                                       ; $02CD4B | | Call either the left arm or the right arm slash routine, depending
    JMP _battle_weapon_effect_animate_right_arm_slash                           ; $02CD4D | | on the hand being processed.
+   JMP _battle_weapon_effect_animate_left_arm_slash                            ; $02CD50 |/

; _battle_weapon_effect_hammer ($02:CD53)
;
; Implements the weapon effect for hammers, wherein the character strikes with
; their weapon and produces a simple hit effect.
_battle_weapon_effect_hammer:
    LDA #AUDIO_EFFECT_HAMMER.b                                                  ; $02CD53 | Load the ID for the hammer sound effect.
    BRA _battle_weapon_effect_staff_rod_hammer_common                           ; $02CD55 | Branch to the common code.

; _battle_weapon_effect_staff_rod ($02:CD57)
;
; Implements the weapon effect for staves and rods, wherein the character
; strikes with their weapon and produces a simple hit effect. Falls through to
; the next function.
_battle_weapon_effect_staff_rod:
    LDA #AUDIO_EFFECT_STAFF_ROD.b                                               ; $02CD57 | Load the ID for the staff and rod sound effect.

; _battle_weapon_effect_staff_rod_hammer_common ($02:CD59)
;
; Common code for both the staff/rod and hammer effects, as they only differ in
; sound effect.
_battle_weapon_effect_staff_rod_hammer_common:
    STA r_battle_weapon_sound_effect.w                                          ; $02CD59 | Save the passed value as the sound effect.
    STZ r_battle_weapon_effect_double_sprite.w                                  ; $02CD5C | Disable the weapon double sprite mode.
    LDA <r_battle_weapon_effect_hand                                            ; $02CD5F |\
    BNE +                                                                       ; $02CD61 | | Call either the left arm or the right arm staff or rod routine,
    JMP _battle_weapon_effect_animate_right_arm_staff_rod                       ; $02CD63 | | depending on the hand being processed.
+   JMP _battle_weapon_effect_animate_left_arm_staff_rod                        ; $02CD66 |/

; _battle_load_weapon_sprite_animation_parameters ($02:CD69)
;
; Loads the parameters for a weapon sprite that affect the animation, based on
; the value of the frame counter at $52. Sets the base tile number, the X and Y
; offsets, and the tile flags.
_battle_load_weapon_sprite_animation_parameters:
    LDA <r_battle_weapon_effect_frame_counter                                   ; $02CD69 |\
    INC A                                                                       ; $02CD6B | | Set the X register to the frame counter plus one's bit 2. After
    AND #%00000100.b                                                            ; $02CD6C | | three frames, it becomes 4, and then alternates every four frames.
    TAX                                                                         ; $02CD6E |/
    LDA r_battle_weapon_effect_charmed.w                                        ; $02CD6F |\
    BEQ +                                                                       ; $02CD72 | | If the character is charmed, add 8 to the offset to load the
    TXA                                                                         ; $02CD74 | | reversed data.
    CLC                                                                         ; $02CD75 | |
    ADC #8.b                                                                    ; $02CD76 | |
    TAX                                                                         ; $02CD78 |/
+   LDA bank16.battle_weapon_sprite_animation_data.l + 0,X                      ; $02CD79 |\ Load the base tile number for the weapon sprite.
    STA r_battle_weapon_sprite_tile.w                                           ; $02CD7D |/
    LDA bank16.battle_weapon_sprite_animation_data.l + 1,X                      ; $02CD80 |\ Load the X offset for the sprite.
    STA r_battle_weapon_sprite_x_offset.w                                       ; $02CD84 |/
    LDA bank16.battle_weapon_sprite_animation_data.l + 2,X                      ; $02CD87 |\ Load the Y offset for the sprite.
    STA r_battle_weapon_sprite_y_offset.w                                       ; $02CD8B |/
    LDA bank16.battle_weapon_sprite_animation_data.l + 3,X                      ; $02CD8E |\ Load the tile flags for the sprite.
    STA r_battle_weapon_sprite_tile_flags.w                                     ; $02CD92 |/
    RTS                                                                         ; $02CD95

; _battle_weapon_effect_set_double_sprite ($02:CD96)
;
; If the double sprite flag at $F233 is set, directly sets the tile flags and
; tile to use the second sprite at tile $182 instead of simply mirroring the
; first sprite.
;
; NOTE: This function has some bugged code that lowers the sprite by eight
;       pixels, highly suggesting this may be specific to whips (or anything
;       else for which it makes sense to lower the sprite).
_battle_weapon_effect_set_double_sprite:
    LDA r_battle_weapon_effect_double_sprite.w                                  ; $02CD96 |\ Skip this function unless the double sprite flag is set.
    BEQ +++                                                                     ; $02CD99 |/
    LDA r_battle_weapon_effect_charmed.w                                        ; $02CD9B |\
    BNE +                                                                       ; $02CD9E | | Set the tile flags to flip the sprite horizontally if the
    LDA #%00111111.b                                                            ; $02CDA0 | | character is charmed.
    BRA ++                                                                      ; $02CDA2 | |
+   LDA #%01111111.b                                                            ; $02CDA4 | |
++  STA r_battle_weapon_sprite_tile_flags.w                                     ; $02CDA6 |/
    LDA r_battle_weapon_sprite_coordinates.y.w                                  ; $02CDA9 |\
    CLC                                                                         ; $02CDAC | | BUG: Add eight to the Y coordinate to lower the sprite. However,
    ADC #8.b                                                                    ; $02CDAD | |      it should instead modify the Y offset at $F0D2. What it does
    STA r_battle_weapon_sprite_coordinates.y.w                                  ; $02CDAF |/       write will be shortly overwritten after this returns.
    LDA <r_battle_weapon_effect_frame_counter                                   ; $02CDB2 |\
    INC A                                                                       ; $02CDB4 | | Set the tile number explicitly to $82 if the frame counter plus
    AND #%00000100.b                                                            ; $02CDB5 | | one has its bit 2 set. This uses the second weapon sprite.
    BEQ +++                                                                     ; $02CDB7 | |
    LDA #$82.b                                                                  ; $02CDB9 | |
    STA r_battle_weapon_sprite_tile.w                                           ; $02CDBB |/
+++ RTS                                                                         ; $02CDBE

; _battle_animate_weapon_sprites_staff_rod ($02:CDBF)
;
; Animates the weapon sprite and the weapon effect sprites for staves and rods.
; This takes one direct parameter in the accumulator, which is the offset within
; the character's OAM sprites to place the weapon sprite. It additionally reads
; numerous other values.
_battle_animate_weapon_sprites_staff_rod:
    STA r_battle_weapon_sprite_tmp_oam_offset.w                                 ; $02CDBF | Set the OAM offset to the value passed in the accumulator.
    JSR _battle_get_current_actor_visual_properties_offset                      ; $02CDC2 |\
    STZ r_battle_character_visual_properties.1.animate_pose.w,X                 ; $02CDC5 | | Disable pose animation and set the pose frame counter to zero.
    STZ r_battle_character_visual_properties.1.pose_frame_counter.w,X           ; $02CDC8 |/
    LDA #16.b                                                                   ; $02CDCB |\ Set the frames remaining count to 16.
    STA <r_battle_weapon_effect_frames_remaining                                ; $02CDCD |/
    JSR _battle_reset_effect_oam_large                                          ; $02CDCF | Reset the effect OAM to large sprites.
@start:
    JSR _battle_wait_next_frame_preserve_x_y                                    ; $02CDD2 | Wait for the next frame.
    LDA <r_battle_weapon_effect_frame_counter                                   ; $02CDD5 |\
    AND #%00000111.b                                                            ; $02CDD7 | | If the effect frame counter mod 8 is zero, play the weapon sound
    BNE +                                                                       ; $02CDD9 | | effect and, if it's a critical hit, flash the screen.
    LDA r_battle_weapon_sound_effect.w                                          ; $02CDDB | |
    JSR _battle_play_sound_effect                                               ; $02CDDE | |
    JSR _battle_action_flash_yellow_if_critical                                 ; $02CDE1 |/
+   JSR _battle_get_current_actor_visual_properties_offset                      ; $02CDE4 |\
    LDA <r_battle_weapon_effect_frame_counter                                   ; $02CDE7 | | Every other frame, increment the pose frame counter.
    AND #%00000001.b                                                            ; $02CDE9 | |
    BNE +                                                                       ; $02CDEB | |
    INC r_battle_character_visual_properties.1.pose_frame_counter.w,X           ; $02CDED |/
+   INC <r_battle_weapon_effect_frame_counter                                   ; $02CDF0 | Increment the effect frame counter.
    LDA <r_battle_weapon_effect_frame_counter                                   ; $02CDF2 |\
    AND #%00000011.b                                                            ; $02CDF4 | | Set the weapon effect parameters for this frame.
    JSR _battle_set_weapon_effect_parameters_single_tile                        ; $02CDF6 |/
    LDA <r_battle_weapon_effect_frame_counter                                   ; $02CDF9 |\
    AND #%00000010.b                                                            ; $02CDFB | | Set the base tile to either $A0 or $A2, depending on the frame.
    CLC                                                                         ; $02CDFD | |
    ADC #$A0.b                                                                  ; $02CDFE | |
    STA r_battle_effect_sprites_base_tile.w                                     ; $02CE00 |/
    JSR _battle_weapon_effect_set_random_coordinates                            ; $02CE03 | Set the weapon effect coordinates randomly.
    JSR _battle_load_weapon_sprite_animation_parameters                         ; $02CE06 | Load the animation parameters for the weapon sprite.
    JSR _battle_weapon_effect_set_double_sprite                                 ; $02CE09 | If a double sprite weapon, set double sprite parameters.
    JSR _battle_get_current_actor_visual_properties_offset                      ; $02CE0C |\
    LDA r_battle_character_visual_properties.1.x.w,X                            ; $02CE0F | | Set the weapon sprite X coordinate to the character's X coordinate
    CLC                                                                         ; $02CE12 | | plus their X offset plus the weapon sprite X offset.
    ADC r_battle_character_visual_properties.1.x_offset.w,X                     ; $02CE13 | |
    ADC r_battle_weapon_sprite_x_offset.w                                       ; $02CE16 | |
    STA r_battle_weapon_sprite_coordinates.x.w                                  ; $02CE19 |/
    LDA r_battle_character_visual_properties.1.y.w,X                            ; $02CE1C |\
    CLC                                                                         ; $02CE1F | | Repeat for the Y coordinate.
    ADC r_battle_character_visual_properties.1.y_offset.w,X                     ; $02CE20 | |
    ADC r_battle_weapon_sprite_y_offset.w                                       ; $02CE23 | |
    STA r_battle_weapon_sprite_coordinates.y.w                                  ; $02CE26 |/
    LDA <r_battle_current_actor_slot                                            ; $02CE29 |\
    TAX                                                                         ; $02CE2B | | Set the target OAM index for the weapon sprite by padding the
    LDA bank16.battle_character_slot_oam_index_data.l,X                         ; $02CE2C | | provided offset to the character's base OAM index.
    CLC                                                                         ; $02CE30 | |
    ADC r_battle_weapon_sprite_tmp_oam_offset.w                                 ; $02CE31 | |
    STA r_battle_weapon_sprite_oam_index.w                                      ; $02CE34 |/
    INC r_battle_weapon_sprite_visible.w                                        ; $02CE37 | Set the weapon sprite as visible.
    LDA r_battle_current_action_details.target_flags.w                          ; $02CE3A |\
    BPL +                                                                       ; $02CE3D | | Draw the effect sprites if the target is a monster and the attack
    LDA r_battle_current_action_details.action_flags.w                          ; $02CE3F | | isn't a miss.
    AND #BATTLE_ACTION_DETAILS_ACTION_FLAG_MISS.b                               ; $02CE42 | |
    BNE +                                                                       ; $02CE44 | |
    INC r_battle_effect_sprites_pending.w                                       ; $02CE46 |/
+   DEC <r_battle_weapon_effect_frames_remaining                                ; $02CE49 |\
    BEQ +                                                                       ; $02CE4B | | Loop until all animation frames have occurred.
    JMP @start                                                                  ; $02CE4D |/
+   STZ r_battle_weapon_sprite_visible.w                                        ; $02CE50 | Set the weapon sprite as no longer visible.
    RTS                                                                         ; $02CE53

; _battle_prepare_weapon_visual_oam_x ($02:CE54)
;
; Sets the character in the slot passed in $48's pose override to the value
; passed in the accumulator, and then loads the visual properties for the
; weapon specified in either $50 or $51 (right or left hand) depending on the
; value in $4E. Sets the character's OAM index override to either their true
; base or their normal value (base + 2), depending on the entry point.
_battle_prepare_weapon_visual_oam_2:
    PHA                                                                         ; $02CE54 | Preserve the parameter in the accumualtor.
    LDA <r_battle_current_actor_slot                                            ; $02CE55 |\
    TAX                                                                         ; $02CE57 | | Load the character's normal OAM index (base+2).
    LDA bank16.battle_character_slot_oam_index_normal_data.l,X                  ; $02CE58 |/
    BRA _battle_prepare_weapon_visual_oam_x_next                                ; $02CE5C | Branch to the next code.
_battle_prepare_weapon_visual_oam_0:
    PHA                                                                         ; $02CE5E | Preserve the parameter in the accumualtor.
    LDA <r_battle_current_actor_slot                                            ; $02CE5F |\
    TAX                                                                         ; $02CE61 | | Load the character's base OAM index.
    LDA bank16.battle_character_slot_oam_index_data.l,X                         ; $02CE62 |/
_battle_prepare_weapon_visual_oam_x_next:
    STA r_battle_character_oam_index_override.w,X                               ; $02CE66 | Store the loaded value as the OAM override.
    PLA                                                                         ; $02CE69 |\ Set the character's pose to the passed value.
    STA r_battle_character_pose.w,X                                             ; $02CE6A |/
    LDA <r_battle_weapon_effect_hand                                            ; $02CE6D |\
    TAX                                                                         ; $02CE6F | | Load the visual data for the current weapon.
    LDA <r_battle_weapon_effect_right_hand,X                                    ; $02CE70 | |
    JSR _battle_load_weapon_visual                                              ; $02CE72 |/
    STZ <r_battle_weapon_effect_frame_counter                                   ; $02CE75 | Reset the weapon effect frame counter.
    RTS                                                                         ; $02CE77

; _battle_weapon_effect_animate_left_arm_staff_rod ($02:CE78)
;
; Animates a character swinging a staff or rod with their left arm, including
; the effect on the actual target.
_battle_weapon_effect_animate_left_arm_staff_rod:
    LDA #BATTLE_POSE_SWINGING_LEFT_ARM.b                                        ; $02CE78 |\ Set the character pose to swinging left arm and prepare some
    JSR _battle_prepare_weapon_visual_oam_2                                     ; $02CE7A |/ weapon visual data.
    TDC                                                                         ; $02CE7D |\ Set the OAM offset to 0 (within the character's OAM) and animate
    JMP _battle_animate_weapon_sprites_staff_rod                                ; $02CE7E |/ the weapon swinging effect.

; _battle_weapon_effect_animate_right_arm_staff_rod ($02:CE81)
;
; Animates a character swinging a staff or rod with their right arm, including
; the effect on the actual target.
_battle_weapon_effect_animate_right_arm_staff_rod:
    LDA #BATTLE_POSE_SWINGING_RIGHT_ARM.b                                       ; $02CE81 |\ Set the character pose to swinging right arm and prepare some
    JSR _battle_prepare_weapon_visual_oam_0                                     ; $02CE83 |/ weapon visual data.
    LDA #6.b                                                                    ; $02CE86 |\ Set the OAM offset to 6 (within the character's OAM) and animate
    JMP _battle_animate_weapon_sprites_staff_rod                                ; $02CE88 |/ the weapon swinging effect.

; _battle_weapon_effect_animate_right_arm_throw ($02:CE8B)
;
; Animates a character raising a weapon behind them with their right hand in
; order to throw it.
_battle_weapon_effect_animate_right_arm_throw:
    LDA #BATTLE_POSE_SWINGING_RIGHT_ARM.b                                       ; $02CE8B |\ Set the character pose to a swinging right arm and prepare the
    JSR _battle_prepare_weapon_visual_oam_0                                     ; $02CE8D |/ weapon visual data.
    LDA #6.b                                                                    ; $02CE90 |\ Set the OAM offset to 6 and animate the weapon throw effect.
    JMP _battle_weapon_effect_animate_throw                                     ; $02CE92 |/

; _battle_weapon_effect_animate_left_arm_throw ($02:CE95)
;
; Animates a character raising a weapon behind them with their left hand in
; order to throw it.
_battle_weapon_effect_animate_left_arm_throw:
    LDA #BATTLE_POSE_SWINGING_LEFT_ARM.b                                        ; $02CE95 |\ Set the character pose to a swinging left arm and prepare the
    JSR _battle_prepare_weapon_visual_oam_2                                     ; $02CE97 |/ weapon visual data.
    TDC                                                                         ; $02CE9A |\ Set the OAM offset to 0 and animate the weapon throw effect.
    JMP _battle_weapon_effect_animate_throw                                     ; $02CE9B |/

; _battle_weapon_effect_animate_right_arm_harp ($02:CE9E)
;
; Animates a character using a harp with their right hand.
_battle_weapon_effect_animate_right_arm_harp:
    LDA #BATTLE_POSE_SWINGING_LEFT_ARM.b                                        ; $02CE9E |\ Set the character pose to a swinging left arm and prepare the
    JSR _battle_prepare_weapon_visual_oam_2                                     ; $02CEA0 |/ weapon visual data.
    JSR _battle_get_current_actor_visual_properties_offset                      ; $02CEA3 |\
    TDC                                                                         ; $02CEA6 | | Set the pose frame counter for the character to zero.
    STA r_battle_character_visual_properties.1.pose_frame_counter.w,X           ; $02CEA7 |/
    JMP _battle_weapon_effect_animate_harp                                      ; $02CEAA | Call the harp animation function with an OAM offset of zero.

; _battle_weapon_effect_animate_left_arm_harp ($02:CEAD)
;
; Animates a character using a harp with their left hand.
_battle_weapon_effect_animate_left_arm_harp:
    LDA #BATTLE_POSE_SWINGING_LEFT_ARM.b                                        ; $02CEAD |\ Set the character pose to a swinging left arm and prepare the
    JSR _battle_prepare_weapon_visual_oam_0                                     ; $02CEAF |/ weapon visual data.
    JSR _battle_get_current_actor_visual_properties_offset                      ; $02CEB2 | \
    LDA #3.b                                                                    ; $02CEB5 | | Set the pose frame counter to three.
    STA r_battle_character_visual_properties.1.pose_frame_counter.w,X           ; $02CEB7 |/
    LDA #6.b                                                                    ; $02CEBA |\ Call the harp animation function with an OAM offset of six.
    JMP _battle_weapon_effect_animate_harp                                      ; $02CEBC |/

; _battle_weapon_effect_animate_right_arm_projectile ($02:CEBF)
;
; Animates a character using a projectile-based weapon with their right arm.
;
; TODO: Is this used by anything other than bows/arrows? It is used with an
; arrow in the right hand. What about stars if you could equip them?
_battle_weapon_effect_animate_right_arm_projectile:
    LDA #BATTLE_POSE_SWINGING_LEFT_ARM.b                                        ; $02CEBF |\ Set the character pose to swinging left arm and prepare weapon
    JSR _battle_prepare_weapon_visual_oam_0                                     ; $02CEC1 |/ visual data.
    JSR _battle_get_current_actor_visual_properties_offset                      ; $02CEC4 |\
    LDA #3.b                                                                    ; $02CEC7 | | Set the pose frame counter to show the fourth frame.
    STA r_battle_character_visual_properties.1.pose_frame_counter.w,X           ; $02CEC9 |/
    LDA #6.b                                                                    ; $02CECC |\ Animate the projectile effect.
    JMP _battle_weapon_effect_animate_projectile                                ; $02CECE |/

; _battle_weapon_effect_animate_left_arm_projectile ($02:CED1)
;
; Animates a character using a projectile-based weapon with their left arm.
_battle_weapon_effect_animate_left_arm_projectile:
    LDA #BATTLE_POSE_SWINGING_LEFT_ARM.b                                        ; $02CED1 |\ Set the character pose to swinging left arm and prepare weapon
    JSR _battle_prepare_weapon_visual_oam_2                                     ; $02CED3 |/ visual data.
    JSR _battle_get_current_actor_visual_properties_offset                      ; $02CED6 |\
    TDC                                                                         ; $02CED9 | | Set the pose frame counter to show the first frame.
    STA r_battle_character_visual_properties.1.pose_frame_counter.w,X           ; $02CEDA |/
    JMP _battle_weapon_effect_animate_projectile                                ; $02CEDD | Animate the projectile effect.

; _battle_weapon_effect_animate_left_arm_slash ($02:CEE0)
;
; Animates a character swinging their weapon with their right arm, including the
; effect on the actual target.
_battle_weapon_effect_animate_left_arm_slash:
    LDA #BATTLE_POSE_SWINGING_LEFT_ARM.b                                        ; $02CEE0 |\ Set the character pose to swinging left arm and prepare some
    JSR _battle_prepare_weapon_visual_oam_2                                     ; $02CEE2 |/ weapon visual data.
    TDC                                                                         ; $02CEE5 |\ Set the OAM offset to 0 (within the character's OAM) and animate
    JMP _battle_animate_weapon_sprites_slash                                    ; $02CEE6 |/ the weapon swinging effect.

; _battle_weapon_effect_animate_right_arm_slash ($02:CEE9)
;
; Animates a character swinging their weapon with their right arm, including the
; effect on the actual target.
_battle_weapon_effect_animate_right_arm_slash:
    LDA #BATTLE_POSE_SWINGING_RIGHT_ARM.b                                       ; $02CEE9 |\ Set the character pose to swinging right arm and prepare some
    JSR _battle_prepare_weapon_visual_oam_0                                     ; $02CEEB |/ weapon visual data.
    LDA #6.b                                                                    ; $02CEEE |\ Set the OAM offset to 6 (within the character's OAM) and animate
    JMP _battle_animate_weapon_sprites_slash                                    ; $02CEF0 |/ the weapon swinging effect.

; _battle_animate_weapon_sprites_slash ($02:CEF3)
;
; Animates the weapon sprite and the weapon effect sprites. This takes one
; direct parameter in the accumulator, which is the offset within the
; character's OAM sprites to place the weapon sprite. It additionally reads
; numerous other values.
_battle_animate_weapon_sprites_slash:
    STA r_battle_weapon_sprite_tmp_oam_offset.w                                 ; $02CEF3 | Save the parameter to a temporary variable.
    JSR _battle_get_current_actor_visual_properties_offset                      ; $02CEF6 | Set the X register to the actor's visual properties offset.
    STZ r_battle_character_visual_properties.1.animate_pose.w,X                 ; $02CEF9 |\ Disable pose animation and set the frame counter to zero to use the
    STZ r_battle_character_visual_properties.1.pose_frame_counter.w,X           ; $02CEFC |/ first frame.
    LDA #16.b                                                                   ; $02CEFF |\ Initialize the number of remaining frames to 16.
    STA <r_battle_weapon_effect_frames_remaining                                ; $02CF01 |/
    LDA <r_battle_effect_target_slot                                            ; $02CF03 |\
    ASL A                                                                       ; $02CF05 | | Set the center coordinates for the effect to the monster's center
    TAY                                                                         ; $02CF06 | | coordinates.
    LDA r_battle_monster_coordinates_center.1.x.w,Y                             ; $02CF07 | |
    STA r_battle_effect_sprites_coordinates.x.w                                 ; $02CF0A | |
    LDA r_battle_monster_coordinates_center.1.y.w,Y                             ; $02CF0D | |
    STA r_battle_effect_sprites_coordinates.y.w                                 ; $02CF10 |/
@start:
    JSR _battle_wait_next_frame_preserve_x_y                                    ; $02CF13 | Wait for the next frame.
    LDA <r_battle_weapon_effect_frame_counter                                   ; $02CF16 |\
    AND #%00000111.b                                                            ; $02CF18 | | If the weapon effect frame counter mod 8 is zero, play the
    BNE +                                                                       ; $02CF1A | | associated sound effect and flash the screen yellow if this is a
    LDA r_battle_weapon_sound_effect.w                                          ; $02CF1C | | critical hit.
    JSR _battle_play_sound_effect                                               ; $02CF1F | |
    JSR _battle_action_flash_yellow_if_critical                                 ; $02CF22 |/
+   JSR _battle_get_current_actor_visual_properties_offset                      ; $02CF25 | Set the X register to the offset to the character's visual data.
    LDA <r_battle_weapon_effect_frame_counter                                   ; $02CF28 |\
    AND #%00000001.b                                                            ; $02CF2A | | If the frame counter mod 2 is zero, increment the character's pose
    BNE +                                                                       ; $02CF2C | | frame counter.
    INC r_battle_character_visual_properties.1.pose_frame_counter.w,X           ; $02CF2E |/
+   INC <r_battle_weapon_effect_frame_counter                                   ; $02CF31 | Increment the weapon effect frame counter.
    INC r_battle_disable_oam_update.w                                           ; $02CF33 | Disable the OAM update so it doesn't update while incomplete.
    STZ r_battle_effect_sprites_reset_mode.w                                    ; $02CF36 | Set the reset mode to zero, which gives 8x8 sprites.
    LDA #%00111111.b                                                            ; $02CF39 |\ Set the effect tile flags to priority 3, palette 7 and set the base
    STA r_battle_effect_sprites_tile_flags.w                                    ; $02CF3B |/ tile number to 256.
    STX <r_battle_generic_tmp_index                                             ; $02CF3E | Save the visual properties index to a temporary variable.
    LDA <r_battle_weapon_effect_sprite_index                                    ; $02CF40 |\
    ASL A                                                                       ; $02CF42 | | Determine the animation offset by multiplying the sprite index by
    ASL A                                                                       ; $02CF43 | | eight, and then adding the frame counter mod 8. (This results in
    ASL A                                                                       ; $02CF44 | | the entire animation sequence playing twice during the animation.)
    STA <r_battle_generic_tmp_index_3_lo                                        ; $02CF45 | |
    LDA <r_battle_weapon_effect_frame_counter                                   ; $02CF47 | |
    AND #%00000111.b                                                            ; $02CF49 | |
    CLC                                                                         ; $02CF4B | |
    ADC <r_battle_generic_tmp_index_3_lo                                        ; $02CF4C | |
    TAX                                                                         ; $02CF4E |/
    LDA #$A0.b                                                                  ; $02CF4F |\ Set the base tile number to $1A0.
    STA r_battle_effect_sprites_base_tile.w                                     ; $02CF51 |/
    LDA bank0D.battle_weapon_effect_slash_pattern_data.l,X                      ; $02CF54 |\ Set the pattern for this frame.
    STA r_battle_effect_sprites_pattern_index.w                                 ; $02CF58 |/
    LDA #16.b                                                                   ; $02CF5B |\ Set the base OAM index for the effect sprites to 16.
    STA r_battle_effect_sprites_base_oam_index.w                                ; $02CF5D |/
    STZ r_battle_disable_oam_update.w                                           ; $02CF60 | Re-enable the OAM update as everything is set.
    JSR _battle_load_weapon_sprite_animation_parameters                         ; $02CF63 | Load the animation parameters for the weapon sprite.
    JSR _battle_weapon_effect_set_double_sprite                                 ; $02CF66 | If this is a double sprite weapon, adjust the parameters.
    LDX <r_battle_generic_tmp_index                                             ; $02CF69 | Load the visual properties offset into the X register.
    LDA r_battle_character_visual_properties.1.x.w,X                            ; $02CF6B |\
    CLC                                                                         ; $02CF6E | | Set the weapon sprite's X coordinate to the character's X
    ADC r_battle_character_visual_properties.1.x_offset.w,X                     ; $02CF6F | | coordinate plus their X offset plus the calculated X offset.
    ADC r_battle_weapon_sprite_x_offset.w                                       ; $02CF72 | |
    STA r_battle_weapon_sprite_coordinates.x.w                                  ; $02CF75 |/
    LDA r_battle_character_visual_properties.1.y.w,X                            ; $02CF78 |\
    CLC                                                                         ; $02CF7B | | Repeat the same with the Y coordinate.
    ADC r_battle_character_visual_properties.1.y_offset.w,X                     ; $02CF7C | |
    ADC r_battle_weapon_sprite_y_offset.w                                       ; $02CF7F | |
    STA r_battle_weapon_sprite_coordinates.y.w                                  ; $02CF82 |/
    LDA <r_battle_current_actor_slot                                            ; $02CF85 |\
    TAX                                                                         ; $02CF87 | | Set the OAM index for the weapon sprite to the character's base
    LDA bank16.battle_character_slot_oam_index_data.l,X                         ; $02CF88 | | OAM index plus the provided parameter.
    CLC                                                                         ; $02CF8C | |
    ADC r_battle_weapon_sprite_tmp_oam_offset.w                                 ; $02CF8D | |
    STA r_battle_weapon_sprite_oam_index.w                                      ; $02CF90 |/
    INC r_battle_weapon_sprite_visible.w                                        ; $02CF93 | Flag the weapon sprite as visible.
    LDA r_battle_effect_disable_effect_sprites.w                                ; $02CF96 |\
    BNE +                                                                       ; $02CF99 | | Flag the effect sprites as pending if effect sprites aren't
    LDA r_battle_current_action_details.target_flags.w                          ; $02CF9B | | disabled, the target is a monster, and the attack was not a miss.
    BPL +                                                                       ; $02CF9E | |
    LDA r_battle_current_action_details.action_flags.w                          ; $02CFA0 | |
    AND #BATTLE_ACTION_DETAILS_ACTION_FLAG_MISS.b                               ; $02CFA3 | |
    BNE +                                                                       ; $02CFA5 | |
    INC r_battle_effect_sprites_pending.w                                       ; $02CFA7 |/
+   DEC <r_battle_weapon_effect_frames_remaining                                ; $02CFAA |\
    BEQ +                                                                       ; $02CFAC | | Decrement the remaining frames and loop until it reaches zero.
    JMP @start                                                                  ; $02CFAE |/
+   STZ r_battle_weapon_sprite_visible.w                                        ; $02CFB1 | Flag the weapon sprite as no longer being visible.
    RTS                                                                         ; $02CFB4

; _battle_animate_physical_attack ($02:CFB5)
;
; Animates a physical attack. There is a second entry point, suffixed with
; _special, that is used for special modes. In those cases, $F480 is set to
; a non-zero value, and the caller is responsible for setting the item IDs at
; $50 and $51 to whatever is needed for their special attack.
_battle_animate_physical_attack:
    STZ r_battle_animate_physical_special_mode.w                                ; $02CFB5 | Disable any special mode.
    LDA <r_battle_current_actor_slot                                            ; $02CFB8 |\
    ASL A                                                                       ; $02CFBA | | Transfer the weapons equipped by the actor into two local
    ASL A                                                                       ; $02CFBB | | variables for easy access.
    ASL A                                                                       ; $02CFBC | |
    TAX                                                                         ; $02CFBD | |
    LDA r_battle_hand_inventory.1.id.w,X                                        ; $02CFBE | |
    STA <r_battle_weapon_effect_right_hand                                      ; $02CFC1 | |
    LDA r_battle_hand_inventory.2.id.w,X                                        ; $02CFC3 | |
    STA <r_battle_weapon_effect_left_hand                                       ; $02CFC6 |/
_battle_animate_physical_attack_special:
    LDA <r_battle_effect_target_slot                                            ; $02CFC8 |\
    ASL A                                                                       ; $02CFCA | | Load the damage value for the target slot.
    TAX                                                                         ; $02CFCB | |
    LDA r_battle_current_action_details.target_flags.w                          ; $02CFCC | |
    BMI +                                                                       ; $02CFCF | |
    LDA r_battle_slot_damage.w + 1,X                                            ; $02CFD1 | |
    BRA ++                                                                      ; $02CFD4 | |
+   LDA r_battle_slot_damage.w + (5 * 2) + 1,X                                  ; $02CFD6 |/
++  AND #(BATTLE_DAMAGE_MISS >> 8.b)                                            ; $02CFD9 |\
    LSR A                                                                       ; $02CFDB | | Update the action flags to set the miss bit if the attack missed
    LSR A                                                                       ; $02CFDC | | this target.
    LSR A                                                                       ; $02CFDD | |
    STA <r_battle_generic_tmp_index_lo                                          ; $02CFDE | | TODO: Is this necessary or was it set already when the action
    LDA r_battle_current_action_details.action_flags.w                          ; $02CFE0 | |       flags were originally set.
    ORA <r_battle_generic_tmp_index_lo                                          ; $02CFE3 | |
    STA r_battle_current_action_details.action_flags.w                          ; $02CFE5 |/
    LDA r_battle_current_action_details.actor_flags.w                           ; $02CFE8 |\ Branch to separate code if the actor is a monster.
    BMI @monster_actor                                                          ; $02CFEB |/
    JSR _battle_get_current_actor_visual_properties_offset                      ; $02CFED |\
-   LDA r_battle_character_visual_properties.1.x.w,X                            ; $02CFF0 | | Wait until the character is in the acting position.
    CMP #BATTLE_COORDINATE_X_PARTY_ACTING.b                                     ; $02CFF3 | |
    BNE -                                                                       ; $02CFF5 |/
    LDA r_battle_animate_physical_special_mode.w                                ; $02CFF7 |\ If a special mode is enabled, don't do any extra processing on the
    BNE ++                                                                      ; $02CFFA |/ item IDs in the hand. Take them for what they are.
    LDA <r_battle_weapon_effect_right_hand                                      ; $02CFFC |\
    CMP #ITEM_FIRST_ARMOR.b                                                     ; $02CFFE | | If the right hand has any item other than a weapon, zero it out.
    BCC +                                                                       ; $02D000 | |
    STZ <r_battle_weapon_effect_right_hand                                      ; $02D002 |/
+   LDA <r_battle_weapon_effect_left_hand                                       ; $02D004 |\
    CMP #ITEM_FIRST_ARMOR.b                                                     ; $02D006 | | If the left hand has any item other than a weapon, zero it out.
    BCC ++                                                                      ; $02D008 | |
    STZ <r_battle_weapon_effect_left_hand                                       ; $02D00A |/
++  JSR _battle_weapon_effect_dispatch                                          ; $02D00C | Dispatch to the correct weapon animation handler.
    JSR _battle_reset_effect_oam_large                                          ; $02D00F | Ensure that the effect OAM is reset.
    JSR _battle_effect_animate_generic_hit                                      ; $02D012 | Animate any necessary hit effects on the characters.
    LDA <r_battle_current_actor_slot                                            ; $02D015 |\ Transfer the actor slot to the X register.
    TAX                                                                         ; $02D017 |/
    TDC                                                                         ; $02D018 |\ Disable any OAM index override for the slot.
    STA r_battle_character_oam_index_override.w,X                               ; $02D019 |/
    STA r_battle_character_pose.w,X                                             ; $02D01C | Reset any pose override for this slot.
    JSR _battle_get_current_actor_visual_properties_offset                      ; $02D01F |\
    LDA #1.b                                                                    ; $02D022 | | Enable automatic pose animation for this slot and return.
    STA r_battle_character_visual_properties.1.animate_pose.w,X                   ; $02D024 | |
    RTS                                                                         ; $02D027 |/
@monster_actor:
    LDA r_formation_flags2_copy_2.w                                             ; $02D028 |\
    AND #FORMATION_FLAGS_2_CHARACTER_SPRITE.b                                   ; $02D02B | | Skip to the last line unless the monster is a character sprite.
    BEQ +                                                                       ; $02D02D |/
    LDA #ITEM_SWORD_BLACK.b                                                     ; $02D02F |\ Load the weapon sprites for the Black sword.
    JSR _battle_load_weapon_visual                                              ; $02D031 |/
    JSR _battle_animate_monster_character_weapon_sprite                         ; $02D034 |\ Animate two sword swings.
    JSR _battle_animate_monster_character_weapon_sprite                         ; $02D037 |/
    LDX #8.w                                                                    ; $02D03A |\ Wait eight frames.
    JSR _battle_wait_x_frames                                                   ; $02D03D |/
    STZ r_battle_weapon_sprite_visible.w                                        ; $02D040 | Unset the weapon sprite visibility.
    JSR _battle_reset_effect_oam_large                                          ; $02D043 | Clear the effect OAM.
    TDC                                                                         ; $02D046 |\ Reset the monster's pose to normal.
    JSR _battle_update_monster_character_tilemap_pose                           ; $02D047 |/
+   JMP _battle_effect_animate_generic_hit                                      ; $02D04A | Animate the actual hit effect.

; _battle_animate_monster_character_weapon_sprite ($02:D04D)
;
; Animates a sword strike by a monster rendered as a character sprite.
_battle_animate_monster_character_weapon_sprite:
    STZ r_battle_load_monster_weapon_sprite_arg_index.w                         ; $02D04D |\ Load the first monster character weapon sprite.
    JSL bank01.battle_load_monster_weapon_sprite.l                              ; $02D050 |/
    LDA #BATTLE_POSE_MONSTER_RAISED_LEFT_ARM.b                                  ; $02D054 |\ Set the monster's pose to a raised left arm.
    JSR _battle_update_monster_character_tilemap_pose                           ; $02D056 |/
    INC r_battle_load_monster_weapon_sprite_arg_index.w                         ; $02D059 |\ Load the second monster character weapon sprite.
    JSL bank01.battle_load_monster_weapon_sprite.l                              ; $02D05C |/
    LDA #BATTLE_POSE_MONSTER_FORWARD_LEFT_ARM.b                                 ; $02D060 |\ Set the monster's pose to forward left arm.
    JSR _battle_update_monster_character_tilemap_pose                           ; $02D062 |/
    RTS                                                                         ; $02D065

; _battle_effect_spell_animate_reeling ($02:D066)
;
; Proxy function to call the related function in another bank.
_battle_effect_spell_animate_reeling:
    JSL bank01.battle_effect_spell_animate_reeling                              ; $02D066
    RTS                                                                         ; $02D06A

; _battle_effect_animate_generic_hit ($02:D06B)
;
; Handles the reeling part of characters being hit as well as the effect when
; a monster punches another monster. Also handles the Cover animation.
_battle_effect_animate_generic_hit:
    LDA r_battle_current_action_details.target_flags.w                          ; $02D06B |\ Skip to different code if the target is a monster.
    BMI @monster                                                                ; $02D06E |/
    TDC                                                                         ; $02D070 |\
    TAX                                                                         ; $02D071 | | Search for the corresponding index to the set covered target. The
-   LDA bank16.index_to_target_data.l,X                                         ; $02D072 | | result is the covered slot in the X register.
    CMP r_battle_current_action_details.covered_target.w                        ; $02D076 | |
    BEQ +                                                                       ; $02D079 | |
    INX                                                                         ; $02D07B | |
    CPX #8.w                                                                    ; $02D07C | |
    BNE -                                                                       ; $02D07F |/
    TDC                                                                         ; $02D081 |\ If not found, explicitly set it to zero.
    TAX                                                                         ; $02D082 |/
+   TXA                                                                         ; $02D083 |\ Save the value to to a separate variable.
    STA r_battle_effect_tmp_covered_slot.w                                      ; $02D084 |/
    STZ <r_battle_monster_effect_counter                                        ; $02D087 | Initialize the effect counter to zero.
    LDA r_battle_current_action_details.action_flags.w                          ; $02D089 |\
    AND #BATTLE_ACTION_DETAILS_ACTION_FLAG_MISS.b                               ; $02D08C | | If the action was not a miss, play the generic hit sound effect
    BNE +                                                                       ; $02D08E | | and flash yellow if it was a critical hit.
    LDA #AUDIO_EFFECT_GENERIC_HIT.b                                             ; $02D090 | |
    JSR _battle_play_sound_effect                                               ; $02D092 | |
    JSR _battle_action_flash_yellow_if_critical                                 ; $02D095 |/
+   LDA <r_battle_effect_target_slot                                            ; $02D098 |\
    TAY                                                                         ; $02D09A | | Back up the covering character's current pose.
    LDA r_battle_character_pose.w,Y                                             ; $02D09B | |
    STA r_battle_character_pose_backup.w,Y                                      ; $02D09E |/
-   JSR _battle_wait_next_frame_preserve_x_y                                    ; $02D0A1 | Wait for the next frame.
    JSR _battle_effect_set_character_hit_pose                                   ; $02D0A4 | Set either the reeling or covering pose, as appropriate.
    JSR _battle_get_effect_target_visual_properties_offset                      ; $02D0A7 |\
    LDA r_battle_current_action_details.action_flags.w                          ; $02D0AA | | If the hit wasn't a miss, set the target's X offset as follows:
    AND #BATTLE_ACTION_DETAILS_ACTION_FLAG_MISS.b                               ; $02D0AD | | The base value is either zero, in most cases, or if it was a
    BNE +                                                                       ; $02D0AF | | critical hit, 16. Beyond that, either 0 or 4 is added depending on
    LDA r_battle_current_action_details.action_flags.w                          ; $02D0B1 | | the current frame. The value changes every 4 frames.
    AND #BATTLE_ACTION_DETAILS_ACTION_FLAG_CRITICAL.b                           ; $02D0B4 | |
    ASL A                                                                       ; $02D0B6 | |
    ASL A                                                                       ; $02D0B7 | |
    STA <r_battle_generic_tmp_index_lo                                          ; $02D0B8 | |
    LDA <r_battle_monster_effect_counter                                        ; $02D0BA | |
    AND #%00000100.b                                                            ; $02D0BC | |
    EOR #%00000100.b                                                            ; $02D0BE | |
    CLC                                                                         ; $02D0C0 | |
    ADC <r_battle_generic_tmp_index_lo                                          ; $02D0C1 | |
    STA r_battle_character_visual_properties.1.x_offset.w,X                     ; $02D0C3 |/
+   INC <r_battle_monster_effect_counter                                        ; $02D0C6 |\
    LDA <r_battle_monster_effect_counter                                        ; $02D0C8 | | Increment the frame counter and loop until sixteen frames have
    CMP #16.b                                                                   ; $02D0CA | | passed.
    BNE -                                                                       ; $02D0CC |/
    TDC                                                                         ; $02D0CE |\ Set the target's X offset to zero.
    STA r_battle_character_visual_properties.1.x_offset.w,X                     ; $02D0CF |/
    LDA <r_battle_effect_target_slot                                            ; $02D0D2 |\
    TAY                                                                         ; $02D0D4 | | Restore the target's original pose.
    LDA r_battle_character_pose_backup.w,Y                                      ; $02D0D5 | |
    STA r_battle_character_pose.w,Y                                             ; $02D0D8 |/
    LDA <r_battle_effect_target_slot                                            ; $02D0DB |\
    TAX                                                                         ; $02D0DD | | Restore the target's original X and Y position, in case they were
    TDC                                                                         ; $02D0DE | | covering.
    STA r_battle_character_sprite_x_override.w,X                                ; $02D0DF | |
    STA r_battle_character_sprite_y_override.w,X                                ; $02D0E2 | |
    RTS                                                                         ; $02D0E5 |/
@monster:
    LDA r_battle_current_action_details.actor_flags.w                           ; $02D0E6 |\ Skip this code if the actor is not also a monster.
    BPL +                                                                       ; $02D0E9 |/
    LDA r_battle_current_action_details.action_flags.w                          ; $02D0EB |\
    AND #BATTLE_ACTION_DETAILS_ACTION_FLAG_MISS.b                               ; $02D0EE | | Skip this code if the attack was a miss.
    BNE +                                                                       ; $02D0F0 |/
    JSR _battle_reset_effect_oam_large                                          ; $02D0F2 | Reset the effect OAM to large sprites.
    TDC                                                                         ; $02D0F5 |\ Load the weapon sprites for a fist.
    JSR _battle_load_weapon_visual                                              ; $02D0F6 |/
    LDA #8.b                                                                    ; $02D0F9 |\ Explictly set the number of hits to eight, regardless of how many
    STA r_battle_current_action_details.action.w                                ; $02D0FB |/ there actually were.
    LDA #AUDIO_EFFECT_PUNCH.b                                                   ; $02D0FE |\ Animate the multiple hits using the punch sound effect.
    JSR _battle_weapon_effect_animate_multiple_hit                              ; $02D100 |/
+   RTS                                                                         ; $02D103

; _battle_effect_set_character_hit_pose ($02:D104)
;
; When a character is hit, sets their pose to the reeling pose. This routine
; also handles any associated Cover animation.
_battle_effect_set_character_hit_pose:
    LDA r_battle_current_action_details.covered_target.w                        ; $02D104 |\ Skip ahead if there is no covered target.
    BEQ +                                                                       ; $02D107 |/
    LDA <r_battle_effect_target_slot                                            ; $02D109 |\ Transfer the actual target slot to the X register.
    TAX                                                                         ; $02D10B |/
    LDA r_battle_effect_tmp_covered_slot.w                                      ; $02D10C |\
    ASL A                                                                       ; $02D10F | | Calculate the visual properties offset for the covered slot and
    ASL A                                                                       ; $02D110 | | transfer it to the Y register.
    ASL A                                                                       ; $02D111 | |
    ASL A                                                                       ; $02D112 | |
    TAY                                                                         ; $02D113 |/
    LDA r_battle_character_visual_properties.1.x.w,Y                            ; $02D114 |\
    SEC                                                                         ; $02D117 | | The coordinates override for the covering character (the actual
    SBC #16.b                                                                   ; $02D118 | | target) to place them 16 pixels to the left of the original target
    STA r_battle_character_sprite_x_override.w,X                                ; $02D11A | | (the covered character).
    LDA r_battle_character_visual_properties.1.y.w,Y                            ; $02D11D | |
    STA r_battle_character_sprite_y_override.w,X                                ; $02D120 |/
    LDA <r_battle_effect_target_slot                                            ; $02D123 |\
    TAY                                                                         ; $02D125 | | Set the covering character's pose to their special pose and
    LDA #BATTLE_POSE_SPECIAL.b                                                  ; $02D126 | | return.
    STA r_battle_character_pose.w,Y                                             ; $02D128 | |
    RTS                                                                         ; $02D12B |/
+   LDA r_battle_current_action_details.action_flags.w                          ; $02D12C |\
    AND #BATTLE_ACTION_DETAILS_ACTION_FLAG_MISS.b                               ; $02D12F | | If there is no covered target, then cover isn't happening. If the
    BNE +                                                                       ; $02D131 | | hit wasn't a miss, set the target's pose to their reeling pose.
    LDA <r_battle_effect_target_slot                                            ; $02D133 | |
    TAY                                                                         ; $02D135 | |
    LDA #BATTLE_POSE_REELING.b                                                  ; $02D136 | |
    STA r_battle_character_pose.w,Y                                             ; $02D138 |/
+   RTS                                                                         ; $02D13B

; _battle_weapon_effect_dispatch ($02:D13C)
;
; Given the currently being processed actor and action, animates the visual
; effect for the weapon or weapons used by that character.
_battle_weapon_effect_dispatch:
    LDA <r_battle_current_actor_slot                                            ; $02D13C |\
    ASL A                                                                       ; $02D13E | | Set the X register to the offset to the slot's visual status data.
    ASL A                                                                       ; $02D13F | |
    TAX                                                                         ; $02D140 |/
    LDA r_character_visual_status.1.status_1.w,X                                ; $02D141 |\
    AND #(STATUS_1_TOAD | STATUS_1_SMALL).b                                     ; $02D144 | | If the character is either a toad or small, unset both the left
    BEQ +                                                                       ; $02D146 | | and right hand weapons, to simply animate the fist effect.
    TDC                                                                         ; $02D148 | |
    TAX                                                                         ; $02D149 | |
    STX <r_battle_weapon_effect_right_hand                                      ; $02D14A |/
+   STZ r_battle_weapon_effect_charmed.w                                        ; $02D14C |\
    LDA r_character_visual_status.1.status_2.w,X                                ; $02D14F | | Set a variable that indicates whether or not the character was
    AND #STATUS_2_CHARM.b                                                       ; $02D152 | | charmed (used for reversing certain aspects of the animation).
    BEQ +                                                                       ; $02D154 | |
    INC r_battle_weapon_effect_charmed.w                                        ; $02D156 |/
+   STZ <r_battle_weapon_effect_hand                                            ; $02D159 | Initially set the hand being used to the right hand.
-   LDA <r_battle_weapon_effect_hand                                            ; $02D15B |\
    TAX                                                                         ; $02D15D | | Load the weapon ID for the weapon in the current hand.
    LDA <r_battle_weapon_effect_right_hand,X                                    ; $02D15E |/
    JSR _battle_set_x_to_4a                                                     ; $02D160 |\
    LDA bank0F.battle_weapon_visual_data.l + weapon_visual.effect,X             ; $02D163 | | Load the pointer to that weapon's visual effect.
    ASL A                                                                       ; $02D167 | |
    TAX                                                                         ; $02D168 | |
    LDA battle_weapon_effect_pointer_data.l + 0,X                               ; $02D169 | |
    STA <r_battle_generic_tmp_ptr_2_addr_lo                                     ; $02D16D | |
    LDA battle_weapon_effect_pointer_data.l + 1,X                               ; $02D16F | |
    STA <r_battle_generic_tmp_ptr_2_addr_hi                                     ; $02D173 |/
    JSR _battle_weapon_effect_execute_handler                                   ; $02D175 | Execute the handler.
    JSR _battle_reset_effect_oam_large                                          ; $02D178 | Reset the effect OAM to large sprites.
    INC <r_battle_weapon_effect_hand                                            ; $02D17B |\
    LDA <r_battle_weapon_effect_hand                                            ; $02D17D | | Increment the hand and loop until both hands have been handled.
    CMP #2.b                                                                    ; $02D17F | |
    BNE -                                                                       ; $02D181 |/
    RTS                                                                         ; $02D183

; _battle_weapon_effect_execute_handler ($02:D184)
;
; Given a 16-bit pointer to a weapon effect handler in $00, jumps to that
; handler.
_battle_weapon_effect_execute_handler:
    JMP (r_battle_generic_tmp_ptr_2_addr.w)                                     ; $02D184 | Jump to the passed pointer.

; battle_weapon_effect_pointer_data ($02:D187)
;
; For each weapon effect, contains the pointer to the handler for that effect.
battle_weapon_effect_pointer_data:
    .addr _battle_weapon_effect_fists                                           ; $02D187.D188 | $00: Fists
    .addr _battle_weapon_effect_slash                                           ; $02D189.D18A | $01: Swords and certain other weapons
    .addr _battle_weapon_effect_staff_rod                                       ; $02D18B.D18C | $02: Staves and Rods
    .addr _battle_weapon_effect_single_fist                                     ; $02D18D.D18E | $03: Claws
    .addr _battle_weapon_effect_bow                                             ; $02D18F.D190 | $04: Bows
    .addr _battle_weapon_effect_arrow                                           ; $02D191.D192 | $05: Arrows
    .addr _battle_weapon_effect_shuriken                                        ; $02D193.D194 | $06: Shurikens
    .addr _battle_weapon_effect_boomerang                                       ; $02D195.D196 | $07: Dwarf Axe/Boomrang
    .addr _battle_weapon_effect_fullmoon                                        ; $02D197.D198 | $08: FullMoon
    .addr _battle_weapon_effect_harp                                            ; $02D199.D19A | $09: Harps
    .addr _battle_weapon_effect_whip                                            ; $02D19B.D19C | $0A: Whips
    .addr _battle_weapon_effect_hammer                                          ; $02D19D.D19E | $0B: Hammers

; _battle_weapon_effect_shuriken ($02:D19F)
;
; Animates the weapon effect used by Shurikens.
_battle_weapon_effect_shuriken:
    STZ r_battle_weapon_effect_double_sprite.w                                  ; $02D19F | Unset the weapon double sprite flag.
    LDA <r_battle_weapon_effect_hand                                            ; $02D1A2 |\
    BNE +                                                                       ; $02D1A4 | | Depending on which hand is being processed, call the appropriate
    JSR _battle_weapon_effect_animate_right_arm_throw                           ; $02D1A6 | | throw animation handler.
    BRA ++                                                                      ; $02D1A9 | |
+   JSR _battle_weapon_effect_animate_left_arm_throw                            ; $02D1AB |/
++  JSR _battle_get_current_actor_visual_properties_offset                      ; $02D1AE | Set the X register to the visual properties offset.
    STZ r_battle_character_visual_properties.1.animate_pose.w,X                 ; $02D1B1 | Disable automatic pose animation.
    LDA r_battle_character_visual_properties.1.x.w,X                            ; $02D1B4 |\
    CLC                                                                         ; $02D1B7 | | Set the projectile source X coordinate to the character's X
    ADC r_battle_character_visual_properties.1.x_offset.w,X                     ; $02D1B8 | | coordinate plus their X offset minus eight.
    SEC                                                                         ; $02D1BB | |
    SBC #8.b                                                                    ; $02D1BC | |
    STA r_battle_effect_projectile_source_coordinates.x.w                       ; $02D1BE |/
    LDA r_battle_character_visual_properties.1.y.w,X                            ; $02D1C1 |\
    CLC                                                                         ; $02D1C4 | | Set the projectile source Y coordinate to the character's Y
    ADC r_battle_character_visual_properties.1.y_offset.w,X                     ; $02D1C5 | | coordinate plus their Y offset.
    STA r_battle_effect_projectile_source_coordinates.y.w                       ; $02D1C8 |/
    LDA #8.b                                                                    ; $02D1CB |\ Set the projectile horizontal rate to 8 pixels per frame.
    STA r_battle_effect_projectile_horizontal_rate.w                            ; $02D1CD |/
    LDA <r_battle_effect_target_slot                                            ; $02D1D0 |\
    ASL A                                                                       ; $02D1D2 | | Set the projectile target coordinates to the center coordinates of
    TAY                                                                         ; $02D1D3 | | the target monster.
    LDA r_battle_monster_coordinates_center.1.x.w,Y                             ; $02D1D4 | |
    STA r_battle_effect_projectile_target_coordinates.x.w                       ; $02D1D7 | |
    LDA r_battle_monster_coordinates_center.1.y.w,Y                             ; $02D1DA | |
    STA r_battle_effect_projectile_target_coordinates.y.w                       ; $02D1DD |/
    JSR _battle_effect_projectile_initialize                                    ; $02D1E0 | Initialize the projectile coordinates data.
    JSR _battle_reset_effect_oam_large                                          ; $02D1E3 | Reset the effect OAM to large sprites.
    STZ <r_battle_weapon_effect_frame_counter                                   ; $02D1E6 | Reset the effect frame counter to zero.
@start:
    JSR _battle_wait_next_frame_preserve_x_y                                    ; $02D1E8 | Wait for the next frame.
    TDC                                                                         ; $02D1EB |\ Set the weapon effect parameters to always use the first OAM entry.
    JSR _battle_set_weapon_effect_parameters_single_tile                        ; $02D1EC |/
    LDA <r_battle_weapon_effect_frame_counter                                   ; $02D1EF |\
    AND #%00000001.b                                                            ; $02D1F1 | | Set the base tile to alternate between $80 and $82 every frame.
    ASL A                                                                       ; $02D1F3 | |
    CLC                                                                         ; $02D1F4 | |
    ADC #$80.b                                                                  ; $02D1F5 | |
    STA r_battle_effect_sprites_base_tile.w                                     ; $02D1F7 |/
    JSR _battle_effect_projectile_update_coordinates                            ; $02D1FA |\ Update the current projectile coordinates and branch ahead to the
    BCS ++                                                                      ; $02D1FD |/ end if the last frame is complete.
    LDA r_battle_effect_projectile_coordinates.x.w                              ; $02D1FF |\
    CLC                                                                         ; $02D202 | | Set the sprite coordinates by adding 24 to each of the projectile
    ADC #24.b                                                                   ; $02D203 | | coordinates, as the expected sprite coordinates are the center of
    STA r_battle_effect_sprites_coordinates.x.w                                 ; $02D205 | | a 6x6 grid.
    LDA r_battle_effect_projectile_coordinates.y.w                              ; $02D208 | |
    CLC                                                                         ; $02D20B | |
    ADC #24.b                                                                   ; $02D20C | |
    STA r_battle_effect_sprites_coordinates.y.w                                 ; $02D20E |/
    LDA r_battle_current_action_details.target_flags.w                          ; $02D211 |\
    BPL +                                                                       ; $02D214 | | If the target is a monster, flag the sprites as pending.
    INC r_battle_effect_sprites_pending.w                                       ; $02D216 |/
+   INC <r_battle_weapon_effect_frame_counter                                   ; $02D219 |\ Increment the frame counter and loop back to the next iteration.
    JMP @start                                                                  ; $02D21B |/
++  LDA r_battle_current_action_details.target_flags.w                          ; $02D21E |\
    BPL +                                                                       ; $02D221 | | If the target is a monster and the attack didn't miss, set the
    LDA r_battle_current_action_details.action_flags.w                          ; $02D223 | | base tile to $A0, flag the sprites as pending, and call a routine
    AND #BATTLE_ACTION_DETAILS_ACTION_FLAG_MISS.b                               ; $02D226 | | to animate the projectile hit effect.
    BNE +                                                                       ; $02D228 | |
    LDA #$A0.b                                                                  ; $02D22A | |
    STA r_battle_effect_sprites_base_tile.w                                     ; $02D22C | |
    INC r_battle_effect_sprites_pending.w                                       ; $02D22F | |
    JSR _battle_weapon_effect_projectile_hit_arrow_shuriken                     ; $02D232 |/
+   RTS                                                                         ; $02D235

; _unused_battle_effect_projectile_reverse_coordinates ($02:D236)
;
; Unused function to reverse the source and target coordinates in $F111 and
; $F113 used by the projectile effects.
_unused_battle_effect_projectile_reverse_coordinates:
    LDX r_battle_effect_projectile_source_coordinates.w                         ; $02D236 |\
    PHX                                                                         ; $02D239 | | Flip the source and target coordinates.
    LDX r_battle_effect_projectile_target_coordinates.w                         ; $02D23A | |
    STX r_battle_effect_projectile_source_coordinates.w                         ; $02D23D | |
    PLX                                                                         ; $02D240 | |
    STX r_battle_effect_projectile_target_coordinates.w                         ; $02D241 |/
    RTS                                                                         ; $02D244

; _battle_weapon_effect_boomerang ($02:D245)
;
; Animates the Boomrang/Dwarf axe weapon effect, which has a weapon travel in
; an ellipse, striking the target, and then returning to the character. Falls
; through to the next function.
_battle_weapon_effect_boomerang:
    STZ r_battle_weapon_effect_double_sprite.w                                  ; $02D245 | Reset the weapon double sprite flag.
    LDA <r_battle_weapon_effect_hand                                            ; $02D248 |\
    BNE +                                                                       ; $02D24A | | Animate either the left arm or the right arm throwing animation,
    JSR _battle_weapon_effect_animate_right_arm_throw                           ; $02D24C | | depending on the hand being processed.
    BRA _battle_weapon_effect_animate_boomerang                                 ; $02D24F | |
+   JSR _battle_weapon_effect_animate_left_arm_throw                            ; $02D251 |/

; _battle_weapon_effect_animate_boomerang ($02:D254)
;
; Common routine to handle both the single sprite and double sprite variants of
; boomerang weapons.
_battle_weapon_effect_animate_boomerang:
    LDA r_battle_current_action_details.target_flags.w                          ; $02D254 |\
    BMI +                                                                       ; $02D257 | | Skip the remainder of the function if not targeting a monster.
    RTS                                                                         ; $02D259 |/
+   STZ r_unknown_f234.w                                                        ; $02D25A | TODO: Zero out an unknown variable.
    JSR _battle_get_current_actor_visual_properties_offset                      ; $02D25D | Set the X register to the visual properties offset.
    STZ r_battle_character_visual_properties.1.animate_pose.w,X                 ; $02D260 | Disable automatic pose animation.
    LDA r_battle_character_visual_properties.1.x.w,X                            ; $02D263 |\
    CLC                                                                         ; $02D266 | | Set the projectile source X coordinate to the X coordinate of the
    ADC r_battle_character_visual_properties.1.x_offset.w,X                     ; $02D267 | | character plus their X offset minus 16.
    SEC                                                                         ; $02D26A | |
    SBC #16.b                                                                   ; $02D26B | |
    STA r_battle_effect_projectile_source_coordinates.x.w                       ; $02D26D |/
    LDA r_battle_character_visual_properties.1.y.w,X                            ; $02D270 |\
    CLC                                                                         ; $02D273 | | Set the projectile source Y coordinate to the Y coordinate of the
    ADC r_battle_character_visual_properties.1.y_offset.w,X                     ; $02D274 | | character plus their Y offset.
    STA r_battle_effect_projectile_source_coordinates.y.w                       ; $02D277 |/
    LDA #8.b                                                                    ; $02D27A |\ Set the horizontal projectile rate to 8 pixels per frame.
    STA r_battle_effect_projectile_horizontal_rate.w                            ; $02D27C |/
    LDA <r_battle_effect_target_slot                                            ; $02D27F |\
    ASL A                                                                       ; $02D281 | | Set the projectile target coordinates to the monster center
    TAY                                                                         ; $02D282 | | coordinates minus eight.
    LDA r_battle_monster_coordinates_center.1.x.w,Y                             ; $02D283 | |
    SEC                                                                         ; $02D286 | |
    SBC #8.b                                                                    ; $02D287 | |
    STA r_battle_effect_projectile_target_coordinates.x.w                       ; $02D289 | |
    LDA r_battle_monster_coordinates_center.1.y.w,Y                             ; $02D28C | |
    SEC                                                                         ; $02D28F | |
    SBC #8.b                                                                    ; $02D290 | |
    STA r_battle_effect_projectile_target_coordinates.y.w                       ; $02D292 |/
    JSR _battle_effect_projectile_initialize                                    ; $02D295 | Initialize the projectile coordinates.
    JSR _battle_reset_effect_oam_large                                          ; $02D298 | Reset the effect OAM to large sprites.
    STZ <r_battle_weapon_effect_frame_counter                                   ; $02D29B | Set the weapon effect frame counter to zero.
    LDA #AUDIO_EFFECT_BOOMERANG.b                                               ; $02D29D |\ Play the boomerang sound effect.
    JSR _battle_play_sound_effect                                               ; $02D29F |/
    JSR _battle_weapon_effect_animate_boomerang_upper                           ; $02D2A2 | Animate the upper portion of the curve.
    JSR _battle_weapon_effect_boomerang_draw_slash                              ; $02D2A5 | Draw the slash at the target.
    LDX r_battle_effect_projectile_source_coordinates.w                         ; $02D2A8 |\
    PHX                                                                         ; $02D2AB | | Swap the source and target coordinates.
    LDX r_battle_effect_projectile_target_coordinates.w                         ; $02D2AC | |
    STX r_battle_effect_projectile_source_coordinates.w                         ; $02D2AF | |
    PLX                                                                         ; $02D2B2 | |
    STX r_battle_effect_projectile_target_coordinates.w                         ; $02D2B3 |/
    LDA #8.b                                                                    ; $02D2B6 |\ Set the horizontal rate to 8 pixels per frame, not that it changed.
    STA r_battle_effect_projectile_horizontal_rate.w                            ; $02D2B8 |/
    JSR _battle_effect_projectile_initialize                                    ; $02D2BB | Initialize the projectile variables.
    JSR _battle_weapon_effect_animate_boomerang_lower                           ; $02D2BE | Animate the lower portion of the curve.
    JMP _battle_reset_effect_oam_large                                          ; $02D2C1 | Reset the effect OAM to large sprites and return.

; _battle_weapon_effect_animate_boomerang_* ($02:D2C4)
;
; Animates the middle portion of the effect used by the Boomrang and Dwarf axe,
; which has the weapon fly through the air in an elliptical curve. The lower
; variant draws the curve below the straight line, and the upper variant draws
; the curve above the straight line.
_battle_weapon_effect_animate_boomerang_lower:
    LDA #1.b                                                                    ; $02D2C4 |\ Enable the vertical inversion flag.
    STA r_battle_effect_boomerang_invert_vertical.w                             ; $02D2C6 |/
    BRA _battle_weapon_effect_animate_boomerang_common                          ; $02D2C9 | Branch to the common code.
_battle_weapon_effect_animate_boomerang_upper:
    STZ r_battle_effect_boomerang_invert_vertical.w                             ; $02D2CB | Disable the vertical inversion flag.
_battle_weapon_effect_animate_boomerang_common:
    JSL battle_weapon_effect_boomerang_initialize                               ; $02D2CE | Initialize some boomerang effect variables.
@start:
    JSR _battle_wait_next_frame_preserve_x_y                                    ; $02D2D2 | Wait for the next frame.
    LDA #16.b                                                                   ; $02D2D5 |\ Set the effect sprites base OAM index to 16.
    STA r_battle_effect_sprites_base_oam_index.w                                ; $02D2D7 |/
    LDA #BATTLE_EFFECT_PATTERN_SINGLE_TILE.b                                    ; $02D2DA |\ Set the effect pattern to the single tile pattern.
    STA r_battle_effect_sprites_pattern_index.w                                 ; $02D2DC |/
    LDA #EFFECT_OAM_RESET_MODE_NONE.b                                           ; $02D2DF |\ Disable resetting the effect OAM.
    STA r_battle_effect_sprites_reset_mode.w                                    ; $02D2E1 |/
    INC <r_battle_weapon_effect_frame_counter                                   ; $02D2E4 | Increment the weapon effect frame counter.
    LDA <r_battle_weapon_effect_frame_counter                                   ; $02D2E6 |\
    AND #%00000110.b                                                            ; $02D2E8 | | Calculate the index into the frame properties data in such a way
    LSR A                                                                       ; $02D2EA | | that it has four states, updating once every other frame.
    TAX                                                                         ; $02D2EB |/
    LDA bank16.battle_weapon_effect_boomerang_frame_tile_data.l,X               ; $02D2EC |\ Set the base tile for this frame.
    STA r_battle_effect_sprites_base_tile.w                                     ; $02D2F0 |/
    LDA r_battle_weapon_effect_double_sprite.w                                  ; $02D2F3 |\
    BNE +                                                                       ; $02D2F6 | | Set the tile flags based on the frame and if the weapon has two
    LDA bank16.battle_weapon_effect_boomerang_single_tile_flags_data.l,X        ; $02D2F8 | | tiles or not.
    BRA ++                                                                      ; $02D2FC | |
+   LDA bank16.battle_weapon_effect_boomerang_double_tile_flags_data.l,X        ; $02D2FE | |
++  STA r_battle_effect_sprites_tile_flags.w                                    ; $02D302 |/
    JSR _battle_effect_projectile_update_coordinates                            ; $02D305 |\ Update the basic projectile coordinates and branch ahead to the end
    BCS @done                                                                   ; $02D308 |/ if the last frame has completed.
    JSL battle_weapon_effect_boomerang_calculate_vertical_offset                ; $02D30A | Update the vertical offset value for this frame.
    LDA r_battle_effect_projectile_coordinates.x.w                              ; $02D30E |\
    STA r_battle_effect_boomerang_coordinates.x.w                               ; $02D311 | | Copy the calculated straight-line projectile X coordinate into
    CLC                                                                         ; $02D314 | | another variable, and then add 24 and save that as the effect
    ADC #24.b                                                                   ; $02D315 | | sprite X coordinate (targeting the center of a 6x6 grid).
    STA r_battle_effect_sprites_coordinates.x.w                                 ; $02D317 |/
    LDA r_battle_effect_boomerang_invert_vertical.w                             ; $02D31A |\
    BNE +                                                                       ; $02D31D | | If not inverting the vertical, copy the projectile Y coordinate to
    LDA r_battle_effect_projectile_coordinates.y.w                              ; $02D31F | | another variable, and then subtract the vertical offset calculated
    STA r_battle_effect_boomerang_coordinates.y.w                               ; $02D322 | | above.
    SEC                                                                         ; $02D325 | |
    SBC <r_math_multiply_8bit_result_hi                                         ; $02D326 | |
    BRA ++                                                                      ; $02D328 |/
+   LDA r_battle_effect_projectile_coordinates.y.w                              ; $02D32A |\
    STA r_battle_effect_boomerang_coordinates.y.w                               ; $02D32D | | If inverting, copy the projectile coordinate, and then add the
    CLC                                                                         ; $02D330 | | vertical offset instead.
    ADC <r_math_multiply_8bit_result_hi                                         ; $02D331 |/
++  CLC                                                                         ; $02D333 |\
    ADC #$18.b                                                                  ; $02D334 | | Either way, add 24 and then set the sprite coordinate.
    STA r_battle_effect_sprites_coordinates.y.w                                 ; $02D336 |/
    INC r_battle_effect_sprites_pending.w                                       ; $02D339 | Flag the sprites as pending to be drawn.
    JMP @start                                                                  ; $02D33C | Loop back to the start of the loop.
@done:
    RTS                                                                         ; $02D33F

; _battle_weapon_effect_boomerang_draw_slash ($02:D340)
;
; Draws the slash effect for the Boomrang/Dwarf axe effect, a simple slash at
; the target coordinates.
_battle_weapon_effect_boomerang_draw_slash:
    LDA r_battle_current_action_details.action_flags.w                          ; $02D340 |\
    AND #BATTLE_ACTION_DETAILS_ACTION_FLAG_MISS.b                               ; $02D343 | | Skip this function if the attack was a miss.
    BNE +                                                                       ; $02D345 |/
    LDX r_battle_effect_projectile_target_coordinates.w                         ; $02D347 |\ Set the coordinates of the sprite to the target coordinates.
    STX r_oam.18.x.w                                                            ; $02D34A |/
    LDA #$A0.b                                                                  ; $02D34D |\ Set the sprite tile number to $A0 (where the slash effect is
    STA r_oam.18.tile.w                                                         ; $02D34F |/ loaded).
    LDA #%00111111.b                                                            ; $02D352 |\ Set the tile flags to priority 3, palette 7, using the high name
    STA r_oam.18.flags.w                                                        ; $02D354 |/ table.
    LDA r_formation_back_attack_copy.w                                          ; $02D357 |\
    BEQ +                                                                       ; $02D35A | | If this is a back attack, change the flags to include the
    LDA #%01111111.b                                                            ; $02D35C | | horizontal flip bit, and flip the X coordinate bits and subtract
    STA r_oam.18.flags.w                                                        ; $02D35E | | eight.
    LDA r_battle_effect_projectile_target_coordinates.x.w                       ; $02D361 | |
    EOR #%11111111.b                                                            ; $02D364 | |
    SEC                                                                         ; $02D366 | |
    SBC #8.b                                                                    ; $02D367 | |
    STA r_oam.18.x.w                                                            ; $02D369 |/
+   RTS                                                                         ; $02D36C

; _battle_weapon_effect_fullmoon ($02:D36D)
;
; Animates the weapon effect used the FullMoon, which primarily differs from the
; Boomrang effect because the FullMoon sprite cannot be flipped horizontally.
_battle_weapon_effect_fullmoon:
    LDA #1.b                                                                    ; $02D36D |\ Set the double sprite flag.
    STA r_battle_weapon_effect_double_sprite.w                                  ; $02D36F |/
    LDA <r_battle_weapon_effect_hand                                            ; $02D372 |\
    BNE +                                                                       ; $02D374 | | Animate either the left or right arm throwing, depending on the
    JSR _battle_weapon_effect_animate_right_arm_throw                           ; $02D376 | | hand being processed.
    BRA ++                                                                      ; $02D379 | |
+   JSR _battle_weapon_effect_animate_left_arm_throw                            ; $02D37B |/
++  JMP _battle_weapon_effect_animate_boomerang                                 ; $02D37E | Jump to animate the boomerang effect.

; _battle_weapon_effect_animate_throw ($02:D381)
;
; Animates the initial part of throwing a weapon, which displays the character
; holding the weapon.
_battle_weapon_effect_animate_throw:
    STA r_battle_weapon_sprite_tmp_oam_offset.w                                 ; $02D381 | Save the parameter OAM offset into a temporary variable.
    JSR _battle_get_current_actor_visual_properties_offset                      ; $02D384 |\
    STZ r_battle_character_visual_properties.1.animate_pose.w,X                 ; $02D387 | | Disable pose animation and set the pose frame counter to zero.
    STZ r_battle_character_visual_properties.1.pose_frame_counter.w,X           ; $02D38A |/
    LDA #5.b                                                                    ; $02D38D |\ Initialize the frames remaining value to five.
    STA <r_battle_weapon_effect_frames_remaining                                ; $02D38F |/
    LDA #AUDIO_EFFECT_DART.b                                                    ; $02D391 |\ Play the Dart sound effect.
    JSR _battle_play_sound_effect                                               ; $02D393 |/
@start:
    JSR _battle_wait_next_frame_preserve_x_y                                    ; $02D396 | Wait for the next frame.
    JSR _battle_get_current_actor_visual_properties_offset                      ; $02D399 | Set the X register to the visual properties offset for this slot.
    LDA <r_battle_weapon_effect_frame_counter                                   ; $02D39C |\
    AND #%00000001.b                                                            ; $02D39E | | Every other frame, increment the pose frame counter.
    BNE +                                                                       ; $02D3A0 | |
    INC r_battle_character_visual_properties.1.pose_frame_counter.w,X           ; $02D3A2 |/
+   INC <r_battle_weapon_effect_frame_counter                                   ; $02D3A5 | Increment the effect frame counter.
    STX <r_battle_generic_tmp_index                                             ; $02D3A7 | Save the visual properties offset to a temporary variable.
    JSR _battle_load_weapon_sprite_animation_parameters                         ; $02D3A9 | Load the weapon sprite animation parameters.
    LDA r_battle_weapon_effect_double_sprite.w                                  ; $02D3AC |\
    BEQ +++                                                                     ; $02D3AF | | If the weapon is a double sprite weapon, set the tile flags to
    LDA r_battle_weapon_effect_charmed.w                                        ; $02D3B1 | | set the horizontal flip bit if the character is charmed.
    BNE +                                                                       ; $02D3B4 | |
    LDA #%00111111.b                                                            ; $02D3B6 | |
    BRA ++                                                                      ; $02D3B8 | |
+   LDA #%01111111.b                                                            ; $02D3BA | |
++  STA r_battle_weapon_sprite_tile_flags.w                                     ; $02D3BC |/
+++ LDX <r_battle_generic_tmp_index                                             ; $02D3BF | Reload the visual properties offset into the X register.
    LDA r_battle_character_visual_properties.1.x.w,X                            ; $02D3C1 |\
    CLC                                                                         ; $02D3C4 | | Set the sprite X coordinate to the character's X coordinate plus
    ADC r_battle_character_visual_properties.1.x_offset.w,X                     ; $02D3C5 | | their X offset and the sprite X offset.
    ADC r_battle_weapon_sprite_x_offset.w                                       ; $02D3C8 | |
    STA r_battle_weapon_sprite_coordinates.x.w                                  ; $02D3CB |/
    LDA r_battle_character_visual_properties.1.y.w,X                            ; $02D3CE |\
    CLC                                                                         ; $02D3D1 | | Repeat for the Y coordinate.
    ADC r_battle_character_visual_properties.1.y_offset.w,X                     ; $02D3D2 | |
    ADC r_battle_weapon_sprite_y_offset.w                                       ; $02D3D5 | |
    STA r_battle_weapon_sprite_coordinates.y.w                                  ; $02D3D8 |/
    LDA <r_battle_current_actor_slot                                            ; $02D3DB |\
    TAX                                                                         ; $02D3DD | | Set the weapon sprite OAM index to the character's base OAM index
    LDA bank16.battle_character_slot_oam_index_data.l,X                         ; $02D3DE | | plus the provided offset.
    CLC                                                                         ; $02D3E2 | |
    ADC r_battle_weapon_sprite_tmp_oam_offset.w                                 ; $02D3E3 | |
    STA r_battle_weapon_sprite_oam_index.w                                      ; $02D3E6 |/
    INC r_battle_weapon_sprite_visible.w                                        ; $02D3E9 | Set the weapon sprite as visible.
    DEC <r_battle_weapon_effect_frames_remaining                                ; $02D3EC |\ Decrement the number of remaining frames and loop until it reaches
    BNE @start                                                                  ; $02D3EE |/ zero.
    STZ r_battle_weapon_sprite_visible.w                                        ; $02D3F0 | Set the weapon sprite as no longer visible.
    RTS                                                                         ; $02D3F3

; _battle_weapon_effect_harp ($02:D3F4)
;
; Animates the weapon effect used by harp weapons.
_battle_weapon_effect_harp:
    LDA <r_battle_weapon_effect_hand                                            ; $02D3F4 |\
    BNE +                                                                       ; $02D3F6 | | Call the appropriate harp animation function depending on the hand
    JMP _battle_weapon_effect_animate_right_arm_harp                            ; $02D3F8 | | being processed.
+   JMP _battle_weapon_effect_animate_left_arm_harp                             ; $02D3FB |/

; _battle_weapon_effect_animate_harp ($02:D3FE)
;
; Given an OAM offset in the accumulator, animates the harp weapon effect.
_battle_weapon_effect_animate_harp:
    STA r_battle_weapon_sprite_tmp_oam_offset.w                                 ; $02D3FE | Save the parameter as the OAM offset.
    JSR _battle_get_current_actor_visual_properties_offset                      ; $02D401 | Set the X register to the visual properties offset.
    STZ r_battle_character_visual_properties.1.animate_pose.w,X                 ; $02D404 | Disable automatic pose animation.
    LDA #16.b                                                                   ; $02D407 |\ Set the number of remaining frames to 16.
    STA <r_battle_weapon_effect_frames_remaining                                ; $02D409 |/
    LDA r_battle_character_visual_properties.1.x.w,X                            ; $02D40B |\
    CLC                                                                         ; $02D40E | | Set the projectile source X coordinate to the character's X
    ADC r_battle_character_visual_properties.1.x_offset.w,X                     ; $02D40F | | coordinate plus their X offset.
    STA r_battle_effect_projectile_source_coordinates.x.w                       ; $02D412 |/
    LDA r_battle_character_visual_properties.1.y.w,X                            ; $02D415 |\
    CLC                                                                         ; $02D418 | | Set the projectile source Y coordinate to the character's Y
    ADC r_battle_character_visual_properties.1.y_offset.w,X                     ; $02D419 | | coordinate plus their Y offset plus eight.
    CLC                                                                         ; $02D41C | |
    ADC #8.b                                                                    ; $02D41D | |
    STA r_battle_effect_projectile_source_coordinates.y.w                       ; $02D41F |/
    LDA #8.b                                                                    ; $02D422 |\ Set the projectile horizontal rate to eight pixels per frame.
    STA r_battle_effect_projectile_horizontal_rate.w                            ; $02D424 |/
    LDA <r_battle_effect_target_slot                                            ; $02D427 |\
    ASL A                                                                       ; $02D429 | | Set the projectile target X coordinate to the target's center X
    TAY                                                                         ; $02D42A | | coordinate.
    LDA r_battle_monster_coordinates_center.1.x.w,Y                             ; $02D42B | |
    STA r_battle_effect_projectile_target_coordinates.x.w                       ; $02D42E |/
    SEC                                                                         ; $02D431 |\ NOTE: Pointlessly subtract eight. Presumably this was meant to go
    SBC #8.b                                                                    ; $02D432 |/       before the STA.
    LDA r_battle_monster_coordinates_center.1.y.w,Y                             ; $02D434 |\ Set the projectile target Y coordinate to the target's center Y
    STA r_battle_effect_projectile_target_coordinates.y.w                       ; $02D437 |/ coordinate.
    JSR _battle_effect_projectile_initialize                                    ; $02D43A | Initialize the projectile variables.
    LDA r_battle_weapon_sprite_tmp_oam_offset.w                                 ; $02D43D |\
    BEQ +                                                                       ; $02D440 | | Update the projectile coordinates if the OAM offset is non-zero.
    JSR _battle_effect_projectile_update_coordinates                            ; $02D442 |/
+   JSR _battle_reset_effect_oam_large                                          ; $02D445 | Reset the effect OAM to large sprites.
    JSR _battle_effect_initialize_sine_indexes                                  ; $02D448 | Initialize the sine indexes.
    LDA #8.b                                                                    ; $02D44B |\ Initialize the sine magnitude to eight (so it will range from -7 to
    JSR _battle_effect_initialize_sine_magnitude                                ; $02D44D |/ 7).
    LDA #AUDIO_EFFECT_HARP.b                                                    ; $02D450 |\ Play the harp sound effect.
    JSR _battle_play_sound_effect                                               ; $02D452 |/
@start:
    JSR _battle_wait_next_frame_preserve_x_y                                    ; $02D455 | Wait for the next frame.
    INC <r_battle_weapon_effect_frame_counter                                   ; $02D458 | Increment the weapon effect frame counter.
    LDA #16.b                                                                   ; $02D45A |\ Set the effect sprites base OAM index to 16.
    STA r_battle_effect_sprites_base_oam_index.w                                ; $02D45C |/
    LDA #BATTLE_EFFECT_PATTERN_SINGLE_TILE.b                                    ; $02D45F |\ Set the effect pattern to the single tile pattern.
    STA r_battle_effect_sprites_pattern_index.w                                 ; $02D461 |/
    LDA #EFFECT_OAM_RESET_MODE_SHIFT.b                                          ; $02D464 |\ Set the reset mode to shift the sprites back one, leaving the
    STA r_battle_effect_sprites_reset_mode.w                                    ; $02D466 |/ sprite in entry 16 ready for modification.
    LDA <r_battle_weapon_effect_frame_counter                                   ; $02D469 |\
    AND #%00000010.b                                                            ; $02D46B | | Set the base tile to either $A0 or $A2, alternating every two
    CLC                                                                         ; $02D46D | | frames.
    ADC #$A0.b                                                                  ; $02D46E | |
    STA r_battle_effect_sprites_base_tile.w                                     ; $02D470 |/
    LDA #%00111111.b                                                            ; $02D473 |\ Set the tile flags for priority 3, palette 7 and to use the high
    STA r_battle_effect_sprites_tile_flags.w                                    ; $02D475 |/ name table.
    JSR _battle_get_current_actor_visual_properties_offset                      ; $02D478 | Set the X register to the visual properties offset.
    LDA #$80.b                                                                  ; $02D47B |\ Set the weapon sprite tile number to $80.
    STA r_battle_weapon_sprite_tile.w                                           ; $02D47D |/
    LDA #%00111111.b                                                            ; $02D480 |\ Set the weapon sprite tile flags as above.
    STA r_battle_weapon_sprite_tile_flags.w                                     ; $02D482 |/
    LDA r_battle_character_visual_properties.1.x.w,X                            ; $02D485 |\
    CLC                                                                         ; $02D488 | | Set the weapon sprite X coordinate to the character's X coordinate
    ADC r_battle_character_visual_properties.1.x_offset.w,X                     ; $02D489 | | plus their X offset minus four.
    SEC                                                                         ; $02D48C | |
    SBC #4.b                                                                    ; $02D48D | |
    STA r_battle_weapon_sprite_coordinates.x.w                                  ; $02D48F |/
    LDA r_battle_character_visual_properties.1.y.w,X                            ; $02D492 |\
    CLC                                                                         ; $02D495 | | Set the weapon sprite Y coordinate to the character's Y coordinate
    ADC r_battle_character_visual_properties.1.y_offset.w,X                     ; $02D496 | | plus their Y offset.
    STA r_battle_weapon_sprite_coordinates.y.w                                  ; $02D499 |/
    LDA r_battle_weapon_effect_charmed.w                                        ; $02D49C |\
    BEQ +                                                                       ; $02D49F | | If the character is charmed, shift the weapon sprite's X
    LDA r_battle_weapon_sprite_coordinates.x.w                                  ; $02D4A1 | | coordinate to the right by eight, and change the tile flags to add
    CLC                                                                         ; $02D4A4 | | the horizontal flip bit.
    ADC #8.b                                                                    ; $02D4A5 | |
    STA r_battle_weapon_sprite_coordinates.x.w                                  ; $02D4A7 | |
    LDA #%01111111.b                                                            ; $02D4AA | |
    STA r_battle_weapon_sprite_tile_flags.w                                     ; $02D4AC |/
+   LDA <r_battle_current_actor_slot                                            ; $02D4AF |\
    TAX                                                                         ; $02D4B1 | | Set the OAM index by taking the character's base OAM index and
    LDA bank16.battle_character_slot_oam_index_data.l,X                         ; $02D4B2 | | adding the passed OAM offset.
    CLC                                                                         ; $02D4B6 | |
    ADC r_battle_weapon_sprite_tmp_oam_offset.w                                 ; $02D4B7 | |
    STA r_battle_weapon_sprite_oam_index.w                                      ; $02D4BA |/
    DEC <r_battle_weapon_effect_frames_remaining                                ; $02D4BD | Decrement the number of remaining frames.
    JSR _battle_effect_projectile_update_coordinates                            ; $02D4BF |\ Update the calculated projectile coordinates and skip to the end if
    BCS ++                                                                      ; $02D4C2 |/ the last frame has been processed.
    LDA r_battle_effect_projectile_coordinates.x.w                              ; $02D4C4 |\
    CLC                                                                         ; $02D4C7 | | Set the sprite X coordinate by adding 24 to the calculated X
    ADC #24.b                                                                   ; $02D4C8 | | coordinate (to target the center of a 6x6 grid).
    STA r_battle_effect_sprites_coordinates.x.w                                 ; $02D4CA |/
    TDC                                                                         ; $02D4CD |\
    TAX                                                                         ; $02D4CE | | Get the next sine value ranging from -7 to 7 and save it to a
    JSR _battle_effect_get_sine_value                                           ; $02D4CF | | temporary variable.
    STA <r_battle_generic_tmp_index_lo                                          ; $02D4D2 |/
    LDA r_battle_effect_sine_index.w + 0                                        ; $02D4D4 |\
    CLC                                                                         ; $02D4D7 | | Add 16 to the sine index.
    ADC #16.b                                                                   ; $02D4D8 | |
    STA r_battle_effect_sine_index.w + 0                                        ; $02D4DA |/
    LDA r_battle_effect_projectile_coordinates.y.w                              ; $02D4DD |\
    CLC                                                                         ; $02D4E0 | | Set the sprite Y coordinate by taking the projectile Y coordinate,
    ADC #16.b                                                                   ; $02D4E1 | | adding 16, and then adding the calculated sine value.
    ADC <r_battle_generic_tmp_index_lo                                          ; $02D4E3 | |
    STA r_battle_effect_sprites_coordinates.y.w                                 ; $02D4E5 |/
    LDA r_battle_current_action_details.target_flags.w                          ; $02D4E8 |\
    BPL +                                                                       ; $02D4EB | | If the target is a monster, flag the sprites as pending.
    INC r_battle_effect_sprites_pending.w                                       ; $02D4ED |/
+   INC r_battle_weapon_sprite_visible.w                                        ; $02D4F0 | Make the weapon sprite visible.
    JMP @start                                                                  ; $02D4F3 | Jump back to the start of the loop.
++  STZ <r_battle_weapon_effect_frame_counter                                   ; $02D4F6 | Zero out the effect frame counter.
-   LDA r_battle_current_action_details.target_flags.w                          ; $02D4F8 |\
    BPL +                                                                       ; $02D4FB | | Skip this next block if the target is not a monster or if it was a
    LDA r_battle_current_action_details.action_flags.w                          ; $02D4FD | | miss.
    AND #BATTLE_ACTION_DETAILS_ACTION_FLAG_MISS.b                               ; $02D500 | |
    BNE +                                                                       ; $02D502 |/
    INC r_battle_effect_sprites_pending.w                                       ; $02D504 | Flag sprites as pending to be drawn.
    JSR _battle_wait_next_frame_preserve_x_y                                    ; $02D507 | Wait a frame.
    INC r_battle_effect_sprites_pending.w                                       ; $02D50A | Again flag sprites as pending to be drawn.
    INC <r_battle_weapon_effect_frame_counter                                   ; $02D50D | Increment the effect frame counter.
    LDA <r_battle_weapon_effect_frame_counter                                   ; $02D50F |\
    CMP #8.b                                                                    ; $02D511 | | Loop until eight frames have passed.
    BNE -                                                                       ; $02D513 |/
    JSR _battle_weapon_effect_animate_harp_hit                                  ; $02D515 | Animate the harp hitting effect.
+   STZ r_battle_weapon_sprite_visible.w                                        ; $02D518 | Set the weapon sprite as no longer visible.
    JMP _battle_reset_effect_oam_large                                          ; $02D51B | Reset the effect OAM to large sprites and return.

; _battle_set_x_to_4a ($02:D51E)
;
; Given an 8-bit value in the accumulator, multiplies that value by four and
; transfers it to the X register.
_battle_set_x_to_4a:
    REP #FLAG_P_ACCUMULATOR                                                     ; $02D51E |\
    ASL A                                                                       ; $02D520 | | Multiply the value in the accumulator by four and transfer it to
    ASL A                                                                       ; $02D521 | | the X register, clearing the accumulator when done.
    TAX                                                                         ; $02D522 | |
    TDC                                                                         ; $02D523 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $02D524 |/
    RTS                                                                         ; $02D526

; _battle_weapon_effect_bow ($02:D527)
;
; Handles the visual effect for the bow weapon, but only if it's in the right
; hand, with an arrow in the left hand.
_battle_weapon_effect_bow:
    LDA <r_battle_weapon_effect_hand                                            ; $02D527 |\ Skip ahead if processing the left hand.
    BNE +                                                                       ; $02D529 |/
    LDA <r_battle_weapon_effect_right_hand                                      ; $02D52B |\
    JSR _battle_set_x_to_4a                                                     ; $02D52D | | Check that the right hand contains a weapon that uses the bow
    LDA bank0F.battle_weapon_visual_data.l + weapon_visual.effect,X             ; $02D530 | | effect. If not, branch ahead to instead use the fist animation.
    CMP #BATTLE_WEAPON_VISUAL_EFFECT_BOW.b                                      ; $02D534 | |
    BNE _battle_weapon_effect_bow_fists                                         ; $02D536 |/
    LDA <r_battle_weapon_effect_left_hand                                       ; $02D538 |\
    JSR _battle_set_x_to_4a                                                     ; $02D53A | | Check that the left hand contains a weapon that uses the arrow
    LDA bank0F.battle_weapon_visual_data.l + weapon_visual.effect,X             ; $02D53D | | effect. If not, branch ahead to instead use the fist animation.
    CMP #BATTLE_WEAPON_VISUAL_EFFECT_ARROW.b                                    ; $02D541 | |
    BNE _battle_weapon_effect_bow_fists                                         ; $02D543 |/
    JSR _battle_weapon_effect_animate_left_arm_projectile                       ; $02D545 | Animate the projectile effect.
    INC <r_battle_weapon_effect_hand                                            ; $02D548 |\ Increment the hand being processed and return.
    RTS                                                                         ; $02D54A |/
+   LDA <r_battle_weapon_effect_right_hand                                      ; $02D54B |\
    BEQ _battle_weapon_effect_bow_fists                                         ; $02D54D | | If this is the left hand, return if the right hand has a weapon.
    RTS                                                                         ; $02D54F |/
_battle_weapon_effect_bow_fists:
    TDC                                                                         ; $02D550 |\
    STA <r_battle_weapon_effect_right_hand                                      ; $02D551 | | Otherwise, set the weapons to zero and call the fists handler.
    STA <r_battle_weapon_effect_left_hand                                       ; $02D553 | |
    STA <r_battle_weapon_effect_hand                                            ; $02D555 | |
    JMP _battle_weapon_effect_fists                                             ; $02D557 |/

; _battle_weapon_effect_arrow ($02:D55A)
;
; Handles the visual effect for the arrow weapon, but only if it's in the
; right hand, with a bow in the left hand. It's essentially identical to the
; bow code, except reversed.
_battle_weapon_effect_arrow:
    LDA <r_battle_weapon_effect_hand                                            ; $02D55A |\ Skip ahead if processing the left hand.
    BNE +                                                                       ; $02D55C |/
    LDA <r_battle_weapon_effect_right_hand                                      ; $02D55E |\
    JSR _battle_set_x_to_4a                                                     ; $02D560 | | Check that the right hand contains a weapon that uses the arrow
    LDA bank0F.battle_weapon_visual_data.l + weapon_visual.effect,X             ; $02D563 | | effect. If not, branch to the fists code.
    CMP #BATTLE_WEAPON_VISUAL_EFFECT_ARROW.b                                    ; $02D567 | |
    BNE _battle_weapon_effect_bow_fists                                         ; $02D569 |/
    LDA <r_battle_weapon_effect_left_hand                                       ; $02D56B |\
    JSR _battle_set_x_to_4a                                                     ; $02D56D | | Check that the left hand contains a weapon that uses the bow
    LDA bank0F.battle_weapon_visual_data.l + weapon_visual.effect,X             ; $02D570 | | effect. If not, branch to the fists code.
    CMP #BATTLE_WEAPON_VISUAL_EFFECT_BOW.b                                      ; $02D574 | |
    BNE _battle_weapon_effect_bow_fists                                         ; $02D576 |/
    JSR _battle_weapon_effect_animate_right_arm_projectile                      ; $02D578 | Animate the projectile effect.
    INC <r_battle_weapon_effect_hand                                            ; $02D57B |\ Increment the hand being processed and return.
    RTS                                                                         ; $02D57D |/
+   LDA <r_battle_weapon_effect_right_hand                                      ; $02D57E |\
    BEQ _battle_weapon_effect_bow_fists                                         ; $02D580 | | Use the fists code if the right hand has no weapon.
    RTS                                                                         ; $02D582 |/

; _battle_action_flash_yellow_if_critical ($02:D583)
;
; If the current action is a critical hit, sets the flash parameters to generate
; a single yellow flash.
_battle_action_flash_yellow_if_critical:
    LDA r_battle_current_action_details.action_flags.w                          ; $02D583 |\
    AND #BATTLE_ACTION_DETAILS_ACTION_FLAG_CRITICAL.b                           ; $02D586 | | If not a critical hit, skip this function.
    BEQ +                                                                       ; $02D588 |/
    LDA r_battle_flash_mode.w                                                   ; $02D58A |\ If a flash mode is already set, skip this function.
    BNE +                                                                       ; $02D58D |/
    JSL bank01.set_battle_flash_continuous_yellow                               ; $02D58F |\
    LDA #BATTLE_FLASH_MODE_SINGLE.b                                             ; $02D593 | | Set parameters for a single yellow flash.
    STA r_battle_flash_mode.w                                                   ; $02D595 |/
+   RTS                                                                         ; $02D598

; _battle_weapon_effect_animate_projectile ($02:D599)
;
; Animates the effect of a projectile-based weapon such as arrows or shurikens.
_battle_weapon_effect_animate_projectile:
    STA r_battle_weapon_sprite_tmp_oam_offset.w                                 ; $02D599 | Store the passed value as the OAM offset.
    JSR _battle_get_current_actor_visual_properties_offset                      ; $02D59C | Set the X register to the offset to the actor's visual properties.
    STZ r_battle_character_visual_properties.1.animate_pose.w,X                 ; $02D59F | Disable automatic animation of the actor's pose.
    LDA #16.b                                                                   ; $02D5A2 |\ Set the number of remaining frames in the animation to 16.
    STA <r_battle_weapon_effect_frames_remaining                                ; $02D5A4 |/
    LDA r_battle_character_visual_properties.1.x.w,X                            ; $02D5A6 |\
    CLC                                                                         ; $02D5A9 | | Set the projectile source X coordinate to the character X
    ADC r_battle_character_visual_properties.1.x_offset.w,X                     ; $02D5AA | | coordinate plus their X offset.
    STA r_battle_effect_projectile_source_coordinates.x.w                       ; $02D5AD |/
    LDA r_battle_character_visual_properties.1.y.w,X                            ; $02D5B0 |\
    CLC                                                                         ; $02D5B3 | | Set the projectile source Y coordinate to the character Y
    ADC r_battle_character_visual_properties.1.y_offset.w,X                     ; $02D5B4 | | coordinate plus their Y offset plus eight.
    CLC                                                                         ; $02D5B7 | |
    ADC #8.b                                                                    ; $02D5B8 | |
    STA r_battle_effect_projectile_source_coordinates.y.w                       ; $02D5BA |/
    LDA #8.b                                                                    ; $02D5BD |\ Set the projectile horizontal rate to eight pixels per frame.
    STA r_battle_effect_projectile_horizontal_rate.w                            ; $02D5BF |/
    LDA <r_battle_effect_target_slot                                            ; $02D5C2 |\
    ASL A                                                                       ; $02D5C4 | | Set the projectile target X coordinate to the coordinate of the
    TAY                                                                         ; $02D5C5 | | monster's center.
    LDA r_battle_monster_coordinates_center.1.x.w,Y                             ; $02D5C6 | |
    STA r_battle_effect_projectile_target_coordinates.x.w                       ; $02D5C9 |/
    SEC                                                                         ; $02D5CC |\ Pointlessly subtract eight from the coordinate.
    SBC #8.b                                                                    ; $02D5CD |/ BUG/NOTE: Should this have been moved before the preceding STA?
    LDA r_battle_monster_coordinates_center.1.y.w,Y                             ; $02D5CF |\ Set the target Y coordinate to the center monster Y coordinate.
    STA r_battle_effect_projectile_target_coordinates.y.w                       ; $02D5D2 |/
    JSR _battle_effect_projectile_initialize                                    ; $02D5D5 | Initialize the coordinates for the projectile sprite.
    LDA #AUDIO_EFFECT_ARROW_FIRING.b                                            ; $02D5D8 |\ Play the arrow firing sound effect.
    JSR _battle_play_sound_effect                                               ; $02D5DA |/
    LDA r_battle_weapon_sprite_tmp_oam_offset.w                                 ; $02D5DD |\
    BEQ +                                                                       ; $02D5E0 | | If the OAM offset is non-zero, update the sprite coordinates.
    JSR _battle_effect_projectile_update_coordinates                            ; $02D5E2 |/
+   JSR _battle_reset_effect_oam_large                                          ; $02D5E5 | Reset the effect OAM to large sprites.
@start:
    JSR _battle_wait_next_frame_preserve_x_y                                    ; $02D5E8 | Wait for the next frame.
    INC <r_battle_weapon_effect_frame_counter                                   ; $02D5EB | Increment the effect frame counter.
    LDA #16.b                                                                   ; $02D5ED |\ Set the base OAM index to 16.
    STA r_battle_effect_sprites_base_oam_index.w                                ; $02D5EF |/
    LDA #BATTLE_EFFECT_PATTERN_SINGLE_TILE.b                                    ; $02D5F2 |\ Select the single tile pattern.
    STA r_battle_effect_sprites_pattern_index.w                                 ; $02D5F4 |/
    LDA #EFFECT_OAM_RESET_MODE_NONE.b                                           ; $02D5F7 |\ Set the reset mode to not reset the sprites.
    STA r_battle_effect_sprites_reset_mode.w                                    ; $02D5F9 |/
    LDA #$A0.b                                                                  ; $02D5FC |\ Set the base tile to $A0.
    STA r_battle_effect_sprites_base_tile.w                                     ; $02D5FE |/
    LDA #%00111111.b                                                            ; $02D601 |\ Set the tile flags to priority 3, palette 7, and the high name
    STA r_battle_effect_sprites_tile_flags.w                                    ; $02D603 |/ table.
    JSR _battle_get_current_actor_visual_properties_offset                      ; $02D606 | Set the X register to the visual properties offset.
    LDA <r_battle_weapon_effect_frame_counter                                   ; $02D609 |\
    INC A                                                                       ; $02D60B | | Set the weapon sprite tile number to $82 for the first four
    AND #%11111100.b                                                            ; $02D60C | | frames and to $80 for every frame after that.
    BNE +                                                                       ; $02D60E | |
    LDA #$82.b                                                                  ; $02D610 | |
    BRA ++                                                                      ; $02D612 | |
+   LDA #$80.b                                                                  ; $02D614 | |
++  STA r_battle_weapon_sprite_tile.w                                           ; $02D616 |/
    LDA #%00111111.b                                                            ; $02D619 |\ Set the weapon sprite tile flags to use priority 3, palette 7 and
    STA r_battle_weapon_sprite_tile_flags.w                                     ; $02D61B |/ the high name table.
    JSR _battle_get_current_actor_visual_properties_offset                      ; $02D61E | Set the X register to the visual properties offset again.
    LDA r_battle_character_visual_properties.1.x.w,X                            ; $02D621 |\
    CLC                                                                         ; $02D624 | | Set the weapon sprite X coordinate to the character's X coordinate
    ADC r_battle_character_visual_properties.1.x_offset.w,X                     ; $02D625 | | plus their X offset minus four.
    ADC #-4.b                                                                   ; $02D628 | |
    STA r_battle_weapon_sprite_coordinates.x.w                                  ; $02D62A |/
    LDA r_battle_character_visual_properties.1.y.w,X                            ; $02D62D |\
    CLC                                                                         ; $02D630 | | Set the weapon sprite Y coordinate to the character's Y coordinate
    ADC r_battle_character_visual_properties.1.y_offset.w,X                     ; $02D631 | | plus their Y offset plus eight.
    ADC #8.b                                                                    ; $02D634 | |
    STA r_battle_weapon_sprite_coordinates.y.w                                  ; $02D636 |/
    LDA r_battle_weapon_effect_charmed.w                                        ; $02D639 |\
    BEQ +                                                                       ; $02D63C | | If the charm flag is set, add 12 to the weapon sprite's X
    LDA r_battle_weapon_sprite_coordinates.x.w                                  ; $02D63E | | coordinate and set the horizontal flip tile flag.
    CLC                                                                         ; $02D641 | |
    ADC #12.b                                                                   ; $02D642 | |
    STA r_battle_weapon_sprite_coordinates.x.w                                  ; $02D644 | |
    LDA #%01111111.b                                                            ; $02D647 | |
    STA r_battle_weapon_sprite_tile_flags.w                                     ; $02D649 |/
+   LDA <r_battle_current_actor_slot                                            ; $02D64C |\
    TAX                                                                         ; $02D64E | | Set the weapon sprite's OAM index to the character's OAM base plus
    LDA bank16.battle_character_slot_oam_index_data.l,X                         ; $02D64F | | the passed OAM offset.
    CLC                                                                         ; $02D653 | |
    ADC r_battle_weapon_sprite_tmp_oam_offset.w                                 ; $02D654 | |
    STA r_battle_weapon_sprite_oam_index.w                                      ; $02D657 |/
    DEC <r_battle_weapon_effect_frames_remaining                                ; $02D65A | Decrement the remaining frame counter.
    JSR _battle_effect_projectile_update_coordinates                            ; $02D65C |\ Update the projectile coordinates and if the last frame has been
    BCS ++                                                                      ; $02D65F |/ reached, branch ahead to break out of the loop.
    LDA r_battle_effect_projectile_coordinates.x.w                              ; $02D661 |\
    CLC                                                                         ; $02D664 | | Set the sprite coordinates by adding 24 to the calculated
    ADC #24.b                                                                   ; $02D665 | | projectile coordinates. This is because the sprite coordinates
    STA r_battle_effect_sprites_coordinates.x.w                                 ; $02D667 | | point to the middle of the 6x6 grid, so three tiles are added.
    LDA r_battle_effect_projectile_coordinates.y.w                              ; $02D66A | |
    CLC                                                                         ; $02D66D | |
    ADC #24.b                                                                   ; $02D66E | |
    STA r_battle_effect_sprites_coordinates.y.w                                 ; $02D670 |/
    LDA r_battle_current_action_details.target_flags.w                          ; $02D673 |\
    BPL +                                                                       ; $02D676 | | If the target is a monster, flag the sprites for drawing.
    INC r_battle_effect_sprites_pending.w                                       ; $02D678 |/
+   LDA r_battle_animate_physical_special_mode.w                                ; $02D67B |\
    BNE +                                                                       ; $02D67E | | Activate the weapon sprite if a special mode is not enabled.
    INC r_battle_weapon_sprite_visible.w                                        ; $02D680 |/
+   JMP @start                                                                  ; $02D683 | Loop to the next iteration.
++  STZ r_battle_weapon_sprite_visible.w                                        ; $02D686 | Disable the visibility of the weapon sprite.
    LDA r_battle_current_action_details.target_flags.w                          ; $02D689 |\
    BPL ++                                                                      ; $02D68C | | If the target is not a monster or if the attack was a miss, skip
    LDA r_battle_current_action_details.action_flags.w                          ; $02D68E | | to the end of the function.
    AND #BATTLE_ACTION_DETAILS_ACTION_FLAG_MISS.b                               ; $02D691 | |
    BNE ++                                                                      ; $02D693 |/
    LDA #$A2.b                                                                  ; $02D695 |\ Set the base tile to $A2.
    STA r_battle_effect_sprites_base_tile.w                                     ; $02D697 |/
    INC r_battle_effect_sprites_pending.w                                       ; $02D69A | Flag the sprites as pending to be drawn.
    LDA r_battle_animate_physical_special_mode.w                                ; $02D69D |\
    CMP #BATTLE_ANIMATE_PHYSICAL_SPECIAL_DANCING.b                              ; $02D6A0 | | If the special mode is anything other than Dancing, jump to the
    BEQ +                                                                       ; $02D6A2 | | standard projectile hit code.
    JMP _battle_weapon_effect_projectile_hit_arrow_shuriken                     ; $02D6A4 |/
+   LDA #$A0.b                                                                  ; $02D6A7 |\
    STA r_battle_effect_sprites_base_tile.w                                     ; $02D6A9 | | Otherwise, set the base tile to $A0 and jump to the Dancing code.
    JMP _battle_weapon_effect_projectile_hit_dancing                            ; $02D6AC |/
++  RTS                                                                         ; $02D6AF

; _battle_weapon_effect_projectile_hit_dancing ($02:D6B0)
;
; Animates the weapon effect for when the Dancing dagger hits the target
; monster. Shows four sprites, with them alternating in direction.
_battle_weapon_effect_projectile_hit_dancing:
    STZ <r_battle_weapon_effect_frame_counter                                   ; $02D6B0 | Set the effect frame counter to zero.
-   LDX #8.w                                                                    ; $02D6B2 |\ Wait for 8 frames.
    JSR _battle_wait_x_frames                                                   ; $02D6B5 |/
    LDA #AUDIO_EFFECT_ARROW_HIT.b                                               ; $02D6B8 |\ Play the arrow hit sound effect.
    JSR _battle_play_sound_effect                                               ; $02D6BA |/
    JSR _battle_action_flash_yellow_if_critical                                 ; $02D6BD | Flash the screen yellow if this is a critical hit.
    INC <r_battle_weapon_effect_frame_counter                                   ; $02D6C0 | Increment the effect counter.
    LDA <r_battle_weapon_effect_frame_counter                                   ; $02D6C2 |\
    PHA                                                                         ; $02D6C4 | | Set the weapon effect parameters, using an OAM index that rotates
    AND #%00000011.b                                                            ; $02D6C5 | | through 0 to 3 based on the effect frame counter.
    CLC                                                                         ; $02D6C7 | |
    JSR _battle_set_weapon_effect_parameters_single_tile                        ; $02D6C8 |/
    PLA                                                                         ; $02D6CB |\
    ROR A                                                                       ; $02D6CC | | Set the tile flags such that every other sprite will be flipped
    ROR A                                                                       ; $02D6CD | | horizontally.
    ROR A                                                                       ; $02D6CE | |
    AND #%01000000.b                                                            ; $02D6CF | |
    ORA #%00111111.b                                                            ; $02D6D1 | |
    STA r_battle_effect_sprites_tile_flags.w                                    ; $02D6D3 |/
    JSR _battle_weapon_effect_set_random_coordinates                            ; $02D6D6 | Set random coordinates for the next sprite.
    INC r_battle_effect_sprites_pending.w                                       ; $02D6D9 | Flag the sprites as pending to be drawn.
    LDA <r_battle_weapon_effect_frame_counter                                   ; $02D6DC |\
    CMP #4.b                                                                    ; $02D6DE | | Loop until four sprites have been drawn.
    BNE -                                                                       ; $02D6E0 |/
    RTS                                                                         ; $02D6E2

; _battle_set_weapon_effect_parameters_single_tile_rotating_eight ($02:D6E3)
;
; Calculates an OAM index to use by incrementing the effect frame counter and
; then taking it mod 8. The resulting index is passed to the following function
; that sets the weapon effect parameters. That function is called by falling
; through.
_battle_set_weapon_effect_parameters_single_tile_rotating_eight:
    INC <r_battle_weapon_effect_frame_counter                                   ; $02D6E3
    LDA <r_battle_weapon_effect_frame_counter                                   ; $02D6E5
    AND #%00000111.b                                                            ; $02D6E7

; _battle_set_weapon_effect_parameters_single_tile ($02:D6E9)
;
; Sets the base OAM index to 16 plus the value passed in the accumulator, sets
; the effect pattern index to a single tile pattern, disables the effect OAM
; reset and sets the tile flags.
_battle_set_weapon_effect_parameters_single_tile:
    CLC                                                                         ; $02D6E9 |\
    ADC #16.b                                                                   ; $02D6EA | | Set the base OAM index to 16 plus the passed value.
    STA r_battle_effect_sprites_base_oam_index.w                                ; $02D6EC |/
    LDA #BATTLE_EFFECT_PATTERN_SINGLE_TILE.b                                    ; $02D6EF |\ Set the pattern index to one for a single tile.
    STA r_battle_effect_sprites_pattern_index.w                                 ; $02D6F1 |/
    LDA #EFFECT_OAM_RESET_MODE_NONE.b                                           ; $02D6F4 |\ Set the effect sprite reset mode to not reset any sprites.
    STA r_battle_effect_sprites_reset_mode.w                                    ; $02D6F6 |/
    LDA #%00111111.b                                                            ; $02D6F9 |\ Set the tile flags to priority 3, palette 7 and the high name
    STA r_battle_effect_sprites_tile_flags.w                                    ; $02D6FB |/ table.
    RTS                                                                         ; $02D6FE

; _battle_weapon_effect_projectile_hit_arrow_shuriken ($02:D6FF)
;
; Animates the weapon effect for arrows and shurikens when they hit the target
; monster. Generally animates one sprite for each hit, up to a limit of 17.
_battle_weapon_effect_projectile_hit_arrow_shuriken:
    LDX #8.w                                                                    ; $02D6FF | Initialize the X register to eight.
    STZ <r_battle_weapon_effect_frame_counter                                   ; $02D702 | Set the effect frame counter to zero.
-   PHX                                                                         ; $02D704 |\
    JSR _battle_wait_next_frame_preserve_x_y                                    ; $02D705 | | Wait for the next frame.
    PLX                                                                         ; $02D708 |/
    DEX                                                                         ; $02D709 |\ Loop until eight frames have been waited.
    BNE -                                                                       ; $02D70A |/
    LDA #AUDIO_EFFECT_ARROW_HIT.b                                               ; $02D70C |\ Play the arrow hit sound effect.
    JSR _battle_play_sound_effect                                               ; $02D70E |/
    JSR _battle_action_flash_yellow_if_critical                                 ; $02D711 | Flash yellow if the hit was a critical hit.
    JSR _battle_set_weapon_effect_parameters_single_tile_rotating_eight         ; $02D714 | Increment the frame counter and set weapon effect parameters.
    JSR _battle_weapon_effect_set_random_coordinates                            ; $02D717 | Set random coordinates for the sprite.
    INC r_battle_effect_sprites_pending.w                                       ; $02D71A | Flag the sprites as pending to be drawn.
    LDX #4.w                                                                    ; $02D71D | Set the X register to four to wait four frames the next time.
    LDA r_battle_current_action_details.action.w                                ; $02D720 |\
    CMP #16.b                                                                   ; $02D723 | | Loop until a number of sprites equal to the number of hits plus
    BCC +                                                                       ; $02D725 | | one have been processed. If the number of hits is greater than
    LDA #16.b                                                                   ; $02D727 | | sixteen, it is assumed to be sixteen.
+   INC A                                                                       ; $02D729 | |
    CMP <r_battle_weapon_effect_frame_counter                                   ; $02D72A | |
    BNE -                                                                       ; $02D72C |/
    RTS                                                                         ; $02D72E

; _battle_weapon_effect_animate_harp_hit ($02:D72F)
;
; Animates the harp hit effect, though nothing it does is harp specific, and
; loading the correct tiles is left to the caller. Falls through to the next
; function, which handles everything except loading the sound effect ID.
_battle_weapon_effect_animate_harp_hit:
    LDA #AUDIO_EFFECT_ARROW_HIT.b                                               ; $02D72F | Load the sound effect ID for the arrow hit sound effect.

; _battle_weapon_effect_animate_multiple_hit ($02:D731)
;
; Animates a weapon hit effect that does a number of sprites related to the
; number of hits, and alternates between two sprites. Used for harps and
; monsters punching other monsters.
_battle_weapon_effect_animate_multiple_hit:
    STA r_battle_weapon_effect_hit_sound_effect.w                               ; $02D731 | Save the passed sound effect to a temporary variable.
    STZ <r_battle_weapon_effect_frame_counter                                   ; $02D734 | Initialize the weapon effect frame counter to zero.
-   JSR _battle_wait_next_frame_preserve_x_y                                    ; $02D736 |\ Wait two frames.
    JSR _battle_wait_next_frame_preserve_x_y                                    ; $02D739 |/
    LDA <r_battle_weapon_effect_frame_counter                                   ; $02D73C |\
    AND #%000000011.b                                                           ; $02D73E | | Every four times through the loop, play the sound effect and
    BEQ +                                                                       ; $02D740 | | flash yellow if the attack was a critical hit.
    LDA r_battle_weapon_effect_hit_sound_effect.w                               ; $02D742 | |
    JSR _battle_play_sound_effect                                               ; $02D745 | |
    JSR _battle_action_flash_yellow_if_critical                                 ; $02D748 |/
+   JSR _battle_set_weapon_effect_parameters_single_tile_rotating_eight         ; $02D74B | Increment the frame counter and set the weapon effect parameters.
    LDA #$A0.b                                                                  ; $02D74E |\ Set the base tile to $A0.
    STA r_battle_effect_sprites_base_tile.w                                     ; $02D750 |/
    JSR _battle_weapon_effect_set_random_coordinates                            ; $02D753 | Set random coordinates for the next sprite.
    INC r_battle_effect_sprites_pending.w                                       ; $02D756 | Flag the sprite as being pending to be drawn.
    JSR _battle_wait_next_frame_preserve_x_y                                    ; $02D759 |\ Wait two more frames.
    JSR _battle_wait_next_frame_preserve_x_y                                    ; $02D75C |/
    LDA #$A2.b                                                                  ; $02D75F |\ Set the base tile to $A2.
    STA r_battle_effect_sprites_base_tile.w                                     ; $02D761 |/
    INC r_battle_effect_sprites_pending.w                                       ; $02D764 | Flag the sprites as pending to be drawn.
    JSR _battle_wait_next_frame_preserve_x_y                                    ; $02D767 | Wait another frame.
    LDA r_battle_current_action_details.action.w                                ; $02D76A |\
    CMP #16.b                                                                   ; $02D76D | | Execute the loop up to either 16 times or the number of hits,
    BCC +                                                                       ; $02D76F | | whichever is greater.
    LDA #16.b                                                                   ; $02D771 | |
+   INC A                                                                       ; $02D773 | |
    CMP <r_battle_weapon_effect_frame_counter                                   ; $02D774 | |
    BNE -                                                                       ; $02D776 |/
    RTS                                                                         ; $02D778

; _battle_weapon_effect_set_random_coordinates ($02:D779)
;
; Sets the coordinates for the weapon effect sprites randomly based on the
; target coordinates.
_battle_weapon_effect_set_random_coordinates:
    LDA r_battle_frame_counter.w                                                ; $02D779 |\
    TAY                                                                         ; $02D77C | | Select one random value from 8 to 39 and one from 0 to 31.
    LDA r_prng_data.w,Y                                                         ; $02D77D | |
    AND #%00011111.b                                                            ; $02D780 | | NOTE: The second value actually reads values from beyond the PRNG
    CLC                                                                         ; $02D782 | |       data if the frame counter is currently 252 or greater. It
    ADC #8.b                                                                    ; $02D783 | |       reads a value that ends up being more or less the same as
    STA <r_battle_generic_tmp_index_lo                                          ; $02D785 | |       reading the PRNG data, however. The difference is a slight
    LDA r_prng_data.w + 4,Y                                                     ; $02D787 | |       bias toward certain single-digit values.
    AND #%00011111.b                                                            ; $02D78A | |
    STA <r_battle_generic_tmp_index_2_lo                                        ; $02D78C |/
    LDA <r_battle_effect_target_slot                                            ; $02D78E |\
    ASL A                                                                       ; $02D790 | | Set the X coordinate for the effect sprite to the target X
    TAY                                                                         ; $02D791 | | coordinate plus the first random value.
    LDA r_battle_monster_coordinates_center.1.x.w,Y                             ; $02D792 | |
    CLC                                                                         ; $02D795 | |
    ADC <r_battle_generic_tmp_index_lo                                          ; $02D796 | |
    STA r_battle_effect_sprites_coordinates.x.w                                 ; $02D798 |/
    LDA r_battle_monster_coordinates_center.1.y.w,Y                             ; $02D79B |\
    CLC                                                                         ; $02D79E | | Set the Y coordinate for the effect sprite to the target Y
    ADC <r_battle_generic_tmp_index_2_lo                                        ; $02D79F | | coordinate plus the second random value.
    STA r_battle_effect_sprites_coordinates.y.w                                 ; $02D7A1 |/
    RTS                                                                         ; $02D7A4

; _battle_weapon_effect_fists ($02:D7A5)
;
; Implements the character punching effect, by calling the single fist weapon
; effect once for each hand. The single fist routine follows this one, so it
; falls through for one of the executions.
_battle_weapon_effect_fists:
    LDA <r_battle_weapon_effect_right_hand                                      ; $02D7A5 |\
    ORA <r_battle_weapon_effect_left_hand                                       ; $02D7A7 | | If either hand has a weapon in it, return without doing anything.
    BEQ +                                                                       ; $02D7A9 | |
    RTS                                                                         ; $02D7AB |/
+   JSR _battle_weapon_effect_single_fist                                       ; $02D7AC |\ Otherwise, execute one of the fists, increment the hand number, and
    INC <r_battle_weapon_effect_hand                                            ; $02D7AF |/ then fall through to do the second fist.

; _battle_weapon_effect_single_fist ($02:D7B1)
;
; Implements the character punching effect for a single fist or claw.
_battle_weapon_effect_single_fist:
    LDA <r_battle_weapon_effect_hand                                            ; $02D7B1 |\
    AND #%00000001.b                                                            ; $02D7B3 | | Set the character's pose to either a swinging right arm or a
    STA <r_battle_generic_tmp_index_lo                                          ; $02D7B5 | | swinging left arm, depending on which hand is being processed.
    LDA <r_battle_current_actor_slot                                            ; $02D7B7 | |
    TAX                                                                         ; $02D7B9 | |
    LDA #BATTLE_POSE_SWINGING_RIGHT_ARM.b                                       ; $02D7BA | |
    CLC                                                                         ; $02D7BC | |
    ADC <r_battle_generic_tmp_index_lo                                          ; $02D7BD | |
    STA r_battle_character_pose.w,X                                             ; $02D7BF |/
    LDA <r_battle_weapon_effect_hand                                            ; $02D7C2 |\
    TAX                                                                         ; $02D7C4 | | Load the sprite, palette and effect tiles for the weapon in the
    LDA <r_battle_weapon_effect_right_hand,X                                    ; $02D7C5 | | target hand (either nothing or a claw).
    JSR _battle_load_weapon_visual                                              ; $02D7C7 |/
    STZ <r_battle_weapon_effect_frame_counter                                   ; $02D7CA | Reset the frame counter to zero.
    JSR _battle_get_current_actor_visual_properties_offset                      ; $02D7CC |\
    STZ r_battle_character_visual_properties.1.animate_pose.w,X                 ; $02D7CF | | Disable animated poses and explicitly select the third frame of
    LDA #2.b                                                                    ; $02D7D2 | | the pose.
    STA r_battle_character_visual_properties.1.pose_frame_counter.w,X           ; $02D7D4 |/
    LDA r_battle_current_action_details.action.w                                ; $02D7D7 |\
    LSR A                                                                       ; $02D7DA | | Set the total number of animation frames to the number of hits
    LSR A                                                                       ; $02D7DB | | divided by eight plus eight.
    LSR A                                                                       ; $02D7DC | |
    CLC                                                                         ; $02D7DD | |
    ADC #8.b                                                                    ; $02D7DE | |
    STA <r_battle_weapon_effect_frames_remaining                                ; $02D7E0 |/
    STZ r_battle_weapon_sprite_visible.w                                        ; $02D7E2 | Ensure the weapon sprite is hidden.
    STZ r_battle_effect_sprites_pending.w                                       ; $02D7E5 | Unset the effect sprites pending flag.
    JSR _battle_reset_effect_oam_large                                          ; $02D7E8 | Reset the effect OAM to large sprites.
@start:
    JSR _battle_wait_next_frame_preserve_x_y                                    ; $02D7EB | Wait for the next frame.
    LDA <r_battle_weapon_effect_frame_counter                                   ; $02D7EE |\
    AND #%00000011.b                                                            ; $02D7F0 | | If the effect frame counter mod 4 is equal to zero, play the
    BNE +                                                                       ; $02D7F2 | | punch sound effect. Additionally, if this was a critical hit,
    LDA #AUDIO_EFFECT_PUNCH.b                                                   ; $02D7F4 | | flash the screen.
    JSR _battle_play_sound_effect                                               ; $02D7F6 | |
    JSR _battle_action_flash_yellow_if_critical                                 ; $02D7F9 |/
+   LDA <r_battle_current_actor_slot                                            ; $02D7FC |\
    TAX                                                                         ; $02D7FE | | Draw the weapon sprite to the first two OAM entries for this
    LDA bank16.battle_character_slot_oam_index_data.l,X                         ; $02D7FF | | character slot.
    STA r_battle_weapon_sprite_oam_index.w                                      ; $02D803 |/
    LDA #$80.b                                                                  ; $02D806 |\ Set the tile number to $80.
    STA r_battle_weapon_sprite_tile.w                                           ; $02D808 |/
    LDA #%00111111.b                                                            ; $02D80B |\ Set the weapon tile flags to have priority 3, use palette 7 and use
    STA r_battle_weapon_sprite_tile_flags.w                                     ; $02D80D |/ the high name table.
    LDA r_battle_frame_counter.w                                                ; $02D810 |\
    TAX                                                                         ; $02D813 | | Select two random values between 0 and 1.
    LDA r_prng_data.w + 0,X                                                     ; $02D814 | |
    AND #%00000001.b                                                            ; $02D817 | |
    STA <r_battle_generic_tmp_index_lo                                          ; $02D819 | |
    LDA r_prng_data.w + 1,X                                                     ; $02D81B | |
    AND #%00000001.b                                                            ; $02D81E | |
    STA <r_battle_generic_tmp_index_hi                                          ; $02D820 |/
    JSR _battle_get_current_actor_visual_properties_offset                      ; $02D822 | Load the character's visual properties offset into the X register.
    LDA r_battle_character_visual_properties.1.x.w,X                            ; $02D825 |\
    SEC                                                                         ; $02D828 | | Set the weapon sprite X coordinate by subtracting 10 from the
    SBC #10.b                                                                   ; $02D829 | | character's X coordinate, adding the character's X offset, and
    CLC                                                                         ; $02D82B | | then adding the first randomly determined value.
    ADC r_battle_character_visual_properties.1.x_offset.w,X                     ; $02D82C | |
    ADC <r_battle_generic_tmp_index_lo                                          ; $02D82F | |
    STA r_battle_weapon_sprite_coordinates.x.w                                  ; $02D831 |/
    LDA r_battle_character_visual_properties.1.y.w,X                            ; $02D834 |\
    CLC                                                                         ; $02D837 | | Repeat the process for the Y coordinate except without the -10.
    ADC r_battle_character_visual_properties.1.y_offset.w,X                     ; $02D838 | |
    ADC <r_battle_generic_tmp_index_lo                                          ; $02D83B | | BUG: They used the first random value, but presumably intended to
    STA r_battle_weapon_sprite_coordinates.y.w                                  ; $02D83D |/       use the second.
    LDA r_battle_weapon_effect_charmed.w                                        ; $02D840 |\
    BEQ +                                                                       ; $02D843 | | If the charmed flag is set, add 12 to the X coordinate and set the
    LDA r_battle_weapon_sprite_coordinates.x.w                                  ; $02D845 | | horizontal flip flag.
    CLC                                                                         ; $02D848 | |
    ADC #$12.b                                                                  ; $02D849 | |
    STA r_battle_weapon_sprite_coordinates.x.w                                  ; $02D84B | |
    LDA r_battle_weapon_sprite_tile_flags.w                                     ; $02D84E | |
    EOR #%01000000.b                                                            ; $02D851 | |
    STA r_battle_weapon_sprite_tile_flags.w                                     ; $02D853 |/
+   LDA <r_battle_current_actor_slot                                            ; $02D856 |\
    ASL A                                                                       ; $02D858 | | If the character is not a toad or small, make the weapon sprite
    ASL A                                                                       ; $02D859 | | visible.
    TAX                                                                         ; $02D85A | |
    LDA r_character_visual_status.1.status_1.w,X                                ; $02D85B | |
    AND #(STATUS_1_TOAD | STATUS_1_SMALL).b                                     ; $02D85E | |
    BNE +                                                                       ; $02D860 | |
    INC r_battle_weapon_sprite_visible.w                                        ; $02D862 |/
+   LDA <r_battle_weapon_effect_frame_counter                                   ; $02D865 |\
    AND #%00000001.b                                                            ; $02D867 | | Set the base tile to either $A0 or $A2 depending on the current
    ASL A                                                                       ; $02D869 | | value of the frame counter.
    CLC                                                                         ; $02D86A | |
    ADC #$A0.b                                                                  ; $02D86B | |
    STA r_battle_effect_sprites_base_tile.w                                     ; $02D86D |/
    LDA <r_battle_weapon_effect_frame_counter                                   ; $02D870 |\
    AND #%00000001.b                                                            ; $02D872 | | Every other frame, add another hit effect sprite at random
    BNE +                                                                       ; $02D874 | | coordinates relative to the target.
    LDA <r_battle_weapon_effect_frame_counter                                   ; $02D876 | |
    AND #%00000110.b                                                            ; $02D878 | |
    LSR A                                                                       ; $02D87A | |
    JSR _battle_set_weapon_effect_parameters_single_tile                        ; $02D87B | |
    JSR _battle_weapon_effect_set_random_coordinates                            ; $02D87E |/
+   LDA r_battle_current_action_details.target_flags.w                          ; $02D881 |\
    BPL +                                                                       ; $02D884 | | If the target is a monster and the attack wasn't a miss, set the
    LDA r_battle_current_action_details.action_flags.w                          ; $02D886 | | effect sprites as pending so they'll actually be drawn.
    AND #BATTLE_ACTION_DETAILS_ACTION_FLAG_MISS.b                               ; $02D889 | |
    BNE +                                                                       ; $02D88B | |
    INC r_battle_effect_sprites_pending.w                                       ; $02D88D |/
+   DEC <r_battle_weapon_effect_frames_remaining                                ; $02D890 |\
    BEQ +                                                                       ; $02D892 | | Increment the frame counter, decrement the remaining frames, and
    INC <r_battle_weapon_effect_frame_counter                                   ; $02D894 | | loop until it reaches zero.
    JMP @start                                                                  ; $02D896 |/
+   STZ r_battle_weapon_sprite_visible.w                                        ; $02D899 | Unset the visibility of the weapon sprite.
    RTS                                                                         ; $02D89C

; _battle_load_effect_palette ($02:D89D)
;
; Given an 8-bit index in the accumulator, loads the corresponding 8-color
; palette from ROM (at $0E:CB00) to the first half of the last palette in the
; CG-RAM staging area.
_battle_load_effect_palette:
    PHX                                                                         ; $02D89D | Preserve the value of the X register.
    REP #FLAG_P_ACCUMULATOR                                                     ; $02D89E |\
    ASL A                                                                       ; $02D8A0 | | Set the X register to the passed value times sixteen (enough for
    ASL A                                                                       ; $02D8A1 | | an eight color palette).
    ASL A                                                                       ; $02D8A2 | |
    ASL A                                                                       ; $02D8A3 | |
    TAX                                                                         ; $02D8A4 | |
    TDC                                                                         ; $02D8A5 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $02D8A6 |/
    TDC                                                                         ; $02D8A8 |\
    TAY                                                                         ; $02D8A9 | | Copy the palette data from ROM to the first eight colors in the
-   LDA bank0E.battle_palette_data.l,X                                          ; $02D8AA | | last palette in the CG-RAM staging area.
    STA r_battle_cgram_data.16.w,Y                                              ; $02D8AE | |
    INY                                                                         ; $02D8B1 | |
    INX                                                                         ; $02D8B2 | |
    CPY #16.w                                                                   ; $02D8B3 | |
    BNE -                                                                       ; $02D8B6 |/
    PLX                                                                         ; $02D8B8 | Restore the X register.
    RTS                                                                         ; $02D8B9

; _battle_load_weapon_visual ($02:D8BA)
;
; Given an 8-bit item ID for a weapon in the accumulator, loads the weapon
; sprite, the effect tiles and the palette for the weapon.
_battle_load_weapon_visual:
    REP #FLAG_P_ACCUMULATOR                                                     ; $02D8BA |\
    ASL A                                                                       ; $02D8BC | | Multiply the item ID parameter by four to determine the index into
    ASL A                                                                       ; $02D8BD | | the weapon visual data.
    TAX                                                                         ; $02D8BE | |
    TDC                                                                         ; $02D8BF | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $02D8C0 |/
    LDA bank0F.battle_weapon_visual_data.l + weapon_visual.weapon_sprite,X      ; $02D8C2 |\ Load the sprite used for the weapon.
    JSR _battle_load_weapon_sprite                                              ; $02D8C6 |/
    LDA bank0F.battle_weapon_visual_data.l + weapon_visual.effect_sprite,X      ; $02D8C9 |\ Copy the weapon's effect sprite index to a local variable.
    STA <r_battle_weapon_effect_sprite_index                                    ; $02D8CD |/
    JSR _battle_load_weapon_effect_tiles                                        ; $02D8CF | Load the weapon's effect tiles.
    LDA bank0F.battle_weapon_visual_data.l + weapon_visual.palette.l,X          ; $02D8D2 |\ Load the palette used for the weapon to the last palette.
    JSR _battle_load_effect_palette                                             ; $02D8D6 |/
    LDA bank0F.battle_weapon_visual_data.l + weapon_visual.effect,X             ; $02D8D9 |\ Copy the effect byte to a local variable.
    STA <r_battle_weapon_effect_index                                           ; $02D8DD |/
    RTS                                                                         ; $02D8DF

; _battle_load_weapon_effect_tiles ($02:D8E0)
;
; Given a weapon effect index in the accumulator, loads the tiles for that
; effect into VRAM at $1A00. Additionally, if the effect is less than 8, sets
; the value for the appropriate sound effect in $F4A0.
_battle_load_weapon_effect_tiles:
    PHX                                                                         ; $02D8E0 | Preserve the value of the X register.
    PHA                                                                         ; $02D8E1 | Save the passed value in the accumulator.
    TAX                                                                         ; $02D8E2 |\
    LDA bank16.battle_sprite_weapon_effect_tile_offset_data.l,X                 ; $02D8E3 | | Load the tile offset for the parameter and then multiply by 24 to
    STA <r_math_multiply_8bit_arg_1                                             ; $02D8E7 | | determine the offset to the tile data in the array.
    LDA #24.b                                                                   ; $02D8E9 | |
    STA <r_math_multiply_8bit_arg_2                                             ; $02D8EB | |
    JSR _math_multiply_8bit                                                     ; $02D8ED |/
    PLA                                                                         ; $02D8F0 |\
    CMP #8.b                                                                    ; $02D8F1 | | If the effect index is less than 8, branch ahead.
    BCC +                                                                       ; $02D8F3 |/
    LDX #$1A00.w                                                                ; $02D8F5 |\ Set the target VRAM address to $1A00.
    STX r_battle_copy_double_to_vram_arg_target_vram_address.w                  ; $02D8F8 |/
    LDA #:bank1C.battle_sprite_weapon_data.b                                    ; $02D8FB |\ Set the source bank to $1C.
    STA r_battle_copy_double_to_vram_arg_source_bank.w                          ; $02D8FD |/
    LDA #8.b                                                                    ; $02D900 |\ Set the per row argument to eight, because no other value is valid.
    STA r_battle_copy_double_to_vram_arg_per_row.w                              ; $02D902 |/
    STA r_battle_copy_double_to_vram_arg_tiles.w                                ; $02D905 | Set the number of tiles to eight (two 16x16 tiles).
    REP #FLAG_P_ACCUMULATOR                                                     ; $02D908 |\
    LDA <r_math_multiply_8bit_result                                            ; $02D90A | | Set the source address to the base address for the sprite data and
    CLC                                                                         ; $02D90C | | add previously calculated offset.
    ADC #bank1C.battle_sprite_weapon_data.w                                     ; $02D90D | |
    STA r_battle_copy_double_to_vram_arg_source_address.w                       ; $02D910 | |
    TDC                                                                         ; $02D913 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $02D914 |/
    JSR _battle_copy_double_to_vram                                             ; $02D916 | Copy the two 16x16 tiles to VRAM.
    PLX                                                                         ; $02D919 |\ Restore the value of the X register and return.
    RTS                                                                         ; $02D91A |/
+   PHA                                                                         ; $02D91B | Save the effect index.
    CMP #BATTLE_WEAPON_EFFECT_HOLY.b                                            ; $02D91C |\
    BNE +                                                                       ; $02D91E | | If this is the holy weapon effect, load the value for the holy
    LDA #AUDIO_EFFECT_WEAPON_HOLY.b                                             ; $02D920 | | weapon sound effect.
    BRA ++                                                                      ; $02D922 |/
+   CMP #BATTLE_WEAPON_EFFECT_ICE.b                                             ; $02D924 |\
    BNE +                                                                       ; $02D926 | | If this is the ice weapon effect, load the value for the ice
    LDA #AUDIO_EFFECT_WEAPON_ICE.b                                              ; $02D928 | | weapon sound effect.
    BRA ++                                                                      ; $02D92A |/
+   CMP #BATTLE_WEAPON_EFFECT_FIRE.b                                            ; $02D92C |\
    BNE +                                                                       ; $02D92E | | If this is the fire weapon effect, load the value for the fire
    LDA #AUDIO_EFFECT_WEAPON_FIRE.b                                             ; $02D930 | | weapon sound effect.
    BRA ++                                                                      ; $02D932 |/
+   CMP #BATTLE_WEAPON_EFFECT_LIGHTNING.b                                       ; $02D934 |\
    BNE +                                                                       ; $02D936 | | If this is the lightning weapon effect (used by Dragoon spear),
    LDA #AUDIO_EFFECT_LIT.b                                                     ; $02D938 | | load the value for the Lit sound effect.
    BRA ++                                                                      ; $02D93A |/
+   LDA #AUDIO_EFFECT_SWORD.b                                                   ; $02D93C | Otherwise, load the value for the generic sword sound effect.
++  STA r_battle_weapon_sound_effect.w                                          ; $02D93E | Save the sound effect value to be used later.
    PLA                                                                         ; $02D941 |\
    REP #FLAG_P_ACCUMULATOR                                                     ; $02D942 | | Set the Y register to the offset to the effect's tile data by
    LDA <r_math_multiply_8bit_result                                            ; $02D944 | | adding the previously calculated offset to the base address.
    CLC                                                                         ; $02D946 | |
    ADC #bank1C.battle_sprite_weapon_data.w                                     ; $02D947 | |
    TAY                                                                         ; $02D94A | |
    TDC                                                                         ; $02D94B | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $02D94C |/
    LDX #16.w                                                                   ; $02D94E |\
    STX <r_battle_copy_3bpp_to_ram_arg_tiles                                    ; $02D951 | | Copy sixteen tiles from ROM to RAM. Not every effect uses that
    LDX #r_battle_load_sprite_data.w                                            ; $02D953 | | many tiles, but that is the maximum.
    LDA #:bank1C.battle_sprite_weapon_data.b                                    ; $02D956 | |
    JSR _battle_copy_3bpp_to_ram                                                ; $02D958 |/
    LDX #512.w                                                                  ; $02D95B |\
    STX <r_battle_copy_to_vram_arg_bytes                                        ; $02D95E | | Copy 512 bytes (16 tiles) from RAM to VRAM at $1A00.
    LDA #:r_battle_load_sprite_data.b                                           ; $02D960 | |
    LDX #r_battle_load_sprite_data.w                                            ; $02D962 | |
    LDY #$1A00.w                                                                ; $02D965 | |
    JSR _battle_copy_to_vram                                                    ; $02D968 |/
    PLX                                                                         ; $02D96B | Restore the value of the X register.
    RTS                                                                         ; $02D96C

; _battle_load_weapon_sprite ($02:D96D)
;
; Given an 8-bit weapon sprite index in the accumulator, loads two 16x16 tiles
; for that weapon to VRAM at $1800. Note that the parameter is the sprite index
; and not the actual weapon number.
_battle_load_weapon_sprite:
    PHX                                                                         ; $02D96D | Preserve the value of the X register.
    TAX                                                                         ; $02D96E |\
    LDA bank16.battle_sprite_weapon_tile_offset_data.l,X                        ; $02D96F | | Load the tile offset for the parameter from ROM and then multiply
    STA <r_math_multiply_8bit_arg_1                                             ; $02D973 | | by 24 (as each tile takes 24 bytes) to determine the offset to the
    LDA #24.b                                                                   ; $02D975 | | desired data.
    STA <r_math_multiply_8bit_arg_2                                             ; $02D977 | |
    JSR _math_multiply_8bit                                                     ; $02D979 |/
    LDX #$1800.w                                                                ; $02D97C |\ Set the target VRAM address.
    STX r_battle_copy_double_to_vram_arg_target_vram_address.w                  ; $02D97F |/
    LDA #:bank1C.battle_sprite_weapon_data.b                                    ; $02D982 |\ Set the source bank to $1C.
    STA r_battle_copy_double_to_vram_arg_source_bank.w                          ; $02D984 |/
    LDA #8.b                                                                    ; $02D987 |\ Set the per row parameter to eight, because all other values are
    STA r_battle_copy_double_to_vram_arg_per_row.w                              ; $02D989 |/ invalid.
    STA r_battle_copy_double_to_vram_arg_tiles.w                                ; $02D98C | Copy eight tiles (two 16x16 tiles).
    REP #FLAG_P_ACCUMULATOR                                                     ; $02D98F |\
    LDA <r_math_multiply_8bit_result                                            ; $02D991 | | Set the source address to the base address for weapon sprite data
    CLC                                                                         ; $02D993 | | and add the result of the earlier multiplication.
    ADC #bank1C.battle_sprite_weapon_data.w                                     ; $02D994 | |
    STA r_battle_copy_double_to_vram_arg_source_address.w                       ; $02D997 | |
    TDC                                                                         ; $02D99A | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $02D99B |/
    JSR _battle_copy_double_to_vram                                             ; $02D99D | Copy the two 16x16 tiles to VRAM.
    PLX                                                                         ; $02D9A0 | Restore the original value of the X register.
    RTS                                                                         ; $02D9A1

; _battle_copy_double_to_vram ($02:D9A2)
;
; Given a 16-bit source address in $F0B5, a 16-bit target VRAM address in $F0B7,
; an 8-bit source bank in $F0B9, and a number of tiles to transfer in $F0BB,
; copies the 3 bits per pixel graphical data from the source to the target
; location in VRAM, expanding it to 4 bits per pixel in the process. $F0BA is
; ostensibly a parameter to control the number of 16x16 tiles per row, but it
; does not make sense to give it a value other than eight. Values other than
; eight will result in potentially odd behavior. The actual tiles copied are
; treated as 16x16 tiles and are arranged in VRAM as such.
_battle_copy_double_to_vram:
-   LDA r_battle_dma_1_pending.w                                                ; $02D9A2 |\
    BEQ +                                                                       ; $02D9A5 | | Wait frames until there is no DMA pending.
    JSR _battle_wait_next_frame_preserve_x_y                                    ; $02D9A7 | |
    BRA -                                                                       ; $02D9AA |/
+   LDA r_battle_copy_double_to_vram_arg_tiles.w                                ; $02D9AC |\
    TAX                                                                         ; $02D9AF | | Load the actual 3 bits per pixel graphical data from ROM into a
    STX <r_battle_copy_3bpp_to_ram_arg_tiles                                    ; $02D9B0 | | temporary area in RAM.
    LDX #r_battle_load_sprite_data.w                                            ; $02D9B2 | |
    LDY r_battle_copy_double_to_vram_arg_source_address.w                       ; $02D9B5 | |
    LDA r_battle_copy_double_to_vram_arg_source_bank.w                          ; $02D9B8 | |
    JSR _battle_copy_3bpp_to_ram                                                ; $02D9BB |/
    LSR r_battle_copy_double_to_vram_arg_tiles.w                                ; $02D9BE |\ Divide the number of tiles by four, as each DMA transfer will copy
    LSR r_battle_copy_double_to_vram_arg_tiles.w                                ; $02D9C1 |/ four tiles.
    LDX #r_battle_load_sprite_data.w                                            ; $02D9C4 |\ Change the source address to the sprite data in RAM.
    STX r_battle_copy_double_to_vram_arg_source_address.w                       ; $02D9C7 |/
    LDX #64.w                                                                   ; $02D9CA |\
    STX r_battle_dma_1_bytes.w                                                  ; $02D9CD | | Configure both DMA transfers to copy 64 bytes (2 tiles).
    STX r_battle_dma_2_bytes.w                                                  ; $02D9D0 |/
    LDA #:r_battle_load_sprite_data.b                                           ; $02D9D3 |\
    STA r_battle_dma_1_source_bank.w                                            ; $02D9D5 | | Set the DMA source bank to $7E.
    STA r_battle_dma_2_source_bank.w                                            ; $02D9D8 |/
-   JSR _battle_wait_next_frame_preserve_x_y                                    ; $02D9DB | Wait for the next frame.
    REP #FLAG_P_ACCUMULATOR                                                     ; $02D9DE |\
    LDA r_battle_copy_double_to_vram_arg_source_address.w                       ; $02D9E0 | | Set the two source addresses to the current source address and the
    STA r_battle_dma_1_source_address.w                                         ; $02D9E3 | | source address plus 64 (to advance two tiles).
    CLC                                                                         ; $02D9E6 | |
    ADC #64.w                                                                   ; $02D9E7 | |
    STA r_battle_dma_2_source_address.w                                         ; $02D9EA |/
    LDA r_battle_copy_double_to_vram_arg_target_vram_address.w                  ; $02D9ED |\
    STA r_battle_dma_1_target_vram_address.w                                    ; $02D9F0 | | Set the two VRAM addresses to the current VRAM address and the
    CLC                                                                         ; $02D9F3 | | VRAM address plus 256 (16 tiles, to copy the second two tiles to
    ADC #256.w                                                                  ; $02D9F4 | | the next row).
    STA r_battle_dma_2_target_vram_address.w                                    ; $02D9F7 |/
    LDA r_battle_copy_double_to_vram_arg_source_address.w                       ; $02D9FA |\
    CLC                                                                         ; $02D9FD | | Increment the source address by 128 to move to the next set of
    ADC #128.w                                                                  ; $02D9FE | | tiles.
    STA r_battle_copy_double_to_vram_arg_source_address.w                       ; $02DA01 |/
    LDA r_battle_copy_double_to_vram_arg_target_vram_address.w                  ; $02DA04 |\
    CLC                                                                         ; $02DA07 | | Increment the target VRAM address by 32 to move two tiles over.
    ADC #32.w                                                                   ; $02DA08 | |
    STA r_battle_copy_double_to_vram_arg_target_vram_address.w                  ; $02DA0B |/
    TDC                                                                         ; $02DA0E |\
    SEP #FLAG_P_ACCUMULATOR                                                     ; $02DA0F | | If the per row count reaches zero, reset it to eight and add 256
    DEC r_battle_copy_double_to_vram_arg_per_row.w                              ; $02DA11 | | to the target VRAM address to skip the row (as we are working with
    BNE +                                                                       ; $02DA14 | | 16x16 tiles).
    LDA #8.b                                                                    ; $02DA16 | |
    STA r_battle_copy_double_to_vram_arg_per_row.w                              ; $02DA18 | |
    REP #FLAG_P_ACCUMULATOR                                                     ; $02DA1B | |
    LDA r_battle_copy_double_to_vram_arg_target_vram_address.w                  ; $02DA1D | |
    CLC                                                                         ; $02DA20 | |
    ADC #256.w                                                                  ; $02DA21 | |
    STA r_battle_copy_double_to_vram_arg_target_vram_address.w                  ; $02DA24 | |
    TDC                                                                         ; $02DA27 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $02DA28 |/
+   LDA #1.b                                                                    ; $02DA2A |\
    STA r_battle_dma_1_pending.w                                                ; $02DA2C | | Flag the two DMA transfers as pending.
    STA r_battle_dma_2_pending.w                                                ; $02DA2F |/
    DEC r_battle_copy_double_to_vram_arg_tiles.w                                ; $02DA32 |\ Loop until all of the transfers are complete.
    BNE -                                                                       ; $02DA35 |/
    JMP _battle_wait_next_frame_preserve_x_y                                    ; $02DA37 | Wait for a frame for the transfer to complete and return.

; _battle_copy_3bpp_to_ram ($02:DA3A)
;
; Copies 3 bits per pixel graphical data from ROM to RAM. The source address is
; specified in the Y register and the source bank is set in the accumulator. The
; target address, relative to the data bank register, should be stored in the X
; register. The number of 8x8 tiles to copy should be passed in $00.
_battle_copy_3bpp_to_ram:
    STY <r_battle_copy_3bpp_to_ram_address                                      ; $02DA3A |\
    STA <r_battle_copy_3bpp_to_ram_address_bank                                 ; $02DA3C | | Initialize by storing the source address and bank in RAM, zeroing
    TDC                                                                         ; $02DA3E | | out the Y register and switching to 16-bit accumulator mode.
    TAY                                                                         ; $02DA3F | |
    REP #FLAG_P_ACCUMULATOR                                                     ; $02DA40 |/
--  LDA #8.w                                                                    ; $02DA42 |\
    STA <r_battle_copy_3bpp_to_ram_count                                        ; $02DA45 | | Copy the first 16 bytes from ROM to RAM.
-   LDA [<r_battle_copy_3bpp_to_ram_address],Y                                  ; $02DA47 | |
    STA 0.w,X                                                                   ; $02DA49 | |
    INY                                                                         ; $02DA4C | |
    INY                                                                         ; $02DA4D | |
    INX                                                                         ; $02DA4E | |
    INX                                                                         ; $02DA4F | |
    DEC <r_battle_copy_3bpp_to_ram_count                                        ; $02DA50 | |
    BNE -                                                                       ; $02DA52 |/
    LDA #8.w                                                                    ; $02DA54 |\
    STA <r_battle_copy_3bpp_to_ram_count                                        ; $02DA57 | | Copy the next eight bytes, expanding each byte to a word during
-   LDA [<r_battle_copy_3bpp_to_ram_address],Y                                  ; $02DA59 | | the process.
    AND #$00FF.w                                                                ; $02DA5B | |
    STA 0.w,X                                                                   ; $02DA5E | |
    INY                                                                         ; $02DA61 | |
    INX                                                                         ; $02DA62 | |
    INX                                                                         ; $02DA63 | |
    DEC <r_battle_copy_3bpp_to_ram_count                                        ; $02DA64 | |
    BNE -                                                                       ; $02DA66 |/
    DEC <r_battle_copy_3bpp_to_ram_arg_tiles                                    ; $02DA68 |\
    BNE --                                                                      ; $02DA6A | | Repeat until the requested number of tiles has been copied.
    TDC                                                                         ; $02DA6C | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $02DA6D |/
    RTS                                                                         ; $02DA6F

; _battle_update_character_palette ($02:DA70)
;
; Given a character slot number in $47, updates that character's palette by
; reading it from ROM if both $F0AD and $F283 (TODO) are zero.  Afterward, if
; a character is currently active and this slot is the active slot, the second
; color in the palette is alternated between grey and black every four frames to
; produce the highlight effect.
_battle_update_character_palette:
    PHX                                                                         ; $02DA70 |\ Preserve the values of the X and Y registers.
    PHY                                                                         ; $02DA71 |/
    LDA <r_battle_draw_character_sprites_slot                                   ; $02DA72 |\
    TAX                                                                         ; $02DA74 | | Load the index of the correct palette for the current character
    LDA r_battle_character_palette_index.w,X                                    ; $02DA75 | | slot.
    TAX                                                                         ; $02DA78 | |
    STX <r_battle_update_character_palette_tmp                                  ; $02DA79 |/
    LDA <r_battle_draw_character_sprites_slot                                   ; $02DA7B |\
    CLC                                                                         ; $02DA7D | | Determine the palette number in CG-RAM by adding 9 to the slot.
    ADC #9.b                                                                    ; $02DA7E |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $02DA80 |\
    ASL A                                                                       ; $02DA82 | | Calculate the CG-RAM offset by multiplying the CG-RAM index by 32.
    ASL A                                                                       ; $02DA83 | |
    ASL A                                                                       ; $02DA84 | |
    ASL A                                                                       ; $02DA85 | |
    ASL A                                                                       ; $02DA86 | |
    TAY                                                                         ; $02DA87 |/
    LDA <r_battle_update_character_palette_tmp                                  ; $02DA88 |\
    ASL A                                                                       ; $02DA8A | | Determine the index to the palette data in ROM by multiplying the
    ASL A                                                                       ; $02DA8B | | palette index by 32.
    ASL A                                                                       ; $02DA8C | |
    ASL A                                                                       ; $02DA8D | |
    ASL A                                                                       ; $02DA8E | |
    TAX                                                                         ; $02DA8F | |
    TDC                                                                         ; $02DA90 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $02DA91 |/
    PHY                                                                         ; $02DA93 |\
    LDA r_unknown_f0ad.w                                                        ; $02DA94 | | TODO: Skip loading the entire palette if either $F0AD or $F283 is
    BNE +                                                                       ; $02DA97 | | non-zero. Review function comment when $F0AD is identified.
    LDA r_battle_effect_target_palette_cycling_party_active.w                   ; $02DA99 | |
    BNE +                                                                       ; $02DA9C |/
    LDA #32.b                                                                   ; $02DA9E |\
    STA <r_battle_update_character_palette_tmp                                  ; $02DAA0 | | Copy the entire palette from ROM into the CG-RAM staging area.
-   LDA bank1C.battle_character_palette_data.l,X                                ; $02DAA2 | |
    STA r_battle_cgram_data.w,Y                                                 ; $02DAA6 | |
    INX                                                                         ; $02DAA9 | |
    INY                                                                         ; $02DAAA | |
    DEC <r_battle_update_character_palette_tmp                                  ; $02DAAB | |
    BNE -                                                                       ; $02DAAD |/
+   PLY                                                                         ; $02DAAF |\
    LDA <r_battle_current_action.manual_pending                                 ; $02DAB0 | | If a character is not currently active or if the active character
    BEQ ++                                                                      ; $02DAB2 | | is not the current slot we are looking at, skip the highlight
    LDA <r_battle_draw_character_sprites_slot                                   ; $02DAB4 | | color replacement.
    CMP r_battle_last_active_character_slot.w                                   ; $02DAB6 | |
    BNE ++                                                                      ; $02DAB9 |/
    LDA r_battle_frame_counter.w                                                ; $02DABB |\
    AND #%00000100.b                                                            ; $02DABE | | If the current frame counter has bit 2 set (alternates between
    BEQ +                                                                       ; $02DAC0 | | true and false every four frames), set the second color to a
    LDA #$EF.b                                                                  ; $02DAC2 | | medium grey to create the highlight effect.
    STA r_battle_cgram_data.1.color2.w,Y                                        ; $02DAC4 | |
    LDA #$3D.b                                                                  ; $02DAC7 | |
    STA r_battle_cgram_data.1.color2.w + 1,Y                                    ; $02DAC9 | |
    BRA ++                                                                      ; $02DACC |/
+   LDA #$00.b                                                                  ; $02DACE |\
    STA r_battle_cgram_data.1.color2.w,Y                                        ; $02DAD0 | | Otherwise, set the color to black.
    STA r_battle_cgram_data.1.color2.w + 1,Y                                    ; $02DAD3 |/
++  PLY                                                                         ; $02DAD6 |\ Restore the saved index registers.
    PLX                                                                         ; $02DAD7 |/
    RTS                                                                         ; $02DAD8

; _set_character_palette_poison ($02:DAD9)
;
; Given the current character slot in $47, updates that character's palette in
; the CG-RAM staging area to replace colors 4, 5 and 9 with two shades of purple
; and black, respectively. This is used for poisoned characters.
_set_character_palette_poison:
    PHX                                                                         ; $02DAD9 |\
    LDA <r_battle_draw_character_sprites_slot                                   ; $02DADA | | Determine the index into the palette data by taking the character
    CLC                                                                         ; $02DADC | | slot, adding 9 (as the character in slot 0 uses palette 9) and
    ADC #9.b                                                                    ; $02DADD | | then multiplying by 32 (the size of a palette).
    REP #FLAG_P_ACCUMULATOR                                                     ; $02DADF | |
    ASL A                                                                       ; $02DAE1 | |
    ASL A                                                                       ; $02DAE2 | |
    ASL A                                                                       ; $02DAE3 | |
    ASL A                                                                       ; $02DAE4 | |
    ASL A                                                                       ; $02DAE5 | |
    TAX                                                                         ; $02DAE6 |/
    LDA #$7DF6.w                                                                ; $02DAE7 |\ Set the first skin tone to 22, 15, 31 (purple).
    STA r_battle_cgram_data.1.color4.w,X                                        ; $02DAEA |/
    LDA #$7D30.w                                                                ; $02DAED |\ Set the second skin tone to 16, 9, 31 (darker purple).
    STA r_battle_cgram_data.1.color5.w,X                                        ; $02DAF0 |/
    TDC                                                                         ; $02DAF3 |\ Set the eye color to black.
    STA r_battle_cgram_data.1.color9.w,X                                        ; $02DAF4 |/
    SEP #FLAG_P_ACCUMULATOR                                                     ; $02DAF7 |\ Restore the value of the X register.
    PLX                                                                         ; $02DAF9 |/
    RTS                                                                         ; $02DAFA

; _battle_update_pending_steps_acting ($02:DAFB)
;
; If the character in the slot passed in $47 is not swooned or stoned and their
; automatic movement is not disabled, potentially adjusts their position. If
; they are in a base position, but not the correct one, they will be moved to
; the correct one (implements Change command). If they have been flagged as
; moving, they will be moved to the acting position.
_battle_update_pending_steps_acting:
    PHX                                                                         ; $02DAFB | Preserve the value of the X register.
    LDA <r_battle_draw_character_sprites_slot                                   ; $02DAFC |\
    ASL A                                                                       ; $02DAFE | | Set the X register to the slot number times four, which indexes
    ASL A                                                                       ; $02DAFF | | the visual status bytes.
    TAX                                                                         ; $02DB00 |/
    LDA r_character_visual_status.1.status_1.w,X                                ; $02DB01 |\
    AND #(STATUS_1_SWOON | STATUS_1_STONE).b                                    ; $02DB04 | | If the character is swooned or stoned or if automatic movement
    BNE +                                                                       ; $02DB06 | | has been inhibited, return without doing anything.
    LDA <r_battle_draw_character_sprites_slot                                   ; $02DB08 | |
    TAX                                                                         ; $02DB0A | |
    LDA r_battle_character_disable_automatic_movement.w,X                       ; $02DB0B | |
    BEQ ++                                                                      ; $02DB0E | |
+   PLX                                                                         ; $02DB10 | |
    RTS                                                                         ; $02DB11 |/
++  PLX                                                                         ; $02DB12 |\
    LDA r_battle_character_visual_properties.1.x.w,X                            ; $02DB13 | | If the character is not currently at either the front or back row
    CMP #BATTLE_COORDINATE_X_PARTY_FRONT_ROW.b                                  ; $02DB16 | | X coordinate, branch to different code.
    BEQ +                                                                       ; $02DB18 | |
    CMP #BATTLE_COORDINATE_X_PARTY_BACK_ROW.b                                   ; $02DB1A | |
    BEQ +                                                                       ; $02DB1C | |
    JMP @moving                                                                 ; $02DB1E |/
+   LDA r_battle_party_formation_two_front.w                                    ; $02DB21 |\
    BNE +                                                                       ; $02DB24 | | If the character is currently at either the front or back row X
    PHX                                                                         ; $02DB26 | | coordinate and the current party formation has three characters in
    LDA <r_battle_draw_character_sprites_slot                                   ; $02DB27 | | front, load the correct X coordinate for this slot in that
    TAX                                                                         ; $02DB29 | | formation into the accumulator.
    LDA bank16.battle_party_three_front_slot_x_coordinate_data.l,X              ; $02DB2A | |
    PLX                                                                         ; $02DB2E | |
    BRA ++                                                                      ; $02DB2F |/
+   PHX                                                                         ; $02DB31 |\
    LDA <r_battle_draw_character_sprites_slot                                   ; $02DB32 | | If the character was at the front row or back row position, instead
    TAX                                                                         ; $02DB34 | | load the correct X coordinate for the two in front formation.
    LDA bank16.battle_party_two_front_slot_x_coordinate_data.l,X                ; $02DB35 | |
    PLX                                                                         ; $02DB39 |/
++  CMP r_battle_character_visual_properties.1.x.w,X                            ; $02DB3A |\ If the character is in the right location, branch to the moving
    BEQ @moving                                                                 ; $02DB3D |/ code. Otherwise, the Change command has been executed.
    PHA                                                                         ; $02DB3F |\
    LDA r_battle_character_visual_properties.1.flags.w,X                        ; $02DB40 | | Unset the various high flags on the character.
    AND #%00001111.b                                                            ; $02DB43 | |
    STA r_battle_character_visual_properties.1.flags.w,X                        ; $02DB45 | |
    PLA                                                                         ; $02DB48 |/
    CMP #BATTLE_COORDINATE_X_PARTY_FRONT_ROW.b                                  ; $02DB49 |\
    BNE +                                                                       ; $02DB4B | | If the character is supposed to be in the front row, load 8 as
    LDA #8.b                                                                    ; $02DB4D | | their pending steps.
    BRA @finalize                                                               ; $02DB4F |/
+   LDA r_battle_character_visual_properties.1.flags.w,X                        ; $02DB51 |\
    ORA #CHARACTER_VISUAL_FLAG_RETREATING.b                                     ; $02DB54 | | If the character is supposed to be in the back row, set the
    STA r_battle_character_visual_properties.1.flags.w,X                        ; $02DB56 | | retreating flag and load 8 as their pending steps value.
    LDA #8.b                                                                    ; $02DB59 | |
    BRA @finalize                                                               ; $02DB5B |/
@moving:
    PHX                                                                         ; $02DB5D |\
    LDA <r_battle_draw_character_sprites_slot                                   ; $02DB5E | | If the character is away from their correct fixed location, check
    TAX                                                                         ; $02DB60 | | to see if they are currently moving. If not, return without doing
    LDA r_battle_character_moving.w,X                                           ; $02DB61 | | anything.
    BEQ +                                                                       ; $02DB64 | |
    PLX                                                                         ; $02DB66 | |
    BRA ++                                                                      ; $02DB67 | |
+   PLX                                                                         ; $02DB69 | |
    BRA @done                                                                   ; $02DB6A |/
++  LDA r_battle_character_visual_properties.1.x.w,X                            ; $02DB6C |\
    CMP #BATTLE_COORDINATE_X_PARTY_ACTING.b                                     ; $02DB6F | | If the character is in the acting position, return.
    BEQ @done                                                                   ; $02DB71 |/
    PHA                                                                         ; $02DB73 |\
    LDA r_battle_character_visual_properties.1.flags.w,X                        ; $02DB74 | | Unset the high bits in the flags variable.
    AND #%00001111.b                                                            ; $02DB77 | |
    STA r_battle_character_visual_properties.1.flags.w,X                        ; $02DB79 | |
    PLA                                                                         ; $02DB7C |/
    STZ r_battle_character_visual_properties.1.frame_counter.w,X                ; $02DB7D | Zero out the character's frame counter.
    STZ r_battle_character_visual_properties.1.pose_frame_counter.w,X           ; $02DB80 | Zero out the character's pose frame counter.
    CMP #BATTLE_COORDINATE_X_PARTY_CHARM.b                                      ; $02DB83 |\
    BNE +                                                                       ; $02DB85 | | If the character is the charm position, set the retreating flag
    LDA r_battle_character_visual_properties.1.flags.w,X                        ; $02DB87 | | and load 16 into the accumulator before branching forward.
    ORA #CHARACTER_VISUAL_FLAG_RETREATING.b                                     ; $02DB8A | |
    STA r_battle_character_visual_properties.1.flags.w,X                        ; $02DB8C | |
    LDA #16.b                                                                   ; $02DB8F | |
    BRA ++                                                                      ; $02DB91 |/
+   LDA r_battle_party_formation_two_front.w                                    ; $02DB93 |\
    BNE +                                                                       ; $02DB96 | | If the party formation is set to three front, load the number
    PHX                                                                         ; $02DB98 | | of steps needed to move them from their base position to the
    LDA <r_battle_draw_character_sprites_slot                                   ; $02DB99 | | charm position.
    TAX                                                                         ; $02DB9B | |
    LDA bank16.battle_party_three_front_slot_pending_steps_data.l,X             ; $02DB9C | |
    PLX                                                                         ; $02DBA0 | |
    BRA ++                                                                      ; $02DBA1 |/
+   PHX                                                                         ; $02DBA3 |\
    LDA <r_battle_draw_character_sprites_slot                                   ; $02DBA4 | | Otherwise, load the value for the two front party.
    TAX                                                                         ; $02DBA6 | |
    LDA bank16.battle_party_two_front_slot_pending_steps_data.l,X               ; $02DBA7 | |
    PLX                                                                         ; $02DBAB |/
++  SEC                                                                         ; $02DBAC |\ In all the moving cases, subtract 8 from the value to get the value
    SBC #8.b                                                                    ; $02DBAD |/ for the acting position instead of the charm position.
@finalize:
    STA r_battle_character_visual_properties.1.pending_steps.w,X                ; $02DBAF | Write the calculated value to the character's movement steps.
    LDA r_character_visual_status.1.status_1.w,Y                                ; $02DBB2 |\
    AND #(STATUS_1_TOAD | STATUS_1_SMALL).b                                     ; $02DBB5 | | Check the toad and small statuses on this character and branch
    BEQ ++                                                                      ; $02DBB7 | | accordingly.
    AND #STATUS_1_TOAD.b                                                        ; $02DBB9 | |
    BEQ +                                                                       ; $02DBBB |/
    LDA r_battle_character_visual_properties.1.flags.w,X                        ; $02DBBD |\
    ORA #CHARACTER_VISUAL_FLAG_TOAD.b                                           ; $02DBC0 | | If a toad, set the toad flag.
    STA r_battle_character_visual_properties.1.flags.w,X                        ; $02DBC2 |/
+   LDA r_battle_character_visual_properties.1.pending_steps.w,X                ; $02DBC5 |\
    ASL A                                                                       ; $02DBC8 | | If a toad or small, multiply the pending steps value by two, as
    STA r_battle_character_visual_properties.1.pending_steps.w,X                ; $02DBC9 | | they only move one pixel instead of two per step.
    BRA @done                                                                   ; $02DBCC |/
++  LDA r_battle_character_visual_properties.1.flags.w,X                        ; $02DBCE |\
    ORA #CHARACTER_VISUAL_FLAG_LARGE.b                                          ; $02DBD1 | | If neither status is set, set the large visual flag.
    STA r_battle_character_visual_properties.1.flags.w,X                        ; $02DBD3 |/
@done:
    RTS                                                                         ; $02DBD6

; _battle_update_pending_steps_charm ($02:DBD7)
;
; Given the current sprite slot in $47, if that character isn't already moving
; and if an unknown flag isn't set, sets the character's pending steps and flags
; in order to move them to the charm X coordinate.
_battle_update_pending_steps_charm:
    PHX                                                                         ; $02DBD7 | Preserve the value of the X register.
    LDA <r_battle_draw_character_sprites_slot                                   ; $02DBD8 |\ Set the X register to the current character slot.
    TAX                                                                         ; $02DBDA |/
    LDA r_battle_character_disable_automatic_movement.w,X                       ; $02DBDB |\
    BNE +                                                                       ; $02DBDE | | Skip this function if the character is flagged as moving or if
    LDA r_battle_character_moving.w,X                                           ; $02DBE0 | | automatic movement has been prevented.
    BEQ ++                                                                      ; $02DBE3 | |
+   PLX                                                                         ; $02DBE5 | |
    RTS                                                                         ; $02DBE6 | |
++  PLX                                                                         ; $02DBE7 |/
    LDA r_battle_character_visual_properties.1.flags.w,X                        ; $02DBE8 |\
    AND #%00001111.b                                                            ; $02DBEB | | Unset the four upper flags.
    STA r_battle_character_visual_properties.1.flags.w,X                        ; $02DBED |/
    LDA r_battle_character_visual_properties.1.x.w,X                            ; $02DBF0 |\
    CMP #BATTLE_COORDINATE_X_PARTY_CHARM.b                                      ; $02DBF3 | | If the character is at the charm X coordinate, skip to the end.
    BEQ @done                                                                   ; $02DBF5 |/
    STZ r_battle_character_visual_properties.1.frame_counter.w,X                ; $02DBF7 | Zero out the character's frame counter.
    STZ r_battle_character_visual_properties.1.pose_frame_counter.w,X           ; $02DBFA | Zero out the character's pose frame counter.
    CMP #BATTLE_COORDINATE_X_PARTY_ACTING.b                                     ; $02DBFD |\
    BNE +                                                                       ; $02DBFF | | If the character is at the acting X coordinate, load 8 into the
    LDA #8.b                                                                    ; $02DC01 | | accumulator.
    BRA ++                                                                      ; $02DC03 |/
+   LDA r_battle_party_formation_two_front.w                                    ; $02DC05 |\
    BNE +                                                                       ; $02DC08 | | Otherwise, they must be at their base coordinate, so load the
    PHX                                                                         ; $02DC0A | | number of steps required to move them to the charm coordinate from
    LDA <r_battle_draw_character_sprites_slot                                   ; $02DC0B | | ROM into the accumulator.
    TAX                                                                         ; $02DC0D | |
    LDA bank16.battle_party_three_front_slot_pending_steps_data.l,X             ; $02DC0E | |
    PLX                                                                         ; $02DC12 | |
    BRA ++                                                                      ; $02DC13 | |
+   PHX                                                                         ; $02DC15 | |
    LDA <r_battle_draw_character_sprites_slot                                   ; $02DC16 | |
    TAX                                                                         ; $02DC18 | |
    LDA bank16.battle_party_two_front_slot_pending_steps_data.l,X               ; $02DC19 | |
    PLX                                                                         ; $02DC1D |/
++  STA r_battle_character_visual_properties.1.pending_steps.w,X                ; $02DC1E | Save the loaded value into their pending steps variable.
    LDA r_character_visual_status.1.status_1.w,Y                                ; $02DC21 |\
    AND #(STATUS_1_SMALL | STATUS_1_TOAD).b                                     ; $02DC24 | | If the character is a toad, set the toad visual flag for this
    BEQ ++                                                                      ; $02DC26 | | character.
    AND #STATUS_1_TOAD.b                                                        ; $02DC28 | |
    BEQ +                                                                       ; $02DC2A | |
    LDA r_battle_character_visual_properties.1.flags.w,X                        ; $02DC2C | |
    ORA #CHARACTER_VISUAL_FLAG_TOAD.b                                           ; $02DC2F | |
    STA r_battle_character_visual_properties.1.flags.w,X                        ; $02DC31 |/
+   LDA r_battle_character_visual_properties.1.pending_steps.w,X                ; $02DC34 |\
    ASL A                                                                       ; $02DC37 | | If the character is a toad or small, multiply the pending steps by
    STA r_battle_character_visual_properties.1.pending_steps.w,X                ; $02DC38 | | two.
    BRA +                                                                       ; $02DC3B |/
++  LDA r_battle_character_visual_properties.1.flags.w,X                        ; $02DC3D |\
    ORA #CHARACTER_VISUAL_FLAG_LARGE.b                                          ; $02DC40 | | Otherwise, set the large flag.
    STA r_battle_character_visual_properties.1.flags.w,X                        ; $02DC42 | |
+   RTS                                                                         ; $02DC45 |/
@done:
    LDA r_battle_character_visual_properties.1.flags.w,X                        ; $02DC46 |\
    ORA #CHARACTER_VISUAL_FLAG_REVERSE.b                                        ; $02DC49 | | If at the charm coordinate, set the reverse flag.
    STA r_battle_character_visual_properties.1.flags.w,X                        ; $02DC4B |/
    RTS                                                                         ; $02DC4E

; _battle_update_pending_steps_normal ($02:DC4F)
;
; Given the current sprite slot in $47, if that character isn't already moving
; and if an unknown flag isn't set, sets the character's pending steps and flags
; in order to move them to their base X coordinate.
_battle_update_pending_steps_normal:
    PHX                                                                         ; $02DC4F | Preserve the value of the X register.
    LDA <r_battle_draw_character_sprites_slot                                   ; $02DC50 |\ Set the X register to the current character slot.
    TAX                                                                         ; $02DC52 |/
    LDA r_battle_character_disable_automatic_movement.w,X                       ; $02DC53 |\
    BNE +                                                                       ; $02DC56 | | Skip this function if the character is moving or if automatic
    LDA r_battle_character_moving.w,X                                           ; $02DC58 | | movement has been disabled.
    BEQ ++                                                                      ; $02DC5B | |
+   PLX                                                                         ; $02DC5D | |
    RTS                                                                         ; $02DC5E | |
++  PLX                                                                         ; $02DC5F |/
    LDA r_battle_party_formation_two_front.w                                    ; $02DC60 |\
    BNE +                                                                       ; $02DC63 | | If the party formation has three characters in front, load the
    PHX                                                                         ; $02DC65 | | pending steps value for the slot to a temporary variable and load
    LDA <r_battle_draw_character_sprites_slot                                   ; $02DC66 | | the base X coordinate data to the accumulator.
    TAX                                                                         ; $02DC68 | |
    LDA bank16.battle_party_three_front_slot_pending_steps_data.l,X             ; $02DC69 | |
    STA <r_battle_visual_properties_tmp_1                                       ; $02DC6D | |
    LDA bank16.battle_party_three_front_slot_x_coordinate_data.l,X              ; $02DC6F | |
    PLX                                                                         ; $02DC73 | |
    BRA ++                                                                      ; $02DC74 |/
+   PHX                                                                         ; $02DC76 |\
    LDA <r_battle_draw_character_sprites_slot                                   ; $02DC77 | | Perform the same action except for the two front party formation.
    TAX                                                                         ; $02DC79 | |
    LDA bank16.battle_party_two_front_slot_pending_steps_data.l,X               ; $02DC7A | |
    STA <r_battle_visual_properties_tmp_1                                       ; $02DC7E | |
    LDA bank16.battle_party_two_front_slot_x_coordinate_data.l,X                ; $02DC80 | |
    PLX                                                                         ; $02DC84 |/
++  PHA                                                                         ; $02DC85 |\
    LDA r_battle_character_visual_properties.1.x.w,X                            ; $02DC86 | | If the character is not currently at the acting coordinate, check
    CMP #BATTLE_COORDINATE_X_PARTY_ACTING.b                                     ; $02DC89 | | their loaded pending steps value. If it's 24 (in other words,
    BNE ++                                                                      ; $02DC8B | | they're a back row character), then change the value to 16.
    LDA <r_battle_visual_properties_tmp_1                                       ; $02DC8D | | Otherwise, it should be 16, so divide it by 2 to make it 8.
    CMP #24.b                                                                   ; $02DC8F | |
    BNE +                                                                       ; $02DC91 | |
    LDA #16.b                                                                   ; $02DC93 | |
    STA <r_battle_visual_properties_tmp_1                                       ; $02DC95 | |
    BRA ++                                                                      ; $02DC97 | |
+   LSR <r_battle_visual_properties_tmp_1                                       ; $02DC99 |/
++  PLA                                                                         ; $02DC9B |\
    CMP r_battle_character_visual_properties.1.x.w,X                            ; $02DC9C | | If the character is at their target X coordinate, skip to the end.
    BEQ @done                                                                   ; $02DC9F |/
    STZ r_battle_character_visual_properties.1.frame_counter.w,X                ; $02DCA1 | Zero out the character's frame counter.
    STZ r_battle_character_visual_properties.1.pose_frame_counter.w,X           ; $02DCA4 | Zero out the character's pose frame counter.
    LDA r_battle_character_visual_properties.1.flags.w,X                        ; $02DCA7 |\
    AND #%00001111.b                                                            ; $02DCAA | | Unset the four upper flags.
    STA r_battle_character_visual_properties.1.flags.w,X                        ; $02DCAC |/
    LDA <r_battle_visual_properties_tmp_1                                       ; $02DCAF |\ Set the calculated pending steps value.
    STA r_battle_character_visual_properties.1.pending_steps.w,X                ; $02DCB1 |/
    LDA r_character_visual_status.1.status_1.w,Y                                ; $02DCB4 |\
    AND #(STATUS_1_TOAD | STATUS_1_SMALL).b                                     ; $02DCB7 | | If the character is a toad, set the toad visual flag for this
    BEQ ++                                                                      ; $02DCB9 | | character.
    AND #STATUS_1_TOAD.b                                                        ; $02DCBB | |
    BEQ +                                                                       ; $02DCBD | |
    LDA r_battle_character_visual_properties.1.flags.w,X                        ; $02DCBF | |
    ORA #CHARACTER_VISUAL_FLAG_TOAD.b                                           ; $02DCC2 | |
    STA r_battle_character_visual_properties.1.flags.w,X                        ; $02DCC4 |/
+   LDA r_battle_character_visual_properties.1.pending_steps.w,X                ; $02DCC7 |\
    ASL A                                                                       ; $02DCCA | | If the character is a toad or small, multiply the pending steps by
    STA r_battle_character_visual_properties.1.pending_steps.w,X                ; $02DCCB | | two.
    BRA +                                                                       ; $02DCCE |/
++  LDA r_battle_character_visual_properties.1.flags.w,X                        ; $02DCD0 |\
    ORA #CHARACTER_VISUAL_FLAG_LARGE.b                                          ; $02DCD3 | | Otherwise, set the large flag.
    STA r_battle_character_visual_properties.1.flags.w,X                        ; $02DCD5 |/
+   LDA r_battle_character_visual_properties.1.flags.w,X                        ; $02DCD8 |\
    ORA #CHARACTER_VISUAL_FLAG_RETREATING.b                                     ; $02DCDB | | Either way, set the retreating flag and return.
    STA r_battle_character_visual_properties.1.flags.w,X                        ; $02DCDD | |
    RTS                                                                         ; $02DCE0 |/
@done:
    LDA r_battle_character_visual_properties.1.flags.w,X                        ; $02DCE1 |\
    AND #CHARACTER_VISUAL_FLAG_REVERSE.b ~ $FF                                  ; $02DCE4 | | If at the correct coordinate, unset the reverse flag.
    STA r_battle_character_visual_properties.1.flags.w,X                        ; $02DCE6 |/
    RTS                                                                         ; $02DCE9

; _battle_draw_status_icon ($02:DCEA)
;
; Draws the status icon for the character in the slot passed in the X register.
_battle_draw_status_icon:
    PHX                                                                         ; $02DCEA |\ Preserve the values of the X and Y registers.
    PHY                                                                         ; $02DCEB |/
    TXA                                                                         ; $02DCEC |\
    ASL A                                                                       ; $02DCED | | Calculate the Y register by multiplying the slot number in the X
    ASL A                                                                       ; $02DCEE | | register by four.
    TAY                                                                         ; $02DCEF |/
    LDA bank16.battle_character_slot_oam_index_data.l,X                         ; $02DCF0 |\
    REP #FLAG_P_ACCUMULATOR                                                     ; $02DCF4 | | Calculate the offset into the actual OAM data by multiplying the
    ASL A                                                                       ; $02DCF6 | | OAM index by four.
    ASL A                                                                       ; $02DCF7 | |
    STA <r_battle_generic_tmp_ptr                                               ; $02DCF8 | |
    TDC                                                                         ; $02DCFA | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $02DCFB |/
    LDA r_battle_draw_character_sprites_status_icon.w                           ; $02DCFD |\
    STA r_battle_character_status_icons.w,X                                     ; $02DD00 | | Calculate the offset into the icon's OAM data by multiplying the
    ASL A                                                                       ; $02DD03 | | number by sixteen (each status icon has two frames of two tiles
    ASL A                                                                       ; $02DD04 | | each, where a tile takes four bytes).
    ASL A                                                                       ; $02DD05 | |
    ASL A                                                                       ; $02DD06 | |
    STA <r_battle_draw_status_icon_oam_offset                                   ; $02DD07 |/
    LDA r_battle_status_icon_timers.1.active.w,Y                                ; $02DD09 |\
    BNE +                                                                       ; $02DD0C | | If this character's timer is inactive, skip this function.
    JMP @done                                                                   ; $02DD0E |/
+   LDA r_battle_status_icon_timers.1.counter.w,Y                               ; $02DD11 |\
    INC A                                                                       ; $02DD14 | | Increment the primary frame counter for this character.
    STA r_battle_status_icon_timers.1.counter.w,Y                               ; $02DD15 |/
    AND #%00000111.b                                                            ; $02DD18 |\
    BNE +                                                                       ; $02DD1A | | If the current frame counter mod 8 is zero, increment the slow
    LDA r_battle_status_icon_timers.1.counter_slow.w,Y                          ; $02DD1C | | frame counter as well.
    INC A                                                                       ; $02DD1F | |
    STA r_battle_status_icon_timers.1.counter_slow.w,Y                          ; $02DD20 |/
+   TXA                                                                         ; $02DD23 |\
    ASL A                                                                       ; $02DD24 | | Now, set the X register to the character slot times two.
    TAX                                                                         ; $02DD25 |/
    LDA r_battle_character_cursor_coordinates.1.x.w,X                           ; $02DD26 |\
    STA <r_battle_generic_tmp_coordinates.x                                     ; $02DD29 | | Set the base coordinates to the character's cursor coordinates.
    LDA r_battle_character_cursor_coordinates.1.y.w,X                           ; $02DD2B | |
    STA <r_battle_generic_tmp_coordinates.y                                     ; $02DD2E |/
    LDA r_battle_status_icon_timers.1.counter_slow.w,Y                          ; $02DD30 |\
    AND #%00000001.b                                                            ; $02DD33 | | Set the X register to the offset to the status icon's OAM data
    ASL A                                                                       ; $02DD35 | | and then add eight if the current slow frame counter is odd, which
    ASL A                                                                       ; $02DD36 | | results in the animation frame changing every eight frames.
    ASL A                                                                       ; $02DD37 | |
    CLC                                                                         ; $02DD38 | |
    ADC <r_battle_draw_status_icon_oam_offset                                   ; $02DD39 | |
    TAX                                                                         ; $02DD3B |/
    LDY <r_battle_generic_tmp_ptr                                               ; $02DD3C |\ Load the character's OAM offset into the Y register and then zero
    STZ <r_battle_generic_tmp_ptr_lo                                            ; $02DD3E |/ out the low byte of the temporary variablew, which is now a counter.
@loop_start:
    LDA bank13.battle_status_icon_oam_data.l,X                                  ; $02DD40 |\
    CLC                                                                         ; $02DD44 | | Set the X coordinate for the tile by adding the base coordinate to
    ADC <r_battle_generic_tmp_coordinates.x                                     ; $02DD45 | | the tile's offset. Mirror the coordinate if the battle is a back
    JSR _mirror_character_sprite_coordinate_if_back_attack                      ; $02DD47 | | attack.
    STA r_oam.w,Y                                                               ; $02DD4A | |
    INX                                                                         ; $02DD4D | |
    INY                                                                         ; $02DD4E |/
    LDA bank13.battle_status_icon_oam_data.l,X                                  ; $02DD4F ||
    CLC                                                                         ; $02DD53 | | Repeat the process except for the Y coordinate, except that there
    ADC <r_battle_generic_tmp_coordinates.y                                     ; $02DD54 | | is no need to mirror the Y coordinate.
    STA r_oam.w,Y                                                               ; $02DD56 | |
    INX                                                                         ; $02DD59 | |
    INY                                                                         ; $02DD5A |/
    LDA r_battle_draw_character_sprites_status_icon.w                           ; $02DD5B |\
    CMP #SPRITE_STATUS_ICON_COUNT.b                                             ; $02DD5E | | If the status icon is set to count, load the tile number directly
    BNE +                                                                       ; $02DD60 | | from the calculated digits.
    PHX                                                                         ; $02DD62 | |
    LDA <r_battle_generic_tmp_ptr_lo                                            ; $02DD63 | |
    TAX                                                                         ; $02DD65 | |
    LDA r_battle_draw_character_sprites_count_digit_1.w,X                       ; $02DD66 | |
    PLX                                                                         ; $02DD69 | |
    BRA ++                                                                      ; $02DD6A |/
+   LDA bank13.battle_status_icon_oam_data.l,X                                  ; $02DD6C | Otherwise, load the tile number from the status icon's data.
++  STA r_oam.w,Y                                                               ; $02DD70 | Either way, save the tile number to the OAM staging area.
    INX                                                                         ; $02DD73 |\ Increment the indexes to move on the flags byte.
    INY                                                                         ; $02DD74 |/
    LDA r_formation_back_attack_copy.w                                          ; $02DD75 |\
    BEQ +                                                                       ; $02DD78 | | If this is a back attack, flip the tile horizontally. Otherwise,
    LDA bank13.battle_status_icon_oam_data.l,X                                  ; $02DD7A | | keep the tile as it is. Either way, store the result in the OAM.
    EOR #%01000000.b                                                            ; $02DD7E | |
    BRA ++                                                                      ; $02DD80 | | BUG: If this is a count icon, the numbers are flipped and end up
+   LDA bank13.battle_status_icon_oam_data.l,X                                  ; $02DD82 | |      backwards if this is a back attack.
++  STA r_oam.w,Y                                                               ; $02DD86 |/
    INX                                                                         ; $02DD89 |\
    INY                                                                         ; $02DD8A | | Increment the indexes and loop until both tiles have been
    INC <r_battle_generic_tmp_ptr_lo                                            ; $02DD8B | | handled.
    LDA <r_battle_generic_tmp_ptr_lo                                            ; $02DD8D | |
    CMP #$02.b                                                                  ; $02DD8F | |
    BNE @loop_start                                                             ; $02DD91 |/
@done:
    PLY                                                                         ; $02DD93 |\ Restore the values of the X and Y registers.
    PLX                                                                         ; $02DD94 |/
    RTS                                                                         ; $02DD95

; _battle_set_character_sprite_tile_to_256 ($02:DD96)
;
; Sets the variables used during the routine that draws character sprites in
; battle to set the base tile number to $0100 or 256. Specifically updates $EFC2
; and $EFC3.
_battle_set_character_sprite_tile_to_256:
    STZ r_battle_draw_character_sprites_base_tile.w                             ; $02DD96 | Set the base tile number to zero.
    LDA r_battle_draw_character_sprites_oam_flags.w                             ; $02DD99 |\
    ORA #%00000001.b                                                            ; $02DD9C | | Set the flag to use the high name table.
    STA r_battle_draw_character_sprites_oam_flags.w                             ; $02DD9E |/
    RTS                                                                         ; $02DDA1

; _check_visual_status ($02:DDA2)
;
; Given the current character sprite slot in $47, checks the character's visual
; status bytes. If the character has any of the swoon, stone, toad, small, mute
; darkness, poison, curse, paralyze, sleep, charm or HP critical statuses, the
; carry bit is cleared. Otherwise, the carry bit is set. The carry bit will be
; set as well if the character is moving, even if they have one of the statuses.
_check_visual_status:
    PHX                                                                         ; $02DDA2 | Prserve the value of the X register.
    LDA <r_battle_draw_character_sprites_slot                                   ; $02DDA3 |\ Set the X register to the current character slot.
    TAX                                                                         ; $02DDA5 |/
    LDA r_battle_character_moving.w,X                                           ; $02DDA6 |\ If the character is currently moving, branch to set the flag.
    BNE +                                                                       ; $02DDA9 |/
    LDA r_battle_disable_status_pose.w,X                                        ; $02DDAB |\ Set the return bit if the character's status-based pose has been
    BNE @set                                                                    ; $02DDAE |/ disabled.
    LDA <r_battle_draw_character_sprites_slot                                   ; $02DDB0 |\
    ASL A                                                                       ; $02DDB2 | | Set the X register to the character slot times four.
    ASL A                                                                       ; $02DDB3 | |
    TAX                                                                         ; $02DDB4 |/
    LDA r_character_visual_status.1.status_1.w,X                                ; $02DDB5 |\
    AND #(STATUS_1_PIG ~ %11111111).b                                           ; $02DDB8 | | Check for swoon, stone, toad, small, mute, darkness and poison.
    STA <r_battle_visual_properties_tmp_1                                       ; $02DDBA |/
    LDA r_character_visual_status.1.status_2.w,X                                ; $02DDBC |\
    AND #%10111000.b                                                            ; $02DDBF | | Check for curse, paralyze, sleep and charm.
    ORA <r_battle_visual_properties_tmp_1                                       ; $02DDC1 | |
    STA <r_battle_visual_properties_tmp_1                                       ; $02DDC3 |/
    LDA r_character_visual_status.1.status_4.w,X                                ; $02DDC5 |\
    AND #STATUS_4_CRITICAL.b                                                    ; $02DDC8 | | Check for HP critical status.
    ORA <r_battle_visual_properties_tmp_1                                       ; $02DDCA |/
    BNE @clear                                                                  ; $02DDCC | If any of the above is set, jump to clear the carry bit.
    PLX                                                                         ; $02DDCE |\
    SEC                                                                         ; $02DDCF | | Restore the X register, set the carry bit and return.
    RTS                                                                         ; $02DDD0 |/
+   INC <r_battle_current_slot_incapacitated                                    ; $02DDD1 | If the character is moving, flag them as being incapacitated.
@set:
    PLX                                                                         ; $02DDD3 |\
    SEC                                                                         ; $02DDD4 | | Restore the X register, set the carry bit and return.
    RTS                                                                         ; $02DDD5 |/
@clear:
    PLX                                                                         ; $02DDD6 |\
    CLC                                                                         ; $02DDD7 | | Restore the X register, clear the carry bit and return.
    RTS                                                                         ; $02DDD8 |/

; _battle_character_sprite_handle_movement ($02:DDD9)
;
; Various routines to handle the movement of the current character sprite in
; $47. Also handles drawing the correct status icons depending on the status
; of the character.
_battle_character_sprite_handle_movement:
    PHX                                                                         ; $02DDD9 |\ Preserve the values of the X and Y registers.
    PHY                                                                         ; $02DDDA |/
    STZ <r_battle_current_slot_incapacitated                                    ; $02DDDB | Initially flag the slot as not incapacitated.
    LDA <r_battle_draw_character_sprites_slot                                   ; $02DDDD |\
    ASL A                                                                       ; $02DDDF | | Set the Y register to the character slot times four.
    ASL A                                                                       ; $02DDE0 | |
    TAY                                                                         ; $02DDE1 |/
    LDA r_battle_character_visual_properties.1.pending_steps.w,X                ; $02DDE2 |\
    BNE +                                                                       ; $02DDE5 | | If the character has no pending steps, branch to later code.
    JMP @stationary                                                             ; $02DDE7 |/
+   INC <r_battle_current_slot_incapacitated                                    ; $02DDEA | If the character has pending steps, flag them as incapacitated.
    LDA r_battle_character_visual_properties.1.flags.w,X                        ; $02DDEC |\
    STA <r_battle_visual_properties_tmp_1                                       ; $02DDEF | | Branch based on whether or not the retreating flag is set.
    AND #CHARACTER_VISUAL_FLAG_RETREATING.b                                     ; $02DDF1 | |
    BEQ ++                                                                      ; $02DDF3 |/
    LDA r_battle_character_visual_properties.1.flags.w,X                        ; $02DDF5 |\
    ORA #CHARACTER_VISUAL_FLAG_REVERSE.b                                        ; $02DDF8 | | Otherwise, set the reverse flag.
    STA r_battle_character_visual_properties.1.flags.w,X                        ; $02DDFA |/
    LDA <r_battle_visual_properties_tmp_1                                       ; $02DDFD |\
    AND #CHARACTER_VISUAL_FLAG_LARGE.b                                          ; $02DDFF | | If the large flag isn't set, set the base tile to 256 and load a
    BNE +                                                                       ; $02DE01 | | 1 into the accumulator, as the small sprite will move one pixel.
    JSR _battle_set_character_sprite_tile_to_256                                ; $02DE03 | |
    LDA #1.b                                                                    ; $02DE06 | |
    BRA +++                                                                     ; $02DE08 |/
+   LDA #2.b                                                                    ; $02DE0A |\ Otherwise, load a 2 into the accumulator and branch forward.
    BRA +++                                                                     ; $02DE0C |/
++  LDA r_battle_character_visual_properties.1.flags.w,X                        ; $02DE0E |\
    AND #CHARACTER_VISUAL_FLAG_REVERSE.b ~ $FF                                  ; $02DE11 | | If the retreating flag is not set, unset the reverse flag. If the
    STA r_battle_character_visual_properties.1.flags.w,X                        ; $02DE13 | | large flag is not set, set the base tile to 256 and set the value
    LDA <r_battle_visual_properties_tmp_1                                       ; $02DE16 | | to -1. Otherwise, set the value to -2.
    AND #CHARACTER_VISUAL_FLAG_LARGE.b                                          ; $02DE18 | |
    BNE +                                                                       ; $02DE1A | |
    JSR _battle_set_character_sprite_tile_to_256                                ; $02DE1C | |
    LDA #-1.b                                                                   ; $02DE1F | |
    BRA +++                                                                     ; $02DE21 | |
+   LDA #-2.b                                                                   ; $02DE23 |/
+++ STA <r_battle_visual_properties_tmp_2                                       ; $02DE25 | Save the value in the accumulator to a temporary variable.
    LDA r_battle_character_visual_properties.1.x.w,X                            ; $02DE27 |\
    CLC                                                                         ; $02DE2A | | Add the value to the character's X coordinate.
    ADC <r_battle_visual_properties_tmp_2                                       ; $02DE2B | |
    STA r_battle_character_visual_properties.1.x.w,X                            ; $02DE2D |/
    LDA <r_battle_visual_properties_tmp_1                                       ; $02DE30 |\
    AND #CHARACTER_VISUAL_FLAG_TOAD.b                                           ; $02DE32 | | If the toad flag isn't set, skip this next block.
    BEQ +                                                                       ; $02DE34 |/
    LDA r_battle_character_visual_properties.1.frame_counter.w,X                ; $02DE36 |\
    AND #%00000111.b                                                            ; $02DE39 | | Set the Y offset by reading the value from the toad hopping data
    PHX                                                                         ; $02DE3B | | in ROM, indexed by taking the frame counter mod 8.
    TAX                                                                         ; $02DE3C | |
    LDA bank0D.battle_toad_hop_data.l,X                                         ; $02DE3D | |
    PLX                                                                         ; $02DE41 | |
    STA r_battle_character_visual_properties.1.y_offset.w,X                     ; $02DE42 |/
    LDA #%00000011.b                                                            ; $02DE45 |\ Configure the character's pose frame counter to advance every four
    STA r_battle_character_visual_properties.1.pose_frame_mask.w,X              ; $02DE47 |/ frames.
+   LDA #BATTLE_POSE_WALKING.b                                                  ; $02DE4A |\ Set the character's pose to walking.
    STA r_battle_character_visual_properties.1.pose.w,X                         ; $02DE4C |/
    DEC r_battle_character_visual_properties.1.pending_steps.w,X                ; $02DE4F | Decrement the pending steps value.
    PHX                                                                         ; $02DE52 |\
    LDA <r_battle_draw_character_sprites_slot                                   ; $02DE53 | | Transfer the current slot into the X register.
    TAX                                                                         ; $02DE55 |/
    LDA r_battle_character_status_icons.w,X                                     ; $02DE56 |\ Copy the character's status icon value to the status icon variable.
    STA r_battle_draw_character_sprites_status_icon.w                           ; $02DE59 |/
    LDA r_battle_character_pose_base.w,X                                        ; $02DE5C |\ Load the character's pose base value.
    STA r_battle_draw_character_sprites_pose_base.w                             ; $02DE5F |/
    LDA r_battle_character_pose.w,X                                             ; $02DE62 |\
    CMP #BATTLE_POSE_SPECIAL.b                                                  ; $02DE65 | | Skip past the next block if the character's pose is not special or
    BEQ +                                                                       ; $02DE67 | | reeling.
    CMP #BATTLE_POSE_REELING.b                                                  ; $02DE69 | |
    BNE ++                                                                      ; $02DE6B |/
+   JSR _check_visual_status                                                    ; $02DE6D |\ Skip the next block if the character has any of several statuses.
    BCC ++                                                                      ; $02DE70 |/
    LDA <r_battle_draw_character_sprites_slot                                   ; $02DE72 |\
    TAX                                                                         ; $02DE74 | | If the character's pose is not invisible (which it shouldn't be
    LDA r_battle_character_pose.w,X                                             ; $02DE75 | | since it can only be special or reeling at this point), copy the
    BEQ ++                                                                      ; $02DE78 | | pose to the visual properties pose (overwriting the walking that
    PLX                                                                         ; $02DE7A | | was set above).
    STA r_battle_character_visual_properties.1.pose.w,X                         ; $02DE7B | |
    BRA +                                                                       ; $02DE7E |/
++  PLX                                                                         ; $02DE80 |\
+   PLY                                                                         ; $02DE81 | | Restore X and Y registers.
    PLX                                                                         ; $02DE82 |/
    RTS                                                                         ; $02DE83
@stationary:
    JSR _battle_update_character_palette                                        ; $02DE84 | Update the character's palette.
    STZ r_battle_draw_character_sprites_status_icon.w                           ; $02DE87 | Zero out the status icon variable.
    STZ r_battle_character_visual_properties.1.stone_status.w,X                 ; $02DE8A | Zero out the character's stone status in the visual properties.
    LDA r_battle_suppress_character_y_offset_reset.w                            ; $02DE8D |\
    BNE +                                                                       ; $02DE90 | | If Y offset reset is not suppressed, zero out the Y offset.
    STZ r_battle_character_visual_properties.1.y_offset.w,X                     ; $02DE92 |/
+   LDA #BATTLE_POSE_NORMAL.b                                                   ; $02DE95 |\ Set the character's pose to normal.
    STA r_battle_character_visual_properties.1.pose.w,X                         ; $02DE97 |/
    LDA r_character_visual_status.1.status_1.w,Y                                ; $02DE9A |\
    STA <r_battle_visual_properties_tmp_status.status_1                         ; $02DE9D | | Copy the visual status bytes for this character to local temporary
    LDA r_character_visual_status.1.status_2.w,Y                                ; $02DE9F | | variables.
    STA <r_battle_visual_properties_tmp_status.status_2                         ; $02DEA2 | |
    LDA r_character_visual_status.1.status_3.w,Y                                ; $02DEA4 | |
    STA <r_battle_visual_properties_tmp_status.status_3                         ; $02DEA7 | |
    LDA r_character_visual_status.1.status_4.w,Y                                ; $02DEA9 | |
    STA <r_battle_visual_properties_tmp_status.status_4                         ; $02DEAC |/
    LDA <r_battle_visual_properties_tmp_status.status_1                         ; $02DEAE |\
    AND #STATUS_1_SWOON.b                                                       ; $02DEB0 | | If the swoon status is set, flag them as incapacitated and set the
    BEQ +                                                                       ; $02DEB2 | | character's visual pose to swoon.
    INC <r_battle_current_slot_incapacitated                                    ; $02DEB4 | |
    LDA #BATTLE_POSE_SWOON.b                                                    ; $02DEB6 | |
    STA r_battle_character_visual_properties.1.pose.w,X                         ; $02DEB8 | |
    JMP @finalize                                                               ; $02DEBB |/
+   LDA <r_battle_visual_properties_tmp_status.status_1                         ; $02DEBE |\
    AND #STATUS_1_STONE.b                                                       ; $02DEC0 | | If the stone status is set, flag them as incapacitated, set the
    BEQ +                                                                       ; $02DEC2 | | stone status to full, and set the battle pose to crouching.
    INC <r_battle_current_slot_incapacitated                                    ; $02DEC4 | |
    LDA #STONE_STATUS_FULL.b                                                    ; $02DEC6 | |
    STA r_battle_character_visual_properties.1.stone_status.w,X                 ; $02DEC8 | |
    INC A                                                                       ; $02DECB | |
    STA r_battle_character_visual_properties.1.pose.w,X                         ; $02DECC | |
    JMP @finalize                                                               ; $02DECF |/
+   LDA <r_battle_visual_properties_tmp_status.status_2                         ; $02DED2 |\
    AND #STATUS_2_STONE_STATUS.b                                                ; $02DED4 | | Transfer the character's stone status over.
    STA r_battle_character_visual_properties.1.stone_status.w,X                 ; $02DED6 |/
    LDA <r_battle_visual_properties_tmp_status.status_1                         ; $02DED9 |\
    AND #STATUS_1_POISON.b                                                      ; $02DEDB | | If the character is poisoned, set the character to the poison
    BEQ +                                                                       ; $02DEDD | | palette and set their pose to crouching.
    JSR _set_character_palette_poison                                           ; $02DEDF | |
    LDA #BATTLE_POSE_CROUCHING.b                                                ; $02DEE2 | |
    STA r_battle_character_visual_properties.1.pose.w,X                         ; $02DEE4 |/
+   LDA <r_battle_visual_properties_tmp_status.status_3                         ; $02DEE7 |\
    AND #STATUS_3_COUNT.b                                                       ; $02DEE9 | | If the count status is set and the character isn't moving, set
    BEQ ++                                                                      ; $02DEEB | | the count status icon.
    PHY                                                                         ; $02DEED | |
    LDA <r_battle_draw_character_sprites_slot                                   ; $02DEEE | |
    TAY                                                                         ; $02DEF0 | |
    LDA r_battle_character_moving.w,Y                                           ; $02DEF1 | |
    BNE +                                                                       ; $02DEF4 | |
    PLY                                                                         ; $02DEF6 | |
    JSL bank01.set_status_icon_count.l                                          ; $02DEF7 | |
    JMP @charm_check                                                            ; $02DEFB |/
+   PLY                                                                         ; $02DEFE |\
++  LDA <r_battle_visual_properties_tmp_status.status_3                         ; $02DEFF | | If the magnetized status is set, set the pose to crouching and
    AND #STATUS_3_MAGNETIZED.b                                                  ; $02DF01 | | draw the appropriate status icon.
    BEQ +                                                                       ; $02DF03 | |
    LDA #BATTLE_POSE_CROUCHING.b                                                ; $02DF05 | |
    STA r_battle_character_visual_properties.1.pose.w,X                         ; $02DF07 | |
    STA r_battle_draw_character_sprites_status_icon.w                           ; $02DF0A | |
    JMP @charm_check                                                            ; $02DF0D |/
+   LDA <r_battle_visual_properties_tmp_status.status_1                         ; $02DF10 |\
    AND #STATUS_1_MUTE.b                                                        ; $02DF12 | | If the mute status is set, set the pose to crouching and draw the
    BEQ +                                                                       ; $02DF14 | | mute status icon.
    LDA #BATTLE_POSE_CROUCHING.b                                                ; $02DF16 | |
    STA r_battle_character_visual_properties.1.pose.w,X                         ; $02DF18 | |
    LDA #SPRITE_STATUS_ICON_MUTE.b                                              ; $02DF1B | |
    STA r_battle_draw_character_sprites_status_icon.w                           ; $02DF1D | |
    JMP @charm_check                                                            ; $02DF20 |/
+   LDA <r_battle_visual_properties_tmp_status.status_1                         ; $02DF23 |\
    AND #STATUS_1_DARKNESS.b                                                    ; $02DF25 | | If the darkness status is set, set the crouching pose and draw the
    BEQ +                                                                       ; $02DF27 | | darkness status icon.
    LDA #BATTLE_POSE_CROUCHING.b                                                ; $02DF29 | |
    STA r_battle_character_visual_properties.1.pose.w,X                         ; $02DF2B | |
    LDA #SPRITE_STATUS_ICON_DARKNESS.b                                          ; $02DF2E | |
    STA r_battle_draw_character_sprites_status_icon.w                           ; $02DF30 | |
    JMP @charm_check                                                            ; $02DF33 |/
+   LDA <r_battle_visual_properties_tmp_status.status_2                         ; $02DF36 |\
    AND #STATUS_2_CURSE.b                                                       ; $02DF38 | |
    BEQ +                                                                       ; $02DF3A | | If the curse status is set, set the crouching pose and and then
    LDA #BATTLE_POSE_CROUCHING.b                                                ; $02DF3C | | draw the curse status icon (which has an ID twice that of the
    STA r_battle_character_visual_properties.1.pose.w,X                         ; $02DF3E | | crouching pose).
    ASL A                                                                       ; $02DF41 | |
    STA r_battle_draw_character_sprites_status_icon.w                           ; $02DF42 | |
    JMP @charm_check                                                            ; $02DF45 |/
+   PHY                                                                         ; $02DF48 |\
    LDA <r_battle_draw_character_sprites_slot                                   ; $02DF49 | | NOTE: A completely useless block of code that doesn't actually do
    TAY                                                                         ; $02DF4B | |       anything. It's possible they originally intended to do
    LDA r_battle_character_moving.w,Y                                           ; $02DF4C | |       different things depending on if the character was moving or
    BEQ +                                                                       ; $02DF4F | |       not.
    PLY                                                                         ; $02DF51 | |
    JMP ++                                                                      ; $02DF52 | |
+   PLY                                                                         ; $02DF55 |/
++  LDA <r_battle_visual_properties_tmp_status.status_2                         ; $02DF56 |\
    AND #STATUS_2_PARALYZE.b                                                    ; $02DF58 | | If the paralyze status is set, flag them as incapacitated, set the
    BEQ +                                                                       ; $02DF5A | | pose to crouching and draw the paralyzed status icon.
    INC <r_battle_current_slot_incapacitated                                    ; $02DF5C | |
    LDA #BATTLE_POSE_CROUCHING.b                                                ; $02DF5E | |
    STA r_battle_character_visual_properties.1.pose.w,X                         ; $02DF60 | |
    STA r_battle_draw_character_sprites_status_icon.w                           ; $02DF63 | |
    JMP @charm_check                                                            ; $02DF66 |/
+   LDA <r_battle_visual_properties_tmp_status.status_2                         ; $02DF69 |\
    AND #STATUS_2_SLEEP.b                                                       ; $02DF6B | | If the sleep status is set, flag them as incapacitated, set the
    BEQ +                                                                       ; $02DF6D | | pose to crouching, and draw the sleeping status icon.
    INC <r_battle_current_slot_incapacitated                                    ; $02DF6F | |
    LDA #BATTLE_POSE_CROUCHING.b                                                ; $02DF71 | |
    STA r_battle_character_visual_properties.1.pose.w,X                         ; $02DF73 | |
    INC A                                                                       ; $02DF76 | |
    STA r_battle_draw_character_sprites_status_icon.w                           ; $02DF77 | |
    JMP @charm_check                                                            ; $02DF7A |/
+   LDA <r_battle_visual_properties_tmp_status.status_2.b                       ; $02DF7D |\
    AND #STATUS_2_CHARM.b                                                       ; $02DF7F | | If the charm status is set, flag them as incapacitated and draw
    BEQ +                                                                       ; $02DF81 | | the charm status icon.
    INC <r_battle_current_slot_incapacitated                                    ; $02DF83 | |
    LDA #SPRITE_STATUS_ICON_CHARM.b                                             ; $02DF85 | |
    STA r_battle_draw_character_sprites_status_icon.w                           ; $02DF87 | |
    JMP @charm_check                                                            ; $02DF8A |/
+   LDA <r_battle_visual_properties_tmp_status.status_2.b                       ; $02DF8D |\
    AND #STATUS_2_FLOAT.b                                                       ; $02DF8F | | Skip the next block if the character isn't floating.
    BEQ +                                                                       ; $02DF91 |/
    LDA r_battle_running.w                                                      ; $02DF93 |\ Skip the next block if the party is running.
    BNE +                                                                       ; $02DF96 |/
    LDA <r_battle_current_slot_incapacitated                                    ; $02DF98 |\ Skip the next block if the character is incapacitated.
    BNE +                                                                       ; $02DF9A |/
    PHX                                                                         ; $02DF9C |\
    LDA #4.b                                                                    ; $02DF9D | | Set the sine amplitude to 4.
    STA <r_math_multiply_8bit_reg_arg_2                                         ; $02DF9F |/
    LDA <r_battle_draw_character_sprites_slot                                   ; $02DFA1 |\
    ASL A                                                                       ; $02DFA3 | | Determine the index by taking the character slot, multiplying by
    ASL A                                                                       ; $02DFA4 | | four, adding the frame counter, and then multiplying the entire
    CLC                                                                         ; $02DFA5 | | thing by eight.
    ADC r_battle_frame_counter.w                                                ; $02DFA6 | |
    ASL A                                                                       ; $02DFA9 | |
    ASL A                                                                       ; $02DFAA | |
    ASL A                                                                       ; $02DFAB |/
    JSR _get_sine_value                                                         ; $02DFAC | Get the sine value for the given parameters.
    PLX                                                                         ; $02DFAF |\
    CLC                                                                         ; $02DFB0 | | Subtract the base value of -8 to determine the Y offset.
    ADC #-8.b                                                                   ; $02DFB1 | |
    STA r_battle_character_visual_properties.1.y_offset.w,X                     ; $02DFB3 |/
    LDA #SPRITE_STATUS_ICON_FLOAT.b                                             ; $02DFB6 |\ Draw a float status icon.
    STA r_battle_draw_character_sprites_status_icon.w                           ; $02DFB8 |/
    JMP @charm_check                                                            ; $02DFBB | Jump to the next section.
+   LDA <r_battle_visual_properties_tmp_status.status_4.b                       ; $02DFBE |\
    AND #STATUS_4_CRITICAL.b                                                    ; $02DFC0 | | If the character has the HP critical status, set their pose to
    BEQ @charm_check                                                            ; $02DFC2 | | crouching and draw the HP critical status icon.
    LDA #BATTLE_POSE_CROUCHING.b                                                ; $02DFC4 | |
    STA r_battle_character_visual_properties.1.pose.w,X                         ; $02DFC6 | |
    DEC A                                                                       ; $02DFC9 | |
    STA r_battle_draw_character_sprites_status_icon.w                           ; $02DFCA |/
@charm_check:
    LDA <r_battle_visual_properties_tmp_status.status_2.b                       ; $02DFCD |\
    AND #STATUS_2_CHARM.b                                                       ; $02DFCF | | If the character is charmed, call the charm version of the pending
    BEQ +                                                                       ; $02DFD1 | | steps update. Otherwise, call the normal version.
    JSR _battle_update_pending_steps_charm                                      ; $02DFD3 | |
    BRA @finalize                                                               ; $02DFD6 | |
+   JSR _battle_update_pending_steps_normal                                     ; $02DFD8 |/
@finalize:
    JSR _battle_character_set_pose_base                                         ; $02DFDB | Set the pose base for this slot.
    JSR _battle_update_pending_steps_acting                                     ; $02DFDE | Update pending steps for the acting position.
    JSR _check_visual_status                                                    ; $02DFE1 |\ Skip this block if the character has a status that will affect
    BCC ++                                                                      ; $02DFE4 |/ their appearance.
    PHX                                                                         ; $02DFE6 |\
    LDA <r_battle_draw_character_sprites_slot                                   ; $02DFE7 | | Otherwise, if the character has a non-zero pose set in the pose
    TAX                                                                         ; $02DFE9 | | variable in RAM, change their visual pose to that value.
    LDA r_battle_character_pose.w,X                                             ; $02DFEA | |
    BEQ +                                                                       ; $02DFED | |
    PLX                                                                         ; $02DFEF | |
    STA r_battle_character_visual_properties.1.pose.w,X                         ; $02DFF0 | |
    BRA ++                                                                      ; $02DFF3 | |
+   PLX                                                                         ; $02DFF5 |/
++  LDA r_battle_running.w                                                      ; $02DFF6 |\
    BEQ +                                                                       ; $02DFF9 | | If the party is running, the character in this slot isn't
    LDA <r_battle_current_slot_incapacitated                                    ; $02DFFB | | incapacitated, and the slot isn't empty, set the character's pose
    BNE +                                                                       ; $02DFFD | | to walking.
    LDA <r_battle_draw_character_sprites_slot                                   ; $02DFFF | |
    TAY                                                                         ; $02E001 | |
    LDA r_character_slot_if_active.w,Y                                          ; $02E002 | |
    CMP #$FF.b                                                                  ; $02E005 | |
    BEQ +                                                                       ; $02E007 | |
    LDA #BATTLE_POSE_WALKING.b                                                  ; $02E009 | |
    STA r_battle_character_visual_properties.1.pose.w,X                         ; $02E00B |/
+   PLY                                                                         ; $02E00E |\ Restore the X and Y registers
    PLX                                                                         ; $02E00F |/
    RTS                                                                         ; $02E010

; get_sine_value ($02:E011)
;
; Calls _get_sine_wave, which returns the value of a sine wave with a period of
; 256.
get_sine_value:
    JSR _get_sine_value                                                         ; $02E011
    RTL                                                                         ; $02E014

; _get_sine_value ($02:E015)
;
; Returns the value of a sine wave with a period of 256. The amplitude is
; determined by the value in $1E, which is approximately double the magnitude.
; However, not all values will necessarily be used.
_get_sine_value:
    TAX                                                                         ; $02E015 |\ Read the designated value from the sine lookup table.
    LDA bank1C.sine_data.l,X                                                    ; $02E016 |/
    BPL +                                                                       ; $02E01A |\
    EOR #%11111111.b                                                            ; $02E01C | | If the read value is $80 or greater (negative if this is signed),
    STA <r_math_multiply_8bit_reg_arg_1                                         ; $02E01E | | flip the bits, multiply by the other argument and then take the
    JSR _math_multiply_8bit_reg                                                 ; $02E020 | | high byte of the result. Flip its bits and add one.
    LDA <r_math_multiply_8bit_reg_result_hi                                     ; $02E023 | |
    EOR #%11111111.b                                                            ; $02E025 | |
    INC A                                                                       ; $02E027 |/
    BPL ++                                                                      ; $02E028 | If the result is positive, branch to clear the carry.
-   SEC                                                                         ; $02E02A |\ Otherwise, set the carry bit and return.
    RTS                                                                         ; $02E02B |/
+   STA <r_math_multiply_8bit_reg_arg_1                                         ; $02E02C |\
    JSR _math_multiply_8bit_reg                                                 ; $02E02E | | If the value was originally positive, multiply by the argument.
    LDA <r_math_multiply_8bit_reg_result_hi                                     ; $02E031 |/
    BMI -                                                                       ; $02E033 |\ Again, set the set the carry bit if the result was negative.
++  CLC                                                                         ; $02E035 |/
    RTS                                                                         ; $02E036

; _battle_character_set_pose_base ($02:E037)
;
; Depending on the sprite/class and status of the character whose visual status
; offset is passed in the Y register, determines the correct pose base and
; stores that value to both $F077 and the array at $F094.
_battle_character_set_pose_base:
    LDA r_character_visual_status.1.status_1.w,Y                                ; $02E037 |\
    AND #(STATUS_1_SMALL | STATUS_1_TOAD).b                                     ; $02E03A | | If the character is a toad, set the pose base to $20. If the
    BEQ +++                                                                     ; $02E03C | | character is small, set it to $10. In either case, set the base
    AND #STATUS_1_TOAD.b                                                        ; $02E03E | | sprite tile to 256 and branch to the end.
    BEQ +                                                                       ; $02E040 | |
    LDA #BATTLE_POSE_BASE_TOAD.b                                                ; $02E042 | |
    BRA ++                                                                      ; $02E044 | |
+   LDA #BATTLE_POSE_BASE_SMALL.b                                               ; $02E046 | |
++  STA r_battle_draw_character_sprites_pose_base.w                             ; $02E048 | |
    JSR _battle_set_character_sprite_tile_to_256                                ; $02E04B | |
    BRA @done                                                                   ; $02E04E |/
+++ LDA r_character_visual_status.1.status_1.w,Y                                ; $02E050 |\
    AND #STATUS_1_PIG.b                                                         ; $02E053 | | If the character is a pig, load $40 into the accumulator and
    BEQ +                                                                       ; $02E055 | | branch to near the end.
    LDA #BATTLE_POSE_BASE_PIG.b                                                 ; $02E057 | |
    BRA ++                                                                      ; $02E059 |/
+   PHY                                                                         ; $02E05B | Save the current value of the Y register.
    TYA                                                                         ; $02E05C |\
    LSR A                                                                       ; $02E05D | | Divide the Y register by four to get the slot number.
    LSR A                                                                       ; $02E05E | |
    TAY                                                                         ; $02E05F |/
    LDA r_battle_character_sprite.w,Y                                           ; $02E060 |\
    CMP #CLASS_GOLBEZ.b                                                         ; $02E063 | | If the character has a sprite/class of Golbez or higher, load $30
    BCC +++                                                                     ; $02E065 | | into the accumulator.
    PLY                                                                         ; $02E067 | |
    CMP #CLASS_GOLBEZ.b                                                         ; $02E068 | |
    BNE +                                                                       ; $02E06A | |
    LDA #BATTLE_POSE_BASE_GOLBEZ.b                                              ; $02E06C | |
    BRA ++                                                                      ; $02E06E | |
+   LDA #BATTLE_POSE_BASE_GOLBEZ.b                                              ; $02E070 |/
++  STA r_battle_draw_character_sprites_pose_base.w                             ; $02E072 |\ If the character was a pig or Golbez or higher, store the loaded
    BRA @done                                                                   ; $02E075 |/ value as the pose base
+++ PLY                                                                         ; $02E077 |\ Otherwise, set the pose base to zero.
    STZ r_battle_draw_character_sprites_pose_base.w                             ; $02E078 |/
@done:
    PHX                                                                         ; $02E07B |\
    LDA <r_battle_draw_character_sprites_slot                                   ; $02E07C | | Save the pose base for the current slot to a separate array.
    TAX                                                                         ; $02E07E | |
    LDA r_battle_draw_character_sprites_pose_base.w                             ; $02E07F | |
    STA r_battle_character_pose_base.w,X                                        ; $02E082 | |
    PLX                                                                         ; $02E085 |/
    RTS                                                                         ; $02E086

; _battle_load_character_sprites ($02:E087)
;
; Loops through the five character slots, loading the sprite data for each slot
; into VRAM. If the character is a pig, loads a pig sprite instead of their
; default sprite.
_battle_load_character_sprites:
    LDX #0000.w                                                                 ; $02E087 |\ Initialize the VRAM address variable to $0000, which is the start
    STX <r_battle_load_character_sprites_vram_address                           ; $02E08A |/ of the OAM tile area.
@start:
    PHX                                                                         ; $02E08C | Push the current slot (initially initalized to zero).
    LDA r_character_slot_if_active.w,X                                          ; $02E08D |\
    CMP #$FF.b                                                                  ; $02E090 | | If the slot is empty, skip to the next iteration.
    BEQ @next                                                                   ; $02E092 |/
    PHX                                                                         ; $02E094 | Push the current slot again.
    JSR _multiply_x_by_128                                                      ; $02E095 | Calculate the offset into this slot's battle stats record.
    LDA r_character_battle.1.status_1.w,X                                       ; $02E098 |\
    AND #STATUS_1_PIG.b                                                         ; $02E09B | | If the character currently has the pig status, load the pig sprite
    BEQ +                                                                       ; $02E09D | | value into the accumulator.
    LDA #CLASS_PIG.b                                                            ; $02E09F | |
    BRA ++                                                                      ; $02E0A1 |/
+   LDA r_character_battle.1.sprite_class.w,X                                   ; $02E0A3 |\ Otherwise, load the actual value of that character's sprite into
    AND #%00011111.b                                                            ; $02E0A6 |/ the accumulator.
++  PLX                                                                         ; $02E0A8 | Restore the slot number to the X register.
    STA r_battle_character_sprite.w,X                                           ; $02E0A9 | Write the calculated sprite number for this character to RAM.
    CMP #CLASS_GOLBEZ.b                                                         ; $02E0AC |\
    BCC +                                                                       ; $02E0AE | | If the sprite is $0F or greater, use a special routine that loads
    JSR _battle_load_character_sprite_get_special_offset                        ; $02E0B0 | | the offset directly instead of calculating it.
    JMP ++                                                                      ; $02E0B3 |/
+   TAX                                                                         ; $02E0B6 |\
    STX <r_math_multiply_16bit_arg_1                                            ; $02E0B7 | | Otherwise, calculate the offset directly by multiplying the sprite
    LDX #bank1A._sizeof_battle_sprite_character_cecil_dknight_data.w            ; $02E0B9 | | number by $800.
    STX <r_math_multiply_16bit_arg_2                                            ; $02E0BC | |
    JSR _math_multiply_16bit                                                    ; $02E0BE |/
++  REP #FLAG_P_ACCUMULATOR                                                     ; $02E0C1 |\
    LDA <r_math_multiply_16bit_result_lo                                        ; $02E0C3 | | Either way, set the X register to the calculated or loaded offset
    CLC                                                                         ; $02E0C5 | | plus the base address for the sprite data.
    ADC #bank1A.battle_sprite_character_cecil_dknight_data.w                    ; $02E0C6 | |
    TAX                                                                         ; $02E0C9 |/
    LDA #bank1A._sizeof_battle_sprite_character_cecil_dknight_data.w            ; $02E0CA |\ Set the number of bytes that need to be loaded.
    STA <r_battle_start_vram_dma5_arg_bytes                                     ; $02E0CD |/
    LDY <r_battle_load_character_sprites_vram_address                           ; $02E0CF | Set the Y register to the target VRAM address.
    TDC                                                                         ; $02E0D1 |\
    SEP #FLAG_P_ACCUMULATOR                                                     ; $02E0D2 | | Set the accumulator to the bank number.
    LDA #:bank1A.battle_sprite_character_cecil_dknight_data                     ; $02E0D4 |/
    JSR _start_vram_dma5                                                        ; $02E0D6 | Transfer the sprite data to VRAM.
@next:
    REP #FLAG_P_ACCUMULATOR                                                     ; $02E0D9 |\
    LDA <r_battle_load_character_sprites_vram_address                           ; $02E0DB | | Add $400 to the VRAM address to move to the spot for the next
    CLC                                                                         ; $02E0DD | | character.
    ADC #$0400.w                                                                ; $02E0DE | |
    STA <r_battle_load_character_sprites_vram_address                           ; $02E0E1 | |
    TDC                                                                         ; $02E0E3 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $02E0E4 |/
    PLX                                                                         ; $02E0E6 |\
    INX                                                                         ; $02E0E7 | | Increment the slot number and loop until all five have been done.
    CPX #5.w                                                                    ; $02E0E8 | |
    BNE @start                                                                  ; $02E0EB |/
    RTS                                                                         ; $02E0ED

; _battle_load_character_sprite_get_special_offset ($02:E0EE)
;
; For the two character sprites at values of $0F and greater, loads the offset
; into the sprite data, as these offsets cannot be calculated due to the varying
; size of the last three character sprites. The 16-bit result is returned in
; $2A.
_battle_load_character_sprite_get_special_offset:
    SEC                                                                         ; $02E0EE |\ Subtract the lowest value that uses this function.
    SBC #CLASS_GOLBEZ.b                                                         ; $02E0EF |/
    ASL A                                                                       ; $02E0F1 |\ Multiply by two to determine the index value.
    TAX                                                                         ; $02E0F2 |/
    LDA bank16.battle_character_sprite_special_offset_data.l + 0,X              ; $02E0F3 |\
    STA <r_math_multiply_16bit_result_lo_lo                                     ; $02E0F7 | | Load the offset into the same place the calculated version will
    LDA bank16.battle_character_sprite_special_offset_data.l + 1,X              ; $02E0F9 | | end up.
    STA <r_math_multiply_16bit_result_lo_hi                                     ; $02E0FD |/
    RTS                                                                         ; $02E0FF

; _multiply_x_by_128 ($02:E100)
;
; Calls _multiply_x_by_128, which multiplies the value in the X register by
; 128, leaving the result in the X register.
multiply_x_by_128:
    JSR _multiply_x_by_128                                                      ; $02E100 | Call the multiply X by 128 function.
    RTL                                                                         ; $02E103

; _multiply_x_by_128 ($02:E104)
;
; Multiplies the value in the X register by 128, storing the result in the X
; register. Any overflow is lost, except for any bit from the last shift.
_multiply_x_by_128:
    REP #FLAG_P_ACCUMULATOR.b                                                   ; $02E104 |\
    TXA                                                                         ; $02E106 | | Multiply the value in the X register by 128 and store it back in
    ASL A                                                                       ; $02E107 | | the X register.
    ASL A                                                                       ; $02E108 | |
    ASL A                                                                       ; $02E109 | |
    ASL A                                                                       ; $02E10A | |
    ASL A                                                                       ; $02E10B | |
    ASL A                                                                       ; $02E10C | |
    ASL A                                                                       ; $02E10D | |
    TAX                                                                         ; $02E10E | |
    TDC                                                                         ; $02E10F | |
    SEP #FLAG_P_ACCUMULATOR.b                                                   ; $02E110 |/
    RTS                                                                         ; $02E112

; _battle_initialize_character_visual_properties ($02:E113)
;
; Loops through the five character slots, initializing the visual properties for
; each.
_battle_initialize_character_visual_properties:
    LDA r_party_formation_two_front.w                                           ; $02E113 |\
    STA r_battle_party_formation_two_front.w                                    ; $02E116 | | Copy the party formation into the battle party formation value.
    LDA r_formation_back_attack_copy.w                                          ; $02E119 | | If the encounter is a back attack, flip the bit, as the party is
    BEQ +                                                                       ; $02E11C | | reversed.
    LDA r_battle_party_formation_two_front.w                                    ; $02E11E | |
    EOR #%00000001.b                                                            ; $02E121 | |
    STA r_battle_party_formation_two_front.w                                    ; $02E123 |/
+   LDX #0.w                                                                    ; $02E126
@loop_start:
    PHX                                                                         ; $02E129 |\ Save the slot number to the stack and to a temporary variable.
    STX <r_battle_generic_tmp_index                                             ; $02E12A |/
    TXA                                                                         ; $02E12C |\ Set this slot as the current slot being drawn.
    STA <r_battle_draw_character_sprites_slot                                   ; $02E12D |/
    ASL A                                                                       ; $02E12F |\
    ASL A                                                                       ; $02E130 | | Set the character's OAM index to their normal OAM index value
    ASL A                                                                       ; $02E131 | | based on the slot number. This leaves the first two entries in
    ASL A                                                                       ; $02E132 | | their allocation unused.
    TAY                                                                         ; $02E133 | |
    LDA bank16.battle_character_slot_oam_index_normal_data.l,X                  ; $02E134 | |
    STA r_battle_character_visual_properties.1.oam_index.w,Y                    ; $02E138 |/
    PHX                                                                         ; $02E13B |\
    LDA r_character_slot_if_active.w,X                                          ; $02E13C | | If this slot does not have a character in it, load zero into the
    CMP #$FF.b                                                                  ; $02E13F | | accumulator and branch ahead to write that as the ID.
    BNE +                                                                       ; $02E141 | |
    TDC                                                                         ; $02E143 | |
    BRA ++                                                                      ; $02E144 |/
+   JSR _multiply_x_by_128                                                      ; $02E146 |\
    LDA r_battle_formation_hi.w                                                 ; $02E149 | | If the current battle is the battle against Golbez at the Castle
    BEQ +                                                                       ; $02E14C | | of Dwarves and if the current character is a Caller, set two
    LDA r_battle_formation_lo.w                                                 ; $02E14E | | status bits on that character. One is jumping, but the other is
    CMP #<BATTLE_FORMATION_GOLBEZ_SHADOW                                        ; $02E151 | | magnetized, which prevents her from acting.
    BNE +                                                                       ; $02E153 | |
    LDA r_character_battle.1.sprite_class.w,X                                   ; $02E155 | | TODO: What's the benefit of jumping?
    AND #%00001111.b                                                            ; $02E158 | |
    CMP #CLASS_CALLER.b                                                         ; $02E15A | |
    BNE +                                                                       ; $02E15C | |
    LDA r_character_battle.1.status_3.w,X                                       ; $02E15E | |
    ORA #STATUS_3_JUMPING.b | STATUS_3_MAGNETIZED                               ; $02E161 | |
    STA r_character_battle.1.status_3.w,X                                       ; $02E163 |/
    LDX <r_battle_generic_tmp_index                                             ; $02E166 |\
    LDA #1.b                                                                    ; $02E168 | | Additionally flag her as invisible so her name and stats don't
    STA r_battle_character_slot_invisible.w,X                                   ; $02E16A | | appear at the bottom of the screen.
    TDC                                                                         ; $02E16D |/
    BRA ++                                                                      ; $02E16E |\
+   LDA r_character_battle.1.id.w,X                                             ; $02E170 | | If the character is not Rydia in that battle, load the correct ID.
    AND #%00111111.b                                                            ; $02E173 |/
++  PLX                                                                         ; $02E175 | Load the slot number back into the X register.
    STA r_battle_character_visual_properties.1.id.w,Y                           ; $02E176 | Save the value as the visual character ID.
    TDC                                                                         ; $02E179 |\
    STA r_battle_character_visual_properties.1.x_offset.w,Y                     ; $02E17A | | Set the character's X and Y offsets to zero, unset any visual
    STA r_battle_character_visual_properties.1.y_offset.w,Y                     ; $02E17D | | stone status, unset visual flags, set pending steps to zero and
    STA r_battle_character_visual_properties.1.stone_status.w,Y                 ; $02E180 | | set the frame counter to zero.
    STA r_battle_character_visual_properties.1.flags.w,Y                        ; $02E183 | |
    STA r_battle_character_visual_properties.1.pending_steps.w,Y                ; $02E186 | |
    STA r_battle_character_visual_properties.1.frame_counter.w,Y                ; $02E189 |/
    LDA r_prng_data.w,Y                                                         ; $02E18C |\ Set the pose frame counter to a value from the PRNG data at the
    STA r_battle_character_visual_properties.1.pose_frame_counter.w,Y           ; $02E18F |/ index of this character's visual properties.
    LDA #BATTLE_POSE_NORMAL.b                                                   ; $02E192 |\ Set the character's pose to normal.
    STA r_battle_character_visual_properties.1.pose.w,Y                         ; $02E194 |/
    LDA #1.b                                                                    ; $02E197 |\ Enable pose animation.
    STA r_battle_character_visual_properties.1.animate_pose.w,Y                 ; $02E199 |/
    LDA r_battle_party_formation_two_front.w                                    ; $02E19C |\
    BNE +                                                                       ; $02E19F | | Load the X coordinate depending on the slot and party formation.
    LDA bank16.battle_party_three_front_slot_x_coordinate_data.l,X              ; $02E1A1 | |
    BRA ++                                                                      ; $02E1A5 | |
+   LDA bank16.battle_party_two_front_slot_x_coordinate_data.l,X                ; $02E1A7 |/
++  PHA                                                                         ; $02E1AB |\
    PHY                                                                         ; $02E1AC | | If the character has either the swoon or stone statuses, use the
    LDA <r_battle_draw_character_sprites_slot                                   ; $02E1AD | | loaded value as the character's X coordinate. Otherwise, set the
    ASL A                                                                       ; $02E1AF | | X coordinate to $F0.
    ASL A                                                                       ; $02E1B0 | |
    TAY                                                                         ; $02E1B1 | |
    LDA r_character_visual_status.1.status_1.w,Y                                ; $02E1B2 | |
    AND #(STATUS_1_SWOON | STATUS_1_STONE).b                                    ; $02E1B5 | |
    BEQ +                                                                       ; $02E1B7 | |
    PLY                                                                         ; $02E1B9 | |
    PLA                                                                         ; $02E1BA | |
    BRA ++                                                                      ; $02E1BB | |
+   PLY                                                                         ; $02E1BD | |
    PLA                                                                         ; $02E1BE | |
    LDA #BATTLE_COORDINATE_X_PARTY_RIGHT_EXIT.b                                 ; $02E1BF | |
++  STA r_battle_character_visual_properties.1.x.w,Y                            ; $02E1C1 |/
    LDA bank16.battle_character_slot_y_coordinate_data.l,X                      ; $02E1C4 |\ Set the character's Y coordinate based on their slot.
    STA r_battle_character_visual_properties.1.y.w,Y                            ; $02E1C8 |/
    JSR _battle_initialize_pending_steps                                        ; $02E1CB | Initialize the character's pending steps.
    TXA                                                                         ; $02E1CE |\
    ASL A                                                                       ; $02E1CF | | Set the character's base tile and OAM flags variables based on the
    TAX                                                                         ; $02E1D0 | | loaded base tile number for this slot.
    LDA bank16.battle_character_slot_base_tile_data.l + 0,X                     ; $02E1D1 | |
    STA r_battle_character_visual_properties.1.base_tile.w,Y                    ; $02E1D5 | |
    LDA bank16.battle_character_slot_base_tile_data.l + 1,X                     ; $02E1D8 | |
    STA r_battle_character_visual_properties.1.oam_flags.w,Y                    ; $02E1DC |/
    PLX                                                                         ; $02E1DF |\
    INX                                                                         ; $02E1E0 | | Increment the slot number and loop until all five characters have
    CPX #5.w                                                                    ; $02E1E1 | | been handled.
    BEQ +                                                                       ; $02E1E4 | |
    JMP @loop_start                                                             ; $02E1E6 |/
+   RTS                                                                         ; $02E1E9

; _battle_initialize_pending_steps ($02:E1EA)
;
; Given a slot value in $47 and the offset to that slot's visual properties in
; the Y register, initializes that slot's pending steps for the start of the
; battle and also sets either the toad or large visual flag as appropriate.
_battle_initialize_pending_steps:
    PHX                                                                         ; $02E1EA |\
    PHY                                                                         ; $02E1EB | | Preserve the X and Y registers, save the Y register value to a
    STY <r_battle_generic_tmp_index                                             ; $02E1EC | | temporary variable, and set the X register to that value.
    LDX <r_battle_generic_tmp_index                                             ; $02E1EE |/
    LDA <r_battle_draw_character_sprites_slot                                   ; $02E1F0 |\ Set the Y register to the character slot.
    TAY                                                                         ; $02E1F2 |/
    TDC                                                                         ; $02E1F3 |\ Reset the character's status icons value.
    STA r_battle_character_status_icons.w,Y                                     ; $02E1F4 |/
    LDA <r_battle_draw_character_sprites_slot                                   ; $02E1F7 |\
    ASL A                                                                       ; $02E1F9 | | If the character in this slot has either the swoon or stone
    ASL A                                                                       ; $02E1FA | | statuses, skip to the end of the function.
    TAY                                                                         ; $02E1FB | |
    LDA r_character_visual_status.1.status_1.w,Y                                ; $02E1FC | |
    AND #(STATUS_1_SWOON | STATUS_1_STONE).b                                    ; $02E1FF | |
    BNE @done                                                                   ; $02E201 |/
    LDA r_battle_party_formation_two_front.w                                    ; $02E203 |\
    BNE +                                                                       ; $02E206 | | If the party formation has three characters in front, load the
    PHX                                                                         ; $02E208 | | pending steps data for that formation.
    LDA <r_battle_draw_character_sprites_slot                                   ; $02E209 | |
    TAX                                                                         ; $02E20B | |
    LDA bank16.battle_party_three_front_slot_initial_pending_steps_data.l,X     ; $02E20C | |
    PLX                                                                         ; $02E210 |/
    BRA ++                                                                      ; $02E211 |\
+   PHX                                                                         ; $02E213 | | Otherwise, load it for the two characters in front formation.
    LDA <r_battle_draw_character_sprites_slot                                   ; $02E214 | |
    TAX                                                                         ; $02E216 | |
    LDA bank16.battle_party_two_front_slot_initial_pending_steps_data.l,X       ; $02E217 | |
    PLX                                                                         ; $02E21B |/
++  STA r_battle_character_visual_properties.1.pending_steps.w,X                ; $02E21C | Save that value in the character's pending steps.
    LDA r_character_visual_status.1.status_1.w,Y                                ; $02E21F |\
    AND #(STATUS_1_SMALL | STATUS_1_TOAD).b                                     ; $02E222 | | Skip  this next block if not a toad or small.
    BEQ ++                                                                      ; $02E224 |/
    AND #STATUS_1_TOAD.b                                                        ; $02E226 |\
    BEQ +                                                                       ; $02E228 | | If a toad, set the visual toad flag.
    LDA r_battle_character_visual_properties.1.flags.w,X                        ; $02E22A | |
    ORA #CHARACTER_VISUAL_FLAG_TOAD.b                                           ; $02E22D | |
    STA r_battle_character_visual_properties.1.flags.w,X                        ; $02E22F |/
+   LDA r_battle_character_visual_properties.1.pending_steps.w,X                ; $02E232 |\
    ASL A                                                                       ; $02E235 | | If either toad or small, divide the pending steps by two.
    STA r_battle_character_visual_properties.1.pending_steps.w,X                ; $02E236 | |
    BRA @done                                                                   ; $02E239 |/
++  LDA r_battle_character_visual_properties.1.flags.w,X                        ; $02E23B |\
    ORA #CHARACTER_VISUAL_FLAG_LARGE.b                                          ; $02E23E | | Otherwise, set the large visual flag.
    STA r_battle_character_visual_properties.1.flags.w,X                        ; $02E240 |/
@done:
    JSR _battle_character_set_pose_base                                         ; $02E243 | Set this slot's pose base.
    PLY                                                                         ; $02E246 |\ Restore the values of the X and Y registers.
    PLX                                                                         ; $02E247 |/
    RTS                                                                         ; $02E248

; _battle_draw_character_sprites ($02:E249)
;
; Loops through the five characters, drawing each of them to the OAM. Also is
; responsible for drawing any status icons.
_battle_draw_character_sprites:
    LDA #$F0.b                                                                  ; $02E249 |\
    LDX #(88 * _sizeof_oam_sprite).w                                            ; $02E24B | | Completely fill the OAM with $F0 starting with sprite 89 through
-   STA r_oam.w,X                                                               ; $02E24E | | the end of the OAM (sprite 127).
    INX                                                                         ; $02E251 | |
    CPX #_sizeof_r_oam.w                                                        ; $02E252 | |
    BNE -                                                                       ; $02E255 |/
    LDX #(88 / 4).w                                                             ; $02E257 |\
    TDC                                                                         ; $02E25A | | For the same sprites, set the high OAM table to make them 8x8 and
-   STA r_oam_hi.w,X                                                            ; $02E25B | | to not set the high bit of the X coordinate.
    INX                                                                         ; $02E25E | |
    CPX #_sizeof_r_oam_hi.w                                                     ; $02E25F | |
    BNE -                                                                       ; $02E262 |/
    LDA r_battle_alternate_party_sprite_mode.w                                  ; $02E264 |\
    BEQ +                                                                       ; $02E267 | | Skip this function if the alternate party sprite mode is set.
    RTS                                                                         ; $02E269 |/
+   LDX #0.w                                                                    ; $02E26A | Initialize the X register to zero.
@loop_start:
    PHX                                                                         ; $02E26D | Preserve the value of the X register.
    TXA                                                                         ; $02E26E | Transfer the X register to the accumulator.
    STZ r_battle_steps_pending.w                                                ; $02E26F | Unset the steps pending flag.
    STA <r_battle_draw_character_sprites_slot                                   ; $02E272 | Save the current slot number to a variable used by various routines.
    ASL A                                                                       ; $02E274 |\ Set the Y register to the slot number times two.
    TAY                                                                         ; $02E275 |/
    ASL A                                                                       ; $02E276 |\
    ASL A                                                                       ; $02E277 | | Set the X register to the slot number times sixteen.
    ASL A                                                                       ; $02E278 | |
    TAX                                                                         ; $02E279 |/
    LDA r_battle_character_visual_properties.1.base_tile.w,X                    ; $02E27A |\ Transfer this character's base tile number to a temporary variable.
    STA r_battle_draw_character_sprites_base_tile.w                             ; $02E27D |/
    LDA r_battle_character_visual_properties.1.oam_flags.w,X                    ; $02E280 |\ Repeat for this character's OAM flags.
    STA r_battle_draw_character_sprites_oam_flags.w                             ; $02E283 |/
    LDA #%00000111.b                                                            ; $02E286 |\ Set the character's pose frame counter to update every eight
    STA r_battle_character_visual_properties.1.pose_frame_mask.w,X              ; $02E288 |/ frames.
    JSR _battle_character_sprite_handle_movement                                ; $02E28B | Handle any movement of the character sprites.
    LDA r_battle_character_visual_properties.1.pending_steps.w,X                ; $02E28E |\
    BEQ +                                                                       ; $02E291 | | If there are pending steps, set the pending steps flag.
    INC r_battle_steps_pending.w                                                ; $02E293 |/
+   LDA r_battle_character_visual_properties.1.id.w,X                           ; $02E296 |\
    BNE +                                                                       ; $02E299 | | If the visual ID has been set to zero, unset any status icon.
    STZ r_battle_draw_character_sprites_status_icon.w                           ; $02E29B |/
+   LDA r_battle_pose_frame_mask_override.w                                     ; $02E29E |\
    BEQ +                                                                       ; $02E2A1 | | If there is a pose frame mask override, set it.
    STA r_battle_character_visual_properties.1.pose_frame_mask.w,X              ; $02E2A3 |/
+   LDA r_battle_character_visual_properties.1.y_offset.w,X                     ; $02E2A6 |\ Copy the character's Y offset to a temporary variable.
    STA <r_battle_draw_character_sprites_tmp_y_offset                           ; $02E2A9 |/
    LDA r_battle_character_visual_properties.1.x.w,X                            ; $02E2AB |\
    CLC                                                                         ; $02E2AE | | Set the drawing X coordinate to the character's X coordinate plus
    ADC r_battle_character_visual_properties.1.x_offset.w,X                     ; $02E2AF | | their X offset.
    STA r_battle_draw_character_sprites_coordinates.x.w                         ; $02E2B2 |/
    SEC                                                                         ; $02E2B5 |\
    SBC #16.b                                                                   ; $02E2B6 | | Subtract 16 to determine the cursor X coordinate.
    STA r_battle_character_cursor_coordinates.1.x.w,Y                           ; $02E2B8 |/
    PHY                                                                         ; $02E2BB |\
    TYA                                                                         ; $02E2BC | | Preserve the existing Y register and set the Y register to the
    ASL A                                                                       ; $02E2BD | | offset for the visual status array.
    TAY                                                                         ; $02E2BE |/
    LDA r_character_visual_status.1.status_1.w,Y                                ; $02E2BF |\
    AND #%11000111.b                                                            ; $02E2C2 | | Skip this next block if the character has any of the following
    BNE ++                                                                      ; $02E2C4 | | statuses: swoon, stone, poison, mute, darkness, curse.
    LDA r_character_visual_status.1.status_2.w,Y                                ; $02E2C6 | |
    BMI ++                                                                      ; $02E2C9 |/
    AND #STATUS_2_FLOAT.b                                                       ; $02E2CB |\ Skip this next block unless the character is floating.
    BEQ ++                                                                      ; $02E2CD |/
    PHY                                                                         ; $02E2CF |\
    LDA <r_battle_draw_character_sprites_slot                                   ; $02E2D0 | | If the character is flagged as moving, set the temporary variable
    TAY                                                                         ; $02E2D2 | | to zero (instead of the Y offset).
    LDA r_battle_character_moving.w,Y                                           ; $02E2D3 | |
    BEQ +                                                                       ; $02E2D6 | |
    PLY                                                                         ; $02E2D8 | |
    STZ <r_battle_draw_character_sprites_tmp_y_offset                           ; $02E2D9 | |
    JMP ++                                                                      ; $02E2DB |/
+   PLY                                                                         ; $02E2DE |\
    LDA #-8.b                                                                   ; $02E2DF | | Otherwise, set it to -8.
    STA <r_battle_draw_character_sprites_tmp_y_offset                           ; $02E2E1 |/
++  LDA r_character_visual_status.1.status_4.w,Y                                ; $02E2E3 |\
    AND #(STATUS_4_IMAGE_TWO_HITS | STATUS_4_IMAGE_ONE_HIT).b                   ; $02E2E6 | | Skip the next block unless the character has the image status.
    BEQ +                                                                       ; $02E2E8 |/
    LSR A                                                                       ; $02E2EA |\
    LSR A                                                                       ; $02E2EB | | Calculate the image bit mask by shifting the bits to the right and
    ORA #%00000001.b                                                            ; $02E2EC | | then always setting the lowest bit (result either 01 or 11).
    STA <r_battle_visual_properties_tmp_1                                       ; $02E2EE |/
    PHX                                                                         ; $02E2F0 |\
    LDA r_battle_character_visual_properties.1.frame_counter.w,X                ; $02E2F1 | | Using the mask and the frame counter, load the X offset for this
    AND <r_battle_visual_properties_tmp_1                                       ; $02E2F4 | | frame and current image status. Adjust the sprite X coordinate
    TAX                                                                         ; $02E2F6 | | with that value.
    LDA bank16.image_status_x_offset_data.l,X                                   ; $02E2F7 | |
    CLC                                                                         ; $02E2FB | |
    ADC r_battle_draw_character_sprites_coordinates.x.w                         ; $02E2FC | |
    STA r_battle_draw_character_sprites_coordinates.x.w                         ; $02E2FF | |
    PLX                                                                         ; $02E302 |/
+   PLY                                                                         ; $02E303 |\
    LDA r_battle_character_visual_properties.1.y.w,X                            ; $02E304 | | Set the drawing Y coordinate to the character's Y coordinate plus
    CLC                                                                         ; $02E307 | | their Y offset.
    ADC r_battle_character_visual_properties.1.y_offset.w,X                     ; $02E308 | |
    STA r_battle_draw_character_sprites_coordinates.y.w                         ; $02E30B |/
    LDA r_battle_character_visual_properties.1.y.w,X                            ; $02E30E |\
    CLC                                                                         ; $02E311 | | Set the Y coordinate of the cursor to the character's Y coordinate
    ADC <r_battle_draw_character_sprites_tmp_y_offset                           ; $02E312 | | plus eight plus the calculated Y offset.
    ADC #8.b                                                                    ; $02E314 | |
    STA r_battle_character_cursor_coordinates.1.y.w,Y                           ; $02E316 |/
    LDA r_battle_character_visual_properties.1.oam_index.w,X                    ; $02E319 |\ Set the drawing OAM index to the character's OAM index.
    STA r_battle_draw_character_sprites_oam_index.w                             ; $02E31C |/
    PHX                                                                         ; $02E31F |\
    LDA r_battle_character_visual_properties.1.stone_status.w,X                 ; $02E320 | | Set the X register to the character's stone status times four.
    ASL A                                                                       ; $02E323 | |
    ASL A                                                                       ; $02E324 | |
    TAX                                                                         ; $02E325 |/
    TYA                                                                         ; $02E326 |\
    CLC                                                                         ; $02E327 | | Set the base OAM flags variable to set the palette to the slot
    ADC #2.b                                                                    ; $02E328 | | plus one.
    STA <r_battle_visual_properties_tmp_1                                       ; $02E32A |/
    AND bank16.battle_character_stone_oam_flag_mask_data.l + 0,X                ; $02E32C |\
    STA r_battle_draw_character_sprites_row_flags.1.w                           ; $02E330 | | For each of the three rows of tiles, mask out the flags based on
    LDA <r_battle_visual_properties_tmp_1                                       ; $02E333 | | the character's level of petrification.
    AND bank16.battle_character_stone_oam_flag_mask_data.l + 1,X                ; $02E335 | |
    STA r_battle_draw_character_sprites_row_flags.2.w                           ; $02E339 | |
    LDA <r_battle_visual_properties_tmp_1                                       ; $02E33C | |
    AND bank16.battle_character_stone_oam_flag_mask_data.l + 2,X                ; $02E33E | |
    STA r_battle_draw_character_sprites_row_flags.3.w                           ; $02E342 |/
    LDA <r_battle_draw_character_sprites_slot                                   ; $02E345 |\
    TAX                                                                         ; $02E347 | | If the character has an OAM index override set, update the OAM
    LDA r_battle_character_oam_index_override.w,X                               ; $02E348 | | index used for drawing accordingly.
    BEQ +                                                                       ; $02E34B | |
    STA r_battle_draw_character_sprites_oam_index.w                             ; $02E34D |/
+   PLX                                                                         ; $02E350 |\
    LDA r_battle_character_visual_properties.1.flags.w,X                        ; $02E351 | | Configure the sprite mirroring if the reverse flag is set on the
    AND #CHARACTER_VISUAL_FLAG_REVERSE.b                                        ; $02E354 | | character.
    STA r_battle_draw_character_sprites_mirror.w                                ; $02E356 |/
    LDA r_battle_running.w                                                      ; $02E359 |\
    BEQ +                                                                       ; $02E35C | | Additionally enable mirroring if the party is currently running
    LDA <r_battle_current_slot_incapacitated                                    ; $02E35E | | and the slot is not incapacitated.
    BNE +                                                                       ; $02E360 | |
    LDA #1.b                                                                    ; $02E362 | |
    STA r_battle_draw_character_sprites_mirror.w                                ; $02E364 |/
+   LDA r_battle_character_visual_properties.1.animate_pose.w,X                 ; $02E367 |\
    BEQ +                                                                       ; $02E36A | | If pose animation is enabled, update the pose frame counter if the
    LDA r_battle_character_visual_properties.1.frame_counter.w,X                ; $02E36C | | current frame has the appropriate bits unset based on the frame
    AND r_battle_character_visual_properties.1.pose_frame_mask.w,X              ; $02E36F | | mask.
    BNE +                                                                       ; $02E372 | |
    INC r_battle_character_visual_properties.1.pose_frame_counter.w,X           ; $02E374 |/
+   INC r_battle_character_visual_properties.1.frame_counter.w,X                ; $02E377 | Increment the character's frame counter.
    LDA r_battle_character_visual_properties.1.pose_frame_counter.w,X           ; $02E37A |\
    AND #%00000011.b                                                            ; $02E37D | | Set a temporary variable to the pose frame counter mod 4.
    STA <r_battle_generic_tmp_ptr_lo                                            ; $02E37F | |
    STZ <r_battle_generic_tmp_ptr_hi                                            ; $02E381 |/
    LDA r_battle_character_visual_properties.1.id.w,X                           ; $02E383 |\
    BNE +                                                                       ; $02E386 | | If no visual character ID is set, load the invisible pose frame ID
    LDA #BATTLE_POSE_FRAME_INVISIBLE.b                                          ; $02E388 | | and branch forward.
    BRA +++                                                                     ; $02E38A |/
+   PHX                                                                         ; $02E38C | Preserve the current value in the X register.
    LDA <r_battle_draw_character_sprites_slot                                   ; $02E38D |\
    ASL A                                                                       ; $02E38F | | Branch ahead to separate code if the character is small or a toad
    ASL A                                                                       ; $02E390 | | or not a pig.
    TAX                                                                         ; $02E391 | |
    LDA r_character_visual_status.1.status_1.w,X                                ; $02E392 | |
    AND #(STATUS_1_SMALL | STATUS_1_TOAD).b                                     ; $02E395 | |
    BNE +                                                                       ; $02E397 | |
    LDA r_character_visual_status.1.status_1.w,X                                ; $02E399 | |
    AND #STATUS_1_PIG.b                                                         ; $02E39C | |
    BEQ +                                                                       ; $02E39E |/
    LDA <r_battle_draw_character_sprites_slot                                   ; $02E3A0 |\
    TAX                                                                         ; $02E3A2 | | If the character is a pig (but not toad or small), set their pose
    LDA #BATTLE_POSE_BASE_PIG.b                                                 ; $02E3A3 | | base to $40.
    STA r_battle_draw_character_sprites_pose_base.w                             ; $02E3A5 | |
    STA r_battle_character_pose_base.w,X                                        ; $02E3A8 | |
    PLX                                                                         ; $02E3AB |/
    LDA r_battle_character_visual_properties.1.pose.w,X                         ; $02E3AC |\ Load the pose and branch ahead.
    BRA ++                                                                      ; $02E3AF |/
+   PLX                                                                         ; $02E3B1 |\
    LDA r_battle_character_visual_properties.1.pose.w,X                         ; $02E3B2 | | Otherwise, load the pose and branch ahead if it's zero.
    BEQ +                                                                       ; $02E3B5 |/
++  CLC                                                                         ; $02E3B7 |\
    ADC r_battle_draw_character_sprites_pose_base.w                             ; $02E3B8 | | If the pose was not zero, add it to the character's base pose
    REP #FLAG_P_ACCUMULATOR                                                     ; $02E3BB | | value, and then multiply by four and add the offset for the
    ASL A                                                                       ; $02E3BD | | current pose frame. Transfer the value to the X register.
    ASL A                                                                       ; $02E3BE | |
    CLC                                                                         ; $02E3BF | |
    ADC <r_battle_generic_tmp_ptr                                               ; $02E3C0 | |
    TAX                                                                         ; $02E3C2 | |
    TDC                                                                         ; $02E3C3 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $02E3C4 | |
    BRA ++                                                                      ; $02E3C6 |/
+   TAX                                                                         ; $02E3C8 | Otherwise, set the X register to zero.
++  LDA bank13.battle_pose_frame_data.l,X                                       ; $02E3C9 |\
+++ STA r_battle_draw_character_sprites_pose_frame.w                            ; $02E3CD | | Load the pose frame value and save it to a local variable.
    PLX                                                                         ; $02E3D0 |/
    LDA r_battle_character_sprite_x_override.w,X                                ; $02E3D1 |\
    ORA r_battle_character_sprite_y_override.w,X                                ; $02E3D4 | | If at least one of the character's override coordinates is
    BEQ +                                                                       ; $02E3D7 | | non-zero, set their coordinates directly from the override values
    LDA r_battle_character_sprite_x_override.w,X                                ; $02E3D9 | | instead of using any previously calculated values.
    STA r_battle_draw_character_sprites_coordinates.x.w                         ; $02E3DC | |
    LDA r_battle_character_sprite_y_override.w,X                                ; $02E3DF | |
    STA r_battle_draw_character_sprites_coordinates.y.w                         ; $02E3E2 |/
+   JSR _battle_draw_character_sprite                                           ; $02E3E5 | Call the routine to actually draw the sprite to the OAM.
    LDA r_battle_draw_character_sprites_pose_frame.w                            ; $02E3E8 |\
    CMP #BATTLE_POSE_FRAME_SPECIAL.b                                            ; $02E3EB | | If the pose frame is the special pose, skip the next code.
    BEQ ++                                                                      ; $02E3ED |/
    LDA r_battle_pause_disabled.w                                               ; $02E3EF |\
    ORA r_battle_steps_pending.w                                                ; $02E3F2 | | Draw the character's status icon unless one of the following is
    ORA r_unknown_f424.w                                                        ; $02E3F5 | | true: pause is disabled, there are steps pending, another TODO
    ORA r_battle_character_oam_index_override.w,X                               ; $02E3F8 | | variable, the character's OAM index has an override, the character
    ORA r_battle_character_moving.w,X                                           ; $02E3FB | | is flagged as moving, the character has automatic movement
    ORA r_battle_character_disable_automatic_movement.w,X                       ; $02E3FE | | disabled, or the party is running and the slot is not
    BNE ++                                                                      ; $02E401 | | incapacitated.
    LDA r_battle_running.w                                                      ; $02E403 | |
    BEQ +                                                                       ; $02E406 | |
    LDA <r_battle_current_slot_incapacitated                                    ; $02E408 | |
    BEQ ++                                                                      ; $02E40A | |
+   JSR _battle_draw_status_icon                                                ; $02E40C |/
++  INX                                                                         ; $02E40F |\
    CPX #5.w                                                                    ; $02E410 | | Increment and loop until all five characters have been set.
    BEQ +                                                                       ; $02E413 | |
    JMP @loop_start                                                             ; $02E415 |/
+   RTS                                                                         ; $02E418

; _battle_draw_character_sprite ($02:E419)
;
; Draws the current character sprite by transferring the correct data into the
; OAM staging area in RAM. Uses data in $EFBA through $EFC3 to determine
; exactly what to do.
_battle_draw_character_sprite:
    PHX                                                                         ; $02E419 | Preserve the value of the X register.
    LDA r_unknown_f424.w                                                        ; $02E41A |\
    BEQ +                                                                       ; $02E41D | | TODO: If $F424 is set and the character is visible, set the pose
    LDA r_battle_draw_character_sprites_pose_frame.w                            ; $02E41F | | frame explicitly to swoon.
    CMP #BATTLE_POSE_FRAME_INVISIBLE.b                                          ; $02E422 | |
    BEQ +                                                                       ; $02E424 | | What is the purpose of this? Is it even used? Does $F424 have
    LDA #BATTLE_POSE_FRAME_SWOON.b                                              ; $02E426 | | other roles?
    STA r_battle_draw_character_sprites_pose_frame.w                            ; $02E428 |/
+   LDA #6.b                                                                    ; $02E42B |\
    STA <r_math_multiply_8bit_reg_arg_2                                         ; $02E42D | | Multiply the pose frame by six. Leave the result, as it will be
    LDA r_battle_draw_character_sprites_pose_frame.w                            ; $02E42F | | read later.
    STA <r_math_multiply_8bit_reg_arg_1                                         ; $02E432 | |
    TAX                                                                         ; $02E434 | |
    JSR _math_multiply_8bit_reg                                                 ; $02E435 |/
    LDA bank0D.battle_pose_frame_pattern_data.l,X                               ; $02E438 | Load the pattern number for the given pose frame.
    CLC                                                                         ; $02E43C |\ Add one if the reversed pattern is desired.
    ADC r_battle_draw_character_sprites_mirror.w                                ; $02E43D |/
    STA <r_math_multiply_8bit_reg_arg_1                                         ; $02E440 |\
    LDA #_sizeof_oam_sprite.b * 8                                               ; $02E442 | | Configure variables to multiply that value by 32.
    STA <r_math_multiply_8bit_reg_arg_2                                         ; $02E444 |/
    LDX <r_math_multiply_8bit_reg_result                                        ; $02E446 |\ Load the previously calculated index and store it in a variable.
    STX <r_battle_generic_tmp_ptr                                               ; $02E448 |/
    JSR _math_multiply_8bit_reg                                                 ; $02E44A | Execute the multiplication that was just configured.
    LDA r_battle_draw_character_sprites_pose_frame.w                            ; $02E44D |\
    CMP #BATTLE_POSE_FRAME_SPECIAL.b                                            ; $02E450 | | This next set of code only applies to the special pose.
    BNE +                                                                       ; $02E452 |/
    LDA r_battle_draw_character_sprites_row_flags.1.w                           ; $02E454 |\
    STA r_battle_draw_character_sprites_row_flags.2.w                           ; $02E457 | | Set the row flags to be the same for each row (as it assumes 2x3).
    STA r_battle_draw_character_sprites_row_flags.3.w                           ; $02E45A |/
    LDA #8.b                                                                    ; $02E45D |\ Set the tile count to eight.
    STA <r_battle_draw_character_sprite_tile_count                              ; $02E45F |/
    LDA r_battle_draw_character_sprites_oam_index.w                             ; $02E461 |\
    SEC                                                                         ; $02E464 | | Load the base OAM index and subtract 2 (to hold the extra 2).
    SBC #2.b                                                                    ; $02E465 |/
    JMP ++                                                                      ; $02E467 | Skip ahead to the next section.
+   LDA #6.b                                                                    ; $02E46A |\
    STA <r_battle_draw_character_sprite_tile_count                              ; $02E46C | | Otherwise, set the tile count to six and load the OAM index.
    LDA r_battle_draw_character_sprites_oam_index.w                             ; $02E46E |/
++  REP #FLAG_P_ACCUMULATOR                                                     ; $02E471 |\
    ASL A                                                                       ; $02E473 | | Set the Y register by mutliplying the calculated OAM index by
    ASL A                                                                       ; $02E474 | | four (as each OAM entry has four bytes).
    TAY                                                                         ; $02E475 | |
    TDC                                                                         ; $02E476 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $02E477 |/
    LDX r_battle_draw_character_sprites_coordinates.w                           ; $02E479 |\ Transfer the coordinates to a temporary location.
    STX <r_battle_generic_tmp_coordinates                                       ; $02E47C |/
    LDX <r_math_multiply_8bit_reg_result                                        ; $02E47E | Set the X register to the calculated pattern offset.
    STZ <r_battle_draw_character_sprite_index                                   ; $02E480 | Initialize the index to zero.
@loop_start:
    LDA r_battle_draw_character_sprites_base_tile.w                             ; $02E482 |\ Copy the base tile number for this character slot.
    STA <r_battle_draw_character_sprite_tile                                    ; $02E485 |/
    LDA r_battle_draw_character_sprites_oam_flags.w                             ; $02E487 |\ Copy the base OAM flags for this character slot.
    STA <r_battle_draw_character_sprite_oam_flags                               ; $02E48A |/
    LDA <r_battle_draw_character_sprite_index                                   ; $02E48C |\
    LSR A                                                                       ; $02E48E | | Determine the row of the sprite by dividing by two and then using
    CMP #3.b                                                                    ; $02E48F | | that to load the correct OAM flags for that row.
    BCC +                                                                       ; $02E491 | |
    LDA #2.b                                                                    ; $02E493 | | BUG: This deals with the special pose by simply setting any value
+   PHX                                                                         ; $02E495 | |      greater than 2 to 2. The loaded data doesn't correspond to the
    TAX                                                                         ; $02E496 | |      actual row for that sprite.
    LDA r_battle_draw_character_sprites_row_flags.w,X                           ; $02E497 |/
    ORA <r_battle_draw_character_sprite_oam_flags                               ; $02E49A |\ Combine with the base OAM flags and then store it back.
    STA <r_battle_draw_character_sprite_oam_flags                               ; $02E49C |/
    LDX <r_battle_generic_tmp_ptr                                               ; $02E49E | Load the offset into the pose frame tile data.
    LDA bank0D.battle_pose_frame_tile_data.l,X                                  ; $02E4A0 | Load the next tile number.
    CMP #$FF.b                                                                  ; $02E4A4 |\
    BNE +                                                                       ; $02E4A6 | | If the value is $FF, set that as the tile number, and then set the
    STA <r_battle_draw_character_sprite_tile                                    ; $02E4A8 | | flags to use the high name table.
    LDA #%00000001.b                                                            ; $02E4AA | |
    STA <r_battle_draw_character_sprite_oam_flags                               ; $02E4AC | |
    BRA ++                                                                      ; $02E4AE |/
+   CLC                                                                         ; $02E4B0 |\
    ADC <r_battle_draw_character_sprite_tile                                    ; $02E4B1 | | Otherwise, add the tile to the base tile and store that.
    STA <r_battle_draw_character_sprite_tile                                    ; $02E4B3 |/
++  INX                                                                         ; $02E4B5 |\ Increment the pose frame tile offset and store it back.
    STX <r_battle_generic_tmp_ptr                                               ; $02E4B6 |/
    PLX                                                                         ; $02E4B8 | Restore the stored X register (the offset into the pattern data).
    LDA bank0D.battle_character_sprite_oam_data.l,X                             ; $02E4B9 |\
    CLC                                                                         ; $02E4BD | | Read the X coordinate from the OAM data, add the base X
    ADC <r_battle_generic_tmp_coordinates.x                                     ; $02E4BE | | coordinate, mirror it if appropriate, and then set the data in the
    JSR _mirror_character_sprite_coordinate_if_back_attack                      ; $02E4C0 | | OAM data.
    STA r_oam.w,Y                                                               ; $02E4C3 | |
    INX                                                                         ; $02E4C6 | |
    INY                                                                         ; $02E4C7 |/
    LDA bank0D.battle_character_sprite_oam_data.l,X                             ; $02E4C8 |\
    CLC                                                                         ; $02E4CC | | Repeat the process with the Y coordinate, except skipping the
    ADC <r_battle_generic_tmp_coordinates.y                                     ; $02E4CD | | mirroring step.
    STA r_oam.w,Y                                                               ; $02E4CF | |
    INX                                                                         ; $02E4D2 | |
    INY                                                                         ; $02E4D3 |/
    LDA r_formation_back_attack_copy.w                                          ; $02E4D4 |\
    BEQ +                                                                       ; $02E4D7 | | If this is a back attack, load the tile number and flags, add in
    REP #FLAG_P_ACCUMULATOR                                                     ; $02E4D9 | | the calculated tile number and flags, and then flip the horizontal
    LDA bank0D.battle_character_sprite_oam_data.l,X                             ; $02E4DB | | flip bit.
    ORA <r_battle_draw_character_sprite_tile                                    ; $02E4DF | |
    EOR #$4000.w                                                                ; $02E4E1 | |
    BRA ++                                                                      ; $02E4E4 |/
+   REP #FLAG_P_ACCUMULATOR                                                     ; $02E4E6 |\
    LDA bank0D.battle_character_sprite_oam_data.l,X                             ; $02E4E8 | | Otherwise, just load the data and add in the calculated data.
    ORA <r_battle_draw_character_sprite_tile                                    ; $02E4EC |/
++  STA r_oam.w,Y                                                               ; $02E4EE | Store the result in the OAM staging area.
    TDC                                                                         ; $02E4F1 |\
    SEP #FLAG_P_ACCUMULATOR                                                     ; $02E4F2 | | Increment the indexes and loop until the total number of tiles
    INX                                                                         ; $02E4F4 | | has been handled.
    INY                                                                         ; $02E4F5 | |
    INX                                                                         ; $02E4F6 | |
    INY                                                                         ; $02E4F7 | |
    INC <r_battle_draw_character_sprite_index                                   ; $02E4F8 | |
    LDA <r_battle_draw_character_sprite_index                                   ; $02E4FA | |
    CMP <r_battle_draw_character_sprite_tile_count                              ; $02E4FC | |
    BNE @loop_start                                                             ; $02E4FE |/
    PLX                                                                         ; $02E500 | Restore the value of the X register.
    RTS                                                                         ; $02E501

; _battle_animate_damage ($02:E502)
;
; Animates the damage effect during battle.
_battle_animate_damage:
    LDA r_battle_damage_active.w                                                ; $02E502 |\ Skip this function if the damage display isn't currently active.
    BEQ +                                                                       ; $02E505 |/
    JSR _battle_reset_effect_oam                                                ; $02E507 | Reset the effect OAM data.
    INC r_battle_damage_counter.w                                               ; $02E50A |\
    LDA r_battle_damage_counter.w                                               ; $02E50D | | Increment the damage counter, and once it reaches $2A, flag the
    CMP #42.b                                                                   ; $02E510 | | damage effect as being over.
    BNE ++                                                                      ; $02E512 | |
    STZ r_battle_damage_active.w                                                ; $02E514 | |
+   JMP @done                                                                   ; $02E517 |/
++  LDY #0.w                                                                    ; $02E51A |\ Initialize the X and Y registers to zero.
    LDX #0.w                                                                    ; $02E51D |/
    STX <r_battle_animate_damage_tmp_index                                      ; $02E520 | Initialize the index to zero.
@loop_start:
    STZ <r_battle_animate_damage_tmp_miss                                       ; $02E522 |\
    LDA r_battle_damage_invisible.w,Y                                           ; $02E524 | | If the invisibility flag for this slot is set to $FF, then set the
    BEQ ++                                                                      ; $02E527 | | miss flag. If the invisibility flag is otherwise non-zero, skip
    CMP #$FF.b                                                                  ; $02E529 | | this slot.
    BEQ +                                                                       ; $02E52B | |
    JMP @next                                                                   ; $02E52D | |
+   INC <r_battle_animate_damage_tmp_miss                                       ; $02E530 |/
++  LDA r_battle_damage_x_coordinates.w,Y                                       ; $02E532 |\
    SEC                                                                         ; $02E535 | | Set the X coordinate to the target X coordinate minus 16 (which will
    SBC #16.b                                                                   ; $02E536 | | center the result).
    STA <r_battle_animate_damage_tmp_coordinates.x                              ; $02E538 |/
    PHX                                                                         ; $02E53A | Push the value of the X register.
    LDA r_battle_damage_y_coordinates.w,Y                                       ; $02E53B |\
    SEC                                                                         ; $02E53E | | Set the base Y coordinate to the target Y coordinate minus 8 (again to
    SBC #8.b                                                                    ; $02E53F | | center the result).
    STA <r_battle_animate_damage_tmp_base_y                                     ; $02E541 |/
    PHY                                                                         ; $02E543 | Push the value of the Y register.
    LDY #0.w                                                                    ; $02E544 | Set the Y register to zero.
    LDA r_battle_damage_counter.w                                               ; $02E547 |\
    TAX                                                                         ; $02E54A |/
    LDA <r_battle_animate_damage_tmp_miss                                       ; $02E54B |\ If the miss flag is set, branch to a different set of code.
    BNE +                                                                       ; $02E54D |/
-   LDA bank16.battle_damage_y_offset_data.l,X                                  ; $02E54F |\
    CLC                                                                         ; $02E553 | | Loop through the potential five digits, setting the Y coordinate
    ADC <r_battle_animate_damage_tmp_base_y                                     ; $02E554 | | by reading the Y offset data from ROM. Each subsequent value is
    STA r_battle_animate_damage_tmp_coordinates.y.w,Y                           ; $02E556 | | three frames ahead in the data to produce the rolling effect.
    INX                                                                         ; $02E559 | | (The stored values will actually be used in reverse order later.)
    INX                                                                         ; $02E55A | | Afterward, branch ahead to the next section.
    INX                                                                         ; $02E55B | |
    INY                                                                         ; $02E55C | |
    CPY #5.w                                                                    ; $02E55D | |
    BNE -                                                                       ; $02E560 | |
    BRA ++                                                                      ; $02E562 |/
+   LDA r_battle_damage_counter.w                                               ; $02E564 |\
    TAX                                                                         ; $02E567 | | If the miss flag was set, instead set all the Y coordinates to the
    LDA bank16.battle_damage_y_offset_data.l,X                                  ; $02E568 | | base value plus the same Y offsest value so the entire word rolls
    CLC                                                                         ; $02E56C | | as a unit.
    ADC <r_battle_animate_damage_tmp_base_y                                     ; $02E56D | |
    STA <r_battle_animate_damage_tmp_coordinates.y.1.b                          ; $02E56F | |
    STA <r_battle_animate_damage_tmp_coordinates.y.2.b                          ; $02E571 | |
    STA <r_battle_animate_damage_tmp_coordinates.y.3.b                          ; $02E573 | |
    STA <r_battle_animate_damage_tmp_coordinates.y.4.b                          ; $02E575 | |
    STA <r_battle_animate_damage_tmp_coordinates.y.5.b                          ; $02E577 |/
++  LDA #_sizeof_r_battle_animate_damage_tmp_coordinates.y.b                    ; $02E579 |\ Initialize the Y coordinate index to 5.
    STA <r_battle_animate_damage_tmp_base_y                                     ; $02E57B |/
    PLY                                                                         ; $02E57D |\ Restore the original X and Y registers before the inner loop.
    PLX                                                                         ; $02E57E |/
    LDA r_formation_back_attack_copy.w                                          ; $02E57F |\
    BEQ @inner_start                                                            ; $02E582 | | If the formation is a back attack, change the X coordinate by
    LDA <r_battle_animate_damage_tmp_coordinates.x.b                            ; $02E584 | | flipping the bits and subtracting 32 to mirror the coordinate to
    EOR #%11111111.b                                                            ; $02E586 | | the other side (though it ends up off by one, because they never
    SEC                                                                         ; $02E588 | | added one).
    SBC #32.b                                                                   ; $02E589 | |
    STA <r_battle_animate_damage_tmp_coordinates.x                              ; $02E58B |/
@inner_start:
    LDA <r_battle_animate_damage_tmp_coordinates.x                              ; $02E58D |\ Set the X coordinate in the OAM data.
    STA r_oam.17.w,X                                                            ; $02E58F |/
    CLC                                                                         ; $02E592 |\
    ADC #8.b                                                                    ; $02E593 | | Add 8 to the coordinate to move to the next digit.
    STA <r_battle_animate_damage_tmp_coordinates.x                              ; $02E595 |/
    INX                                                                         ; $02E597 | Increment the X register to move to the next byte in the OAM.
    PHX                                                                         ; $02E598 |\
    LDA <r_battle_animate_damage_tmp_base_y                                     ; $02E599 | | Decrement the Y coordinate index, and set the Y coordinate in the
    DEC A                                                                       ; $02E59B | | OAM data, by reading it from the Y coordinate array (in reverse
    TAX                                                                         ; $02E59C | | order).
    LDA <r_battle_animate_damage_tmp_coordinates.y.b,X                          ; $02E59D | |
    PLX                                                                         ; $02E59F | |
    STA r_oam.17.w,X                                                            ; $02E5A0 |/
    INX                                                                         ; $02E5A3 | Increment the X register to move to the next OAM byte.
    PHX                                                                         ; $02E5A4 |\
    LDX <r_battle_animate_damage_tmp_index                                      ; $02E5A5 | | Increment the tile index, load the tile number from memory, and
    INX                                                                         ; $02E5A7 | | save it to the OAM data.
    STX <r_battle_animate_damage_tmp_index                                      ; $02E5A8 | |
    LDA r_battle_damage_sprites.w,X                                             ; $02E5AA | |
    PLX                                                                         ; $02E5AD | |
    STA r_oam.17.w,X                                                            ; $02E5AE |/
    INX                                                                         ; $02E5B1 | Increment the X register to move to the next OAM byte.
    LDA r_battle_damage_oam_flags.w,Y                                           ; $02E5B2 |\ Write the flags byte to the OAM data.
    STA r_oam.17.w,X                                                            ; $02E5B5 |/
    INX                                                                         ; $02E5B8 | Increment the X register to move to the next OAM byte.
    DEC <r_battle_animate_damage_tmp_base_y                                     ; $02E5B9 | Decrement the Y coordinate index.
    BNE @inner_start                                                            ; $02E5BB | Loop until all potential five digits have been processed.
    BRA +                                                                       ; $02E5BD | Branch ahead past the skip code.
@next:
    REP #FLAG_P_ACCUMULATOR                                                     ; $02E5BF |\
    LDA <r_battle_animate_damage_tmp_index                                      ; $02E5C1 | | If this slot is being skipped, add five to the index to move to
    CLC                                                                         ; $02E5C3 | | the next value.
    ADC #5.w                                                                    ; $02E5C4 | |
    STA <r_battle_animate_damage_tmp_index                                      ; $02E5C7 | |
    TDC                                                                         ; $02E5C9 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $02E5CA |/
+   INY                                                                         ; $02E5CC |\
    CPY #(5 + 8).w                                                              ; $02E5CD | | Increment the Y register and loop until all 14 slots have been
    BEQ @done                                                                   ; $02E5D0 | | handled.
    JMP @loop_start                                                             ; $02E5D2 |/
@done:
    RTS                                                                         ; $02E5D5

; _battle_copy_weapon_sprite_to_oam ($02:E5D6)
;
; Based on the values in $F0C9 through $F0CE, draws a weapon sprite to the OAM
; mirror in RAM. Technically, there's no reason it couldn't draw any arbitrary
; sprite, as it takes a tile number, but it seems to be used to draw the weapon
; sprites when a character attacks.
_battle_copy_weapon_sprite_to_oam:
    LDA r_battle_weapon_sprite_visible.w                                        ; $02E5D6 |\ If the sprite isn't visible, skip this function.
    BEQ @done                                                                   ; $02E5D9 |/
    LDA r_battle_weapon_sprite_oam_index.w                                      ; $02E5DB |\ Copy the OAM index to a local variable.
    STA <r_battle_weapon_sprite_tmp_oam_index                                   ; $02E5DE |/
    LSR A                                                                       ; $02E5E0 |\
    LSR A                                                                       ; $02E5E1 | | Divide the OAM index by four to determine the high OAM index.
    TAY                                                                         ; $02E5E2 |/
    LDA <r_battle_weapon_sprite_tmp_oam_index                                   ; $02E5E3 |\
    AND #%00000011.b                                                            ; $02E5E5 | | Load the bitmasks to clear and set the sprite size bit for the
    TAX                                                                         ; $02E5E7 | | given OAM index in the high OAM table.
    LDA bank0D.oam_hi_sprite_size_set_data.l,X                                  ; $02E5E8 | |
    STA <r_battle_weapon_sprite_tmp_oam_hi_set                                  ; $02E5EC | |
    LDA bank0D.oam_hi_mask_data.l,X                                             ; $02E5EE | |
    STA <r_battle_weapon_sprite_tmp_oam_hi_mask                                 ; $02E5F2 |/
    LDA r_oam_hi.w,Y                                                            ; $02E5F4 |\
    AND <r_battle_weapon_sprite_tmp_oam_hi_mask                                 ; $02E5F7 | | Set the high OAM table for this index to set the sprite size bit
    ORA <r_battle_weapon_sprite_tmp_oam_hi_set                                  ; $02E5F9 | | and unset the high X bit.
    STA r_oam_hi.w,Y                                                            ; $02E5FB |/
    LDA <r_battle_weapon_sprite_tmp_oam_index                                   ; $02E5FE |\
    REP #FLAG_P_ACCUMULATOR                                                     ; $02E600 | | Set the X register to the target OAM index times four, to index
    ASL A                                                                       ; $02E602 | | the OAM table.
    ASL A                                                                       ; $02E603 | |
    TAX                                                                         ; $02E604 | |
    TDC                                                                         ; $02E605 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $02E606 |/
    LDA r_battle_weapon_sprite_coordinates.y.w                                  ; $02E608 |\ Set the sprite Y coordinate.
    STA r_oam.1.y.w,X                                                           ; $02E60B |/
    LDA r_battle_weapon_sprite_tile.w                                           ; $02E60E |\ Set the tile number.
    STA r_oam.1.tile.w,X                                                        ; $02E611 |/
    LDA r_formation_back_attack_copy.w                                          ; $02E614 |\ If this is not a back attack, branch ahead to other code.
    BEQ +                                                                       ; $02E617 |/
    LDA r_battle_weapon_sprite_coordinates.x.w                                  ; $02E619 |\
    EOR #%11111111.b                                                            ; $02E61C | | Set the X coordinate by flipping the bits and subtracting 16, to
    SEC                                                                         ; $02E61E | | move to roughly the right place on the other side.
    SBC #16.b                                                                   ; $02E61F | |
    STA r_oam.1.x.w,X                                                           ; $02E621 |/
    LDA r_battle_weapon_sprite_tile_flags.w                                     ; $02E624 |\
    EOR #%01000000.b                                                            ; $02E627 | | Set the horizontal flip bit in the sprite data.
    STA r_oam.1.flags.w,X                                                       ; $02E629 |/
@done:
    RTS                                                                         ; $02E62C | Return.
+   LDA r_battle_weapon_sprite_coordinates.x.w                                  ; $02E62D |\ If not a back attack, set the X coordinate directly.
    STA r_oam.1.x.w,X                                                           ; $02E630 |/
    LDA r_battle_weapon_sprite_tile_flags.w                                     ; $02E633 |\ Set the flags directly, as well.
    STA r_oam.1.flags.w,X                                                       ; $02E636 |/
    RTS                                                                         ; $02E639

; _battle_copy_effect_sprites_to_oam ($02:E63A)
;
; Based on the values in $F0C1 through $F0C8, copies various tiles into the OAM
; mirror at $300 to eventually be copied to the actual OAM.
_battle_copy_effect_sprites_to_oam:
    LDA r_battle_effect_sprites_pending.w                                       ; $02E63A |\
    BNE +                                                                       ; $02E63D | | Only execute this routine if battle effect sprites are pending.
    RTS                                                                         ; $02E63F |/
+   STZ r_battle_effect_sprites_pending.w                                       ; $02E640 | Zero out the flag so this will only be executed once.
    LDA r_battle_effect_sprites_reset_mode.w                                    ; $02E643 |\
    BNE +                                                                       ; $02E646 | | TODO: Resets OAM entries depending on the value in $F0C7. Would
    JSR _battle_reset_effect_oam                                                ; $02E648 | |       like to see it being set in the various ways before fully
    BRA ++                                                                      ; $02E64B | |       trying to comment this section.
+   CMP #EFFECT_OAM_RESET_MODE_NONE.b                                           ; $02E64D | |
    BEQ ++                                                                      ; $02E64F | |
    CMP #EFFECT_OAM_RESET_MODE_SHIFT.b                                          ; $02E651 | |
    BEQ +                                                                       ; $02E653 | |
    JSR _battle_reset_effect_oam_large                                          ; $02E655 | |
    BRA ++                                                                      ; $02E658 | |
+   JSR _battle_shift_effect_oam                                                ; $02E65A |/
++  LDA r_battle_effect_sprites_pattern_index.w                                 ; $02E65D |\
    ASL A                                                                       ; $02E660 | | Load the pointer to the pattern data by reading it from ROM.
    TAX                                                                         ; $02E661 | |
    LDA bank0D.battle_effect_sprite_pattern_offset_data.l + 0,X                 ; $02E662 | |
    STA <r_battle_effect_sprites_tmp_pattern_pointer_addr_lo                    ; $02E666 | |
    LDA bank0D.battle_effect_sprite_pattern_offset_data.l + 1,X                 ; $02E668 | |
    STA <r_battle_effect_sprites_tmp_pattern_pointer_addr_hi                    ; $02E66C | |
    LDA #:bank0D.battle_effect_sprite_pattern_offset_data.b                     ; $02E66E | |
    STA <r_battle_effect_sprites_tmp_pattern_pointer_bank                       ; $02E670 |/
    LDA r_battle_effect_sprites_coordinates.x.w                                 ; $02E672 |\
    SEC                                                                         ; $02E675 | | Determine the leftmost X coordinate by taking the parameter and
    SBC #(8 * 3).b                                                              ; $02E676 | | subtracting three tiles.
    STA <r_battle_effect_sprites_tmp_coordinates.x                              ; $02E678 |/
    LDA r_battle_effect_sprites_coordinates.y.w                                 ; $02E67A |\
    SEC                                                                         ; $02E67D | | Determine the uppermost Y coordinate by taking the parameter and
    SBC #(8 * 3).b                                                              ; $02E67E | | subtracting three tiles.
    STA <r_battle_effect_sprites_tmp_coordinates.y                              ; $02E680 |/
    LDA r_battle_effect_sprites_base_tile.w                                     ; $02E682 |\ Copy the base tile number to a local variable.
    STA <r_battle_effect_sprites_tmp_base_tile                                  ; $02E685 |/
    LDA r_battle_effect_sprites_base_oam_index.w                                ; $02E687 |\
    REP #FLAG_P_ACCUMULATOR                                                     ; $02E68A | | Set the X register to the base OAM index times four (to index the
    ASL A                                                                       ; $02E68C | | OAM data).
    ASL A                                                                       ; $02E68D | |
    TAX                                                                         ; $02E68E | |
    TDC                                                                         ; $02E68F | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $02E690 |/
    LDY #0.w                                                                    ; $02E692 | Initialize the Y register to zero.
@loop_start:
    LDA [<r_battle_effect_sprites_tmp_pattern_pointer],Y                        ; $02E695 | Read the next byte of the sprite pattern.
    CMP #$FF.b                                                                  ; $02E697 |\ If reaching the last byte of the pattern, skip to the end.
    BEQ @done                                                                   ; $02E699 |/
    PHA                                                                         ; $02E69B |\
    AND #%11110000.b                                                            ; $02E69C | | Calculate the target X coordinate by masking out the correct bits,
    LSR A                                                                       ; $02E69E | | shifting right once (to effectively multiply by eight), and adding
    CLC                                                                         ; $02E69F | | the base X coordinate.
    ADC <r_battle_effect_sprites_tmp_coordinates.x                              ; $02E6A0 |/
    JSR _mirror_character_sprite_coordinate_if_back_attack                      ; $02E6A2 | Mirror the coordinate if this is a back attack.
    STA r_oam.w,X                                                               ; $02E6A5 | Set the X coordinate in the OAM data.
    INX                                                                         ; $02E6A8 | Increment the X register to move to the Y coordinate.
    PLA                                                                         ; $02E6A9 |\
    AND #%00001111.b                                                            ; $02E6AA | | Set the Y coordinate in the OAM data by taking the desired tile
    ASL A                                                                       ; $02E6AC | | coordinate, multiplying by eight, and adding the base Y
    ASL A                                                                       ; $02E6AD | | coordinate.
    ASL A                                                                       ; $02E6AE | |
    CLC                                                                         ; $02E6AF | |
    ADC <r_battle_effect_sprites_tmp_coordinates.y                              ; $02E6B0 | |
    STA r_oam.w,X                                                               ; $02E6B2 |/
    INX                                                                         ; $02E6B5 |\ Increment both X and Y to move to the tile byte.
    INY                                                                         ; $02E6B6 |/
    LDA [<r_battle_effect_sprites_tmp_pattern_pointer],Y                        ; $02E6B7 |\
    CLC                                                                         ; $02E6B9 | | Set the tile number by adding the tile offset for this particular
    ADC <r_battle_effect_sprites_tmp_base_tile                                  ; $02E6BA | | tile to the base tile number.
    STA r_oam.w,X                                                               ; $02E6BC |/
    INX                                                                         ; $02E6BF | Increment the X register to move to the flags byte in the OAM.
    INY                                                                         ; $02E6C0 | Increment the Y register to prepare to read the next byte.
    LDA r_formation_back_attack_copy.w                                          ; $02E6C1 |\
    BEQ +                                                                       ; $02E6C4 | | If this is a back attack, load the desired tile flags and flip the
    LDA r_battle_effect_sprites_tile_flags.w                                    ; $02E6C6 | | horizontal flip bit to properly mirror the tile. Set the flags in
    EOR #%01000000.b                                                            ; $02E6C9 | | the OAM.
    STA r_oam.w,X                                                               ; $02E6CB | |
    INX                                                                         ; $02E6CE | |
    JMP @loop_start                                                             ; $02E6CF |/
+   LDA r_battle_effect_sprites_tile_flags.w                                    ; $02E6D2 |\
    STA r_oam.w,X                                                               ; $02E6D5 | | Otherwise, just store the desired flags as is.
    INX                                                                         ; $02E6D8 | |
    JMP @loop_start                                                             ; $02E6D9 |/
@done:
    RTS                                                                         ; $02E6DC

; _battle_shift_effect_oam ($02:E6DD)
;
; Shifts OAM entries 16 through 23 to slots 17 through 24 instead. The values in
; OAM entry 16 do remain as is.
_battle_shift_effect_oam:
    LDX #32.w                                                                   ; $02E6DD |\
-   LDA r_oam.17.w - 1,X                                                        ; $02E6E0 | | For OAM entries 16 through 23, copy them to the new range of 17
    STA r_oam.18.w - 1,X                                                        ; $02E6E3 | | through 24.
    DEX                                                                         ; $02E6E6 | |
    BNE -                                                                       ; $02E6E7 |/
    RTS                                                                         ; $02E6E9

; _battle_set_effect_oam_offscreen ($02:E6EA)
;
; Resets OAM entries 16 through 87 to $F0, which results in them being drawn
; off screen. This range appears to be used for effects during battle.
_battle_set_effect_oam_offscreen:
    LDX #_sizeof_oam_sprite.w * 16                                              ; $02E6EA | Initialize the X register to the 16th OAM entry.
    LDA #240.b                                                                  ; $02E6ED | Set the accumulator to 240.
-   STA r_oam.w,X                                                               ; $02E6EF |\
    INX                                                                         ; $02E6F2 | | Loop through OAM entries 16 through 87, setting all values to
    CPX #_sizeof_oam_sprite.w * 88                                              ; $02E6F3 | | 240, which will draw them off screen.
    BNE -                                                                       ; $02E6F6 |/
    STZ r_battle_disable_oam_update.w                                           ; $02E6F8 | Enable battle OAM updates if disabled.
    RTS                                                                         ; $02E6FB

; battle_reset_effect_oam ($02:E6FC)
;
; Proxy function to call _battle_reset_effect_oam from another bank.
battle_reset_effect_oam:
    JSR _battle_reset_effect_oam                                                ; $02E6FC
    RTL                                                                         ; $02E6FF

; battle_reset_effect_oam_large ($02:E700)
;
; Proxy function to call _battle_reset_effect_oam_large from another bank.
battle_reset_effect_oam_large:
    JSR _battle_reset_effect_oam_large                                          ; $02E700
    RTL                                                                         ; $02E703

; _battle_reset_effect_oam_large ($02:E704)
;
; Resets OAM entries 16 through 87 to draw off screen and sets the high OAM
; table for those entries to set the sprite size to 16x16.
_battle_reset_effect_oam_large:
    PHX                                                                         ; $02E704 | Preserve the value of the X register.
    LDX #0.w                                                                    ; $02E705 | Initialize the X register to zero.
    LDA #%10101010.b                                                            ; $02E708 | Load the value to store in the high OAM.
    INC r_battle_disable_oam_update.w                                           ; $02E70A | Disable the transfer of OAM data to the PPU.
-   STA r_oam_hi.w + 4,X                                                        ; $02E70D |\
    INX                                                                         ; $02E710 | | Fill the high OAM corresponding to OAM entries 16 through 87
    CPX #18.w                                                                   ; $02E711 | | with $AA, which sets all sprites to be 16x16.
    BNE -                                                                       ; $02E714 |/
    JSR _battle_set_effect_oam_offscreen                                        ; $02E716 | Set the OAM data for these same entries to $F0.
    PLX                                                                         ; $02E719 | Restore the value of the X register.
    RTS                                                                         ; $02E71A

; _battle_reset_effect_oam ($02:E71B)
;
; Resets OAM entries 16 through 87 to draw off screen and zeroes out the high
; OAM table corresponding to those entries.
_battle_reset_effect_oam:
    PHX                                                                         ; $02E71B | Preserve the value of the X register.
    TDC                                                                         ; $02E71C |\ Set the X register to zero.
    TAX                                                                         ; $02E71D |/
    INC r_battle_disable_oam_update.w                                           ; $02E71E | Disable the transfer of OAM data to the PPU.
-   STA r_oam_hi.w + 4,X                                                        ; $02E721 |\
    INX                                                                         ; $02E724 | | Fill the high OAM corresponding to entries 16 through 87 with
    CPX #18.w                                                                   ; $02E725 | | zeroes.
    BNE -                                                                       ; $02E728 |/
    JSR _battle_set_effect_oam_offscreen                                        ; $02E72A | Set the OAM data for these same entries to $F0.
    PLX                                                                         ; $02E72D | Restore the value of the X register.
    RTS                                                                         ; $02E72E

; _battle_effect_increment_sine_indexes ($02:E72F)
;
; Given a value in the accumulator and an index in the X register, updates that
; index in the sine index arrays by adding the passed value.
_battle_effect_increment_sine_indexes:
    PHA                                                                         ; $02E72F |\
    CLC                                                                         ; $02E730 | | Update the first sine index array, adding the passed value.
    ADC r_battle_effect_sine_index.w,X                                          ; $02E731 | |
    STA r_battle_effect_sine_index.w,X                                          ; $02E734 | |
    PLA                                                                         ; $02E737 |/
    CLC                                                                         ; $02E738 |\
    ADC r_battle_effect_sine_index_2.w,X                                        ; $02E739 | | Update the second sine index array, adding the passed value.
    STA r_battle_effect_sine_index_2.w,X                                        ; $02E73C |/
    RTS                                                                         ; $02E73F

; battle_effect_initialize_sine_indexes ($02:E740)
;
; Proxy function to call _battle_effect_initialize_sine_indexes from antoher
; bank.
battle_effect_initialize_sine_indexes:
    JSR _battle_effect_initialize_sine_indexes                                  ; $02E740
    RTL                                                                         ; $02E743

; _battle_effect_initialize_sine_indexes ($02:E744)
;
; Initializes the two sine indexes to allow the first to serve as the sine and
; the second to serve as the cosine. This version initializes eight values,
; spaced equally around the data. (The eight points defined by the two sets
; would form a circle.)
_battle_effect_initialize_sine_indexes:
    LDX #0.w                                                                    ; $02E744 |\
    LDA #64.b                                                                   ; $02E747 | | Set the first sine index value to zero and set the second sine
-   STZ r_battle_effect_sine_index.w,X                                          ; $02E749 | | index value to 64, which allows it to serve as the cosine instead.
    STA r_battle_effect_sine_index_2.w,X                                        ; $02E74C | |
    INX                                                                         ; $02E74F | |
    CPX #8.w                                                                    ; $02E750 | |
    BNE -                                                                       ; $02E753 |/
    RTS                                                                         ; $02E755

; battle_effect_initialize_sine_magnitude ($02:E756)
;
; Proxy function to call _battle_effect_initialize_sine_magnitude from another
; bank.
battle_effect_initialize_sine_magnitude:
    JSR _battle_effect_initialize_sine_magnitude                                ; $02E756
    RTL                                                                         ; $02E759

; _battle_effect_initialize_sine_magnitude ($02:E75A)
;
; Initializes the sine magnitude arrays at $F1B3 and $F1F3 to the value passed
; in the accumulator. This version only initializes the first eight values.
_battle_effect_initialize_sine_magnitude:
    LDX #0.w                                                                    ; $02E75A |\
-   STA r_battle_effect_sine_magnitude.w,X                                      ; $02E75D | | Initialize the two magnitude arrays to the value passed in the
    STA r_battle_effect_sine_magnitude_2.w,X                                    ; $02E760 | | accumulator.
    INX                                                                         ; $02E763 | |
    CPX #8.w                                                                    ; $02E764 | |
    BNE -                                                                       ; $02E767 |/
    RTS                                                                         ; $02E769

; _unused_battle_effect_update_sine_magnitude ($02:E76A)
;
; Given a value in the accumulator and the offset to the desired index in the X
; register, updates the value of the sine magnitudes for that index to add the
; value in the acccumulator.
_unused_battle_effect_update_sine_magnitude:
    PHA                                                                         ; $02E76A | Preserve the value in the accumulator.
    CLC                                                                         ; $02E76B |\
    ADC r_battle_effect_sine_magnitude.w,X                                      ; $02E76C | | Add the value to the first sine magnitude.
    STA r_battle_effect_sine_magnitude.w,X                                      ; $02E76F |/
    PLA                                                                         ; $02E772 |\
    CLC                                                                         ; $02E773 | | Add the value to the second sine magnitude.
    ADC r_battle_effect_sine_magnitude_2.w,X                                    ; $02E774 | |
    STA r_battle_effect_sine_magnitude_2.w,X                                    ; $02E777 |/
    RTS                                                                         ; $02E77A

; _battle_effect_get_sine_value ($02:E77B)
;
; Given an index to the sine magnitude array at $F1B3 in the X register,
; returns the current sine value in the accumulator.
_battle_effect_get_sine_value:
    LDA r_battle_effect_sine_magnitude.w,X                                      ; $02E77B |\
    ASL A                                                                       ; $02E77E | | Double the sine magnitude, as the sine data only goes to $7F.
    STA <r_math_multiply_8bit_arg_2                                             ; $02E77F |/
    LDA r_battle_effect_sine_index.w,X                                          ; $02E781 | Load the current sine index.
    JMP _battle_get_scaled_sine_value                                           ; $02E784 | Get the scaled sine value.

; _unused_battle_effect_get_sine_value_2 ($02:E787)
;
; Given an index to the second sine magnitude array at $F1F3 in the X register,
; returns the current sine value in the accumulator.
_unused_battle_effect_get_sine_value_2:
    LDA r_battle_effect_sine_magnitude_2.w,X                                    ; $02E787 |\
    ASL A                                                                       ; $02E78A | | Double the sine magnitude, as the sine data only goes to $7F.
    STA <r_math_multiply_8bit_arg_2                                             ; $02E78B |/
    LDA r_battle_effect_sine_index_2.w,X                                        ; $02E78D | Load the current sine index.
    JMP _battle_get_scaled_sine_value                                           ; $02E790 | Get the scaled sine value.

; battle_get_scaled_sine_value ($02:E793)
;
; Proxy function to call _battle_get_scaled_sine_value from another bank.
battle_get_scaled_sine_value:
    JSR _battle_get_scaled_sine_value                                           ; $02E793
    RTL                                                                         ; $02E796

; _battle_get_scaled_sine_value ($02:E797)
;
; Given an index to the sine data in the accumulator and a scaling value passed
; in $28, returns the sine value for that index multiplied by the scaling value
; and then divided by 256. (In other words, multiplied by the value / 256). If
; the value is negative, the carry flag is set. Otherwise, it is cleared.
; In general, half the multiplier is the magnitude of the returned result.
_battle_get_scaled_sine_value:
    TAX                                                                         ; $02E797 |\ Load the sine value corresponding to the passed index.
    LDA bank1C.sine_data.l,X                                                    ; $02E798 |/
    BPL +                                                                       ; $02E79C |\
    EOR #%11111111.b                                                            ; $02E79E | | If the value is negative, flip the bits and multiply by the set
    STA <r_math_multiply_8bit_arg_1                                             ; $02E7A0 | | scaling value. Flip the bits of the result and add one to negate
    JSR _math_multiply_8bit                                                     ; $02E7A2 | | it.
    LDA <r_math_multiply_8bit_result_hi                                         ; $02E7A5 | |
    EOR #%11111111.b                                                            ; $02E7A7 | |
    INC A                                                                       ; $02E7A9 |/
    BPL ++                                                                      ; $02E7AA | If the result is positive, branch to clear the carry flag.
-   SEC                                                                         ; $02E7AC |\ Otherwise, set the carry flag and return.
    RTS                                                                         ; $02E7AD |/
+   STA <r_math_multiply_8bit_arg_1                                             ; $02E7AE |\
    JSR _math_multiply_8bit                                                     ; $02E7B0 | | If the value was positive, simply multiply it by the scalar.
    LDA <r_math_multiply_8bit_result_hi                                         ; $02E7B3 |/
    BMI -                                                                       ; $02E7B5 | If the result is negative, set the carry value and return.
++  CLC                                                                         ; $02E7B7 | Otherwise, clear the carry value and return.
    RTS                                                                         ; $02E7B8

; battle_effect_projectile_initialize ($02:E7B9)
;
; Proxy function to call _battle_effect_projectile_initialize from another bank.
battle_effect_projectile_initialize:
    JSR _battle_effect_projectile_initialize                                    ; $02E7B9
    RTL                                                                         ; $02E7BC

; _battle_effect_projectile_initialize ($02:E7BD)
;
; Initializes the coordinates and other properties used when updating the
; coordinates of a projectile weapon effect.
_battle_effect_projectile_initialize:
    STZ r_unknown_f120.w                                                        ; $02E7BD | TODO: Zero out an unknown variable.
    LDX r_battle_effect_projectile_source_coordinates.w                         ; $02E7C0 |\ Set the projectile's initial coordinates to the source coordinates.
    STX r_battle_effect_projectile_coordinates.w                                ; $02E7C3 |/
    STZ r_battle_effect_projectile_direction.x.w                                ; $02E7C6 |\ Initialize the direction variables to zero.
    STZ r_battle_effect_projectile_direction.y.w                                ; $02E7C9 |/
    STZ r_battle_effect_projectile_y_delta.w                                    ; $02E7CC |\ Initialize the delta values to zero.
    STZ r_battle_effect_projectile_x_delta.w                                    ; $02E7CF |/
    STZ r_battle_effect_projectile_y_remainder.w                                ; $02E7D2 | Initialize the Y remainder value to zero.
    LDA r_battle_effect_projectile_source_coordinates.y.w                       ; $02E7D5 |\
    CMP r_battle_effect_projectile_target_coordinates.y.w                       ; $02E7D8 | | Depending on the relationship between the source and target Y
    BEQ ++                                                                      ; $02E7DB | | coordinates, branch to the appropriate section of code.
    BCC +                                                                       ; $02E7DD |/
    DEC r_battle_effect_projectile_direction.y.w                                ; $02E7DF |\
    LDA r_battle_effect_projectile_source_coordinates.y.w                       ; $02E7E2 | | If the target Y coordinate is above the source Y coordinate, set
    SEC                                                                         ; $02E7E5 | | the direction value to one, set the delta value to the source
    SBC r_battle_effect_projectile_target_coordinates.y.w                       ; $02E7E6 | | minus the target, and set the middle Y coordinate.
    STA r_battle_effect_projectile_y_delta.w                                    ; $02E7E9 | |
    LSR A                                                                       ; $02E7EC | |
    CLC                                                                         ; $02E7ED | |
    ADC r_battle_effect_projectile_target_coordinates.y.w                       ; $02E7EE | |
    STA r_battle_effect_projectile_middle_coordinates.y.w                       ; $02E7F1 | |
    BRA ++                                                                      ; $02E7F4 |/
+   INC r_battle_effect_projectile_direction.y.w                                ; $02E7F6 |\
    LDA r_battle_effect_projectile_target_coordinates.y.w                       ; $02E7F9 | | If the target Y coordinate is below the source Y coordinate, set
    SEC                                                                         ; $02E7FC | | the direction value to negative one, and then set both the delta
    SBC r_battle_effect_projectile_source_coordinates.y.w                       ; $02E7FD | | value and the middle Y coordinate.
    STA r_battle_effect_projectile_y_delta.w                                    ; $02E800 | |
    LSR A                                                                       ; $02E803 | |
    CLC                                                                         ; $02E804 | |
    ADC r_battle_effect_projectile_source_coordinates.y.w                       ; $02E805 | |
    STA r_battle_effect_projectile_middle_coordinates.y.w                       ; $02E808 | |
    BRA ++                                                                      ; $02E80B |/
++  LDA r_battle_effect_projectile_source_coordinates.x.w                       ; $02E80D |\
    CMP r_battle_effect_projectile_target_coordinates.x.w                       ; $02E810 | | Depending on the relationship between the source and target X
    BEQ ++                                                                      ; $02E813 | | coordinates, branch accordingly.
    BCC +                                                                       ; $02E815 |/
    DEC r_battle_effect_projectile_direction.x.w                                ; $02E817 |\
    LDA r_battle_effect_projectile_source_coordinates.x.w                       ; $02E81A | | If the target X coordinate is to the left of the source X
    SEC                                                                         ; $02E81D | | coordinate, set the direction to negative one and then set the
    SBC r_battle_effect_projectile_target_coordinates.x.w                       ; $02E81E | | delta and middle X coordinate.
    STA r_battle_effect_projectile_x_delta.w                                    ; $02E821 | |
    LSR A                                                                       ; $02E824 | |
    CLC                                                                         ; $02E825 | |
    ADC r_battle_effect_projectile_target_coordinates.x.w                       ; $02E826 | |
    STA r_battle_effect_projectile_middle_coordinates.x.w                       ; $02E829 | |
    BRA ++                                                                      ; $02E82C |/
+   INC r_battle_effect_projectile_direction.x.w                                ; $02E82E |\
    LDA r_battle_effect_projectile_target_coordinates.x.w                       ; $02E831 | | If the target X coordinate is to the right of the source X
    SEC                                                                         ; $02E834 | | coordinate, do the same thing, except the direction is set to one
    SBC r_battle_effect_projectile_source_coordinates.x.w                       ; $02E835 | |
    STA r_battle_effect_projectile_x_delta.w                                    ; $02E838 | |
    LSR A                                                                       ; $02E83B | |
    CLC                                                                         ; $02E83C | |
    ADC r_battle_effect_projectile_source_coordinates.x.w                       ; $02E83D | |
    STA r_battle_effect_projectile_middle_coordinates.x.w                       ; $02E840 |/
++  LDA r_battle_effect_projectile_x_delta.w                                    ; $02E843 |\
    TAX                                                                         ; $02E846 | | Set the total number of frames for the animation to the total X
    STX <r_math_divide_16bit_arg_1                                              ; $02E847 | | distance divided by the horizontal rate, and then add one.
    LDA r_battle_effect_projectile_horizontal_rate.w                            ; $02E849 | |
    TAX                                                                         ; $02E84C | |
    STX <r_math_divide_16bit_arg_2                                              ; $02E84D | |
    JSR _math_divide_16bit                                                      ; $02E84F | |
    LDA <r_math_divide_16bit_result                                             ; $02E852 | |
    INC A                                                                       ; $02E854 | |
    STA r_battle_effect_projectile_frames_remaining.w                           ; $02E855 |/
    RTS                                                                         ; $02E858

; battle_effect_projectile_update_coordinates ($02:E859)
;
; Proxy function to call _battle_effect_projectile_update_coordinates from
; another bank.
battle_effect_projectile_update_coordinates:
    JSR _battle_effect_projectile_update_coordinates                            ; $02E859
    RTL                                                                         ; $02E85C

; _battle_effect_projectile_update_coordinates ($02:E85D)
;
; Updates the current coordinates of a weapon projectile, based on the values
; in memory from $F111 to $F11D. Sets the carry flag if the last frame of the
; animation has been reached, and clears the carry flag otherwise.
_battle_effect_projectile_update_coordinates:
    STZ r_battle_effect_projectile_y_counter_lo.w                               ; $02E85D |\ Initialize the Y coordinate change counter to zero.
    STZ r_battle_effect_projectile_y_counter_hi.w                               ; $02E860 |/
    LDA r_battle_effect_projectile_horizontal_rate.w                            ; $02E863 |\ Transfer the horizontal rate to a local variable.
    STA <r_battle_generic_tmp_index_lo                                          ; $02E866 |/
@outer_start:
    LDA r_battle_effect_projectile_coordinates.x.w                              ; $02E868 |\
    CLC                                                                         ; $02E86B | | Move the X coordinate by one in the desired direction.
    ADC r_battle_effect_projectile_direction.x.w                                ; $02E86C | |
    STA r_battle_effect_projectile_coordinates.x.w                              ; $02E86F |/
    LDA r_battle_effect_projectile_y_remainder.w                                ; $02E872 |\
    CLC                                                                         ; $02E875 | | Add the total Y delta to the Y remainder value (using the delta
    ADC r_battle_effect_projectile_y_delta.w                                    ; $02E876 | | values as a way to measure the ratio of deltaX to deltaY).
    STA r_battle_effect_projectile_y_remainder.w                                ; $02E879 |/
@inner_start:
    CMP r_battle_effect_projectile_x_delta.w                                    ; $02E87C |\ Skip to the next outer iteration if the current Y remainder is less
    BCC @next                                                                   ; $02E87F |/ than the size of the X delta.
    LDA r_battle_effect_projectile_direction.y.w                                ; $02E881 |\
    BMI +                                                                       ; $02E884 | | If the projectile is moving downward, extend the direction by
    REP #FLAG_P_ACCUMULATOR                                                     ; $02E886 | | reading the 16-bit value and masking out the high bits and storing
    LDA <r_battle_generic_tmp_index                                             ; $02E888 | | that to a variable.
    PHA                                                                         ; $02E88A | |
    LDA r_battle_effect_projectile_direction.y.w                                ; $02E88B | |
    AND #$00FF.w                                                                ; $02E88E | |
    STA <r_battle_generic_tmp_index                                             ; $02E891 | |
    BRA ++                                                                      ; $02E893 |/
+   REP #FLAG_P_ACCUMULATOR.b                                                   ; $02E895 |\
    LDA <r_battle_generic_tmp_index                                             ; $02E897 | | Otherwise, extend the value from 8 bits to 16 bits by setting all
    PHA                                                                         ; $02E899 | | the bits in the high byte and then storing that value.
    LDA r_battle_effect_projectile_direction.y.w                                ; $02E89A | |
    ORA #$FF00.w                                                                ; $02E89D | | Either way the result is the direction extended from 8 to 16 bits.
    STA <r_battle_generic_tmp_index                                             ; $02E8A0 |/
++  LDA r_battle_effect_projectile_y_counter.w                                  ; $02E8A2 |\
    CLC                                                                         ; $02E8A5 | | Add the calculated Y direction value to the Y counter, which
    ADC <r_battle_generic_tmp_index                                             ; $02E8A6 | | results in it containing the total Y distance moved this frame.
    STA r_battle_effect_projectile_y_counter.w                                  ; $02E8A8 | |
    PLA                                                                         ; $02E8AB | |
    STA <r_battle_generic_tmp_index                                             ; $02E8AC | |
    TDC                                                                         ; $02E8AE | |
    SEP #FLAG_P_ACCUMULATOR.b                                                   ; $02E8AF |/
    LDA r_battle_effect_projectile_coordinates.y.w                              ; $02E8B1 |\
    CLC                                                                         ; $02E8B4 | | Update the current Y coordinate in the target direction.
    ADC r_battle_effect_projectile_direction.y.w                                ; $02E8B5 | |
    STA r_battle_effect_projectile_coordinates.y.w                              ; $02E8B8 |/
    LDA r_battle_effect_projectile_y_remainder.w                                ; $02E8BB |\
    SEC                                                                         ; $02E8BE | | Subtract the X delta from the Y remainder and then loop back. The
    SBC r_battle_effect_projectile_x_delta.w                                    ; $02E8BF | | loop will continue until the remainder is less than the X delta.
    STA r_battle_effect_projectile_y_remainder.w                                ; $02E8C2 | | (This results in Y being updated proportionally to X.)
    JMP @inner_start                                                            ; $02E8C5 |/
@next:
    DEC <r_battle_generic_tmp_index_lo                                          ; $02E8C8 |\ Loop until the X coordinate has been updated a number of times
    BNE @outer_start                                                            ; $02E8CA |/ equal to the rate.
    DEC r_battle_effect_projectile_frames_remaining.w                           ; $02E8CC |\
    BNE +                                                                       ; $02E8CF | | If the number of remaining frames reaches zero, set the carry flag
    SEC                                                                         ; $02E8D1 | | and return.
    RTS                                                                         ; $02E8D2 |/
+   CLC                                                                         ; $02E8D3 | Otherwise clear the carry flag before returning.
    RTS                                                                         ; $02E8D4

; _battle_load_monster_death_palette ($02:E8D5)
;
; Proxy function to call the battle_load_monster_death_palette function in bank
; $03, which loads the palette used for monster death animations to the eighth
; palette.
_battle_load_monster_death_palette:
    JSL bank03.battle_load_monster_death_palette                                ; $02E8D5 | Jump to the palette loading function.
    RTS                                                                         ; $02E8D9

; _battle_monster_slot_map_enable_pre_action ($02:E8DA)
;
; Proxy function to call the battle_monster_slot_map_enable_pre_action function
; in bank $03.
_battle_monster_slot_map_enable_pre_action:
    JSL bank03.battle_monster_slot_map_enable_pre_action                        ; $02E8DA
    RTS                                                                         ; $02E8DE

; _battle_monster_slot_map_disable_pre_action ($02:E8DF)
;
; Proxy function to call the battle_monster_slot_map_disable_pre_action function
; in bank $03.
_battle_monster_slot_map_disable_pre_action:
    JSL bank03.battle_monster_slot_map_disable_pre_action                       ; $02E8DF
    RTS                                                                         ; $02E8E3

; _battle_erase_monster ($02:E8E4)
;
; Given a monster slot in the accumulator, erases that monster from view.
_battle_erase_monster:
    TAX                                                                         ; $02E8E4 |\
    LDA #$FF.b                                                                  ; $02E8E5 | | Set the monster's ID to $FF to make it disappear.
    STA r_monster_slot_to_id_index_pre_action.w,X                               ; $02E8E7 |/
    JSR _battle_monster_slot_map_enable_pre_action                              ; $02E8EA | Switch to using the modified slot map.
    JSR _battle_prepare_monster_tilemap                                         ; $02E8ED | Draw the updated monsters.
    JSR _battle_monster_slot_map_disable_pre_action                             ; $02E8F0 | Switch back to the other slot map.
    JMP _copy_battle_tilemap_bg1_left_to_vram                                   ; $02E8F3 | Copy the redrawn monsters to VRAM.

; _battle_animate_monster_death ($02:E8F6)
;
; Animates the death or other disappearance of a monster from the battle field.
_battle_animate_monster_death:
    LDA r_battle_effect_spell_index.w                                           ; $02E8F6 |\
    CMP #SPELL_MONSTER_ALERT.b                                                  ; $02E8F9 | | If the current spell is Alert, flag the audio as being pending and
    BNE +                                                                       ; $02E8FB | | set the spell index to zero. This is necessary for the Alert audio
    STA r_battle_monster_effect_audio_pending.w                                 ; $02E8FD | | to play and for it to stop quickly.
    STZ r_battle_effect_spell_index.w                                           ; $02E900 |/
+   LDA r_battle_disable_monster_drawing.w                                      ; $02E903 |\ Skip this next block if the drawing of monsters is disabled.
    BNE +                                                                       ; $02E906 |/
    TDC                                                                         ; $02E908 |\
    TAX                                                                         ; $02E909 | | Search for a monster that has been killed by the current action
-   LDA r_monster_slot_to_id_index.w,X                                          ; $02E90A | | by comparing the pre and post-action slot maps. If none is found,
    CMP r_monster_slot_to_id_index_pre_action.w,X                               ; $02E90D | | branch to the end.
    BNE +                                                                       ; $02E910 | |
    INX                                                                         ; $02E912 | |
    CPX #8.w                                                                    ; $02E913 | |
    BNE -                                                                       ; $02E916 | |
    JMP @done                                                                   ; $02E918 |/
+   LDA r_battle_monster_special_transition.w                                   ; $02E91B |\
    CMP #BATTLE_MONSTER_TRANSITION_SWAP.b                                       ; $02E91E | | Skip this function if the monster transition is set to swap.
    BNE +                                                                       ; $02E920 | |
    JMP @done                                                                   ; $02E922 |/
+   LDA r_formation_flags1.w                                                    ; $02E925 |\
    AND #FORMATION_FLAGS_1_SLOW_DEATH                                           ; $02E928 | | If the slow death flag is set on the formation, and if no other
    BEQ +                                                                       ; $02E92A | | special transition has been set, clear the right side of BG1,
    LDA r_battle_monster_special_transition.w                                   ; $02E92C | | switch to the pre-action slot map, and animate the slow dissolve
    BNE +                                                                       ; $02E92F | | effect on the monsters. Branch ahead afterward.
    JSR _battle_clear_bg1_right                                                 ; $02E931 | |
    JSR _battle_monster_slot_map_enable_pre_action                              ; $02E934 | |
    JSL bank03.battle_monster_slow_dissolve                                     ; $02E937 | |
    BRA ++                                                                      ; $02E93B |/
+   JSR _battle_monster_slot_map_enable_pre_action                              ; $02E93D |\ Load tilemaps for the pre-action monsters.
    JSR _battle_load_monster_tilemaps                                           ; $02E940 |/
    LDY r_battle_formation.w                                                    ; $02E943 |\
    CPY #BATTLE_FORMATION_ZEROMUS_FINAL.w                                       ; $02E946 | | If this is the final Zeromus battle and if no special transition
    BNE +                                                                       ; $02E949 | | is configured, set the Zeromus death flag, and animate the Zeromus
    LDA r_battle_monster_special_transition.w                                   ; $02E94B | | death sequence.
    BNE +                                                                       ; $02E94E | |
    INC r_battle_zeromus_dead.w                                                 ; $02E950 | |
    JSR _battle_prepare_monster_tilemap                                         ; $02E953 | |
    JSR _copy_battle_tilemap_bg1_left_to_vram                                   ; $02E956 | |
    JSL bank03.battle_zeromus_death_animation                                   ; $02E959 |/
++  JSR _battle_monster_slot_map_disable_pre_action                             ; $02E95D |\
    TDC                                                                         ; $02E960 | | For Zeromus and slow monster death, reset the slot map to post-
    JSR _battle_play_sound_effect                                               ; $02E961 | | action, end any sound effect, and branch to the end.
    BRA @done                                                                   ; $02E964 |/
+   TDC                                                                         ; $02E966 |\
    TAX                                                                         ; $02E967 | | Scan through the slot map, identifying any monsters that have been
-   LDA r_monster_slot_to_id_index.w,X                                          ; $02E968 | | eliminated by the current action. For each of those, change their
    CMP r_monster_slot_to_id_index_backup.w,X                                   ; $02E96B | | palette to palette 7.
    BEQ +                                                                       ; $02E96E | |
    PHX                                                                         ; $02E970 | |
    TXA                                                                         ; $02E971 | |
    STA r_battle_update_monster_palette_arg_slot.w                              ; $02E972 | |
    LDA #7.b                                                                    ; $02E975 | |
    STA r_battle_update_monster_palette_arg_palette.w                           ; $02E977 | |
    JSR _battle_update_monster_palette                                          ; $02E97A | |
    PLX                                                                         ; $02E97D | |
+   INX                                                                         ; $02E97E | |
    CPX #8.w                                                                    ; $02E97F | |
    BNE -                                                                       ; $02E982 |/
    JSR _flip_battle_monster_tilemap                                            ; $02E984 | Reverse the loaded tilemap if necessary.
    JSR _battle_monster_slot_map_disable_pre_action                             ; $02E987 | Switch back to the post-action slot map.
    JSR _copy_battle_tilemap_bg1_right_to_vram                                  ; $02E98A | Transfer the tilemap with updated palette to BG1 right.
    JSR _battle_load_monster_death_palette                                      ; $02E98D | Load the monster death palette.
    LDA #1.b                                                                    ; $02E990 |\ Set the horizontal scroll to the right half of BG1 to display the
    JSR _battle_set_bg1_horizontal_hi_scroll                                    ; $02E992 |/ fading monsters.
    JSR _battle_prepare_monster_tilemap                                         ; $02E995 |\ Load the tilemap without the eliminated monsters and copy it to the
    JSR _copy_battle_tilemap_bg1_left_to_vram                                   ; $02E998 |/ left half of BG1.
    JSR _battle_animate_monster_dissolve                                        ; $02E99B | Animate the dissolve of the eliminated monsters.
    TDC                                                                         ; $02E99E |\ Reset to displaying the left half of BG1.
    JSR _battle_set_bg1_horizontal_hi_scroll                                    ; $02E99F |/
@done:
    STZ r_battle_monster_effect_audio_pending.w                                 ; $02E9A2 | Unset the pending monster effect audio flag.
    RTS                                                                         ; $02E9A5

; _battle_animate_monster_dissolve ($02:E9A6)
;
; Animates the monster visual effect used when the monster dies or runs away.
; Fades the eighth palette to black slowly while calling another function to
; update the HDMA tables to create the actual dissolve effect.
_battle_animate_monster_dissolve:
    LDA r_battle_monster_effect_audio_pending.w                                 ; $02E9A6 |\
    BNE @start                                                                  ; $02E9A9 | | If the sound effect for this monster effect has not been played,
    LDA #%10000000.b                                                            ; $02E9AB | | load the correct track number from ROM and play the effect.
    STA r_battle_play_audio_pan_monster.w                                       ; $02E9AD | |
    LDA r_battle_monster_special_transition.w                                   ; $02E9B0 | |
    TAX                                                                         ; $02E9B3 | |
    LDA bank03.battle_monster_effect_audio_data.l,X                             ; $02E9B4 | |
    JSR _battle_play_sound_effect                                               ; $02E9B8 |/
@start:
    STZ r_battle_monster_effect_audio_pending.w                                 ; $02E9BB | Ensure the sound effect is played only once.
    JSR _battle_wait_next_frame_preserve_x_y                                    ; $02E9BE | Wait for the next frame.
    TDC                                                                         ; $02E9C1 |\ Initialize the X register to zero.
    TAX                                                                         ; $02E9C2 |/
-   LDA r_battle_cgram_data.8.w,X                                               ; $02E9C3 |\
    STA <r_battle_fade_color_arg_color_lo                                       ; $02E9C6 | | Fade the current color in the palette one step closer to black.
    LDA r_battle_cgram_data.8.w + 1,X                                           ; $02E9C8 | |
    STA <r_battle_fade_color_arg_color_hi                                       ; $02E9CB | |
    LDA #1.b                                                                    ; $02E9CD | |
    JSR _battle_fade_color                                                      ; $02E9CF | |
    LDA <r_battle_fade_color_arg_color_lo                                       ; $02E9D2 | |
    STA r_battle_cgram_data.8.w,X                                               ; $02E9D4 | |
    LDA <r_battle_fade_color_arg_color_hi                                       ; $02E9D7 | |
    STA r_battle_cgram_data.8.w + 1,X                                           ; $02E9D9 |/
    INX                                                                         ; $02E9DC |\
    INX                                                                         ; $02E9DD | | Increment the X register by two to the move to the next color and
    CPX #_sizeof_palette.w                                                      ; $02E9DE | | repeat until all colors have been stepped.
    BNE -                                                                       ; $02E9E1 |/
    JSL bank03.battle_update_monster_dissolve.l                                 ; $02E9E3 | Update the HDMA table for the monster dissolve effect.
    INC <r_battle_monster_effect_counter                                        ; $02E9E7 |\ Increment the counter.
    LDA <r_battle_monster_effect_counter                                        ; $02E9E9 |/
    CMP #48.b                                                                   ; $02E9EB |\ Repeat until it reaches 48.
    BNE @start                                                                  ; $02E9ED |/
    RTS                                                                         ; $02E9EF

; battle_effect_update_odin_scroll_hdma ($02:E9F0)
;
; Given a sine index in the accumulator and an 8-bit line number to start
; modifying, updates the BG1 HDMA scroll values for the 24 lines beginining at
; the start line to have a scroll value corresponding to the given sine index
; with a magnitude of 16.
battle_effect_update_odin_scroll_hdma:
    PHA                                                                         ; $02E9F0 |\
    LDA #32.b                                                                   ; $02E9F1 | | Get the sine value for the passed index, with a magnitude of 16,
    STA <r_math_multiply_8bit_arg_2                                             ; $02E9F3 | | and then extend the highest bit by one, to cause the final value
    PLA                                                                         ; $02E9F5 | | to range from 496 to 511 or 0 to 15. Save the result to a local
    JSR _battle_get_scaled_sine_value                                           ; $02E9F6 | | variable.
    STA <r_battle_generic_tmp_index_3_lo                                        ; $02E9F9 | |
    ASL <r_math_multiply_8bit_result_hi                                         ; $02E9FB | |
    ROL <r_battle_generic_tmp_index_3_hi                                        ; $02E9FD | |
    LDA <r_battle_generic_tmp_index_3_hi                                        ; $02E9FF | |
    AND #%00000001.b                                                            ; $02EA01 | |
    STA <r_battle_generic_tmp_index_3_hi                                        ; $02EA03 |/
    LDY #24.w                                                                   ; $02EA05 |\ Initialize the counter to 24.
    STY <r_battle_generic_tmp_index                                             ; $02EA08 |/
    LDA <r_battle_generic_tmp_index_2_lo                                        ; $02EA0A |\
    REP #FLAG_P_ACCUMULATOR                                                     ; $02EA0C | | Set the Y register to the parameter passed in $02 times four,
    ASL A                                                                       ; $02EA0E | | which determines the first line to modify.
    ASL A                                                                       ; $02EA0F | |
    TAY                                                                         ; $02EA10 |/
    LDA <r_battle_generic_tmp_index_3                                           ; $02EA11 | Load the previously calculated value.
-   STA r_battle_bg1_hdma_data.1.horizontal.w,Y                                 ; $02EA13 | Save the value as the horizontal scroll value for this line.
    INY                                                                         ; $02EA16 |\
    INY                                                                         ; $02EA17 | | Increment the Y register by four to move to the next line.
    INY                                                                         ; $02EA18 | |
    INY                                                                         ; $02EA19 |/
    DEC <r_battle_generic_tmp_index                                             ; $02EA1A |\ Decrement the counter and loop until all 24 lines have been set.
    BNE -                                                                       ; $02EA1C |/
    TDC                                                                         ; $02EA1E |\
    SEP #FLAG_P_ACCUMULATOR                                                     ; $02EA1F | | Add 24 to the initial line to allow subsequent calls to resume
    LDA <r_battle_generic_tmp_index_2_lo                                        ; $02EA21 | | from where this one left off.
    CLC                                                                         ; $02EA23 | |
    ADC #24.b                                                                   ; $02EA24 | |
    STA <r_battle_generic_tmp_index_2_lo                                        ; $02EA26 |/
    RTL                                                                         ; $02EA28

; battle_spell_cast_effect_audio_index_data ($02:EA29)
;
; For each casting effect (black, white and call) determines which spell audio
; index to use to look up the correct audio effect for the effect.
battle_spell_cast_effect_audio_index_data:
    .db $FC                                                                     ; $02EA29
    .db $FD                                                                     ; $02EA2A
    .db $FE                                                                     ; $02EA2B

; _battle_animate_cast_effect_generic ($02:EA2C)
;
; A given a value ranging from 0 to 2 in the accumulator, supposedly animates
; the corresponding casting effect. However, this actually only applies in the
; case of A = 0 for black magic. For white and call magic, it will play the
; appropriate sound effect, but the actual visual animation is handled by
; another routine to be called subsequently.
_battle_animate_cast_effect_generic:
    PHA                                                                         ; $02EA2C |\
    TAX                                                                         ; $02EA2D | | Set the appropriate audio index for the casting effect by loading
    LDA battle_spell_cast_effect_audio_index_data.l,X                           ; $02EA2E | | the value from ROM.
    STA r_battle_effect_spell_audio_index.w                                     ; $02EA32 | |
    PLA                                                                         ; $02EA35 |/
    PHA                                                                         ; $02EA36 |\
    LDA <r_battle_current_actor_slot                                            ; $02EA37 | | Wait until the actor reaches the acting position.
    ASL A                                                                       ; $02EA39 | |
    ASL A                                                                       ; $02EA3A | |
    ASL A                                                                       ; $02EA3B | |
    ASL A                                                                       ; $02EA3C | |
    TAX                                                                         ; $02EA3D | |
-   LDA r_battle_character_visual_properties.1.x.w,X                            ; $02EA3E | |
    CMP #BATTLE_COORDINATE_X_PARTY_ACTING.b                                     ; $02EA41 | |
    BNE -                                                                       ; $02EA43 | |
    PLA                                                                         ; $02EA45 |/
    STZ r_battle_effect_spell_sprite_pattern.w                                  ; $02EA46 | Initialize the sprite pattern to fixed.
    PHA                                                                         ; $02EA49 |\
    JSR _battle_load_casting_spell_tiles                                        ; $02EA4A | | Load the tiles associated with this casting effect.
    PLA                                                                         ; $02EA4D |/
    PHA                                                                         ; $02EA4E |\
    CLC                                                                         ; $02EA4F | | Load the palette associated with the effect. Specifically, load
    ADC #6.b                                                                    ; $02EA50 | | the miscellaneous palette numbered six plus the effect number.
    LDX #15.w                                                                   ; $02EA52 | | Load the palette into palette 15 (the last palette) for use by
    STA r_battle_effect_load_palette_arg_palette.w                              ; $02EA55 | | effect sprites.
    JSR _battle_load_miscellaneous_palette                                      ; $02EA58 |/
    STZ <r_battle_effect_spell_animate_arg_monster                              ; $02EA5B | Specify that the animation is targeting party members.
    JSR _battle_get_current_actor_target_mask                                   ; $02EA5D | Set the target mask to a mask matching the current actor.
    STZ <r_battle_effect_spell_animate_arg_wall_targets                         ; $02EA60 | Specify that there are no wall targets for the effect.
    PLA                                                                         ; $02EA62 |\ Save the effect ID to a temporary variable.
    STA <r_battle_generic_tmp_index_3_lo                                        ; $02EA63 |/
    LDA r_battle_effect_spell_animate_reeling.w                                 ; $02EA65 |\ Preserve the existing value of the reeling flag.
    PHA                                                                         ; $02EA68 |/
    STZ r_battle_effect_spell_animate_reeling.w                                 ; $02EA69 | Set the reeling flag to zero (as the effect does not cause reeling).
    LDA r_battle_current_action_details.actor_flags.w                           ; $02EA6C |\ Set the audio effect to pan to the party member side.
    STA r_battle_play_audio_pan_monster.w                                       ; $02EA6F |/
    LDA <r_battle_generic_tmp_index_3_lo                                        ; $02EA72 |\ Animate the casting effect.
    JSR _battle_effect_spell_animate                                            ; $02EA74 |/
    PLA                                                                         ; $02EA77 |\ Restore the original value of the reeling flag.
    STA r_battle_effect_spell_animate_reeling.w                                 ; $02EA78 |/
    JSR _battle_reset_effect_oam_large                                          ; $02EA7B | Reset the effect OAM to large sprites.
    RTS                                                                         ; $02EA7E

; _battle_load_call_sprite ($02:EA7F)
;
; Given a spell number (referring to a Call spell) in the accumulator (ranging
; from $4D to $5D), loads the sprite for that spell into VRAM.
_battle_load_call_sprite:
    PHA                                                                         ; $02EA7F | Preserve the value in the accumulator.
    SEC                                                                         ; $02EA80 |\
    SBC #SPELL_FIRST_CALL.b                                                     ; $02EA81 | | Subtract the base call spell index from the parameter, push it
    PHA                                                                         ; $02EA83 | | twice to the stack, and then transfer it to the X register.
    PHA                                                                         ; $02EA84 | |
    TAX                                                                         ; $02EA85 |/
    LDA bank0D.battle_call_sprite_palette_data.l,X                              ; $02EA86 |\
    LDX #12.w                                                                   ; $02EA8A | | Load the specified palette for this sprite.
    JSR _battle_load_monster_palette                                            ; $02EA8D |/
    PLA                                                                         ; $02EA90 |\
    ASL A                                                                       ; $02EA91 | | Transfer double the spell index into the X register.
    TAX                                                                         ; $02EA92 |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $02EA93 |\
    LDA #128.w                                                                  ; $02EA95 | | Configure to transfer 128 tiles.
    STA <r_battle_copy_3bpp_to_ram_arg_tiles                                    ; $02EA98 |/
    LDA bank0D.battle_sprite_call_offset_data.l,X                               ; $02EA9A |\ Load the offset for this spell and transfer it to the Y register.
    TAY                                                                         ; $02EA9E |/
    LDX #r_battle_load_sprite_data.w                                            ; $02EA9F | Set the X register to the destination array.
    TDC                                                                         ; $02EAA2 |\
    SEP #FLAG_P_ACCUMULATOR                                                     ; $02EAA3 | | Load the bank number into the accumulator.
    LDA #:bank0D.battle_sprite_call_offset_data.b                               ; $02EAA5 |/
    JSR _battle_copy_3bpp_to_ram                                                ; $02EAA7 | Copy the sprite graphical data to RAM, expanding to 4bpp.
    PLA                                                                         ; $02EAAA |\
    ASL A                                                                       ; $02EAAB | | Transfer the spell index times two to the X register.
    TAX                                                                         ; $02EAAC |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $02EAAD |\
    LDA bank0D.battle_sprite_call_tilemap_offset_data.l,X                       ; $02EAAF | | Load the offset to the tilemap data for the sprite into the X
    TAX                                                                         ; $02EAB3 | | register.
    TDC                                                                         ; $02EAB4 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $02EAB5 |/
    LDA #:bank0D.battle_sprite_call_tilemap_offset_data.b                       ; $02EAB7 | Load the bank number into the accumulator.
    JSR _battle_copy_call_sprite_to_vram                                        ; $02EAB9 | Load the sprite into VRAM.
    PLA                                                                         ; $02EABC | Restore the value in the accumulator.
    RTS                                                                         ; $02EABD

; _battle_script_audiovisual_animate_spell ($02:EABE)
;
; Reads the next byte from the audiovisual script, and animates the associated
; spell.
_battle_script_audiovisual_animate_spell:
    STZ r_battle_effect_spell_special_mode.w                                    ; $02EABE
    LDA (<r_battle_script_audiovisual_ptr)                                      ; $02EAC1
    BNE _battle_effect_animate_spell                                            ; $02EAC3
    RTS                                                                         ; $02EAC5

; _battle_effect_animate_spell ($02:EAC6)
;
; Given a spell ID in the accumulator, animates that spell.
_battle_effect_animate_spell:
    STA r_battle_effect_spell_index.w                                           ; $02EAC6 | Save the spell index for use by other routines.
    STA r_battle_effect_spell_audio_index.w                                     ; $02EAC9 |\ Set the audio index to the spell index minus one.
    DEC r_battle_effect_spell_audio_index.w                                     ; $02EACC |/
    STZ r_battle_effect_palette_cycle_enabled.w                                 ; $02EACF | Disable palette cycling.
    STZ r_battle_effect_target_palette_cycling_disable.w                        ; $02EAD2 | Disable target palette cycling.
    CMP #SPELL_FIRST_CALL.b                                                     ; $02EAD5 |\
    BCC ++                                                                      ; $02EAD7 | | Skip this next block unless the spell is in the Call spell range.
    CMP #SPELL_LAST_CALL.b + 1                                                  ; $02EAD9 | |
    BCS ++                                                                      ; $02EADB |/
    PHA                                                                         ; $02EADD | Preserve the spell ID.
    JSR _battle_load_call_sprite                                                ; $02EADE | Load the associated sprite data.
    JSL bank03.battle_initialize_alternate_party_sprite                         ; $02EAE1 | Initialize the alternate party sprite parameters.
    LDA #ALTERNATE_PARTY_SPRITE_MODE_CALL.b                                     ; $02EAE5 |\ Set the alternate party sprite mode to Call to enable its display.
    STA r_battle_alternate_party_sprite_mode.w                                  ; $02EAE7 |/
    JSL bank03.battle_fade_sprites_from_white                                   ; $02EAEA | Fade the character sprites from white.
    JSR _battle_activate_battle_background_fade                                 ; $02EAEE | Activate the battle background fade effect.
    LDA r_battle_current_action_details.target.w                                ; $02EAF1 |\
    BNE +                                                                       ; $02EAF4 | | If there were no successful targets for the spell, jump to
    PLA                                                                         ; $02EAF6 | | immediately animate the Call finish.
    JMP _battle_animate_call_finish                                             ; $02EAF7 |/
+   PLA                                                                         ; $02EAFA | Restore the spell ID to the accumulator.
++  DEC A                                                                       ; $02EAFB |\
    REP #FLAG_P_ACCUMULATOR                                                     ; $02EAFC | | Set the X register to the spell ID minus one times four, to index
    ASL A                                                                       ; $02EAFE | | the spell visual properties.
    ASL A                                                                       ; $02EAFF | |
    TAX                                                                         ; $02EB00 | |
    TDC                                                                         ; $02EB01 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $02EB02 |/
    LDA bank0F.spell_visual_property_data.l + spell_visual.palette,X            ; $02EB04 |\
    PHX                                                                         ; $02EB08 | | Read the palette byte and load that palette into palette 15.
    LDX #15.w                                                                   ; $02EB09 | |
    STA r_battle_effect_load_palette_arg_palette.w                              ; $02EB0C | |
    JSR _battle_load_miscellaneous_palette                                      ; $02EB0F | |
    PLX                                                                         ; $02EB12 |/
    LDA bank0F.spell_visual_property_data.l + spell_visual.tile_block.l,X       ; $02EB13 |\
    PHX                                                                         ; $02EB17 | | Load the tile blocks for the spell.
    JSR _battle_load_spell_tiles_multiple_blocks                                ; $02EB18 |/
    LDA r_battle_current_action_details.target_flags.w                          ; $02EB1B |\ Set the audio to pan to the monster side if the target is a
    STA r_battle_play_audio_pan_monster.w                                       ; $02EB1E |/ monster.
    PLX                                                                         ; $02EB21 | Restore the visual properties offset to the X register.
    LDA bank0F.spell_visual_property_data.l + spell_visual.script,X             ; $02EB22 |\
    CMP #$FF.b                                                                  ; $02EB26 | | Load the script for the spell, and if $FF, skip the next block.
    BEQ +                                                                       ; $02EB28 |/
    STA r_battle_effect_spell_script_index.w                                    ; $02EB2A | Store the spell's script index.
    LDA #1.b                                                                    ; $02EB2D |\
    STA r_battle_effect_oam_reset_inhibit_counter_base.w                        ; $02EB2F | | Set the OAM reset inhibit counter and base counter to 1.
    STA r_battle_effect_oam_reset_inhibit_counter.w                             ; $02EB32 |/
    LDA bank0F.spell_visual_property_data.l + spell_visual.handler,X            ; $02EB35 |\
    CMP #$FF.b                                                                  ; $02EB39 | | Skip this next block if the handler is set to $FF.
    BEQ +                                                                       ; $02EB3B |/
    ASL A                                                                       ; $02EB3D |\
    TAX                                                                         ; $02EB3E | | Load the pointer to the handler into a temporary variable.
    LDA battle_effect_spell_animate_handler_offset_data.l + 0,X                 ; $02EB3F | |
    STA <r_battle_generic_tmp_ptr_2_addr_lo                                     ; $02EB43 | |
    LDA battle_effect_spell_animate_handler_offset_data.l + 1,X                 ; $02EB45 | |
    STA <r_battle_generic_tmp_ptr_2_addr_hi                                     ; $02EB49 |/
    JSR _battle_effect_spell_animate_dispatch                                   ; $02EB4B | Call the handler.
+   STZ r_battle_effect_spell_special_mode.w                                    ; $02EB4E | Reset the special mode to none.
    JMP _battle_reset_effect_oam_large.w                                        ; $02EB51 | Reset the effect OAM to large sprites.

; _battle_effect_spell_animate_dispatch ($02:EB54)
;
; Given a 16-bit pointer to a spell effect handler in $00, jumps to that handler
; after eanble automatic OAM updates.
_battle_effect_spell_animate_dispatch:
    STZ r_battle_disable_oam_update.w                                           ; $02EB54 | Re-enable automatic OAM updates.
    JMP (r_battle_generic_tmp_ptr_2_addr.w)                                     ; $02EB57 | Jump to the handler.

; battle_effect_spell_animate_internal ($02:EB5A)
;
; Given a spell effect in the accumulator, loads the pointer for that handler
; and calls that handler. This version of the function does no other setup and
; is used internally by certain spell effects to animate part of their full
; effect (e.g. the Stone spell part of the Cocktric call).
battle_effect_spell_animate_internal:
    CMP #$FF.b                                                                  ; $02EB5A |\ If the passed value is $FF, return without doing anything.
    BEQ +                                                                       ; $02EB5C |/
    ASL A                                                                       ; $02EB5E |\
    TAX                                                                         ; $02EB5F | | Read the pointer for the associated handler and store it in the
    LDA battle_effect_spell_animate_handler_offset_data.l + 0,X                 ; $02EB60 | | parameter for the dispatch routine.
    STA <r_battle_generic_tmp_ptr_2_addr_lo                                     ; $02EB64 | |
    LDA battle_effect_spell_animate_handler_offset_data.l + 1,X                 ; $02EB66 | |
    STA <r_battle_generic_tmp_ptr_2_addr_hi                                     ; $02EB6A |/
    JSR _battle_effect_spell_animate_internal_dispatch                          ; $02EB6C | Dispatch to the loaded handler.
+   RTL                                                                         ; $02EB6F

; _battle_effect_spell_animate_internal_dispatch ($02:EB70)
;
; Given a 16-bit pointer to a spell effect handler in $00, jumps to that handler
; after enabling automatic OAM updates.
_battle_effect_spell_animate_internal_dispatch:
    STZ r_battle_disable_oam_update.w                                           ; $02EB70 | Enable the automatic update of the OAM.
    JMP (r_battle_generic_tmp_ptr_2_addr.w)                                     ; $02EB73 | Jump to the provided handler.

; battle_effect_spell_animate_handler_offset_data ($02:EB76)
;
; For each spell effect, contains the pointer to the handler for that effect.
battle_effect_spell_animate_handler_offset_data:
    .addr _battle_effect_spell_animate_standard_fixed                           ; $02EB76.EB77 | $00: Various Spells
    .addr _battle_effect_spell_animate_standard_block                           ; $02EB78.EB79 | $01: <unused>
    .addr _battle_effect_spell_animate_standard_random                          ; $02EB7A.EB7B | $02: Various Spells
    .addr _battle_effect_spell_animate_exit                                     ; $02EB7C.EB7D | $03: Exit
    .addr _battle_effect_spell_animate_meteo                                    ; $02EB7E.EB7F | $04: Meteo, W.Meteo
    .addr _battle_effect_spell_animate_comet                                    ; $02EB80.EB81 | $05: Comet
    .addr _battle_effect_spell_animate_drain                                    ; $02EB82.EB83 | $06: Drain, Psych, Absorb, Vampire
    .addr _battle_effect_spell_animate_quake                                    ; $02EB84.EB85 | $07: Quake
    .addr _battle_effect_spell_animate_standard_party_field                     ; $02EB86.EB87 | $08: <unused>
    .addr _battle_effect_spell_animate_standard_monster_field                   ; $02EB88.EB89 | $09: <unused>
    .addr _battle_effect_spell_animate_imp                                      ; $02EB8A.EB8B | $0A: Imp
    .addr _battle_effect_spell_animate_bomb                                     ; $02EB8C.EB8D | $0B: Bomb
    .addr _battle_effect_spell_animate_cocktric                                 ; $02EB8E.EB8F | $0C: Dummy (Cocktric)
    .addr _battle_effect_spell_animate_mage                                     ; $02EB90.EB91 | $0D: Mage
    .addr _battle_effect_spell_animate_chocobo                                  ; $02EB92.EB93 | $0E: Chocobo
    .addr _battle_effect_spell_animate_shiva                                    ; $02EB94.EB95 | $0F: Shiva
    .addr _battle_effect_spell_animate_indra                                    ; $02EB96.EB97 | $10: Indra
    .addr _battle_effect_spell_animate_jinn                                     ; $02EB98.EB99 | $11: Jinn, Stone, Ray, Beak, Petrify, Hug
    .addr _battle_effect_spell_animate_titan                                    ; $02EB9A.EB9B | $12: Titan
    .addr _battle_effect_spell_animate_mist                                     ; $02EB9C.EB9D | $13: Mist
    .addr _battle_effect_spell_animate_sylph                                    ; $02EB9E.EB9F | $14: Sylph
    .addr _battle_effect_spell_animate_odin                                     ; $02EBA0.EBA1 | $15: Odin
    .addr _battle_effect_spell_animate_leviatan                                 ; $02EBA2.EBA3 | $16: Leviatan
    .addr _battle_effect_spell_animate_asura                                    ; $02EBA4.EBA5 | $17: Asura (1)
    .addr _battle_effect_spell_animate_asura                                    ; $02EBA6.EBA7 | $18: Asura (2)
    .addr _battle_effect_spell_animate_asura                                    ; $02EBA8.EBA9 | $19: Asura (3)
    .addr _battle_effect_spell_animate_bahamut                                  ; $02EBAA.EBAB | $1A: Bahamut
    .addr _battle_effect_spell_animate_standard_fixed_no_target_palette_cycling ; $02EBAC.EBAD | $1B: <unused>
    .addr _battle_effect_spell_animate_original                                 ; $02EBAE.EBAF | $1C: <unused>
    .addr _battle_effect_spell_animate_explode                                  ; $02EBB0.EBB1 | $1D: Explode
    .addr _battle_effect_spell_animate_reaction                                 ; $02EBB2.EBB3 | $1E: Reaction
    .addr _battle_effect_spell_animate_explode_acting_monster                   ; $02EBB4.EBB5 | $1F: Reaction (sub-call by the main handler)
    .addr _battle_effect_spell_animate_demolish                                 ; $02EBB6.EBB7 | $20: Warp, Demolish, Disrupt
    .addr _battle_effect_spell_animate_nuke                                     ; $02EBB8.EBB9 | $21: Nuke
    .addr _battle_effect_spell_animate_wave                                     ; $02EBBA.EBBB | $22: Big Wave, Wave
    .addr _battle_effect_spell_animate_fire3                                    ; $02EBBC.EBBD | $23: Fire3
    .addr _battle_effect_spell_animate_noop                                     ; $02EBBE.EBBF | $24: <unused>
    .addr _battle_effect_spell_animate_white                                    ; $02EBC0.EBC1 | $25: White
    .addr _battle_effect_spell_animate_odin_monster                             ; $02EBC2.EBC3 | $26: Odin (monster)
    .addr _battle_effect_spell_animate_big_bang                                 ; $02EBC4.EBC5 | $27: Big Bang
    .addr _battle_effect_spell_animate_actor_as_target                          ; $02EBC6.EBC7 | $28: Fission
    .addr _battle_effect_spell_animate_rotating_pair                            ; $02EBC8.EBC9 | $29: Cure4
    .addr _battle_effect_spell_animate_standard_fixed_flash_blue                ; $02EBCA.EBCB | $2A: Glance
    .addr _battle_effect_spell_animate_standard_fixed_flash_red                 ; $02EBCC.EBCD | $2B: Crush
    .addr _battle_effect_spell_animate_standard_fixed_flash_yellow              ; $02EBCE.EBCF | $2C: <unused>
    .addr _battle_effect_spell_animate_standard_fixed_flash_white               ; $02EBD0.EBD1 | $2D: Gaze, Slap
    .addr _battle_effect_spell_animate_actor_and_target                         ; $02EBD2.EBD3 | $2E: <unused>
    .addr _battle_effect_spell_animate_blk_hole                                 ; $02EBD4.EBD5 | $2F: Blk.Hole

; _battle_effect_spell_animate_blk_hole ($02:EBD6)
;
; Animation handler for the Blk.Hole spell.
_battle_effect_spell_animate_blk_hole:
    JSR _battle_play_sound_effect_spell                                         ; $02EBD6 | Play the sound effect for the spell.
    JSR _battle_activate_battle_background_fade                                 ; $02EBD9 | Activate the battle background fade effect.
    JSL bank01.set_battle_flash_continuous_white                                ; $02EBDC | Start a white flash effect.
    LDX #32.w                                                                   ; $02EBE0 |\ Wait for 32 frames.
    JSR _battle_wait_x_frames                                                   ; $02EBE3 |/
    STZ r_battle_flash_mode.w                                                   ; $02EBE6 | Disable the flash effect.
    JMP _battle_deactivate_battle_background_fade                               ; $02EBE9 | Deactivate the battle background fade effect.

; _battle_effect_spell_animate_actor_and_target ($02:EBEC)
;
; Animation handler for spells that animate the effect on both the actor and
; the target.
_battle_effect_spell_animate_actor_and_target:
    JSR _battle_effect_spell_animate_actor                                      ; $02EBEC | Animate the spell on the actor.
    JMP _battle_effect_spell_animate_original                                   ; $02EBEF | Animate the spell on the target.

; _battle_effect_spell_animate_big_bang ($02:EBF2)
;
; Animation handler for the Big Bang spell.
_battle_effect_spell_animate_big_bang:
    LDA #BATTLE_SPELL_SPECIAL_MODE_BIG_BANG.b                                   ; $02EBF2 |\ Set the spell special mode to Big Bang.
    STA r_battle_effect_spell_special_mode.w                                    ; $02EBF4 |/
    JSL bank03.battle_animate_big_bang                                          ; $02EBF7 | Animate the Big Bang effect.
    RTS                                                                         ; $02EBFB

; _battle_effect_spell_animate_standard_fixed_flash_blue ($02:EBFC)
;
; Animation handler for standard fixed spells that start with a blue flash
; effect.
_battle_effect_spell_animate_standard_fixed_flash_blue:
    JSR _battle_play_sound_effect_spell                                         ; $02EBFC | Play the sound effect for the spell.
    JSL bank01.set_battle_flash_continuous_blue                                 ; $02EBFF | Start a blue battle flash.
    JMP _battle_effect_spell_animate_standard_fixed_flash_common                ; $02EC03 | Jump to the common code.

; _battle_effect_spell_animate_standard_fixed_flash_red ($02:EC06)
;
; Animation handler for standard fixed spells that start with a red flash
; effect.
_battle_effect_spell_animate_standard_fixed_flash_red:
    JSR _battle_play_sound_effect_spell                                         ; $02EC06 | Play the sound effect for the spell.
    JSL bank01.set_battle_flash_continuous_red                                  ; $02EC09 | Start a red battle flash.
    JMP _battle_effect_spell_animate_standard_fixed_flash_common                ; $02EC0D | Jump to the common code.

; _battle_effect_spell_animate_standard_fixed_flash_yellow ($02:EC10)
;
; Animation handler for standard fixed spells that start with a yellow flash
; effect.
_battle_effect_spell_animate_standard_fixed_flash_yellow:
    JSR _battle_play_sound_effect_spell                                         ; $02EC10 | Play the sound effect for the spell.
    JSL bank01.set_battle_flash_continuous_yellow                               ; $02EC13 | Start a yellow battle flash.
    JMP _battle_effect_spell_animate_standard_fixed_flash_common                ; $02EC17 | Jump to the common code.

; _battle_effect_spell_animate_standard_fixed_flash_white ($02:EC1A)
;
; Animation handler for standard fixed spells that start with a white flash
; effect.
_battle_effect_spell_animate_standard_fixed_flash_white:
    JSR _battle_play_sound_effect_spell                                         ; $02EC1A | Play the sound effect for the spell.
    JSL bank01.set_battle_flash_continuous_white.l                              ; $02EC1D | Start a white battle flash and fall through.

; _battle_effect_spell_animate_standard_fixed_flash_common ($02:EC21)
;
; Common code for the spell effects that start with a battle flash.
_battle_effect_spell_animate_standard_fixed_flash_common:
    LDX #16.w                                                                   ; $02EC21 |\ Wait 16 frames.
    JSR _battle_wait_x_frames                                                   ; $02EC24 |/
    STZ r_battle_flash_mode.w                                                   ; $02EC27 | Disable the battle flash.
    JMP _battle_effect_spell_animate_standard_fixed                             ; $02EC2A | Animate a standard fixed spell effect.

; _battle_effect_spell_rotating_pair_initialize ($02:EC2D)
;
; Initializes the sine data and sprite pattern for any spell using the rotating
; pair sprite effect.
_battle_effect_spell_rotating_pair_initialize:
    JSR _battle_effect_initialize_sine_indexes                                  ; $02EC2D | Initialize the sine indexes.
    LDA #24.b                                                                   ; $02EC30 |\ Set the sine magnitude to 24.
    JSR _battle_effect_initialize_sine_magnitude                                ; $02EC32 |/
    LDX #4.w                                                                    ; $02EC35 | Initialize the X register to four.
-   LDA #128.b                                                                  ; $02EC38 |\
    JSR _battle_effect_increment_sine_indexes                                   ; $02EC3A | | Increment sine indexes 4 through 7 by 128.
    INX                                                                         ; $02EC3D | |
    CPX #8.w                                                                    ; $02EC3E | |
    BNE -                                                                       ; $02EC41 |/
    JSR _battle_effect_spell_set_sprite_pattern_block                           ; $02EC43 | NOTE: Pointlessly set the sprite pattern to block.
    LDA #BATTLE_SPELL_SPRITE_PATTERN_ROTATING_PAIR.b                            ; $02EC46 |\ Set the sprite pattern to rotating pair.
    STA r_battle_effect_spell_sprite_pattern.w                                  ; $02EC48 |/
    RTS                                                                         ; $02EC4B

; _battle_effect_spell_animate_rotating_pair ($02:EC4C)
;
; Animation handler for the Cure4 spell (or any other spells using the rotating
; pair effect, if they existed).
_battle_effect_spell_animate_rotating_pair:
    JSR _battle_effect_spell_rotating_pair_initialize                           ; $02EC4C | Initialize the rotating pair sine parameters.
    JSR _battle_effect_spell_animate_original                                   ; $02EC4F | Animate the original cast.
    JSR _battle_effect_spell_rotating_pair_initialize                           ; $02EC52 | Initialize the rotating pair sine parameters.
    JMP _battle_effect_spell_animate_reflected                                  ; $02EC55 | Animate the reflected cast.

; _battle_effect_spell_white_animate_cast ($02:EC58)
;
; Animates a single cast of the White spell, including the sound effect, given
; target flags in $F462 and the target mask in $F463.
_battle_effect_spell_white_animate_cast:
    LDA #SPELL_WHITE.b - 1                                                      ; $02EC58 |\ Set the audio index for the White spell.
    STA r_battle_effect_spell_audio_index.w                                     ; $02EC5A |/
    JSL bank01.battle_animate_spell_white                                       ; $02EC5D | Animate the White spell on the current target.
    LDA #$FF.b                                                                  ; $02EC61 |\ Set the audio index to not play audio for the next animation.
    STA r_battle_effect_spell_audio_index.w                                     ; $02EC63 |/
    RTS                                                                         ; $02EC66

; _battle_effect_spell_animate_white ($02:EC67)
;
; Animation handler for the White spell.
_battle_effect_spell_animate_white:
    JSR _battle_effect_spell_set_sprite_pattern_block                           ; $02EC67 |\ Set the sprite pattern to a random effect.
    INC r_battle_effect_spell_sprite_pattern.w                                  ; $02EC6A |/
    LDA r_battle_current_action_details.target_flags.w                          ; $02EC6D |\ Set the target flags for the initial cast.
    STA r_battle_effect_spell_white_target_flags.w                              ; $02EC70 |/
    LDA r_battle_current_action_details.target.w                                ; $02EC73 |\
    ORA r_battle_command_wall_sources.w                                         ; $02EC76 | | Set the target to either the target or the wall source.
    STA r_battle_effect_spell_white_target.w                                    ; $02EC79 |/
    JSR _battle_effect_spell_white_animate_cast                                 ; $02EC7C | Animate the initial cast.
    JSR _battle_effect_spell_animate_original                                   ; $02EC7F | Animate the explosion effect when the spell hits the target.
    LDA r_battle_command_wall_sources.w                                         ; $02EC82 |\ If there were no wall sources, skip to the end, as the spell didn't
    BEQ +                                                                       ; $02EC85 |/ reflect.
    LDA r_battle_current_action_details.target_flags.w                          ; $02EC87 |\
    EOR #BATTLE_ACTION_DETAILS_TARGET_FLAG_MONSTER.b                            ; $02EC8A | | Set the target flags to the opposite side.
    STA r_battle_effect_spell_white_target_flags.w                              ; $02EC8C |/
    LDA r_battle_command_wall_targets.w                                         ; $02EC8F |\ Set the target to the wall targets.
    STA r_battle_effect_spell_white_target.w                                    ; $02EC92 |/
    JSR _battle_effect_spell_white_animate_cast                                 ; $02EC95 | Animate the cast on the reflected target.
    JSR _battle_effect_spell_animate_reflected                                  ; $02EC98 | Animate the explosion effect on the reflected target.
+   RTS                                                                         ; $02EC9B

; _battle_effect_spell_animate_noop ($02:EC9C)
;
; Animation handler for spells that does nothing.
_battle_effect_spell_animate_noop:
    JSL bank01.battle_do_nothing_but_return_2                                   ; $02EC9C
    RTS                                                                         ; $02ECA0

; _battle_effect_spell_animate_odin_monster ($02:ECA1)
;
; Animation handler for the Odin monster spell.
_battle_effect_spell_animate_odin_monster:
    JSR _battle_clear_bg1_right                                                 ; $02ECA1 | Clear the right half of BG1 (not that it's needed).
    JSL bank01.battle_animate_odin                                              ; $02ECA4 | Animate Odin striking.
    RTS                                                                         ; $02ECA8

; _battle_effect_spell_animate_actor_as_target ($02:ECA9)
;
; Animates a standard fixed spell effect using the associated script, except
; temporarily replacing the target with the actor so the effect is animated
; on the actor instead. Used as the animation handler for the Fission spell.
_battle_effect_spell_animate_actor_as_target:
    LDX r_battle_current_action_details.target_flags.w                          ; $02ECA9 |\ Preserve the existing target flags and target.
    PHX                                                                         ; $02ECAC |/
    LDA r_battle_current_action_details.actor_flags.w                           ; $02ECAD |\ Transfer the actor flags into the target flags variable.
    STA r_battle_current_action_details.target_flags.w                          ; $02ECB0 |/
    LDA r_battle_current_action_details.actor.w                                 ; $02ECB3 |\
    TAX                                                                         ; $02ECB6 | | Set the target to the mask that matches the actor.
    LDA bank16.index_to_target_data.l,X                                         ; $02ECB7 | |
    STA r_battle_current_action_details.target.w                                ; $02ECBB |/
    JSR _battle_effect_spell_animate_standard_fixed                             ; $02ECBE | Animate the standard fixed effect with the associated script.
    PLX                                                                         ; $02ECC1 |\ Restore the original target flags and target.
    STX r_battle_current_action_details.target_flags.w                          ; $02ECC2 |/
    RTS                                                                         ; $02ECC5

; _battle_effect_spell_animate_fire3 ($02:ECC6)
;
; Animation handler for the Fire3 spell.
_battle_effect_spell_animate_fire3:
    JSR _battle_effect_spell_set_sprite_pattern_block                           ; $02ECC6 | Set the sprite pattern to a moving block. NOTE: Useless code.
    LDA #BATTLE_SPELL_SPRITE_PATTERN_FIRE3.b                                    ; $02ECC9 |\ Set the sprite pattern instead to the Fire3 pattern.
    STA r_battle_effect_spell_sprite_pattern.w                                  ; $02ECCB |/
    LDA #%00001111.b                                                            ; $02ECCE |\
    STA <r_battle_effect_fire3_update_coordinate_offsets_arg                    ; $02ECD0 | | Update the coordinate offsets for all four potential sprites.
    JSL bank01.battle_effect_fire3_update_coordinate_offsets                    ; $02ECD2 |/
    STZ r_battle_effect_fire3_frame_counter.w                                   ; $02ECD6 | Initialize the Fire3 frame counter to zero.
    LDA #1.b                                                                    ; $02ECD9 | NOTE: Pointlessly load one into the accumulator.
    JSR _battle_effect_spell_animate_original                                   ; $02ECDB | Animate the original targets of the spell and any walls.
    LDA r_battle_current_action_details.target_flags.w                          ; $02ECDE |\ Transfer the target flags into the splatter target flags argument.
    STA r_battle_effect_spell_fire3_arg_target_flags.w                          ; $02ECE1 |/
    LDA r_battle_current_action_details.target.w                                ; $02ECE4 |\
    BEQ +                                                                       ; $02ECE7 | | If there is an original target, animate the splatter effect.
    JSL bank01.battle_effect_spell_fire3_animate_splatter                       ; $02ECE9 |/
+   STZ r_battle_effect_fire3_frame_counter.w                                   ; $02ECED | Reset the frame counter back to zero.
    LDA r_battle_current_action_details.target_flags.w                          ; $02ECF0 |\
    EOR #%10000000.b                                                            ; $02ECF3 | | Toggle the target monster flag to affect the other side.
    STA r_battle_effect_spell_fire3_arg_target_flags.w                          ; $02ECF5 |/
    JSR _battle_effect_spell_animate_reflected                                  ; $02ECF8 | Animate the reflected Fire3 effect.
    LDA r_battle_command_wall_targets.w                                         ; $02ECFB |\
    BEQ +                                                                       ; $02ECFE | | If the spell was reflected, animate the reflected splatter.
    JSL bank01.battle_effect_spell_fire3_animate_splatter                       ; $02ED00 |/
+   RTS                                                                         ; $02ED04

; _battle_effect_spell_animate_wave ($02:ED05)
;
; Animation handler for the Big Wave and Wave spells.
_battle_effect_spell_animate_wave:
    JSL bank01.battle_animate_wave                                              ; $02ED05 | Animate the Wave effect.
    RTS                                                                         ; $02ED09

; _battle_effect_activate_target_palette_cycling ($02:ED0A)
;
; Given a palette number in the accumulator, activates target palette cycling
; on the current action's targets, and loads the given palette into the
; appropriate palette index given the target's monster flag.
;
; NOTE: Regardless of whether the target is the party or a monster, the monsters
;       corresponding to the targeted slots have their palettes changed. Since
;       these changes are only implemented on the right half of BG1, and nothing
;       else will actually cause the right half to be displayed, it doesn't do
;       anything visible.
_battle_effect_activate_target_palette_cycling:
    PHA                                                                         ; $02ED0A | Preserve the passed palette value.
    LDA r_battle_current_action_details.target_flags.w                          ; $02ED0B |\
    AND #BATTLE_ACTION_DETAILS_TARGET_FLAG_MONSTER.b                            ; $02ED0E | | Set the target palette cycling flag to match the target.
    STA r_battle_effect_target_palette_cycling_monster.w                        ; $02ED10 |/
    LDA r_battle_current_action_details.target.w                                ; $02ED13 |\
    STA r_battle_effect_spell_targets.w                                         ; $02ED16 | | Set the spell targets and palette cycling targets to the targets
    STA r_battle_monster_set_palette_cycle_arg_targets.w                        ; $02ED19 | | of the spell.
    STA r_battle_effect_target_palette_cycling_target.w                         ; $02ED1C |/
    JSR _battle_monster_set_palette_cycle                                       ; $02ED1F | Update the palettes of targeted monsters for cycling.
    JSR _battle_effect_enable_target_palette_cycling                            ; $02ED22 | Enable target palette cycling.
    LDA #TARGET_PALETTE_CYCLING_MODE_CYCLE.b                                    ; $02ED25 |\ Set the target palette cycling mode to cycle.
    STA r_battle_effect_target_palette_cycling_mode.w                           ; $02ED27 |/
    PLA                                                                         ; $02ED2A |\ Load the passed palette as the palette cycling palette.
    JSR _battle_palette_cycle_load_palette                                      ; $02ED2B |/
    INC r_battle_effect_target_palette_cycling_active.w                         ; $02ED2E | Flag that target palette cycling is active.
    RTS                                                                         ; $02ED31

; _battle_animate_nuke_particles ($02:ED32)
;
; Animates the particle phase of the Nuke spell, including setting the target
; palette cycling and playing the sound effect.
_battle_animate_nuke_particles:
    LDA #TARGET_PALETTE_CYCLING_PALETTE_FIRE.b                                  ; $02ED32 |\ Activate target palette cycling with the Fire palette for the
    JSR _battle_effect_activate_target_palette_cycling                          ; $02ED34 |/ spell's targets.
    JSR _battle_play_sound_effect_spell                                         ; $02ED37 | Play the sound effect for this spell.
    JSL bank01.battle_animate_nuke_particles                                    ; $02ED3A | Animate the particles approaching the target.
    LDA #$FF.b                                                                  ; $02ED3E |\ Set the audio index to $FF to prevent the sound effect from playing
    STA r_battle_effect_spell_audio_index.w                                     ; $02ED40 |/ again.
    RTS                                                                         ; $02ED43

; _battle_effect_spell_animate_nuke ($02:ED44)
;
; Animation handler for the Nuke spell (and the Crystal item).
_battle_effect_spell_animate_nuke:
    LDA r_battle_current_action_details.target.w                                ; $02ED44 |\ If there are no initial targets, skip to the reflected targets
    BEQ +                                                                       ; $02ED47 |/ code.
    JSR _battle_animate_nuke_particles                                          ; $02ED49 | Animate the particles.
    JSR _battle_effect_spell_animate_standard_random                            ; $02ED4C | Animate the rest of the effect using the random sprite pattern.
    STZ r_battle_effect_target_palette_cycling_active.w                         ; $02ED4F | Disable target palette cycling.
    RTS                                                                         ; $02ED52 | Return.
+   LDA r_battle_command_wall_sources.w                                         ; $02ED53 |\ If there are no reflected targets, skip to the end.
    BEQ +                                                                       ; $02ED56 |/
    JSR _battle_effect_spell_animate_original                                   ; $02ED58 | Animate the Wall effect on the wall targets.
    JSR _battle_effect_fake_wall_targets                                        ; $02ED5B | Fake the wall targets as if they're the actual targets.
    JSR _battle_animate_nuke_particles                                          ; $02ED5E | Animate the particle effect.
    JSR _battle_effect_spell_set_sprite_pattern_block                           ; $02ED61 |\ Set the sprite pattern to random.
    INC r_battle_effect_spell_sprite_pattern.w                                  ; $02ED64 |/
    JSR _battle_effect_undo_fake_wall_targets                                   ; $02ED67 | Undo the faked wall targets.
    JSR _battle_effect_spell_animate_reflected                                  ; $02ED6A | Animate the reflected portion of the spell.
    STZ r_battle_effect_target_palette_cycling_active.w                         ; $02ED6D | Disable target palette cycling.
+   RTS                                                                         ; $02ED70

; _battle_effect_fake_wall_targets ($02:ED71)
;
; Fakes the target flags, targets and target slot to match the values in the
; wall targets variable. This is only effective if there is a single wall
; target (that is, the spell reflected only onto a single target).
_battle_effect_fake_wall_targets:
    LDX r_battle_current_action_details.target_flags.w                          ; $02ED71 |\ Back up the target flags and the target values.
    STX r_battle_effect_target_and_flags_backup.w                               ; $02ED74 |/
    LDA r_battle_current_action_details.target_flags.w                          ; $02ED77 |\
    EOR #%10000000.b                                                            ; $02ED7A | | Flip the monster bit on the target flags to change sides.
    STA r_battle_current_action_details.target_flags.w                          ; $02ED7C |/
    LDA r_battle_effect_target_slot.w                                           ; $02ED7F |\ Back up the target slot.
    STA r_battle_effect_target_slot_backup.w                                    ; $02ED82 |/
    JSR _battle_set_effect_target_to_wall_target                                ; $02ED85 | Set the target slot to match the wall target.
    LDA r_battle_command_wall_targets.w                                         ; $02ED88 |\ Set the targets value to match the wall targets.
    STA r_battle_current_action_details.target.w                                ; $02ED8B |/
    RTS                                                                         ; $02ED8E

; _battle_effect_undo_fake_wall_targets ($02:ED8F)
;
; Undoes the effect of the _battle_effect_fake_wall_targets function, and
; restores the target flags, targets and target slot to the original values.
_battle_effect_undo_fake_wall_targets:
    LDA r_battle_effect_target_slot_backup.w                                    ; $02ED8F |\ Restore the original target slot.
    STA r_battle_effect_target_slot.w                                           ; $02ED92 |/
    LDX r_battle_effect_target_and_flags_backup.w                               ; $02ED95 |\ Restore the original target flags, targets and target slot.
    STX r_battle_current_action_details.target_flags.w                          ; $02ED98 |/
    RTS                                                                         ; $02ED9B

; _battle_effect_spell_animate_demolish ($02:ED9C)
;
; Animation handler for the Demolish and Disrupt spells.
;
; NOTE: This technically is also the handler for the Warp spell, but Warp is
;       manually set to replace its effect with a "Nothing happened." message.
_battle_effect_spell_animate_demolish:
    LDA r_battle_current_action_details.target.w                                ; $02ED9C |\
    BEQ +                                                                       ; $02ED9F | | If there is a direct target, simply animate the spell and return.
    JSL bank01.battle_animate_spell_demolish                                    ; $02EDA1 | |
    RTS                                                                         ; $02EDA5 |/
+   LDA r_battle_command_wall_sources.w                                         ; $02EDA6 |\
    BEQ +                                                                       ; $02EDA9 | | Otherwise, animate the reflect effect on the wall sources.
    JSR _battle_effect_spell_animate_original                                   ; $02EDAB |/
    LDA r_battle_current_action_details.target_flags.w                          ; $02EDAE |\
    PHA                                                                         ; $02EDB1 | | Flip the target monster flag, saving the original flags in the
    EOR #BATTLE_ACTION_DETAILS_TARGET_FLAG_MONSTER.b                            ; $02EDB2 | | process.
    STA r_battle_current_action_details.target_flags.w                          ; $02EDB4 |/
    LDA r_battle_effect_target_slot.w                                           ; $02EDB7 |\ Preserve the existing target slot.
    PHA                                                                         ; $02EDBA |/
    JSR _battle_set_effect_target_to_wall_target                                ; $02EDBB | Set the effect target to the wall target.
    JSL bank01.battle_animate_spell_demolish                                    ; $02EDBE | Animate the Demolish effect on the reflected target.
    PLA                                                                         ; $02EDC2 |\ Restore the target slot.
    STA r_battle_effect_target_slot.w                                           ; $02EDC3 |/
    PLA                                                                         ; $02EDC6 |\ Restore the target flags.
    STA r_battle_current_action_details.target_flags.w                          ; $02EDC7 |/
+   RTS                                                                         ; $02EDCA

; _battle_set_effect_target_to_wall_target ($02:EDCB)
;
; Sets the effect target variable at $49 to the slot that matches the value of
; the wall targets variable at $3523. If no slot matches, the slot is set to
; zero.
_battle_set_effect_target_to_wall_target:
    LDX #0.w                                                                    ; $02EDCB | Initialize the X register to zero.
-   LDA bank16.index_to_target_data.l,X                                         ; $02EDCE |\
    CMP r_battle_command_wall_targets.w                                         ; $02EDD2 | | Branch ahead if this slot matches the wall targets.
    BEQ +                                                                       ; $02EDD5 |/
    INX                                                                         ; $02EDD7 |\
    CPX #8.w                                                                    ; $02EDD8 | | Loop until all eight slots have been checked.
    BNE -                                                                       ; $02EDDB |/
    LDX #0.w                                                                    ; $02EDDD | Otherwise, set the result to zero.
+   TXA                                                                         ; $02EDE0 |\ Set the target slot to the slot that matches the wall targets.
    STA r_battle_effect_target_slot.w                                           ; $02EDE1 |/
    RTS                                                                         ; $02EDE4

; _battle_effect_spell_animate_actor ($02:EDE5)
;
; Animates the current spell with the current actor as the target.
_battle_effect_spell_animate_actor:
    LDA r_battle_current_action_details.actor_flags.w                           ; $02EDE5 |\
    AND #BATTLE_ACTION_DETAILS_ACTOR_FLAG_MONSTER.b                             ; $02EDE8 | | Set the monster flag if the actor is a monster.
    STA <r_battle_effect_spell_animate_arg_monster                              ; $02EDEA |/
    JSR _battle_get_current_actor_target_mask.w                                 ; $02EDEC | Set the target mask to match the actor.
    JMP _battle_effect_spell_animate_original_manual_targets                    ; $02EDEF | Animate the effect with the actor as the target.

; _battle_effect_spell_animate_explode_acting_monster ($02:EDF2)
;
; Animates the current spell occurring on the actor and erases the actor from
; the screen. This assumes the actor is a monster.
_battle_effect_spell_animate_explode_acting_monster:
    JSR _battle_effect_spell_animate_actor                                      ; $02EDF2 | Animate the explosion effect on the actor.
    LDA r_battle_current_actor_slot.w                                           ; $02EDF5 |\ Erase the acting monster.
    JMP _battle_erase_monster                                                   ; $02EDF8 |/

; _battle_effect_spell_animate_reaction ($02:EDFB)
;
; Animation handler for the Reaction spell.
_battle_effect_spell_animate_reaction:
    JSL bank01.battle_animate_reaction                                          ; $02EDFB | Animate the Reaction spell.
    RTS                                                                         ; $02EDFF

; _battle_effect_spell_animate_explode ($02:EE00)
;
; Animation handler for the Explode spell.
_battle_effect_spell_animate_explode:
    JSR _battle_effect_spell_animate_explode_acting_monster                     ; $02EE00 | Animate the actor exploding.
    JMP _battle_effect_spell_animate_original                                   ; $02EE03 | Animate the resulting explosion on the target as well.

; _battle_effect_spell_animate_drain ($02:EE06)
;
; Animation handler for Drain and similar spells (Psych, Absorb and Vampire).
_battle_effect_spell_animate_drain:
    LDA r_battle_current_action_details.target.w                                ; $02EE06 |\
    BEQ +                                                                       ; $02EE09 | | If there is an actual direct target, animate the drain effect on
    JSL bank01.battle_animate_drain                                             ; $02EE0B | | that target.
    RTS                                                                         ; $02EE0F |/
+   LDA r_battle_command_wall_sources.w                                         ; $02EE10 |\
    BEQ +                                                                       ; $02EE13 | | Otherwise, if there are wall sources, animate the original effect
    JSR _battle_effect_spell_animate_original                                   ; $02EE15 | | to animate the wall, and then animate the drain effect on the
    JSR _battle_effect_fake_wall_targets                                        ; $02EE18 | | wall target.
    JSL bank01.battle_animate_drain                                             ; $02EE1B | |
    JSR _battle_effect_undo_fake_wall_targets                                   ; $02EE1F |/
+   RTS                                                                         ; $02EE22

; _battle_get_current_actor_target_mask ($02:EE23)
;
; For the current actor, loads the target mask corresponding to that slot and
; returns it in $01.
_battle_get_current_actor_target_mask:
    LDA r_battle_current_action_details.actor.w                                 ; $02EE23 |\
    TAX                                                                         ; $02EE26 | | Load the target mask for the actor and store it in the return
    LDA bank16.index_to_target_data.l,X                                         ; $02EE27 | | variable.
    STA <r_battle_generic_tmp_index_hi                                          ; $02EE2B |/
    RTS                                                                         ; $02EE2D

; _battle_copy_weapon_sprite_to_vram ($02:EE2E)
;
; Given an offset to a weapon sprite from bank $1C in the Y register, loads that
; sprite and copies it to VRAM to a location that corresponds to tiles $60, $61,
; $70 and $71. (Additionally, $62, $63, $72 and $73 are clobbered.)
_battle_copy_weapon_sprite_to_vram:
    LDX #4.w                                                                    ; $02EE2E |\
    STX <r_battle_copy_3bpp_to_ram_arg_tiles                                    ; $02EE31 | | Copy four tiles from bank $1C at the offset provided in the Y
    LDA #:bank1C.battle_sprite_weapon_data.b                                    ; $02EE33 | | register to RAM.
    LDX #r_battle_load_sprite_data.w                                            ; $02EE35 | |
    JSR _battle_copy_3bpp_to_ram                                                ; $02EE38 |/
    LDX #128.w                                                                  ; $02EE3B |\
    STX <r_battle_copy_to_vram_arg_bytes                                        ; $02EE3E | | Copy the upper two tiles to VRAM. This is only 64 bytes, but the
    LDA #:r_battle_load_sprite_data.b                                           ; $02EE40 | | copy function only copies in blocks of 128.
    LDX #r_battle_load_sprite_data.w + 0                                        ; $02EE42 | |
    LDY #$0600.w                                                                ; $02EE45 | |
    JSR _battle_copy_to_vram                                                    ; $02EE48 |/
    LDX #128.w                                                                  ; $02EE4B |\
    STX <r_battle_copy_to_vram_arg_bytes                                        ; $02EE4E | | Copy the lower two tiles to VRAM below the upper two.
    LDA #:r_battle_load_sprite_data.b                                           ; $02EE50 | |
    LDX #r_battle_load_sprite_data.w + 64                                       ; $02EE52 | |
    LDY #$0700.w                                                                ; $02EE55 |/
    JMP _battle_copy_to_vram                                                    ; $02EE58

; _battle_effect_spell_animate_imp ($02:EE5B)
;
; Animation handler for the Imp spell.
_battle_effect_spell_animate_imp:
    LDY #bank1C.battle_sprite_weapon_effect_rod_staff_data.w + 96               ; $02EE5B |\ Load the weapon effect sprite from the rod/staff block.
    JSR _battle_copy_weapon_sprite_to_vram                                      ; $02EE5E |/
    JSL bank01.battle_animate_call_imp                                          ; $02EE61 | Animate the Imp attacking.
    JMP _battle_animate_call_finish                                             ; $02EE65 | Animate the end of the Call spell.

; _battle_effect_spell_animate_bomb ($02:EE68)
;
; Animation handler for the Bomb spell.
_battle_effect_spell_animate_bomb:
    JSL bank01.battle_animate_call_bomb_initial                                 ; $02EE68 | Animate the Bomb sprite moving forward and flashing.
    STZ r_battle_effect_spell_sprite_pattern.w                                  ; $02EE6C | Set the sprite pattern to fixed.
    STZ <r_battle_effect_spell_animate_arg_monster                              ; $02EE6F | Set the monster flag to indicate a party target.
    LDA #BATTLE_SPELL_SPECIAL_MODE_BOMB.b                                       ; $02EE71 |\ Set the special mode to Bomb.
    STA r_battle_effect_spell_special_mode.w                                    ; $02EE73 |/
    LDA #%10000000.b                                                            ; $02EE76 |\ Set the targets to the first slot.
    STA <r_battle_effect_spell_animate_arg_targets                              ; $02EE78 |/
    STZ <r_battle_effect_spell_animate_arg_wall_targets                         ; $02EE7A | Set the wall targets value to zero, as there are none.
    LDA r_battle_effect_spell_script_index.w                                    ; $02EE7C |\ Animate the explosion on the alternate party sprite.
    JSR _battle_effect_spell_animate                                            ; $02EE7F |/
    LDA #ALTERNATE_PARTY_SPRITE_MODE_INVISIBLE.b                                ; $02EE82 |\ Make the alternate party sprite invisible.
    STA r_battle_alternate_party_sprite_mode.w                                  ; $02EE84 |/
    STZ r_battle_effect_spell_special_mode.w                                    ; $02EE87 | Unset the special mode.
    JSR _battle_effect_spell_animate_standard_fixed                             ; $02EE8A | Animate the explosion on the targets.
    JMP _battle_animate_call_finish                                             ; $02EE8D | Animate the party returning.

; _battle_effect_spell_animate_cocktric ($02:EE90)
;
; Animation handler for the Dummy (Cocktric) spell.
_battle_effect_spell_animate_cocktric:
    INC r_battle_effect_target_palette_cycling_disable.w                        ; $02EE90 | Disable target palette cycling.
    JSL bank01.battle_animate_call_with_spell                                   ; $02EE93 | Animate the monster moving forward and the associated spell.
    JMP _battle_animate_call_finish                                             ; $02EE97 | Animate the monster disappearing and the party returning.

; _battle_effect_spell_animate_mage ($02:EE9A)
;
; Animation handler for the Mage spell.
_battle_effect_spell_animate_mage ($02:EE9A):
    JSL bank01.battle_animate_call_with_spell                                   ; $02EE9A | Animate the monster moving forward and the associated spell.
    JMP _battle_animate_call_finish                                             ; $02EE9E | Animate the monster disappearing and the party returning.

; _battle_effect_spell_animate_chocobo ($02:EEA1)
;
; Animation handler for the Chocobo spell.
_battle_effect_spell_animate_chocobo:
    LDY #bank1C.battle_sprite_weapon_effect_fist_claw_hammer_data.w             ; $02EEA1 |\ Load the Fist/Claw/Hammer weapon effect sprite.
    JSR _battle_copy_weapon_sprite_to_vram                                      ; $02EEA4 |/
    LDX r_battle_alternate_party_sprite_coordinates.w                           ; $02EEA7 |\ Preserve the current alternate party sprite coordinates.
    PHX                                                                         ; $02EEAA |/
    LDA #8.b                                                                    ; $02EEAB |\ Set the horizontal projectile rate to eight pixels per frame.
    STA r_battle_effect_projectile_horizontal_rate.w                            ; $02EEAD |/
    LDX r_battle_alternate_party_sprite_coordinates.w                           ; $02EEB0 |\ Set the projectile source coordinates to the current alternate
    STX r_battle_effect_projectile_source_coordinates.w                         ; $02EEB3 |/ party sprite coordinates.
    LDA <r_battle_effect_target_slot                                            ; $02EEB6 |\
    ASL A                                                                       ; $02EEB8 | | Set the projectile target X coordinate to the monster's center X
    TAX                                                                         ; $02EEB9 | | coordinate plus half the width in pixels (to effectively get the
    LDA r_monster_size.1.width.w,X                                              ; $02EEBA | | coordinate of the right side).
    ASL A                                                                       ; $02EEBD | |
    ASL A                                                                       ; $02EEBE | |
    CLC                                                                         ; $02EEBF | |
    ADC r_battle_monster_coordinates_center.1.x.w,X                             ; $02EEC0 | |
    STA r_battle_effect_projectile_target_coordinates.x.w                       ; $02EEC3 |/
    LDA r_battle_monster_coordinates_center.1.y.w,X                             ; $02EEC6 |\
    SEC                                                                         ; $02EEC9 | | Set the target Y coordinate to the monster's center Y coordinate
    SBC #16.b                                                                   ; $02EECA | | minus sixteen (half the size of the Chocobo).
    STA r_battle_effect_projectile_target_coordinates.y.w                       ; $02EECC |/
    JSR _battle_effect_projectile_initialize                                    ; $02EECF | Initialize the projectile variables.
    JSR _battle_alternate_party_sprite_animate_projectile                       ; $02EED2 | Animate the Chocobo moving to the target.
    JSL bank01.battle_animate_call_chocobo_kick                                 ; $02EED5 | Animate the actual Chocobo kicking.
    PLX                                                                         ; $02EED9 |\ Set the original sprite coordinates as the new target coordinates.
    STX r_battle_effect_projectile_target_coordinates.w                         ; $02EEDA |/
    LDX r_battle_alternate_party_sprite_coordinates.w                           ; $02EEDD |\ Set the projectile source coordinates to the current sprite
    STX r_battle_effect_projectile_source_coordinates.w                         ; $02EEE0 |/ coordinates.
    LDA #8.b                                                                    ; $02EEE3 |\ Set the horizontal projectile rate to 8 pixels per frame.
    STA r_battle_effect_projectile_horizontal_rate.w                            ; $02EEE5 |/
    JSR _battle_effect_projectile_initialize                                    ; $02EEE8 | Initialize the projectile variables.
    JSR _battle_alternate_party_sprite_animate_projectile                       ; $02EEEB | Animate the Chocobo moving back to its original location.
    JMP _battle_animate_call_finish                                             ; $02EEEE | Animate the Chocobo disappearing and the party reappearing.

; _battle_alternate_party_sprite_animate_projectile ($02:EEF1)
;
; Assuming a properly configured and initialized projectile effect, animates the
; movement of the alternate party sprite along that projectile path.
_battle_alternate_party_sprite_animate_projectile:
-   JSR _battle_wait_next_frame_preserve_x_y                                    ; $02EEF1 | Wait for the next frame.
    JSR _battle_effect_projectile_update_coordinates                            ; $02EEF4 | Update the current projectile coordinates.
    BCS +                                                                       ; $02EEF7 | Jump to the end if the target has been reached.
    LDX r_battle_effect_projectile_coordinates.w                                ; $02EEF9 |\ Update the alternate party sprite coordinates to the current
    STX r_battle_alternate_party_sprite_coordinates.w                           ; $02EEFC |/ projectile coordinates.
    JMP -                                                                       ; $02EEFF | Jump to the next loop.
+   RTS                                                                         ; $02EF02

; _battle_effect_spell_animate_shiva ($02:EF03)
;
; Animation handler for the Shiva spell.
_battle_effect_spell_animate_shiva:
    JSL bank01.battle_animate_call_shiva                                        ; $02EF03 | Animate the Shiva spell effect.
    JMP _battle_animate_call_finish                                             ; $02EF07 | Animate Shiva disappearing and the party reappearing.

; _battle_effect_spell_animate_indra ($02:EF0A)
;
; Animation handler for the Indra spell.
_battle_effect_spell_animate_indra:
    JSL bank01.battle_animate_call_indra                                        ; $02EF0A | Animate the Indra spell effect.
    JMP _battle_animate_call_finish                                             ; $02EF0E | Animate Indra disappearing and the party reappearing.

; _battle_effect_spell_animate_jinn ($02:EF11)
;
; Animation handler for the Jinn spell.
;
; NOTE: For whatever reason, this is also the handler for the Stone family of
;       spells (Stone, Ray, Hug, Beak, Petrify). There doesn't appear to be any
;       good reason for this, however. The parts that are Jinn-specific will
;       not do anything for the other spells, as they don't use the alternate
;       party sprite. Their handlers should be able to be changed to $00 instead
;       with no repurcussions, unless the changing of $F2D0 to 5 is relevant.
; TODO: Is that relevant?
_battle_effect_spell_animate_jinn:
    LDA #BATTLE_SPELL_SPECIAL_MODE_JINN.b                                       ; $02EF11 |\ Set the special mode to Jinn.
    STA r_battle_effect_spell_special_mode.w                                    ; $02EF13 |/
    LDA #8.b                                                                    ; $02EF16 |\ Set the frame counter to eight to switch to the next frame.
    STA r_battle_alternate_party_sprite_frame_counter.w                         ; $02EF18 |/
    JSR _battle_effect_spell_animate_standard_fixed                             ; $02EF1B | Animate the main spell portion of the attack.
    JSL bank01.battle_do_nothing_but_return                                     ; $02EF1E | NOTE: This call (no longer?) does anything.
    JMP _battle_animate_call_finish                                             ; $02EF22 | Animate Jinn disappearing and the party reappearing.

; _battle_effect_spell_animate_titan ($02:EF25)
;
; Animation handler for the Titan spell.
_battle_effect_spell_animate_titan:
    JSL bank01.battle_animate_call_titan                                        ; $02EF25 | Animates Titan moving forward and Quake.
    JMP _battle_animate_call_finish                                             ; $02EF29 | Animates Titan disappearing and the party reappearing.

; _battle_effect_spell_animate_mist ($02:EF2C)
;
; Animation handler for the Mist spell.
_battle_effect_spell_animate_mist:
    JSL bank01.battle_animate_call_mist                                         ; $02EF2C | Animate the Mist effect.
    JMP _battle_animate_call_finish                                             ; $02EF30 | Animate Mist disappearing and the party reappearing.

; _battle_effect_spell_animate_sylph ($02:EF33)
;
; Animation handler for the Sylph spell.
_battle_effect_spell_animate_sylph:
    JSL bank01.battle_animate_call_sylph_initial                                ; $02EF33 | Animate the Sylphs' initial movement.
    JSR _battle_effect_spell_animate_standard_fixed                             ; $02EF37 | Animate the attack portion of the spell.
    JSR _battle_reset_effect_oam_large                                          ; $02EF3A | Reset the effect OAM.
    JSR _battle_animate_call_finish                                             ; $02EF3D | Animate the Sylphs disappearing and the party reappearing.
    LDA r_battle_current_action_details.actor_flags.w                           ; $02EF40 |\
    AND #BATTLE_ACTION_DETAILS_ACTOR_FLAG_MONSTER.b                             ; $02EF43 | | Set the spell effect to work on the actor side.
    STA <r_battle_effect_spell_animate_arg_monster                              ; $02EF45 |/  NOTE: It's kind of weird to even bother with this.
    STZ <r_battle_effect_spell_animate_arg_targets                              ; $02EF47 | Initialize the targets to an empty value.
    LDY #0.w                                                                    ; $02EF49 | Initialize the Y register to zero.
-   LDA r_character_slot_if_active.w,Y                                          ; $02EF4C |\
    CMP #$FF.b                                                                  ; $02EF4F | | Skip this slot if it's empty.
    BEQ +                                                                       ; $02EF51 |/
    TYA                                                                         ; $02EF53 |\
    TAX                                                                         ; $02EF54 | | Convert the slot into a target mask and set it in the targets
    LDA bank16.index_to_target_data.l,X                                         ; $02EF55 | | value.
    ORA <r_battle_effect_spell_animate_arg_targets                              ; $02EF59 | |
    STA <r_battle_effect_spell_animate_arg_targets                              ; $02EF5B |/
+   INY                                                                         ; $02EF5D |\
    CPY #5.w                                                                    ; $02EF5E | | Loop until all five character slots have been checked.
    BNE -                                                                       ; $02EF61 |/
    STZ <r_battle_effect_spell_animate_arg_wall_targets                         ; $02EF63 | Set the wall targets value to zero.
    LDA #SPELL_VISUAL_EFFECT_SCRIPT_SYLPH_CURE.b                                ; $02EF65 |\ Animate the cure portion of the effect on the selected targets.
    JSR _battle_effect_spell_animate                                            ; $02EF67 |/
    LDA #AUDIO_EFFECT_NONE.b                                                    ; $02EF6A |\ Stop the sound effect.
    JMP _battle_play_sound_effect                                               ; $02EF6C |/

; _battle_effect_spell_animate_odin ($02:EF6F)
;
; Animation handler for the Odin spell.
_battle_effect_spell_animate_odin:
    JSL bank01.battle_animate_call_odin                                         ; $02EF6F
    JMP _battle_animate_call_finish                                             ; $02EF73

; _battle_effect_spell_animate_leviatan ($02:EF76)
;
; Animation handler for the Leviatan spell.
_battle_effect_spell_animate_leviatan:
    JSL bank01.battle_animate_call_leviatan_wave                                ; $02EF76 | Animate the Leviatan wave effect.
    JMP _battle_animate_call_finish                                             ; $02EF7A | Animate the Leviatan's disappearance and appearance of the party.

; _battle_effect_spell_animate_asura ($02:EF7D)
;
; Animation handler for the Asura spells.
_battle_effect_spell_animate_asura:
    JSL bank01.battle_animate_call_asura                                        ; $02EF7D | Animate the Asura head rotation effect.
    JSR _battle_animate_call_finish                                             ; $02EF81 | Animate the disappearance of Asura and the appearance of the party.
    JMP _battle_effect_spell_animate_standard_fixed                             ; $02EF84 | Animate a standard magic effect with a fixed sprite pattern.

; _battle_effect_spell_animate_bahamut ($02:EF87)
;
; Animation handler for the Bahamut spell.
_battle_effect_spell_animate_bahamut:
    JSL bank01.battle_animate_call_bahamut                                      ; $02EF87 | Animate the Bahamut effect.
    JMP _battle_animate_call_finish                                             ; $02EF8B | Animate the disappearance of Bahamut and appearance of the party.

; _battle_effect_spell_animate_quake ($02:EF8E)
;
; Animation handler for the Quake spell.
_battle_effect_spell_animate_quake:
    LDA r_battle_current_action_details.target.w                                ; $02EF8E |\ Skip this function if there is no target.
    BEQ +                                                                       ; $02EF91 |/
    LDX #$80B0.w                                                                ; $02EF93 |\ Set the OAM priority to entry 88 (first entry beyond the effect
    STX r_battle_oam_priority.w                                                 ; $02EF96 |/ range), so the effect is underneath the character sprites.
    LDA #BATTLE_SPELL_SPECIAL_MODE_QUAKE.b                                      ; $02EF99 |\ Set the special mode to Quake.
    STA r_battle_effect_spell_special_mode.w                                    ; $02EF9B |/
    JSR _battle_effect_spell_animate_standard_fixed                             ; $02EF9E | Animate a standard fixed spell effect.
    LDX #0.w                                                                    ; $02EFA1 |\ Reset the OAM priority to default.
    STX r_battle_oam_priority.w                                                 ; $02EFA4 |/
+   RTS                                                                         ; $02EFA7

; _battle_effect_spell_animate_standard_party_field ($02:EFA8)
;
; Animation handler for a standard spell that uses the party field special mode.
; This handler is presumably unused.
_battle_effect_spell_animate_standard_party_field:
    LDA #BATTLE_SPELL_SPECIAL_MODE_PARTY_FIELD.b                                ; $02EFA8 |\ Set the special mode to party field.
    STA r_battle_effect_spell_special_mode.w                                    ; $02EFAA |/
    JMP _battle_effect_spell_animate_standard_block                             ; $02EFAD | Animate a standard moving block spell.

; _battle_effect_spell_animate_standard_monster_field ($02:EFB0)
;
; Animation handler for a standard spell that uses the monster field special
; mode. This handler is presumably unused.
_battle_effect_spell_animate_standard_monster_field:
    LDA #BATTLE_SPELL_SPECIAL_MODE_MONSTER_FIELD.b                              ; $02EFB0 |\ Set the special mode to monster field.
    STA r_battle_effect_spell_special_mode.w                                    ; $02EFB2 |/
    JMP _battle_effect_spell_animate_standard_block                             ; $02EFB5 | Animate a standard moving block spell.

; _battle_effect_spell_animate_meteo ($02:EFB8)
;
; Animation handler for the Meteo spell.
_battle_effect_spell_animate_meteo:
    LDA #BATTLE_SPELL_TILE_BASE_METEO.b                                         ; $02EFB8 | Set the base tile to the Meteo tile.
    JMP _battle_effect_spell_animate_meteo_comet                                ; $02EFBA | Jump to the animation function.

; _battle_effect_spell_animate_comet ($02:EFBD)
;
; Animation handler for the Comet spell. Falls through to the next function.
_battle_effect_spell_animate_comet:
    LDA #BATTLE_SPELL_TILE_BASE_COMET.b                                         ; $02EFBD | Set the base tile to the Comet tile.

; _battle_effect_spell_animate_meteo_comet ($02:EFBF)
;
; Given a base tile number in the accumulator, animates the Meteo/Comet effect.
_battle_effect_spell_animate_meteo_comet:
    STA r_battle_effect_spell_meteo_comet_base_tile.w                           ; $02EFBF | Save the passed value as the tile number.
    LDA r_battle_current_action_details.target.w                                ; $02EFC2 |\
    BNE +                                                                       ; $02EFC5 | | Skip this function if there are no targets.
    RTS                                                                         ; $02EFC7 |/
+   LDA #BATTLE_SPELL_SPECIAL_MODE_METEO.b                                      ; $02EFC8 |\ Set the special mode to Meteo.
    STA r_battle_effect_spell_special_mode.w                                    ; $02EFCA |/
    LDX #$8060.w                                                                ; $02EFCD |\ Set OAM entry 48 (the range used by this effect) to have the
    STX r_battle_oam_priority.w                                                 ; $02EFD0 |/ highest priority.
    JSR _battle_effect_spell_animate_standard_fixed                             ; $02EFD3 | NOTE: Seems to be useless, as the standard script is empty.
    LDA #%10001101.b                                                            ; $02EFD6 |\ Set the palette mode to alternate between a fire palette and a
    JSR _battle_effect_set_palette_or_flash                                     ; $02EFD8 |/ yellow/green palette.
    JSL bank01.set_battle_flash_continuous_red                                  ; $02EFDB |\
    LDA #BATTLE_FLASH_MODE_PULSE.b                                              ; $02EFDF | | Start a pulsing red flash effect.
    STA r_battle_flash_mode.w                                                   ; $02EFE1 |/
    STZ r_battle_effect_spell_special_mode.w                                    ; $02EFE4 | Unset the special mode.
    TDC                                                                         ; $02EFE7 |\ Initialize the X register and the accumulator to zero.
    TAX                                                                         ; $02EFE8 |/
-   STZ r_battle_effect_spell_meteo_comet_coordinates.1.x.w,X                   ; $02EFE9 | Set the current X coordinate to zero.
    STA r_battle_effect_spell_meteo_comet_coordinates.1.y.w,X                   ; $02EFEC | Set the current Y coordinate to the value in the accumulator.
    PHA                                                                         ; $02EFEF |\
    LDA #%10000000.b                                                            ; $02EFF0 | | Set the initial value of the counter for this sprite to set the
    STA r_battle_effect_spell_meteo_comet_counters.w,X                          ; $02EFF2 | | invisibility bit.
    PLA                                                                         ; $02EFF5 |/
    CLC                                                                         ; $02EFF6 |\ Add sixteen to the value in the accumulator.
    ADC #16.b                                                                   ; $02EFF7 |/
    INX                                                                         ; $02EFF9 |\
    INX                                                                         ; $02EFFA | | Increment the X register twice and loop until all sixteen entries
    CPX #32.w                                                                   ; $02EFFB | | have been intialized.
    BNE -                                                                       ; $02EFFE |/
    LDA #160.b                                                                  ; $02F000 |\ Initialize the frame counter to 160.
    STA r_battle_effect_spell_meteo_comet_frame_counter.w                       ; $02F002 |/
@outer_start:
    JSR _battle_wait_next_frame_preserve_x_y                                    ; $02F005 | Wait for the next frame.
    JSR _battle_effect_check_palette_cycle                                      ; $02F008 | Check for any pending palette cycling.
    LDX #0.w                                                                    ; $02F00B | Initialize the X register to zero.
@first_inner_start:
    LDA r_battle_effect_spell_meteo_comet_coordinates.1.y.w,X                   ; $02F00E |\ Skip ahead if the Y coordinate isn't zero.
    BNE +++                                                                     ; $02F011 |/
    LDA r_battle_current_action_details.target_flags.w                          ; $02F013 |\
    BMI +                                                                       ; $02F016 | | If the target is the party, set the X coordinate to a random
    JSR _battle_get_next_rng                                                    ; $02F018 | | number from 96 to 223. If the target is the monsters, instead set
    AND #%01111111.b                                                            ; $02F01B | | it to a random number from 0 to 255.
    CLC                                                                         ; $02F01D | |
    ADC #96.b                                                                   ; $02F01E | |
    BRA ++                                                                      ; $02F020 | |
+   JSR _battle_get_next_rng                                                    ; $02F022 | |
++  STA r_battle_effect_spell_meteo_comet_coordinates.1.x.w,X                   ; $02F025 |/
    LDA #15.b                                                                   ; $02F028 |\ Set the counter for this sprite to 15, which unsets the
    STA r_battle_effect_spell_meteo_comet_counters.w,X                          ; $02F02A |/ invisibility bit.
+++ TXA                                                                         ; $02F02D |\
    AND #%00000111.b                                                            ; $02F02E | | Set a temporary variable to a value from 3 to 10, depending on the
    CLC                                                                         ; $02F030 | | current value of the X register.
    ADC #3.b                                                                    ; $02F031 | |
    STA <r_battle_generic_tmp_index_2_lo                                        ; $02F033 |/
    LDA r_battle_current_action_details.target_flags.w                          ; $02F035 |\ Skip ahead to separate code if the target is the party.
    BPL ++                                                                      ; $02F038 |/
    LDA #%00111111.b                                                            ; $02F03A |\ Set the base flags to priority 3, palette 7 and high name table.
    STA <r_battle_generic_tmp_index_lo                                          ; $02F03C |/
    LDA r_battle_effect_spell_meteo_comet_coordinates.1.x.w,X                   ; $02F03E |\
    SEC                                                                         ; $02F041 | | Subtract the previously calculated value (from 3 to 10) from the X
    SBC <r_battle_generic_tmp_index_2_lo                                        ; $02F042 | | coordinate for this sprite.
    STA r_battle_effect_spell_meteo_comet_coordinates.1.x.w,X                   ; $02F044 |/
    BCS +                                                                       ; $02F047 |\
    LDA r_battle_effect_spell_meteo_comet_counters.w,X                          ; $02F049 | | If the value crosses below zero, set the high bit on the counter
    ORA #%10000000.b                                                            ; $02F04C | | to make the sprite invisible.
    STA r_battle_effect_spell_meteo_comet_counters.w,X                          ; $02F04E |/
+   JMP +++                                                                     ; $02F051 | Branch ahead past the party-specific target code.
++  LDA #%01111111.b                                                            ; $02F054 |\ If the party is a target, set the flags for priority 3, palette 7,
    STA <r_battle_generic_tmp_index_lo                                          ; $02F056 |/ high name table, and toggle the horizontal flip bit.
    LDA r_battle_effect_spell_meteo_comet_coordinates.1.x.w,X                   ; $02F058 |\
    CLC                                                                         ; $02F05B | | Add the previously calculated value (from 3 to 10) to the X
    ADC <r_battle_generic_tmp_index_2_lo                                        ; $02F05C | | coordinate for this sprite.
    STA r_battle_effect_spell_meteo_comet_coordinates.1.x.w,X                   ; $02F05E |/
    BCC +++                                                                     ; $02F061 |\
    LDA r_battle_effect_spell_meteo_comet_counters.w,X                          ; $02F063 | | If the value wraps back to zero, toggle the invisibility bit.
    ORA #%10000000.b                                                            ; $02F066 | |
    STA r_battle_effect_spell_meteo_comet_counters.w,X                          ; $02F068 |/
+++ LDA r_battle_effect_spell_meteo_comet_coordinates.1.y.w,X                   ; $02F06B |\
    CLC                                                                         ; $02F06E | | Add eight to the Y coordinate for the sprite, regardless of the
    ADC #8.b                                                                    ; $02F06F | | target.
    STA r_battle_effect_spell_meteo_comet_coordinates.1.y.w,X                   ; $02F071 |/
    INX                                                                         ; $02F074 |\
    INX                                                                         ; $02F075 | | Increment the X register twice and loop until all 16 sprites have
    CPX #32.w                                                                   ; $02F076 | | had their coordinates updated.
    BNE @first_inner_start                                                      ; $02F079 |/
    LDX #0.w                                                                    ; $02F07B |\ Initialize the X and Y registers to zero.
    LDY #0.w                                                                    ; $02F07E |/
@second_inner_start:
    LDA r_battle_effect_spell_meteo_comet_counters.w,X                          ; $02F081 |\
    BPL +                                                                       ; $02F084 | | If the invisibility bit is set on the counter, set the OAM
    LDA #240.b                                                                  ; $02F086 | | coordinates for this sprite to 240 and skip to the next iteration.
    STA r_oam.49.x.w,Y                                                          ; $02F088 | |
    STA r_oam.49.y.w,Y                                                          ; $02F08B | |
    JMP @next                                                                   ; $02F08E |/
+   DEC r_battle_effect_spell_meteo_comet_counters.w,X                          ; $02F091 | Decrement the counter.
    LDA r_battle_effect_spell_meteo_comet_coordinates.1.x.w,X                   ; $02F094 |\ Set the OAM X coordinate to the previously calculated X coordinate.
    STA r_oam.49.x.w,Y                                                          ; $02F097 |/
    LDA r_battle_effect_spell_meteo_comet_coordinates.1.y.w,X                   ; $02F09A |\
    SEC                                                                         ; $02F09D | | Set the OAM Y coordinate to the calculated Y coordinate minus
    SBC #4.b                                                                    ; $02F09E | | four.
    STA r_oam.49.y.w,Y                                                          ; $02F0A0 |/
    LDA r_battle_effect_spell_meteo_comet_base_tile.w                           ; $02F0A3 | Load the tile number into the accumulator.
    CMP #BATTLE_SPELL_TILE_BASE_COMET.b                                         ; $02F0A6 |\
    BEQ +                                                                       ; $02F0A8 | | If the tile is for anything other than Comet, add either 0 or 2
    LDA r_battle_frame_counter.w                                                ; $02F0AA | | depending on the value of the frame counter (alternates every two
    AND #%00000010.b                                                            ; $02F0AD | | frames).
    CLC                                                                         ; $02F0AF | |
    ADC r_battle_effect_spell_meteo_comet_base_tile.w                           ; $02F0B0 |/
+   STA r_oam.49.tile.w,Y                                                       ; $02F0B3 | Set the loaded value as the tile for this sprite.
    LDA r_formation_back_attack_copy.w                                          ; $02F0B6 |\
    BEQ +                                                                       ; $02F0B9 | | If this is a back attack, toggle the horizontal flip bit in the
    LDA <r_battle_generic_tmp_index_lo                                          ; $02F0BB | | flags, and mirror the coordinates by flipping the bits and adding
    EOR #%01000000.b                                                            ; $02F0BD | | 16.
    STA r_oam.49.flags.w,Y                                                      ; $02F0BF | |
    LDA r_battle_effect_spell_meteo_comet_coordinates.1.x.w,X                   ; $02F0C2 | |
    EOR #%11111111.b                                                            ; $02F0C5 | |
    SEC                                                                         ; $02F0C7 | |
    SBC #16.b                                                                   ; $02F0C8 | |
    STA r_oam.49.x.w,Y                                                          ; $02F0CA | |
    BRA @next                                                                   ; $02F0CD |/
+   LDA <r_battle_generic_tmp_index_lo                                          ; $02F0CF |\ Otherwise, merely store the previously set flags (the coordinates
    STA r_oam.49.flags.w,Y                                                      ; $02F0D1 |/ were already set).
@next:
    INY                                                                         ; $02F0D4 |\
    INY                                                                         ; $02F0D5 | | Increment the Y register by four to move to the next OAM entry.
    INY                                                                         ; $02F0D6 | |
    INY                                                                         ; $02F0D7 |/
    INX                                                                         ; $02F0D8 |\ Increment the X register by two to move to the next sprite.
    INX                                                                         ; $02F0D9 |/
    CPX #32.w                                                                   ; $02F0DA |\ Loop until all 16 sprites have been set.
    BNE @second_inner_start                                                     ; $02F0DD |/
    DEC r_battle_effect_spell_meteo_comet_frame_counter.w                       ; $02F0DF |\
    BEQ +                                                                       ; $02F0E2 | | Decrement the overall frame counter and loop until it's zero.
    JMP @outer_start                                                            ; $02F0E4 |/
+   STZ r_battle_flash_mode.w                                                   ; $02F0E7 | Disable the battle flash effect.
    LDX #0.w                                                                    ; $02F0EA |\ Unset the OAM priority value to return to default.
    STX r_battle_oam_priority.w                                                 ; $02F0ED |/
    RTS                                                                         ; $02F0F0

; _battle_effect_spell_animate_exit ($02:F0F1)
;
; Animation handler for the Exit spell effect.
_battle_effect_spell_animate_exit:
    LDA r_battle_current_action_details.target.w                                ; $02F0F1 |\
    BNE +                                                                       ; $02F0F4 | | Skip this routine if the action has no targets.
    RTS                                                                         ; $02F0F6 |/
+   JSR _battle_play_sound_effect_spell                                         ; $02F0F7 | Play the sound effect for the spell.
    JSR _battle_reset_effect_oam_large                                          ; $02F0FA | Reset the effect OAM to large sprites.
    JSL bank01.battle_animate_exit_palette_change.l                             ; $02F0FD |\
    LDX #5.w                                                                    ; $02F101 | | Change the background and monster palettes to the monochrome
    LDA #BATTLE_MISC_PALETTE_EXIT_MONSTER.b                                     ; $02F104 | | brown. The changes are gradual except for one monster palette.
    JSR _battle_load_miscellaneous_palette                                      ; $02F106 |/
    JSR _battle_effect_initialize_sine_indexes                                  ; $02F109 | Initialize the sine indexes.
    TDC                                                                         ; $02F10C |\
    TAX                                                                         ; $02F10D | | Initialize the three variables to zero (an an extra byte, as the
    STX r_battle_effect_exit_vertical_sine_index.w                              ; $02F10E | | variables are all single bytes).
    STX r_battle_effect_exit_horizontal_sine_index.w                            ; $02F111 |/
    JSR _battle_effect_initialize_sine_magnitude                                ; $02F114 | Initialize the sine magnitudes to zero.
    LDA #$60.b                                                                  ; $02F117 |\ Set the BG1 tilemap address to $6000 and the size to 32x32.
    STA reg_ppu_bg1sc.l                                                         ; $02F119 |/
    LDA #$58.b                                                                  ; $02F11D |\ Set the BG1 tilemap address to $5800 and the size to 32x32.
    STA reg_ppu_bg2sc.l                                                         ; $02F11F |/
    LDA #3.b                                                                    ; $02F123 |\ Set the third sine magnitude to 3.
    STA r_battle_effect_sine_magnitude.w + 2                                    ; $02F125 |/ TODO: Does this even serve a purpose?
    INC A                                                                       ; $02F128 |\ Set the first sine magnitude to 4.
    STA r_battle_effect_sine_magnitude.w + 0                                    ; $02F129 |/
    LDA r_formation_flags2_copy_2.w                                             ; $02F12C |\
    AND #FORMATION_FLAGS_2_FLOATING.b ~ %11111111                               ; $02F12F | | Unset the floating bit to disable shadow updates.
    STA r_formation_flags2_copy_2.w                                             ; $02F131 |/
    TDC                                                                         ; $02F134 |\ Set the BG1 vertical scroll to zero.
    JSR _battle_set_bg1_vertical_scroll                                         ; $02F135 |/
    JSR _battle_update_command_menu_close                                       ; $02F138 | Close any open command menus.
@outer_start:
    JSR _battle_wait_next_frame_preserve_x_y                                    ; $02F13B | Wait for the next frame.
    JSR _battle_effect_exit_fade_palette                                        ; $02F13E | Fade the palettes if appropriate.
    LDA r_battle_effect_exit_vertical_sine_index.w                              ; $02F141 |\
    CLC                                                                         ; $02F144 | | Add four to the vertical sine index (to run through the entire
    ADC #4.b                                                                    ; $02F145 | | cycle in 64 frames).
    STA r_battle_effect_exit_vertical_sine_index.w                              ; $02F147 |/
    STA r_battle_effect_sine_index.w + 0                                        ; $02F14A | Transfer that value to the first sine index.
    LDA r_battle_effect_exit_horizontal_sine_index.w                            ; $02F14D |\
    CLC                                                                         ; $02F150 | | Add eight to the horizontal sine index (to run through the cycle
    ADC #8.b                                                                    ; $02F151 | | in 32 frames).
    STA r_battle_effect_exit_horizontal_sine_index.w                            ; $02F153 |/
    STA r_battle_effect_sine_index.w + 1                                        ; $02F156 | Transfer that value to the second sine index.
    LDY #0.w                                                                    ; $02F159 | Initialize the Y register to zero.
@inner_start:
    LDX #0.w                                                                    ; $02F15C |\
    JSR _battle_effect_get_sine_value                                           ; $02F15F | | Read the first sine value and use it to set the vertical BG1
    STA r_battle_bg1_hdma_data.1.vertical_lo,Y                                  ; $02F162 | | scroll values for lines separated by 32 lines.
    STA r_battle_bg1_hdma_data.33.vertical_lo.w,Y                               ; $02F165 | |
    STA r_battle_bg1_hdma_data.65.vertical_lo.w,Y                               ; $02F168 | |
    STA r_battle_bg1_hdma_data.97.vertical_lo.w,Y                               ; $02F16B | |
    STA r_battle_bg1_hdma_data.129.vertical_lo.w,Y                              ; $02F16E |/
    LDX #1.w                                                                    ; $02F171 |\
    JSR _battle_effect_get_sine_value                                           ; $02F174 | | Read the second sine value and save to the stack twice.
    PHA                                                                         ; $02F177 | |
    PHA                                                                         ; $02F178 |/
    STA r_battle_bg1_hdma_data.1.horizontal_lo.w,Y                              ; $02F179 |\
    STA r_battle_bg1_hdma_data.33.horizontal_lo.w,Y                             ; $02F17C | | Use the same value to set the horizontal scroll value for the same
    STA r_battle_bg1_hdma_data.65.horizontal_lo.w,Y                             ; $02F17F | | lines.
    STA r_battle_bg1_hdma_data.97.horizontal_lo.w,Y                             ; $02F182 | |
    STA r_battle_bg1_hdma_data.129.horizontal_lo.w,Y                            ; $02F185 |/
    PLA                                                                         ; $02F188 |\
    BMI +                                                                       ; $02F189 | | Load the second sine value, and if it's negative, set the high
    TDC                                                                         ; $02F18B | | byte of the BG1 horizontal scroll value to 1.
    BRA ++                                                                      ; $02F18C | |
+   LDA #1.b                                                                    ; $02F18E | | NOTE: This doesn't seem to serve much of a purpose. The background
++  STA r_battle_bg1_hdma_data.1.horizontal_hi.w,Y                              ; $02F190 | |       has already been changed to 32x32, so it's only 256 pixels
    STA r_battle_bg1_hdma_data.33.horizontal_hi.w,Y                             ; $02F193 | |       wide. Adding 256 to the scroll value doesn't change
    STA r_battle_bg1_hdma_data.65.horizontal_hi.w,Y                             ; $02F196 | |       anything.
    STA r_battle_bg1_hdma_data.97.horizontal_hi.w,Y                             ; $02F199 | |
    STA r_battle_bg1_hdma_data.129.horizontal_hi.w,Y                            ; $02F19C |/
    PLA                                                                         ; $02F19F |\
    STA r_battle_bg2_hdma_data.1.horizontal_lo.w,Y                              ; $02F1A0 | | Load the second sine value and use that to set the horizontal
    STA r_battle_bg2_hdma_data.33.horizontal_lo.w,Y                             ; $02F1A3 | | scroll value for BG2.
    STA r_battle_bg2_hdma_data.65.horizontal_lo.w,Y                             ; $02F1A6 | |
    STA r_battle_bg2_hdma_data.97.horizontal_lo.w,Y                             ; $02F1A9 |/
    CPY #_sizeof_scroll_hdma_data_entry.w * 12                                  ; $02F1AC |\
    BCS +                                                                       ; $02F1AF | | Add a restriction on the last line to avoid going too low.
    STA r_battle_bg2_hdma_data.129.horizontal_lo.w,Y                            ; $02F1B1 |/
+   LDA r_battle_effect_sine_index.w + 0                                        ; $02F1B4 |\
    CLC                                                                         ; $02F1B7 | | Add eight to the two sine indexes, so the entire cycle will be
    ADC #8.b                                                                    ; $02F1B8 | | used among the 32 lines.
    STA r_battle_effect_sine_index.w + 0                                        ; $02F1BA | |
    LDA r_battle_effect_sine_index.w + 1                                        ; $02F1BD | |
    CLC                                                                         ; $02F1C0 | |
    ADC #8.b                                                                    ; $02F1C1 | |
    STA r_battle_effect_sine_index.w + 1                                        ; $02F1C3 |/
    INY                                                                         ; $02F1C6 |\
    INY                                                                         ; $02F1C7 | | Increment the Y register by four to move to the next entry.
    INY                                                                         ; $02F1C8 | |
    INY                                                                         ; $02F1C9 |/
    CPY #(32 * 4).w                                                             ; $02F1CA |\
    BEQ +                                                                       ; $02F1CD | | Loop until all 32 lines have been set.
    JMP @inner_start                                                            ; $02F1CF |/
+   LDA r_battle_effect_exit_frame_counter.w                                    ; $02F1D2 |\
    LSR A                                                                       ; $02F1D5 | | Set the second sine magnitude to the current frame counter divided
    LSR A                                                                       ; $02F1D6 | | by eight. (It will therefore range from 0 to 12.)
    LSR A                                                                       ; $02F1D7 | |
    STA r_battle_effect_sine_magnitude.w + 1                                    ; $02F1D8 |/
    LDA r_battle_effect_exit_vertical_sine_index.w                              ; $02F1DB |\
    STA r_battle_effect_sine_index.w + 0                                        ; $02F1DE | | Reset the sine indexes to the current base values.
    LDA r_battle_effect_exit_horizontal_sine_index.w                            ; $02F1E1 | |
    STA r_battle_effect_sine_index.w + 1                                        ; $02F1E4 |/
    INC r_battle_effect_exit_frame_counter.w                                    ; $02F1E7 | Increment the frame counter.
    LDA r_battle_effect_exit_frame_counter.w                                    ; $02F1EA |\
    CMP #100.b                                                                  ; $02F1ED | | Loop until the frame counter reaches 100.
    BEQ +                                                                       ; $02F1EF | |
    JMP @outer_start                                                            ; $02F1F1 |/
+   INC r_battle_suspend_animation.w                                            ; $02F1F4 | Set the flag to suspend animation.
    RTS                                                                         ; $02F1F7

; _battle_effect_exit_fade_palette ($02:F1F8)
;
; Part of the Exit effect animation, handles fading the background and monster
; palettes by one step on designated frames.
_battle_effect_exit_fade_palette:
    LDA r_battle_effect_exit_frame_counter.w                                    ; $02F1F8 |\
    AND #%01000000.b                                                            ; $02F1FB | | If the frame counter hasn't reached 64, return, doing nothing.
    BEQ +                                                                       ; $02F1FD |/
    LDX #0.w                                                                    ; $02F1FF | Initialize the X register to zero.
-   LDA r_battle_cgram_data.2.color1.w + 0,X                                    ; $02F202 |\
    STA <r_battle_fade_color_arg_color_lo                                       ; $02F205 | | Transfer the current color to the fading function argument.
    LDA r_battle_cgram_data.2.color1.w + 1,X                                    ; $02F207 | |
    STA <r_battle_fade_color_arg_color_hi                                       ; $02F20A |/
    LDA #1.b                                                                    ; $02F20C |\ Fade the color by one step.
    JSR _battle_fade_color                                                      ; $02F20E |/
    LDA <r_battle_fade_color_arg_color_lo                                       ; $02F211 |\
    STA r_battle_cgram_data.2.color1.w + 0,X                                    ; $02F213 | | Copy the result back to the original color location.
    LDA <r_battle_fade_color_arg_color_hi                                       ; $02F216 | |
    STA r_battle_cgram_data.2.color1.w + 1,X                                    ; $02F218 |/
    INX                                                                         ; $02F21B |\
    INX                                                                         ; $02F21C | | Increment the X register and loop until palettes 2-7 (background
    CPX #_sizeof_palette.w * 6                                                  ; $02F21D | | and monster) have been faded by one step.
    BNE -                                                                       ; $02F220 |/
+   RTS                                                                         ; $02F222

; _battle_activate_battle_background_fade ($02:F223)
;
; Activates the battle background fade effect. If $F487 is already non-zero, it
; will instead return without doing anything.
_battle_activate_battle_background_fade:
    LDA r_battle_background_fade_active.w                                       ; $02F223 |\
    BEQ +                                                                       ; $02F226 | | Return if the fade is already active. Otherwise, set the flag that
    RTS                                                                         ; $02F228 | | indicates that it's active.
+   INC r_battle_background_fade_active.w                                       ; $02F229 |/
    LDX #0.w                                                                    ; $02F22C | Initialize the X register to zero.
-   LDA r_battle_cgram_data.2.w,X                                               ; $02F22F |\
    STA r_battle_background_palette_backup.w,X                                  ; $02F232 | | Copy the battle background palettes to the backup area in RAM.
    INX                                                                         ; $02F235 | |
    CPX #_sizeof_palette.w * 2                                                  ; $02F236 | |
    BNE -                                                                       ; $02F239 |/
    LDA r_battle_background.w                                                   ; $02F23B |\
    AND #BATTLE_BACKGROUND_BACKGROUND.b                                         ; $02F23E | | Load the intensity of the fade (and therefore the number of frames
    TAX                                                                         ; $02F240 | | to take) for this particular battle background.
    LDA bank0D.battle_background_fade_intensity_data.l,X                        ; $02F241 | |
    TAX                                                                         ; $02F245 |/
-   JSR _battle_wait_next_frame_preserve_x_y                                    ; $02F246 |\
    JSR _battle_fade_battle_background_palettes                                 ; $02F249 | | Loop the correct number of frames, decreasing the intensity by one
    DEX                                                                         ; $02F24C | | step each frame.
    BNE -                                                                       ; $02F24D |/
    RTS                                                                         ; $02F24F

; _battle_fade_battle_background_palettes ($02:F250)
;
; This routine fades the second and third palettes (used for the battle
; background) by a value of 1 on each component.
_battle_fade_battle_background_palettes:
    PHX                                                                         ; $02F250 | Preserve the value of the X register.
    LDX #0.w                                                                    ; $02F251 | Initialize the X register to zero.
-   LDA r_battle_cgram_data.2.w + 0,X                                           ; $02F254 |\
    STA <r_battle_fade_color_arg_color_lo                                       ; $02F257 | | Fade the current color by 1.
    LDA r_battle_cgram_data.2.w + 1,X                                           ; $02F259 | |
    STA <r_battle_fade_color_arg_color_hi                                       ; $02F25C | |
    LDA #1.b                                                                    ; $02F25E | |
    JSR _battle_fade_color                                                      ; $02F260 | |
    LDA <r_battle_fade_color_arg_color_lo                                       ; $02F263 | |
    STA r_battle_cgram_data.2.w + 0,X                                           ; $02F265 | |
    LDA <r_battle_fade_color_arg_color_hi                                       ; $02F268 | |
    STA r_battle_cgram_data.2.w + 1,X                                           ; $02F26A |/
    INX                                                                         ; $02F26D |\ Increment the X register by two to move to the next color.
    INX                                                                         ; $02F26E |/
    CPX #_sizeof_palette.w * 2                                                  ; $02F26F |\ Loop until 2 complete palettes have been darkened.
    BNE -                                                                       ; $02F272 |/
    PLX                                                                         ; $02F274 | Restore the X register value.
    RTS                                                                         ; $02F275

; _battle_deactivate_battle_background_fade ($02:F276)
;
; Deactivates the battle background fade effect. If $F487 is already zero, it
; will instead return without doing anything.
_battle_deactivate_battle_background_fade:
    LDA r_battle_background_fade_active.w                                       ; $02F276 |\
    BNE +                                                                       ; $02F279 | | If the fade effect is not active, simply return. Otherwise, unset
    RTS                                                                         ; $02F27B | | the active flag.
+   STZ r_battle_background_fade_active.w                                       ; $02F27C |/
    LDA r_battle_background.w                                                   ; $02F27F |\
    AND #BATTLE_BACKGROUND_BACKGROUND.b                                         ; $02F282 | | Load the intensit/duration value from ROM for this battle
    TAX                                                                         ; $02F284 | | background and transfer it to the X register.
    LDA bank0D.battle_background_fade_intensity_data.l,X                        ; $02F285 | |
    TAX                                                                         ; $02F289 |/
-   JSR _battle_wait_next_frame_preserve_x_y                                    ; $02F28A | Wait for the next frame.
    TXA                                                                         ; $02F28D |\ Transfer the current value of the X register to the parameter for
    STA <r_battle_generic_tmp_index_2_lo                                        ; $02F28E |/ the fade routine.
    JSR _battle_fade_battle_background_palette_from_backups                     ; $02F290 | Call the fade routine.
    DEX                                                                         ; $02F293 |\ Decrement the X register and loop until it reaches zero.
    BNE -                                                                       ; $02F294 |/
    LDX #0.w                                                                    ; $02F296 | Initialize the X register to zero.
-   LDA r_battle_background_palette_backup.w,X                                  ; $02F299 |\
    STA r_battle_cgram_data.2.w,X                                               ; $02F29C | | Copy the original values for the background palettes back to the
    INX                                                                         ; $02F29F | | CG-RAM mirror.
    CPX #_sizeof_palette.w * 2                                                  ; $02F2A0 | |
    BNE -                                                                       ; $02F2A3 |/
    RTS                                                                         ; $02F2A5

; _battle_fade_battle_background_palette_from_backups ($02:F2A6)
;
; This routine fades the second and third palettes (used for the battle
; background) by the value passed in $02 on each component. Note that this
; subtracts the value from the backups stored at $F3C4 instead of the actual
; data. This can be used to reverse the fade effect, by calling this routine
; repeatedly with a decreasing value.
_battle_fade_battle_background_palette_from_backups:
    PHX                                                                         ; $02F2A6 | Preserve the value of the X register.
    LDX #0.w                                                                    ; $02F2A7 | Initialize the X register to zero.
-   LDA r_battle_background_palette_backup.w + 0,X                              ; $02F2AA |\
    STA <r_battle_fade_color_arg_color_lo                                       ; $02F2AD | | Load the original color from the backup array in memory, and then
    LDA r_battle_background_palette_backup.w + 1,X                              ; $02F2AF | | fade each color by the value passed in $02. Write the faded colors
    STA <r_battle_fade_color_arg_color_hi                                       ; $02F2B2 | | directly into the CG-RAM mirror.
    LDA <r_battle_generic_tmp_index_2_lo                                        ; $02F2B4 | |
    JSR _battle_fade_color                                                      ; $02F2B6 | |
    LDA <r_battle_fade_color_arg_color_lo                                       ; $02F2B9 | |
    STA r_battle_cgram_data.2.w + 0,X                                           ; $02F2BB | |
    LDA <r_battle_fade_color_arg_color_hi                                       ; $02F2BE | |
    STA r_battle_cgram_data.2.w + 1,X                                           ; $02F2C0 |/
    INX                                                                         ; $02F2C3 |\ Increment the X register by two to move to the next color.
    INX                                                                         ; $02F2C4 |/
    CPX #_sizeof_palette.w * 2                                                  ; $02F2C5 |\ Loop until both palettes have been completely set.
    BNE -                                                                       ; $02F2C8 |/
    PLX                                                                         ; $02F2CA | Restore the X register.
    RTS                                                                         ; $02F2CB

; battle_fade_monster_palettes ($02:F2CC)
;
; Fades the monster palettes, ranging from 3 to 7, each by one step.
battle_fade_monster_palettes:
    LDX #0.w                                                                    ; $02F2CC | Initialize the X register to zero.
-   LDA r_battle_cgram_data.4.w + 0,X                                           ; $02F2CF |\
    STA <r_battle_fade_color_arg_color_lo                                       ; $02F2D2 | | Fade the current color by 1.
    LDA r_battle_cgram_data.4.w + 1,X                                           ; $02F2D4 | |
    STA <r_battle_fade_color_arg_color_hi                                       ; $02F2D7 | |
    LDA #1.b                                                                    ; $02F2D9 | |
    JSR _battle_fade_color                                                      ; $02F2DB | |
    LDA <r_battle_fade_color_arg_color_lo                                       ; $02F2DE | |
    STA r_battle_cgram_data.4.w + 0,X                                           ; $02F2E0 | |
    LDA <r_battle_fade_color_arg_color_hi                                       ; $02F2E3 | |
    STA r_battle_cgram_data.4.w + 1,X                                           ; $02F2E5 |/
    INX                                                                         ; $02F2E8 |\ Increment the X register by two to move to the next color.
    INX                                                                         ; $02F2E9 |/
    CPX #_sizeof_palette.w * 4                                                  ; $02F2EA |\ Loop until palettes 3, 4, 5 and 6 have all been faded.
    BNE -                                                                       ; $02F2ED |/
    RTL                                                                         ; $02F2EF

; _battle_effect_spell_set_sprite_pattern_block ($02:F2F0)
;
; Sets the sprite pattern to the moving block pattern.
_battle_effect_spell_set_sprite_pattern_block:
    LDA #BATTLE_SPELL_SPRITE_PATTERN_BLOCK.b                                    ; $02F2F0 |\ Set the sprite pattern to the moving block pattern.
    STA r_battle_effect_spell_sprite_pattern.w                                  ; $02F2F2 |/
    RTS                                                                         ; $02F2F5

; _battle_effect_spell_animate_standard_random ($02:F2F6)
;
; Animates a standard spell with a random sprite pattern.
_battle_effect_spell_animate_standard_random:
    JSR _battle_effect_spell_set_sprite_pattern_block                           ; $02F2F6 |\ Set the sprite pattern to random.
    INC r_battle_effect_spell_sprite_pattern.w                                  ; $02F2F9 |/
    LDA #1.b                                                                    ; $02F2FC | NOTE: This line is completely useless.
    JMP _battle_effect_spell_animate_standard_common                            ; $02F2FE | Jump to animate the standard spell.

; _battle_effect_spell_animate_standard_block ($02:F301)
;
; Animates a standard spell with the moving block sprite pattern.
_battle_effect_spell_animate_standard_block:
    JSR _battle_effect_spell_set_sprite_pattern_block                           ; $02F301 | Set the sprite pattern to the moving block pattern.
    JMP _battle_effect_spell_animate_standard_common                            ; $02F304 | Jump to animate an otherwise standard spell.

; _battle_effect_spell_animate_standard_fixed_no_target_palette_cycling ($02:F307)
;
; Animates a standard spell with a fixed sprite pattern, except with no target
; palette cycling. Falls thorugh to the next routine.
_battle_effect_spell_animate_standard_fixed_no_target_palette_cycling:
    INC r_battle_effect_target_palette_cycling_disable.w                        ; $02F307 | Disable target palette cycling and fall through.

; _battle_effect_spell_animate_standard_fixed ($02:F30A)
;
; Animates a standard spell using a fixed sprite pattern, by animating the
; original cast, and then any reflected spells.
_battle_effect_spell_animate_standard_fixed:
    STZ r_battle_effect_spell_sprite_pattern.w                                  ; $02F30A | Set the sprite pattern to fixed.
_battle_effect_spell_animate_standard_common:
    JSR _battle_effect_spell_animate_original                                   ; $02F30D | Animate the original cast.
    JMP _battle_effect_spell_animate_reflected                                  ; $02F310 | Animate the reflected cast.

; _battle_effect_spell_animate_original ($02:F313)
;
; Animates the original casting of a spell, including the direct targets and the
; walls that indicate a spell was reflected. The _manual_targets variant allows
; the caller to set the monster flag and targets manually, by specifying the
; monster flag in $00 and the targets in $01.
_battle_effect_spell_animate_original:
    LDA r_battle_current_action_details.target_flags.w                          ; $02F313 |\
    AND #BATTLE_ACTION_DETAILS_TARGET_FLAG_MONSTER.b                            ; $02F316 | | Set the flag that determines if the targets are monsters.
    STA <r_battle_effect_spell_animate_arg_monster                              ; $02F318 |/
    LDA r_battle_current_action_details.target.w                                ; $02F31A |\ Set the targets parameter.
    STA <r_battle_effect_spell_animate_arg_targets                              ; $02F31D |/
_battle_effect_spell_animate_original_manual_targets:
    LDA r_battle_command_wall_sources.w                                         ; $02F31F |\ Set the wall targets parameter to the targets who are having spells
    STA <r_battle_effect_spell_animate_arg_wall_targets                         ; $02F322 |/ reflected off them.
    LDA r_battle_effect_spell_script_index.w                                    ; $02F324 |\ Animate the effect using the configured script.
    JMP _battle_effect_spell_animate                                            ; $02F327 |/

; _battle_effect_spell_animate_reflected ($02:F32A)
;
; Animates the reflected casting of a spell, which includes only the targets
; that are hit as a result of a reflection.
_battle_effect_spell_animate_reflected:
    LDA r_battle_current_action_details.target_flags.w                          ; $02F32A |\
    AND #BATTLE_ACTION_DETAILS_TARGET_FLAG_MONSTER.b                            ; $02F32D | | Set the monster flag by inverting the bit on the target flags (as
    EOR #BATTLE_ACTION_DETAILS_TARGET_FLAG_MONSTER.b                            ; $02F32F | | we are animating any reflected spells).
    STA <r_battle_effect_spell_animate_arg_monster                              ; $02F331 |/
    LDA r_battle_command_wall_targets.w                                         ; $02F333 |\ Set the targets argument to the reflected targets.
    STA <r_battle_effect_spell_animate_arg_targets                              ; $02F336 |/
    STZ <r_battle_effect_spell_animate_arg_wall_targets                         ; $02F338 | There are no walls to be animated this time.
    LDA r_battle_effect_spell_script_index.w                                    ; $02F33A |\ Animate the effect using the configured script.
    JMP _battle_effect_spell_animate                                            ; $02F33D |/

; _battle_effect_coordinate_offset_subtract_half_height ($02:F340)
;
; Subtracts half the height of the current effect in pixels from the global Y
; coordinate offset at $2D.
_battle_effect_coordinate_offset_subtract_half_height:
    LDA r_battle_effect_spell_size.height.w                                     ; $02F340 |\
    ASL A                                                                       ; $02F343 | | Subtract half the effect's height in pixels from the global Y
    ASL A                                                                       ; $02F344 | | coordinate offset.
    ASL A                                                                       ; $02F345 | |
    STA <r_battle_effect_spell_tmp                                              ; $02F346 | |
    LDA <r_battle_effect_spell_tmp_coordinate_offsets.y                         ; $02F348 | |
    SEC                                                                         ; $02F34A | |
    SBC <r_battle_effect_spell_tmp                                              ; $02F34B | |
    STA <r_battle_effect_spell_tmp_coordinate_offsets.y                         ; $02F34D |/
    RTS                                                                         ; $02F34F

; _battle_effect_coordinate_offset_add_half_height ($02:F350)
;
; Adds half the height of the current effect in pixels to the global Y
; coordinate offset at $2D.
_battle_effect_coordinate_offset_add_half_height:
    LDA r_battle_effect_spell_size.height.w                                     ; $02F350 |\
    ASL A                                                                       ; $02F353 | | Add half the effect's height in pixels to the global Y coordinate
    ASL A                                                                       ; $02F354 | | offset.
    ASL A                                                                       ; $02F355 | |
    CLC                                                                         ; $02F356 | |
    ADC <r_battle_effect_spell_tmp_coordinate_offsets.y                         ; $02F357 | |
    STA <r_battle_effect_spell_tmp_coordinate_offsets.y                         ; $02F359 |/
    RTS                                                                         ; $02F35B

; _battle_effect_spell_calculate_coordinates ($02:F35C)
;
; Based on the effect parameters in its script, determines the appropriate
; coordinates for the effect. Primary return values are a 16-bit pointer to an
; array containing coordinate offsets for each slot in $08, and two 8-bit
; coordinate offsets to apply to all slots in $2C and $2D.
_battle_effect_spell_calculate_coordinates:
    TDC                                                                         ; $02F35C |\
    TAX                                                                         ; $02F35D | | Initialize the main coordinate array to all zeroes. This array
-   STA r_battle_effect_spell_coordinates.w,X                                   ; $02F35E | | will be returned if the primary offset is the only relevant
    INX                                                                         ; $02F361 | | information, with no slot-specific coordinates.
    CPX #_sizeof_r_battle_effect_spell_coordinates.w                            ; $02F362 | |
    BNE -                                                                       ; $02F365 |/
    LDA r_battle_effect_spell_special_mode.w                                    ; $02F367 |\
    CMP #BATTLE_SPELL_SPECIAL_MODE_BOMB.b                                       ; $02F36A | | If the special mode is set to Bomb, set the coordinates pointer to
    BNE +                                                                       ; $02F36C | | the zero coordinates array, set the spell target to slot zero, and
    LDX #r_battle_effect_spell_coordinates.w                                    ; $02F36E | | set the main coordinate offsets to 200 and 84, where the Bomb will
    STX <r_battle_effect_spell_coordinates_ptr                                  ; $02F371 | | be on the screen.
    LDA #%10000000.b                                                            ; $02F373 | |
    STA r_battle_effect_spell_targets.w                                         ; $02F375 | |
    LDA #200.b                                                                  ; $02F378 | |
    STA <r_battle_effect_spell_tmp_coordinate_offsets.x                         ; $02F37A | |
    LDA #84.b                                                                   ; $02F37C | |
    STA <r_battle_effect_spell_tmp_coordinate_offsets.y                         ; $02F37E | |
    RTS                                                                         ; $02F380 |/
+   LDA [<r_battle_effect_spell_data_ptr]                                       ; $02F381 |\
    AND #%11110000.b                                                            ; $02F383 | | Branch ahead if the current spell's size is not one used by Quake,
    CMP #BATTLE_SPELL_SIZE_FIRE.b << 4                                          ; $02F385 | | ColdMist or Fire.
    BEQ +                                                                       ; $02F387 | |
    CMP #BATTLE_SPELL_SIZE_COLDMIST.b << 4                                      ; $02F389 | |
    BEQ +                                                                       ; $02F38B | |
    CMP #BATTLE_SPELL_SIZE_QUAKE.b << 4                                         ; $02F38D | |
    BNE ++                                                                      ; $02F38F |/
+   LDA #68.b                                                                   ; $02F391 |\
    STA <r_battle_effect_spell_tmp_coordinate_offsets.y                         ; $02F393 | | For these spells, set the Y coordinate offset to 68, ensure the
    LDX #r_battle_effect_spell_coordinates.w                                    ; $02F395 | | slot-specific coordinates reference the zero array, and set the
    STX <r_battle_effect_spell_coordinates_ptr                                  ; $02F398 | | spell target to slot zero.
    LDA #%10000000.b                                                            ; $02F39A | |
    STA r_battle_effect_spell_targets.w                                         ; $02F39C |/
    LDA <r_battle_generic_tmp_index_lo                                          ; $02F39F |\
    BNE +                                                                       ; $02F3A1 | | If the spell is targeting characters, set the X coordinate offset
    LDA #216.b                                                                  ; $02F3A3 | | to 216 and return.
    STA <r_battle_effect_spell_tmp_coordinate_offsets.x                         ; $02F3A5 | |
    RTS                                                                         ; $02F3A7 |/
+   LDA #96.b                                                                   ; $02F3A8 |\
    STA <r_battle_effect_spell_tmp_coordinate_offsets.x                         ; $02F3AA | | Otherwise, set it to 96 and return.
    RTS                                                                         ; $02F3AC |/
++  CMP #BATTLE_SPELL_SIZE_12_BY_9.b << 4                                       ; $02F3AD |\
    BNE +                                                                       ; $02F3AF | | If the effect size is to set to 12x9 (used by most large spell
    LDA r_battle_effect_spell_index.w                                           ; $02F3B1 | | effects, such as Lit-Bolt, Flame, and so on), this block applies.
    CMP #SPELL_MONSTER_FISSION.b                                                ; $02F3B4 | | If the spell is Fission, branch ahead to other code later.
    BEQ ++                                                                      ; $02F3B6 | | Otherwise, set the X coordinate offset to 96, set the Y coordinate
    LDA #96.b                                                                   ; $02F3B8 | | offset to 68, set the spell coordinates pointer to the coordinates
    STA <r_battle_effect_spell_tmp_coordinate_offsets.x                         ; $02F3BA | | array, and set the spell target to slot zero.
    LDA #68.b                                                                   ; $02F3BC | |
    STA <r_battle_effect_spell_tmp_coordinate_offsets.y                         ; $02F3BE | |
    LDX #r_battle_effect_spell_coordinates.w                                    ; $02F3C0 | |
    STX <r_battle_effect_spell_coordinates_ptr                                  ; $02F3C3 | |
    LDA #%10000000.b                                                            ; $02F3C5 | |
    STA r_battle_effect_spell_targets.w                                         ; $02F3C7 | |
    RTS                                                                         ; $02F3CA |/
+   CMP #BATTLE_SPELL_SIZE_16_BY_9.b << 4                                       ; $02F3CB |\
    BNE ++                                                                      ; $02F3CD | | If the spell effect size if 16x9 (used by Indra and Big Bang), set
    LDA #128.b                                                                  ; $02F3CF | | the coordinate offsets to 128, 68, set the coordinates pointer to
    STA <r_battle_effect_spell_tmp_coordinate_offsets.x                         ; $02F3D1 | | the zero coordinatess array, and set the target to slot zero.
    LDA #68.b                                                                   ; $02F3D3 | |
    STA <r_battle_effect_spell_tmp_coordinate_offsets.y                         ; $02F3D5 | |
    LDX #r_battle_effect_spell_coordinates.w                                    ; $02F3D7 | |
    STX <r_battle_effect_spell_coordinates_ptr                                  ; $02F3DA | |
    LDA #%10000000.b                                                            ; $02F3DC | |
    STA r_battle_effect_spell_targets.w                                         ; $02F3DE | |
    RTS                                                                         ; $02F3E1 |/
++  LDY #1.w                                                                    ; $02F3E2 |\
    LDA [<r_battle_effect_spell_data_ptr],Y                                     ; $02F3E5 | | Mask out the alignment bits from the second byte of the script,
    AND #%01100000.b                                                            ; $02F3E7 | | and branch ahead if the alignment is not centered.
    BNE ++                                                                      ; $02F3E9 |/
    LDA <r_battle_generic_tmp_index_lo                                          ; $02F3EB |\
    BNE +                                                                       ; $02F3ED | | If the spell is targeting characters, set the coordinate offsets
    STZ <r_battle_effect_spell_tmp_coordinate_offsets.y                         ; $02F3EF | | to 24 and 0 to center the coordinates, enable the mirorr flag, and
    LDA #24.b                                                                   ; $02F3F1 | | load the character cursor coordinates address into the X register,
    STA <r_battle_effect_spell_tmp_coordinate_offsets.x                         ; $02F3F3 | | before branching to the end.
    LDA #1.b                                                                    ; $02F3F5 | |
    STA r_battle_effect_spell_mirror.w                                          ; $02F3F7 | |
    LDX #r_battle_character_cursor_coordinates_copy_2.w                         ; $02F3FA | |
    JMP @done                                                                   ; $02F3FD |/
+   TDC                                                                         ; $02F400 |\
    TAX                                                                         ; $02F401 | | If the target is monsters, set the global offset to zero, unset
    STX <r_battle_effect_spell_tmp_coordinate_offsets                           ; $02F402 | | the mirror flag, and load the address for the monster center
    STA r_battle_effect_spell_mirror.w                                          ; $02F404 | | coordinates array into the X register, before branching to the
    LDX #r_battle_monster_coordinates_center.w                                  ; $02F407 | | end.
    JMP @done                                                                   ; $02F40A |/
++  CMP #BATTLE_SPELL_ALIGNMENT_TOP.b << 5                                      ; $02F40D |\ Branch to the next check if the alignment mode isn't set to top.
    BNE ++                                                                      ; $02F40F |/
    LDA <r_battle_generic_tmp_index_lo                                          ; $02F411 |\
    BNE +                                                                       ; $02F413 | | If the spell is targeting characters, set the global offsets to
    LDA #-12.b                                                                  ; $02F415 | | -12 and 23 to adjust for the relative position of the cursor
    STA <r_battle_effect_spell_tmp_coordinate_offsets.y                         ; $02F417 | | coordinates, add half the height of the effect to push its top
    LDA #23.b                                                                   ; $02F419 | | down to the calculated position, enable the mirror flag, load the
    STA <r_battle_effect_spell_tmp_coordinate_offsets.x                         ; $02F41B | | cursor coordinates array address into the X register, and branch
    JSR _battle_effect_coordinate_offset_add_half_height                        ; $02F41D | | to the end.
    LDA #1.b                                                                    ; $02F420 | |
    STA r_battle_effect_spell_mirror.w                                          ; $02F422 | |
    LDX #r_battle_character_cursor_coordinates_copy_1.w                         ; $02F425 | |
    BRA @done                                                                   ; $02F428 |/
+   LDX #0.w                                                                    ; $02F42A |\
    STX <r_battle_effect_spell_tmp_coordinate_offsets                           ; $02F42D | | If the target is monsters, set the offsets to zero, then add half
    JSR _battle_effect_coordinate_offset_add_half_height                        ; $02F42F | | the height of the effect, unset the mirror flag, load the top
    TDC                                                                         ; $02F432 | | center monster coordinates address into the X register, then
    STA r_battle_effect_spell_mirror.w                                          ; $02F433 | | branch to the end.
    LDX #r_battle_monster_coordinates_top_center.w                              ; $02F436 | |
    BRA @done                                                                   ; $02F439 |/
++  CMP #BATTLE_SPELL_ALIGNMENT_ABOVE.b << 5                                    ; $02F43B |\ If the alignment of the effect isn't above, branch to the next
    BNE ++                                                                      ; $02F43D |/ section.
    LDA <r_battle_generic_tmp_index_lo                                          ; $02F43F |\
    BNE +                                                                       ; $02F441 | | If the effect is targeting characters, set the global offsets to
    LDA #-24.b                                                                  ; $02F443 | | 23 and -24 to adjust the base coordinates to 16 pixels above the
    STA <r_battle_effect_spell_tmp_coordinate_offsets.y                         ; $02F445 | | center of the character, add half the height of the effect, set
    LDA #23.b                                                                   ; $02F447 | | the mirror flag, load the character cursor coordinates address
    STA <r_battle_effect_spell_tmp_coordinate_offsets.x                         ; $02F449 | | into the X register, and branch to the end.
    JSR _battle_effect_coordinate_offset_add_half_height                        ; $02F44B | |
    LDA #1.b                                                                    ; $02F44E | |
    STA r_battle_effect_spell_mirror.w                                          ; $02F450 | |
    LDX #r_battle_character_cursor_coordinates_copy_1.w                         ; $02F453 | |
    BRA @done                                                                   ; $02F456 |/
+   STZ <r_battle_effect_spell_tmp_coordinate_offsets.x                         ; $02F458 |\
    LDA #-16.b                                                                  ; $02F45A | | For monsters, set the coordinate offsets to 0 and -16 to achieve
    STA <r_battle_effect_spell_tmp_coordinate_offsets.y                         ; $02F45C | | the same effect, add half the height of the effect, unset the
    JSR _battle_effect_coordinate_offset_add_half_height                        ; $02F45E | | mirror flag, load the address of the top center monster
    TDC                                                                         ; $02F461 | | coordinates array into the X register and branch to the end.
    STA r_battle_effect_spell_mirror.w                                          ; $02F462 | |
    LDX #r_battle_monster_coordinates_top_center.w                              ; $02F465 | |
    BRA @done                                                                   ; $02F468 |/
++  LDA <r_battle_generic_tmp_index_lo                                          ; $02F46A |\
    BNE +                                                                       ; $02F46C | | Finally, for bottom aligned mode, for character targets, set the
    STZ <r_battle_effect_spell_tmp_coordinate_offsets.x                         ; $02F46E | | coordinate offsets to 0 and -8, subtract half the effect height,
    LDA #-8.b                                                                   ; $02F470 | | set the mirror flag, and then load the bottom coordinates
    STA <r_battle_effect_spell_tmp_coordinate_offsets.y                         ; $02F472 | | address into the X register, before branching to the end.
    JSR _battle_effect_coordinate_offset_subtract_half_height                   ; $02F474 | |
    LDA #1.b                                                                    ; $02F477 | |
    STA r_battle_effect_spell_mirror.w                                          ; $02F479 | |
    LDX #r_battle_character_cursor_coordinates_plus_24.w                        ; $02F47C | |
    BRA @done                                                                   ; $02F47F |/
+   LDX #0.w                                                                    ; $02F481 |\
    STX <r_battle_effect_spell_tmp_coordinate_offsets                           ; $02F484 | | For monsters, set the coordinate offsets to zero, subtract half
    JSR _battle_effect_coordinate_offset_subtract_half_height                   ; $02F486 | | the height of the effect, unset the mirror flag, and load the
    LDA #0.b                                                                    ; $02F489 | | bottom center monster coordinates array address into the X
    STA r_battle_effect_spell_mirror.w                                          ; $02F48B | | register.
    LDX #r_battle_monster_coordinates_bottom_center.w                           ; $02F48E |/
@done:
    STX <r_battle_effect_spell_coordinates_ptr                                  ; $02F491 | Store the loaded value as the spell coordinates pointer.
    RTS                                                                         ; $02F493

; _battle_set_bg1_horizontal_scroll ($02:F494)
;
; Given a value in the accumulator, sets the low byte of the horizontal scroll
; values for each of the first 140 lines of BG1 in the HDMA tables.
_battle_set_bg1_horizontal_scroll:
    PHA                                                                         ; $02F494 | Preserve the value in the accumulator.
    LDX #0.w                                                                    ; $02F495 | Initialize the X register to zero.
-   STA r_battle_bg1_hdma_data.1.horizontal_lo.w,X                              ; $02F498 |\
    STA r_battle_bg1_hdma_data.36.horizontal_lo.w,X                             ; $02F49B | | Update the HDMA tables with the passed value.
    STA r_battle_bg1_hdma_data.71.horizontal_lo.w,X                             ; $02F49E | |
    STA r_battle_bg1_hdma_data.106.horizontal_lo.w,X                            ; $02F4A1 |/
    INX                                                                         ; $02F4A4 |\
    INX                                                                         ; $02F4A5 | | Increment the X register four times to move to the next entry and
    INX                                                                         ; $02F4A6 | | loop until 140 lines have been updated.
    INX                                                                         ; $02F4A7 | |
    CPX #_sizeof_scroll_hdma_data_entry.w * 35                                  ; $02F4A8 | |
    BNE -                                                                       ; $02F4AB |/
    PLA                                                                         ; $02F4AD | Restore the value in the accumulator.
    RTS                                                                         ; $02F4AE

; _battle_set_bg2_horizontal_scroll ($02:F4AF)
;
; Sets the low byte of the scroll value of BG2 by altering the BG2 HDMA tables.
; If the battle background is the Zeromus background, the function does nothing.
_battle_set_bg2_horizontal_scroll:
    PHA                                                                         ; $02F4AF |\
    LDA r_battle_background.w                                                   ; $02F4B0 | | If the current battle background is the Zeromus background, abort
    CMP #BATTLE_BACKGROUND_ZEROMUS.b                                            ; $02F4B3 | | executing this function, as it has its own BG2 scroll handling.
    BNE +                                                                       ; $02F4B5 | |
    PLA                                                                         ; $02F4B7 | |
    RTS                                                                         ; $02F4B8 | |
+   PLA                                                                         ; $02F4B9 |/
    LDX #0.w                                                                    ; $02F4BA | Initialize the X register to zero.
-   STA r_battle_bg2_hdma_data.1.horizontal_lo.w,X                              ; $02F4BD |\
    STA r_battle_bg2_hdma_data.36.horizontal_lo.w,X                             ; $02F4C0 | | Loop through the HDMA data, updating the low byte of the
    STA r_battle_bg2_hdma_data.71.horizontal_lo.w,X                             ; $02F4C3 | | horizontal scroll value for each line.
    STA r_battle_bg2_hdma_data.106.horizontal_lo.w,X                            ; $02F4C6 | |
    INX                                                                         ; $02F4C9 | |
    INX                                                                         ; $02F4CA | |
    INX                                                                         ; $02F4CB | |
    INX                                                                         ; $02F4CC | |
    CPX #_sizeof_scroll_hdma_data_entry.w * 35                                  ; $02F4CD | |
    BNE -                                                                       ; $02F4D0 |/
    RTS                                                                         ; $02F4D2

; _battle_effect_spell_check_special_mode_field ($02:F4D3)
;
; If the special mode is $F2D0 is set to either party field or monster field,
; explicitly sets the spell targets to all targets on the targeted side and sets
; the slot offsets to produce the field effect.
_battle_effect_spell_check_special_mode_field:
    LDA r_battle_effect_spell_special_mode.w                                    ; $02F4D3 |\
    CMP #BATTLE_SPELL_SPECIAL_MODE_PARTY_FIELD.b                                ; $02F4D6 | | Return unless the special mode is set to either party field or
    BEQ +                                                                       ; $02F4D8 | | monster field.
    CMP #BATTLE_SPELL_SPECIAL_MODE_MONSTER_FIELD.b                              ; $02F4DA | |
    BEQ +                                                                       ; $02F4DC | |
    RTS                                                                         ; $02F4DE |/
+   LDA #%11111111.b                                                            ; $02F4DF |\ Explicitly set the spell targets to all targets.
    STA r_battle_effect_spell_targets.w                                         ; $02F4E1 |/
    TDC                                                                         ; $02F4E4 |\
    TAY                                                                         ; $02F4E5 | | Set the coordinates for all slots to 0.
-   STA r_battle_effect_spell_slot_coordinates.w,Y                              ; $02F4E6 | |
    INY                                                                         ; $02F4E9 | |
    CPY #16.w                                                                   ; $02F4EA | |
    BNE -                                                                       ; $02F4ED |/
    LDA r_battle_effect_spell_sprite_pattern.w                                  ; $02F4EF |\ Update the slot offsets to correct values for the mode.
    JMP _battle_effect_spell_set_offsets                                        ; $02F4F2 |/

; _battle_monster_set_palette_cycle ($02:F4F5)
;
; Given a bitmask of monster targets in $F281, updates the palettes of those
; monsters to palette 7 (used for palette cycling).
_battle_monster_set_palette_cycle:
    JSR _battle_monster_slot_map_enable_pre_action                              ; $02F4F5 | Switch to the pre-action monster slot data.
    JSR _battle_load_monster_tilemaps                                           ; $02F4F8 | Load the monster tilemaps.
    LDX #0.w                                                                    ; $02F4FB | Initialize the X register to zero.
-   ASL r_battle_monster_set_palette_cycle_arg_targets.w                        ; $02F4FE |\ Skip this slot if it was not set as a target.
    BCC +                                                                       ; $02F501 |/
    TXA                                                                         ; $02F503 |\ Set the palette slot number to the current slot.
    STA r_battle_update_monster_palette_arg_slot.w                              ; $02F504 |/
    LDA #7.b                                                                    ; $02F507 |\ Set the monster's palette to palette 7.
    STA r_battle_update_monster_palette_arg_palette.w                           ; $02F509 |/
    PHX                                                                         ; $02F50C |\
    JSR _battle_update_monster_palette                                          ; $02F50D | | Update the monster's palette.
    PLX                                                                         ; $02F510 |/
+   INX                                                                         ; $02F511 |\
    CPX #8.w                                                                    ; $02F512 | | Loop through all eight monster slots.
    BNE -                                                                       ; $02F515 |/
    JSR _flip_battle_monster_tilemap                                            ; $02F517 | Flip the tilemap as appropriate for a back attack.
    JSR _copy_battle_tilemap_bg1_right_to_vram                                  ; $02F51A | Copy the new tilemap to VRAM.
    JSR _battle_monster_slot_map_disable_pre_action                             ; $02F51D | Switch back to the live version of the monster slot data.
    RTS                                                                         ; $02F520

; _battle_palette_cycle_load_palette ($02:F521)
;
; Given a palette value in the accumulator, loads that palette into either the
; character palettes or the eighth palette (for monsters). Reliant on other
; palette cycling variables. Palettes are relative to palette 28 in the
; miscellaneous battle palettes.
_battle_palette_cycle_load_palette:
    CLC                                                                         ; $02F521 |\
    ADC #BATTLE_MISC_PALETTE_UNKNOWN_28.b                                       ; $02F522 | | Calculate the offset to the desired palette data in ROM. The value
    STA <r_math_multiply_8bit_arg_1                                             ; $02F524 | | in the accumulator is added to $28 and multiplied by the size of
    LDA #16.b                                                                   ; $02F526 | | an 8 color palette.
    STA <r_math_multiply_8bit_arg_2                                             ; $02F528 | |
    JSR _math_multiply_8bit                                                     ; $02F52A |/
    LDA r_battle_effect_target_palette_cycling_monster.w                        ; $02F52D |\ Branch to the monster code if the intended cycling target is a
    BNE @monster                                                                ; $02F530 |/ monster.
    LDA r_battle_effect_target_palette_cycling_target.w                         ; $02F532 |\ Transfer the target value to a temporary variable (reusing the
    STA <r_math_multiply_8bit_arg_1                                             ; $02F535 |/ multiply argument location).
    LDY #0.w                                                                    ; $02F537 | Initialize the Y register to zero.
--  ASL <r_math_multiply_8bit_arg_1                                             ; $02F53A |\ Skip this target if not set in the target value.
    BCC +                                                                       ; $02F53C |/
    PHY                                                                         ; $02F53E | Preserve the value of the Y register.
    TYA                                                                         ; $02F53F |\
    ASL A                                                                       ; $02F540 | | Set the Y register to the slot number times 32 to serve as a
    ASL A                                                                       ; $02F541 | | palette offset.
    ASL A                                                                       ; $02F542 | |
    ASL A                                                                       ; $02F543 | |
    ASL A                                                                       ; $02F544 | |
    TAY                                                                         ; $02F545 |/
    LDA #16.b                                                                   ; $02F546 |\ Initialize the counter (reusing a variable) to 16.
    STA <r_math_multiply_8bit_arg_2                                             ; $02F548 |/
    LDX <r_math_multiply_8bit_result                                            ; $02F54A | Set the X register to the ROM palette offset.
-   LDA bank0E.battle_palette_data.l,X                                          ; $02F54C |\
    STA r_battle_cgram_data.10.color1.w,Y                                       ; $02F550 | | Set two colors on both sides of the palette to the read value.
    STA r_battle_cgram_data.10.color9.w,Y                                       ; $02F553 |/
    INX                                                                         ; $02F556 |\
    INY                                                                         ; $02F557 | | Increment the indexes and loop until all 8 colors have been
    DEC <r_math_multiply_8bit_arg_2                                             ; $02F558 | | written.
    BNE -                                                                       ; $02F55A |/
    PLY                                                                         ; $02F55C | Restore the value of the Y register.
+   INY                                                                         ; $02F55D |\
    CPY #5.w                                                                    ; $02F55E | | Loop until all five characters have been written.
    BNE --                                                                      ; $02F561 |/
    RTS                                                                         ; $02F563
@monster:
    LDY #0.w                                                                    ; $02F564 | Initialize the Y register to zero.
    LDX <r_math_multiply_8bit_result                                            ; $02F567 | Initialize the X register to the ROM palette data offset.
-   LDA bank0E.battle_palette_data.l,X                                          ; $02F569 |\
    STA r_battle_cgram_data.8.color1.w,Y                                        ; $02F56D | | Transfer the color byte to palette 8.
    STA r_battle_cgram_data.8.color9.w,Y                                        ; $02F570 |/
    INX                                                                         ; $02F573 |\
    INY                                                                         ; $02F574 | | Loop until all eight colors have been copied.
    CPY #16.w                                                                   ; $02F575 | |
    BNE -                                                                       ; $02F578 |/
    RTS                                                                         ; $02F57A

; _battle_effect_disable_target_palette_cycling ($02:F57B)
;
; Disables target palette cycling by either disabling it (for party members) or
; by switching BG1 to display the unchanged half (for monsters).
_battle_effect_disable_target_palette_cycling:
    LDA r_battle_effect_target_palette_cycling_monster.w                        ; $02F57B |\
    BNE +                                                                       ; $02F57E | | If the target palette cycling is affecting the party, disable
    STZ r_battle_effect_target_palette_cycling_party_active.w                   ; $02F580 | | party palette cycling and return.
    RTS                                                                         ; $02F583 |/
+   LDA r_battle_effect_monster_palette_cycling_enabled.w                       ; $02F584 |\
    CMP #1.b                                                                    ; $02F587 | | If the flag says that monster palette cycling is enabled, unset
    BNE +                                                                       ; $02F589 | | the flag and set BG1 to display the left half.
    STZ r_battle_effect_monster_palette_cycling_enabled.w                       ; $02F58B | |
    TDC                                                                         ; $02F58E | | NOTE: This flag is only used as tracking here and does not change
    JMP _battle_set_bg1_horizontal_hi_scroll                                    ; $02F58F |/        behavior of the palette cycling code.
+   RTS                                                                         ; $02F592

; _battle_effect_enable_target_palette_cycling ($02:F593)
;
; Enables target palette cycling by either enabling it (for party members) or
; by switching BG1 to display the changed half (for monsters).
_battle_effect_enable_target_palette_cycling:
    LDA r_battle_effect_target_palette_cycling_monster.w                        ; $02F593 |\
    BNE +                                                                       ; $02F596 | | If the target palette cycling is affecting the party, enable party
    LDA #1.b                                                                    ; $02F598 | | palette cycling and return.
    STA r_battle_effect_target_palette_cycling_party_active.w                   ; $02F59A | |
-   RTS                                                                         ; $02F59D |/
+   LDA r_battle_effect_monster_palette_cycling_enabled.w                       ; $02F59E |\
    BNE -                                                                       ; $02F5A1 | | If the flag says that monster palette cycling is disabled, set the
    LDA #1.b                                                                    ; $02F5A3 | | flag and set BG1 to display the right half.
    STA r_battle_effect_monster_palette_cycling_enabled.w                       ; $02F5A5 | |
    LDA #1.b                                                                    ; $02F5A8 | |
    JMP _battle_set_bg1_horizontal_hi_scroll                                    ; $02F5AA |/

; battle_reset_bg1_bg2_horizontal_scroll ($02:F5AD)
;
; Resets both the BG1 and BG2 horizontal scroll values to zero. Only affects BG2
; if the battle background is not the Zeromus background.
battle_reset_bg1_bg2_horizontal_scroll:
    TDC                                                                         ; $02F5AD |\ Set the BG1 and BG2 horizontal scroll values to zero.
    JSR _battle_set_bg1_bg2_horizontal_scroll                                   ; $02F5AE |/
    RTL                                                                         ; $02F5B1

; battle_update_shake_scroll ($02:F5B2)
;
; Depending on the current value of the battle frame counter, updates the BG1
; horizontal scroll value to produce the shaking effect.
battle_update_shake_scroll:
    LDA r_battle_frame_counter.w                                                ; $02F5B2 |\
    AND #%00000111.b                                                            ; $02F5B5 | | Determine the index by taking the frame counter mod 8.
    TAX                                                                         ; $02F5B7 |/
    LDA bank0D.battle_shake_scroll_data.l,X                                     ; $02F5B8 |\ Load the appropriate scroll data from ROM and set the BG1 scroll
    JSR _battle_set_bg1_horizontal_scroll                                       ; $02F5BC |/ value.
    RTL                                                                         ; $02F5BF

; _unused_battle_frame_counter_update_bg1_bg2_shake_scroll ($02:F5C0)
;
; Depending on the current value of the battle frame counter, updates the BG1
; and BG2 shake scroll to produce a shaking effect.
_unused_battle_frame_counter_update_bg1_bg2_shake_scroll:
    LDA r_battle_frame_counter.w                                                ; $02F5C0 |\
    AND #%00000111.b                                                            ; $02F5C3 | | Determine the index by taking the frame counter mod 8.
    TAX                                                                         ; $02F5C5 |/
    JSR _battle_update_bg1_bg2_shake_scroll                                     ; $02F5C6 | Jump to set the scroll values for BG1 and BG2.
    RTL                                                                         ; $02F5C9

; _battle_update_bg1_bg2_shake_scroll ($02:F5CA)
;
; Given an offset in the X register, loads the associated shaking offset and
; uses it to set the horizontal scroll values for BG1 and BG2. It achieves this
; by falling through to the next function.
_battle_update_bg1_bg2_shake_scroll:
    LDA bank0D.battle_shake_scroll_data.l,X                                     ; $02F5CA

; _battle_set_bg1_bg2_horizontal_scroll ($02:F5CE)
;
; Sets the low byte of the horizontal scroll value for both BG1 and BG2. BG2 is
; only updated if the battle background is not the Zeromus background.
_battle_set_bg1_bg2_horizontal_scroll:
    JSR _battle_set_bg1_horizontal_scroll                                       ; $02F5CE
    JMP _battle_set_bg2_horizontal_scroll                                       ; $02F5D1

; battle_play_sound_effect ($02:F5D4)
;
; A long proxy to the _battle_play_sound_effect function.
battle_play_sound_effect:
    JSR _battle_play_sound_effect                                               ; $02F5D4
    RTL                                                                         ; $02F5D7

; battle_play_sound_effect_spell ($02:F5D8)
;
; Proxy to call _battle_play_sound_effect_spell from another bank.
battle_play_sound_effect_spell:
    JSR _battle_play_sound_effect_spell                                         ; $02F5D8
    RTL                                                                         ; $02F5DB

; _battle_play_sound_effect_* ($02:F5DC)
;
; Configures the battle audio system to play the sound effect number passed in
; the accumulator. Does not return until the effect has started to play. The
; _spell entry point instead reads the value at $F47F and uses that as an index
; to the spell sound effect table, and then plays that sound effect.
_battle_play_sound_effect:
    STA r_battle_effect_spell_audio_index.w                                     ; $02F5DC | Save the track number to a variable in memory. TODO: Why? It doesn't match.
    PHX                                                                         ; $02F5DF |\ Preserve the values of the X and Y registers.
    PHY                                                                         ; $02F5E0 |/
    JMP _battle_play_sound_effect_finalize                                      ; $02F5E1 | Jump to the audio playing code.
_battle_play_sound_effect_spell:
    PHX                                                                         ; $02F5E4 |\ Preserve the values of the X and Y registers.
    PHY                                                                         ; $02F5E5 |/
    LDA r_battle_effect_spell_audio_index.w                                     ; $02F5E6 |\
    CMP #$FF.b                                                                  ; $02F5E9 | | If the audio index is $FF, skip playing a sound effect.
    BEQ _battle_play_sound_effect_done                                          ; $02F5EB |/
    TAX                                                                         ; $02F5ED |\ Load the sound effect associated with this audio index.
    LDA bank0F.battle_effect_spell_audio_effect_data.l,X                        ; $02F5EE |/
_battle_play_sound_effect_finalize:
    PHA                                                                         ; $02F5F2 | Preserve the argument in the accumulator.
    CMP #AUDIO_EFFECT_LARGE_DOOR.b                                              ; $02F5F3 |\
    BEQ +                                                                       ; $02F5F5 | | If the desired audio effect is either the large door effect (used
    CMP #AUDIO_EFFECT_BIG_BANG.b                                                ; $02F5F7 | | as the EvilWall movement sound) or the Big Bang effect, set the
    BNE ++                                                                      ; $02F5F9 | | pan to the center.
+   LDA #AUDIO_PAN_CENTER.b                                                     ; $02F5FB | |
    BRA +++                                                                     ; $02F5FD |/
++  LDA r_battle_play_audio_pan_monster.w                                       ; $02F5FF |\
    BMI +                                                                       ; $02F602 | | Otherwise, if the audio has been flagged as a monster effect, set
    LDA #AUDIO_PAN_CENTER_RIGHT.b                                               ; $02F604 | | the pan to center left. Otherwise, set it to center right.
    BRA +++                                                                     ; $02F606 | |
+   LDA #AUDIO_PAN_CENTER_LEFT.b                                                ; $02F608 |/
+++ STA r_battle_play_audio_pan.w                                               ; $02F60A | Set the configured pan value.
    PLA                                                                         ; $02F60D |\ Restore the track argument and set that value.
    STA r_battle_play_audio_track.w                                             ; $02F60E |/
    LDA #$FF.b                                                                  ; $02F611 |\ TODO: Set the unknown audio parameter to $FF.
    STA r_battle_play_audio_unknown.w                                           ; $02F613 |/
    LDA #AUDIO_MODE_EFFECT.b                                                    ; $02F616 |\ Set the audio code to play a sound effect.
    STA r_battle_play_audio_mode.w                                              ; $02F618 |/
-   LDA r_battle_play_audio_mode.w                                              ; $02F61B |\ Loop until the effect has been played.
    BNE -                                                                       ; $02F61E |/
_battle_play_sound_effect_done:
    PLY                                                                         ; $02F620 |\ Restore the values of the Y and X registers.
    PLX                                                                         ; $02F621 |/
    RTS                                                                         ; $02F622

; battle_effect_set_palette_or_flash ($02:F623)
;
; Proxy function to call _battle_effect_set_palette_or_flash from another bank.
battle_effect_set_palette_or_flash:
    JSR _battle_effect_set_palette_or_flash                                     ; $02F623
    RTL                                                                         ; $02F626

; battle_effect_load_palette ($02:F627)
;
; Proxy function to call _battle_effect_load_palette from another bank.
battle_effect_load_palette:
    JSR _battle_effect_load_palette                                             ; $02F627
    RTL                                                                         ; $02F62A

; _battle_effect_load_palette ($02:F62B)
;
; Given a miscellaneous palette index in $F457, loads that 8 color palette into
; the last palette in the CG-RAM mirror in RAM.
_battle_effect_load_palette:
    LDA r_battle_effect_load_palette_arg_palette.w                              ; $02F62B |\
    LDX #15.w                                                                   ; $02F62E | | Load the desired palette into palette 15.
    JSR _battle_load_miscellaneous_palette                                      ; $02F631 |/
    STZ r_battle_effect_palette_cycle_enabled.w                                 ; $02F634 | Disable automatic effect palette cycling.
    RTS                                                                         ; $02F637

; _battle_effect_set_palette_or_flash ($02:F638)
;
; Given an 8-bit value in the accumulator, sets either the last palette (used
; for effects) or sets the flash parameters. The mode of operation is selected
; by bit 3. If this bit is set, the function affects the palette. Otherwise, it
; affects the flash.
;
; If using the flash mode, the uppermost three bits determine which colors are
; set in the flash, with blue being the highest bit and red being the lowest.
; The flash mode is determined by the lowest three bits.
;
; If using the palette mode, the upper four bits determine which pair of
; palettes to load as the two palettes to cycle. If that value is zero, palette
; cycling will be disabled, and the default palette in $F457 will be used
; instead. Otherwise, the palette cycling will be configured to update at rate
; specified by the low three bits, where a value of zero corresponds to every
; 128 frames, with each successive value dividing this value by 2 (32, 16, 8,
; etc.).
_battle_effect_set_palette_or_flash:
    PHX                                                                         ; $02F638 |\
    PHA                                                                         ; $02F639 | | If bit 3 is unset, branch ahead to the flash code.
    AND #%00001000.b                                                            ; $02F63A | |
    BEQ @flash                                                                  ; $02F63C | |
    PLA                                                                         ; $02F63E | |
    PHA                                                                         ; $02F63F |/
    AND #%11110000.b                                                            ; $02F640 |\ If any of bits 4-7 is set, branch ahead to the palette cycling
    BNE @cycle                                                                  ; $02F642 |/ code.
    JSR _battle_effect_load_palette                                             ; $02F644 |\
    PLA                                                                         ; $02F647 | | Otherwise, call the routine to simply load the palette set at
    PLX                                                                         ; $02F648 | | $F457 and return (also disables automatic palette cycling).
    RTS                                                                         ; $02F649 |/
@cycle:
    LSR A                                                                       ; $02F64A |\
    LSR A                                                                       ; $02F64B | | Set the X register to the upper four bits, multiplied by two.
    LSR A                                                                       ; $02F64C | |
    TAX                                                                         ; $02F64D |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $02F64E |\
    LDA bank16.battle_effect_palette_cycle_palette_data.l,X                     ; $02F650 | | Load the two palettes referenced by that index and store them in
    STA r_battle_effect_palette_cycle_palettes.w                                ; $02F654 | | the palette cycle data.
    TDC                                                                         ; $02F657 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $02F658 |/
    PLA                                                                         ; $02F65A |\
    AND #%00000111.b                                                            ; $02F65B | | Load the desired frame mask by using the low three bits of the
    TAX                                                                         ; $02F65D | | value as an index.
    LDA bank03.frame_mask_data.l,X                                              ; $02F65E | |
    STA r_battle_effect_palette_cycle_frame_mask.w                              ; $02F662 |/
    INC r_battle_effect_palette_cycle_enabled.w                                 ; $02F665 | Enable automatic palette cycling.
    STZ r_battle_effect_palette_cycle_frame_counter.w                           ; $02F668 |\ Set the frame counter and palette counter to zero.
    STZ r_battle_effect_palette_cycle_palette_counter.w                         ; $02F66B |/
    PLX                                                                         ; $02F66E |\ Restore the X register and return.
    RTS                                                                         ; $02F66F |/
@flash:
    PLA                                                                         ; $02F670 |\
    PHA                                                                         ; $02F671 | | Set the flash color based on the upper three bits of the
    AND #%11100000.b                                                            ; $02F672 | | parameter.
    STA r_battle_flash_color.w                                                  ; $02F674 | |
    PLA                                                                         ; $02F677 | |
    PHA                                                                         ; $02F678 |/
    LDA #31.b                                                                   ; $02F679 |\
    STA r_battle_flash_red_intensity.w                                          ; $02F67B | | Set the intensity for all three colors to maximum.
    STA r_battle_flash_green_intensity.w                                        ; $02F67E | |
    STA r_battle_flash_blue_intensity.w                                         ; $02F681 |/
    STZ r_battle_flash_phase.w                                                  ; $02F684 | Initialize the flash phase to zero.
    STZ r_battle_flash_counter.w                                                ; $02F687 | Initialize the flash counter to zero.
    PLA                                                                         ; $02F68A |\
    AND #%00000111.b                                                            ; $02F68B | | Set the flash mode to the low three bits of the parameter.
    STA r_battle_flash_mode.w                                                   ; $02F68D |/
    PLX                                                                         ; $02F690 | Restore the X register.
    RTS                                                                         ; $02F691

; battle_effect_check_palette_cycle ($02:F692)
;
; Proxy function to call _battle_effect_check_palette_cycle from another bank.
battle_effect_check_palette_cycle:
    JSR _battle_effect_check_palette_cycle                                      ; $02F692
    RTL                                                                         ; $02F695

; _battle_effect_check_palette_cycle ($02:F696)
;
; Handles the effect palette cycling, which alternates between two palettes at
; a configurable interval. Controlled by the variables in $F451 to $F456, and
; updates the last palette, used for battle effects.
_battle_effect_check_palette_cycle:
    LDA r_battle_effect_palette_cycle_enabled.w                                 ; $02F696 |\ Skip this function if automatic effect palette cycling is not
    BEQ ++                                                                      ; $02F699 |/ enabled.
    LDA r_battle_effect_palette_cycle_frame_counter.w                           ; $02F69B |\
    AND r_battle_effect_palette_cycle_frame_mask.w                              ; $02F69E | | Skip to near the end if the current frame does not match the mask.
    BNE +                                                                       ; $02F6A1 |/
    INC r_battle_effect_palette_cycle_palette_counter.w                         ; $02F6A3 |\
    LDA r_battle_effect_palette_cycle_palette_counter.w                         ; $02F6A6 | | Increment the palette counter, mask out only the low bit (as there
    AND #%00000001.b                                                            ; $02F6A9 | | are only two palettes), and load the palette number from RAM.
    TAX                                                                         ; $02F6AB | |
    LDA r_battle_effect_palette_cycle_palettes.w,X                              ; $02F6AC |/
    LDX #$000F.w                                                                ; $02F6AF |\ Load that palette into the last palette.
    JSR _battle_load_miscellaneous_palette                                      ; $02F6B2 |/
+   INC r_battle_effect_palette_cycle_frame_counter.w                           ; $02F6B5 | Increment the frame counter.
++  RTS                                                                         ; $02F6B8

; _battle_effect_spell_animate ($02:F6B9)
;
; Given an effect ID in the accumulator, an 8-bit value in $00 which should be
; $00 if the effect is targeting the party or $80 if targeting monsters, an
; 8-bit target mask in $01 and an 8-bit wall target mask in $02, animates the
; effect of a spell.
_battle_effect_spell_animate:
    ASL A                                                                       ; $02F6B9 |\ Set the X register to the provided effect parameter times two.
    TAX                                                                         ; $02F6BA |/
    STZ r_battle_effect_reset_flash.w                                           ; $02F6BB | Initialize the flash reset flag to zero.
    LDA #1.b                                                                    ; $02F6BE |\ Set the mirror flag, which will mirror the effect on the X axis.
    STA r_battle_effect_spell_mirror.w                                          ; $02F6C0 |/
    LDA <r_battle_effect_spell_animate_arg_wall_targets                         ; $02F6C3 |\ Copy the wall targets value to another location.
    STA r_battle_effect_spell_wall_targets.w                                    ; $02F6C5 |/
    STA <r_battle_generic_tmp_count                                             ; $02F6C8 | Also save it to another variable (TODO: pointlessly?)
    LDA bank0F.battle_effect_spell_script_pointer_data.l + 0,X                  ; $02F6CA |\
    STA <r_battle_effect_spell_data_ptr_addr_lo                                 ; $02F6CE | | Set the pointer to the data for this spell effect.
    LDA bank0F.battle_effect_spell_script_pointer_data.l + 1,X                  ; $02F6D0 | |
    STA <r_battle_effect_spell_data_ptr_addr_hi                                 ; $02F6D4 | |
    LDA #:bank0F.battle_effect_spell_script_pointer_data.b                      ; $02F6D6 | |
    STA <r_battle_effect_spell_data_ptr_bank                                    ; $02F6D8 |/
    STA r_battle_effect_spell_data_bank.w                                       ; $02F6DA | Save the bank to RAM for easy restoration later.
    LDA <r_battle_effect_spell_animate_arg_targets                              ; $02F6DD |\
    ORA r_battle_effect_spell_wall_targets.w                                    ; $02F6DF | | If there are neither any actual targets nor wall targets, reset
    BNE +                                                                       ; $02F6E2 | | some effect variables and return.
    JMP _battle_effect_reset                                                    ; $02F6E4 |/
+   LDA <r_battle_effect_spell_animate_arg_monster                              ; $02F6E7 |\
    STA r_battle_play_audio_pan_monster.w                                       ; $02F6E9 | | Set the audio pan appropriately and play the configured effect.
    JSR _battle_play_sound_effect_spell                                         ; $02F6EC |/
    LDX <r_battle_generic_tmp_index                                             ; $02F6EF |\ Transfer the monster/character target flag to the palette cycling
    STX r_battle_effect_target_palette_cycling_monster.w                        ; $02F6F1 |/ variable and the targets to $F27A as generic spell targets.
    LDA <r_battle_effect_spell_animate_arg_targets                              ; $02F6F4 |\ Transfer the target mask to the argument to the routine that sets
    STA r_battle_monster_set_palette_cycle_arg_targets.w                        ; $02F6F6 |/ target monsters to the cycling palette.
    STA r_battle_effect_target_palette_cycling_target.w                         ; $02F6F9 | Additionally transfer it into the target palette cycling targets.
    LDA r_battle_effect_spell_special_mode.w                                    ; $02F6FC |\
    CMP #BATTLE_SPELL_SPECIAL_MODE_PARTY_FIELD.b                                ; $02F6FF | | If the special mode is set to either party field or monster field,
    BEQ +                                                                       ; $02F701 | | explicitly set the spell targets to all targets.
    CMP #BATTLE_SPELL_SPECIAL_MODE_MONSTER_FIELD.b                              ; $02F703 | |
    BNE ++                                                                      ; $02F705 | |
+   LDA #%11111111.b                                                            ; $02F707 | |
    STA r_battle_effect_spell_targets.w                                         ; $02F709 |/
++  LDX <r_battle_effect_spell_data_ptr_addr                                    ; $02F70C |\
    INX                                                                         ; $02F70E | | Increment the data pointer by two, which points to the actual
    INX                                                                         ; $02F70F | | script data (skipping the header) and save it to memory.
    STX r_battle_effect_spell_data_script_ptr_addr.w                            ; $02F710 |/
    LDA [<r_battle_effect_spell_data_ptr]                                       ; $02F713 |\
    AND #%11110000.b                                                            ; $02F715 | | Using the top four bits of the first byte as an index into the
    LSR A                                                                       ; $02F717 | | size array, read the size of the grid used by this effect.
    LSR A                                                                       ; $02F718 | |
    LSR A                                                                       ; $02F719 | |
    TAX                                                                         ; $02F71A | |
    LDA bank0D.battle_effect_spell_size_data.l + 0,X                            ; $02F71B | |
    STA r_battle_effect_spell_size.width.w                                      ; $02F71F | |
    LDA bank0D.battle_effect_spell_size_data.l + 1,X                            ; $02F722 | |
    STA r_battle_effect_spell_size.height.w                                     ; $02F726 |/
    LDA [<r_battle_effect_spell_data_ptr]                                       ; $02F729 |\
    AND #%00001111.b                                                            ; $02F72B | | Set the total number of times the animation is repeated by using
    INC A                                                                       ; $02F72D | | the low four bits.
    STA r_battle_effect_spell_cycles_remaining.w                                ; $02F72E |/
    JSR _battle_effect_spell_calculate_coordinates                              ; $02F731 | Calculate coordinates for the effect.
    LDY #0.w                                                                    ; $02F734 | Initialize the Y register to zero.
-   LDA (<r_battle_effect_spell_coordinates_ptr),Y                              ; $02F737 |\
    CLC                                                                         ; $02F739 | | Set the X coordinate for this slot to the base X coordinate plus
    ADC <r_battle_effect_spell_tmp_coordinate_offsets.x.b                       ; $02F73A | | the effect-specific offset.
    STA r_battle_effect_spell_slot_coordinates.w,Y                              ; $02F73C |/
    INY                                                                         ; $02F73F | Increment the Y register to move to the Y coordinate.
    LDA (<r_battle_effect_spell_coordinates_ptr),Y                              ; $02F740 |\
    CLC                                                                         ; $02F742 | | Set the Y coordinate for this slot to the base X coordinate plus
    ADC <r_battle_effect_spell_tmp_coordinate_offsets.y.b                       ; $02F743 | | the effect-specific offset.
    STA r_battle_effect_spell_slot_coordinates.w,Y                              ; $02F745 |/
    INY                                                                         ; $02F748 |\
    CPY #_sizeof_r_battle_effect_spell_slot_coordinates.w                       ; $02F749 | | Increment the Y register and loop until both coordinates are set.
    BNE -                                                                       ; $02F74C |/
    LDX #0.w                                                                    ; $02F74E |\
-   STZ r_battle_effect_spell_slot_coordinate_offsets.w,X                       ; $02F751 | | Initialize the coordinate offsets to zero for each slot.
    INX                                                                         ; $02F754 | |
    CPX #16.w                                                                   ; $02F755 | |
    BNE -                                                                       ; $02F758 |/
    JSR _battle_effect_spell_check_special_mode_field                           ; $02F75A | Set the slot coordinates and offsets if using a field special mode.
    LDY #1.w                                                                    ; $02F75D |\
    LDA [<r_battle_effect_spell_data_ptr],Y                                     ; $02F760 | | Set the frame counter mask for the effect, by using the middle two
    AND #%00011000.b                                                            ; $02F762 | | bits from the second byte to index the frame counter mask array.
    LSR A                                                                       ; $02F764 | | This effectively determines the animation speed, with 0 being the
    LSR A                                                                       ; $02F765 | | slowest (8 frames per animation frame) and 3 being the fastest (1
    LSR A                                                                       ; $02F766 | | frame per animation frame).
    TAX                                                                         ; $02F767 | |
    LDA bank0D.battle_spell_effect_frame_counter_mask_data.l,X                  ; $02F768 | |
    STA r_battle_effect_spell_frame_counter_mask.w                              ; $02F76C |/
    LDY #1.w                                                                    ; $02F76F |\
    LDA [<r_battle_effect_spell_data_ptr],Y                                     ; $02F772 | | If the high bit of the second byte is set, disable mirroring.
    BPL +                                                                       ; $02F774 | |
    STZ r_battle_effect_spell_mirror.w                                          ; $02F776 |/
+   LDA [<r_battle_effect_spell_data_ptr],Y                                     ; $02F779 |\
    AND #%00000111.b                                                            ; $02F77B | | Set the frame block using the low three bits of the second byte.
    STA r_battle_effect_spell_frame_block.w                                     ; $02F77D |/
    LDA #16.b                                                                   ; $02F780 |\
    STA r_battle_effect_spell_base_oam_entry.w                                  ; $02F782 | | Set the current and base OAM entry to use to 16.
    STA r_battle_effect_spell_current_oam_entry.w                               ; $02F785 |/
    JSR _battle_reset_effect_oam_large                                          ; $02F788 | Reset the effect OAM to large sprites.
    STZ r_battle_effect_spell_frame_counter.w                                   ; $02F78B | Initialize the frame counter to zero.
    STZ r_battle_effect_spell_data_script_offset.w                              ; $02F78E | Initialize the script offset to zero.
    STZ r_battle_effect_spell_coordinate_offsets.x.w                            ; $02F791 |\ Initialize the overall coordinate offsets to zero.=
    STZ r_battle_effect_spell_coordinate_offsets.y.w                            ; $02F794 |/
    JSR _battle_monster_set_palette_cycle                                       ; $02F797 | Set targeted monsters to the cycling palette.
    LDX #0.w                                                                    ; $02F79A |\ Set the target palette cycling mode to none and disable monster
    STX r_battle_effect_target_palette_cycling_mode.w                           ; $02F79D |/ palette cycling.
@frame_start:
    JSR _battle_wait_next_frame_preserve_x_y                                    ; $02F7A0 | Wait for the next frame.
    JSR _battle_effect_check_palette_cycle                                      ; $02F7A3 | Check any effect palette cycling that needs to occur.
    LDA r_battle_effect_spell_frame_counter.w                                   ; $02F7A6 |\
    AND r_battle_effect_spell_frame_counter_mask.w                              ; $02F7A9 | | If the current frame and frame counter mask match and the sprite
    BNE +                                                                       ; $02F7AC | | pattern is set to Fire3, call the Fire3 sprite update routine.
    LDA r_battle_effect_spell_sprite_pattern.w                                  ; $02F7AE | |
    CMP #BATTLE_SPELL_SPRITE_PATTERN_FIRE3.b                                    ; $02F7B1 | |
    BNE +                                                                       ; $02F7B3 | |
    JSL bank01.battle_effect_fire3_update_sprites                               ; $02F7B5 |/
+   LDA r_battle_effect_spell_sprite_pattern.w                                  ; $02F7B9 |\
    CMP #BATTLE_SPELL_SPRITE_PATTERN_ROTATING_PAIR.b                            ; $02F7BC | | If the sprite pattern is to set to a rotating pair, call the
    BNE +                                                                       ; $02F7BE | | rotating pair update routine.
    JSL bank01.battle_effect_spell_rotating_pair_update_offsets                 ; $02F7C0 |/
+   LDA r_battle_effect_target_palette_cycling_mode.w                           ; $02F7C4 |\
    BEQ +++                                                                     ; $02F7C7 | | If the target palette cycling mode is either none or cycle, skip
    CMP #TARGET_PALETTE_CYCLING_MODE_CYCLE.b                                    ; $02F7C9 | | this next section (which handles strobing).
    BEQ +++                                                                     ; $02F7CB |/
    CMP #TARGET_PALETTE_CYCLING_MODE_FAST_STROBE.b                              ; $02F7CD |\
    BEQ +                                                                       ; $02F7CF | | Set the frame counter mask, depending on the mode. For the slow
    LDA #%00000100.b                                                            ; $02F7D1 | | strobe, set it to 4, to update every four frames, otherwise set it
    JMP ++                                                                      ; $02F7D3 | | to 2.
+   LDA #%00000010.b                                                            ; $02F7D6 | |
++  STA <r_battle_generic_tmp_index_lo                                          ; $02F7D8 |/
    LDA r_battle_frame_counter.w                                                ; $02F7DA |\
    AND <r_battle_generic_tmp_index_lo                                          ; $02F7DD | | Enable or disable the target palette cycling depending on the
    BEQ +                                                                       ; $02F7DF | | current frame.
    JSR _battle_effect_enable_target_palette_cycling                            ; $02F7E1 | |
    JMP +++                                                                     ; $02F7E4 | |
+   JSR _battle_effect_disable_target_palette_cycling                           ; $02F7E7 |/
+++ LDA r_battle_effect_spell_special_mode.w                                    ; $02F7EA |\ If no special mode is set, branch ahead to other code.
    BEQ +++                                                                     ; $02F7ED |/
    CMP #BATTLE_SPELL_SPECIAL_MODE_QUAKE.b                                      ; $02F7EF |\ If the special mode is anything other than Quake, branch ahead to
    BNE ++                                                                      ; $02F7F1 |/ yet more code.
    LDA r_battle_effect_spell_frame_counter.w                                   ; $02F7F3 |\
    AND #%00000111.b                                                            ; $02F7F6 | | Set the X register to a value based on the frame counter.
    TAX                                                                         ; $02F7F8 |/
    LDA r_battle_effect_target_palette_cycling_monster.w                        ; $02F7F9 |\
    BNE +                                                                       ; $02F7FC | | If target palette cycling is affecting the party, load the shaking
    LDA bank0D.battle_shake_scroll_data.l,X                                     ; $02F7FE | | scroll data, use it to set the coordinate offsets for the effect,
    STA r_battle_effect_spell_slot_coordinate_offsets.1.x.w                     ; $02F802 | | set the BG2 horizontal scroll values, and then set the X offsets
    JSR _battle_set_bg2_horizontal_scroll                                       ; $02F805 | | for the affected party members.
    JSR _battle_effect_set_x_offset_party                                       ; $02F808 | |
    JMP +++                                                                     ; $02F80B |/
+   JSR _battle_update_bg1_bg2_shake_scroll                                     ; $02F80E |\ Otherwise, update the scroll values for BG1 and BG2.
    JMP +++                                                                     ; $02F811 |/
++  CMP #BATTLE_SPELL_SPECIAL_MODE_JINN.b                                       ; $02F814 |\
    BNE +++                                                                     ; $02F816 | | If the Jinn special mode is set, update the strike animation.
    JSL bank01.battle_alternate_party_sprite_update_forward_strike              ; $02F818 |/
+++ INC r_battle_effect_spell_frame_counter.w                                   ; $02F81C | Increment the frame counter.
@loop_start:
    LDY r_battle_effect_spell_data_script_ptr_addr.w                            ; $02F81F |\
    STY <r_battle_effect_spell_data_ptr_addr                                    ; $02F822 | | Load the pointer to the start of the effect's script data.
    LDA r_battle_effect_spell_data_bank.w                                       ; $02F824 | |
    STA <r_battle_effect_spell_data_ptr_bank                                    ; $02F827 |/
    LDA r_battle_effect_spell_data_script_offset.w                              ; $02F829 |\ Set the Y register to the offset to the current location in the
    TAY                                                                         ; $02F82C |/ script data.
    LDA [<r_battle_effect_spell_data_ptr],Y                                     ; $02F82D |\
    CMP #$FF.b                                                                  ; $02F82F | | Read the next byte of the script, and if it's $FF, branch to the
    BNE +                                                                       ; $02F831 | | completion of the effect.
    JMP @done                                                                   ; $02F833 |/
+   LDA [<r_battle_effect_spell_data_ptr],Y                                     ; $02F836 |\
    BMI +                                                                       ; $02F838 | | If the high bit is not set, jump to update to that frame.
    JMP @update_frame                                                           ; $02F83A |/
+   STA <r_battle_generic_tmp_count                                             ; $02F83D | Save the byte to a temporary variable.
    CMP #$88.b                                                                  ; $02F83F |\
    BNE +                                                                       ; $02F841 | | If the byte is equal to $88, treat the following byte as an
    INC r_battle_effect_spell_data_script_offset.w                              ; $02F843 | | argument to the set_palette_or_flash function and then jump to
    INY                                                                         ; $02F846 | | move to the next byte. Set the reset flash flag so the flash
    LDA [<r_battle_effect_spell_data_ptr],Y                                     ; $02F847 | | mode will be reset next time the effects are reset.
    INC r_battle_effect_reset_flash.w                                           ; $02F849 | |
    JSR _battle_effect_set_palette_or_flash                                     ; $02F84C | |
    JMP ++                                                                      ; $02F84F |/
+   AND #%00001000.b                                                            ; $02F852 |\ If bit 3 is not set, branch to the translation code.
    BEQ @translate                                                              ; $02F854 |/
    AND #%00000100.b                                                            ; $02F856 |\
    BEQ +                                                                       ; $02F858 | | If bit 2 is set, disable target palette cycling.
    JSR _battle_effect_disable_target_palette_cycling                           ; $02F85A | |
    JMP ++                                                                      ; $02F85D |/
+   LDA <r_battle_generic_tmp_count                                             ; $02F860 |\
    PHA                                                                         ; $02F862 | | Otherwise, load the palette cycling palette set by bits 4-6 in the
    LSR A                                                                       ; $02F863 | | byte.
    LSR A                                                                       ; $02F864 | |
    LSR A                                                                       ; $02F865 | |
    LSR A                                                                       ; $02F866 | |
    AND #%00000111.b                                                            ; $02F867 | |
    JSR _battle_palette_cycle_load_palette                                      ; $02F869 |/
    PLA                                                                         ; $02F86C |\
    AND #%00000011.b                                                            ; $02F86D | | Set the cycling mode to the value in the low two bits.
    STA r_battle_effect_target_palette_cycling_mode.w                           ; $02F86F |/
    JSR _battle_effect_enable_target_palette_cycling                            ; $02F872 | Enable target palette cycling.
++  INC r_battle_effect_spell_data_script_offset.w                              ; $02F875 | Increment the script offset.
    JMP @loop_start                                                             ; $02F878 | Loop back to read the next byte.
@translate:
    LDA <r_battle_generic_tmp_count                                             ; $02F87B |\
    LSR A                                                                       ; $02F87D | | Set the X register to double the value in bits 4-6, which serves
    LSR A                                                                       ; $02F87E | | as the translation mode.
    LSR A                                                                       ; $02F87F | |
    LSR A                                                                       ; $02F880 | |
    AND #%00000111.b                                                            ; $02F881 | |
    ASL A                                                                       ; $02F883 | |
    TAX                                                                         ; $02F884 |/
    LDA <r_battle_generic_tmp_count                                             ; $02F885 |\
    AND #%00000111.b                                                            ; $02F887 | | Set the magnitude to the value in the lowest three bits plus one.
    INC A                                                                       ; $02F889 | |
    STA <r_battle_effect_spell_translate_arg_magnitude                          ; $02F88A |/
    JSR _battle_effect_spell_translate                                          ; $02F88C | Calculate the translation values based on the mode and magnitude.
    LDA r_battle_effect_spell_coordinate_offsets.x.w                            ; $02F88F |\
    CLC                                                                         ; $02F892 | | Add the X translation value to the horizontal offset.
    ADC <r_battle_effect_spell_translate_result.x                               ; $02F893 | |
    STA r_battle_effect_spell_coordinate_offsets.x.w                            ; $02F895 |/
    LDA r_battle_effect_spell_coordinate_offsets.y.w                            ; $02F898 |\
    CLC                                                                         ; $02F89B | | Add the Y translation value to the vertical offset.
    ADC <r_battle_effect_spell_translate_result.y                               ; $02F89C | |
    STA r_battle_effect_spell_coordinate_offsets.y.w                            ; $02F89E |/
    INC r_battle_effect_spell_data_script_offset.w                              ; $02F8A1 | Increment the script offset to read the next byte.
    JMP @loop_start                                                             ; $02F8A4 | Jump back to the start of the loop.
@update_frame:
    AND #%01111111.b                                                            ; $02F8A7 |\ Set the frame index to the lower seven bits.
    STA r_battle_effect_spell_frame_index.w                                     ; $02F8A9 |/
    LDA r_battle_effect_spell_targets.w                                         ; $02F8AC |\ Transfer the targets into the temporary targets variable.
    STA r_battle_effect_spell_tmp_targets.w                                     ; $02F8AF |/
    LDA #1.b                                                                    ; $02F8B2 |\ Flag that a spell effect is pending.
    STA r_battle_effect_spell_pending.w                                         ; $02F8B4 |/
    LDA r_battle_effect_spell_frame_counter.w                                   ; $02F8B7 |\
    AND r_battle_effect_spell_frame_counter_mask.w                              ; $02F8BA | | If the current frame matches the frame counter mask, increment
    BNE +                                                                       ; $02F8BD | | the script offset to move to the next animation frame.
    INC r_battle_effect_spell_data_script_offset.w                              ; $02F8BF |/
+   JMP @frame_start                                                            ; $02F8C2 | Jump back to the start of the frame processing.
@done:
    STZ r_battle_effect_spell_data_script_offset.w                              ; $02F8C5 | Reset the script offset back to zero.
    LDA r_battle_effect_spell_sprite_pattern.w                                  ; $02F8C8 |\
    BEQ +                                                                       ; $02F8CB | | If a certain sprite patterns are set, calculate the offsets.
    JSR _battle_effect_spell_set_offsets                                        ; $02F8CD |/
+   DEC r_battle_effect_spell_cycles_remaining.w                                ; $02F8D0 |\
    BEQ +                                                                       ; $02F8D3 | | Decrement the number of remaining cycles and loop until it's zero.
    JMP @frame_start                                                            ; $02F8D5 |/
+   LDA r_battle_effect_target_palette_cycling_disable.w                        ; $02F8D8 |\
    BNE +                                                                       ; $02F8DB | | Disable target palette cycling if the disable flag has been set.
    JSR _battle_effect_disable_target_palette_cycling                           ; $02F8DD |/
+   JSR _battle_effect_reset                                                    ; $02F8E0 | Reset the effect variables.
    LDA r_battle_effect_target_palette_cycling_target.w                         ; $02F8E3 |\ Save the palette cycling targets as the reeling targets.
    STA r_battle_effect_spell_reeling_targets.w                                 ; $02F8E6 |/
    JSR _battle_effect_spell_animate_reeling                                    ; $02F8E9 | Animate any appropriate reeling effect.
    TDC                                                                         ; $02F8EC |\ Set the horizontal scroll values to show the left half of BG1 and
    JMP _battle_set_bg1_bg2_horizontal_scroll                                   ; $02F8ED |/ BG2.

; _battle_effect_reset ($02:F8F0)
;
; Resets various parameters related to spell effects in battle. Primarily
; disables palette cycling, flashing, and sets the X offsets of all characters
; to zero.
_battle_effect_reset:
    TDC                                                                         ; $02F8F0 |\ Disable target palette cycling.
    STA r_battle_effect_target_palette_cycling_active.w                         ; $02F8F1 |/
    STA r_battle_character_visual_properties.1.x_offset.w                       ; $02F8F4 |\
    STA r_battle_character_visual_properties.2.x_offset.w                       ; $02F8F7 | | Set the X offset for all characters to zero.
    STA r_battle_character_visual_properties.3.x_offset.w                       ; $02F8FA | |
    STA r_battle_character_visual_properties.4.x_offset.w                       ; $02F8FD | |
    STA r_battle_character_visual_properties.5.x_offset.w                       ; $02F900 |/
    STA r_battle_effect_target_palette_cycling_mode.w                           ; $02F903 |\ Reset additional variables related to target palette cycling.
    STA r_battle_effect_target_palette_cycling_party_active.w                   ; $02F906 |/
    STA r_battle_effect_palette_cycle_enabled.w                                 ; $02F909 | Disable automatic effect palette cycling.
    LDA r_battle_effect_reset_flash.w                                           ; $02F90C |\
    BEQ +                                                                       ; $02F90F | | Reset the flash mode if the reset flash flag was set.
    STZ r_battle_flash_mode.w                                                   ; $02F911 |/
+   LDA r_battle_effect_target_palette_cycling_monster.w                        ; $02F914 |\ Save the palette cycle monster flag to the flag that enables
    STA r_battle_effect_spell_reeling_monster.w                                 ; $02F917 |/ reeling only for party targets.
    RTS                                                                         ; $02F91A

; _battle_effect_spell_set_random_oam_offsets ($02:F91B)
;
; Sets random offsets for the first nine OAM entries. These offsets are stored
; in a separate array at $F3B0, to be applied later by other code.
_battle_effect_spell_set_random_oam_offsets:
    LDA r_battle_frame_counter.w                                                ; $02F91B |\ Set the X register to the value of the battle frame counter.
    TAX                                                                         ; $02F91E |/
    LDY #0.w                                                                    ; $02F91F | Initialize the Y register to zero.
-   LDA r_prng_data.w,X                                                         ; $02F922 |\ Load a random value and take it mod 16.
    AND #%00001111.b                                                            ; $02F925 |/
    SEC                                                                         ; $02F927 |\
    SBC #6.b                                                                    ; $02F928 | | Subtract 6 and set it as the coordinate offset for this entry.
    STA r_battle_effect_spell_oam_coordinate_offsets.1.x.w,Y                    ; $02F92A |/
    INX                                                                         ; $02F92D |\
    TXA                                                                         ; $02F92E | | Increment the registers and loop until all slots have been set.
    TAX                                                                         ; $02F92F | |
    INY                                                                         ; $02F930 | |
    CPY #_sizeof_r_battle_effect_spell_oam_coordinate_offsets.w                 ; $02F931 | |
    BNE -                                                                       ; $02F934 |/
    RTS                                                                         ; $02F936

; _battle_effect_spell_set_offsets ($02:F937)
;
; Depending on the values at $F2A0 and $F2D0, sets the offsets for the sprites
; for this effect. The exact values that are updated depends on the
; aforementioned values.
_battle_effect_spell_set_offsets:
    CMP #BATTLE_SPELL_SPRITE_PATTERN_FIRE3.b                                    ; $02F937 |\
    BEQ +                                                                       ; $02F939 | | Return if the passed sprite pattern is either Fire3 or the
    CMP #BATTLE_SPELL_SPRITE_PATTERN_ROTATING_PAIR.b                            ; $02F93B | | rotating pair pattern.
    BNE ++                                                                      ; $02F93D | |
+   RTS                                                                         ; $02F93F |/
++  CMP #BATTLE_SPELL_SPRITE_PATTERN_RANDOM.b                                   ; $02F940 |\
    BNE +                                                                       ; $02F942 | | If the pattern is random, jump to set random OAM offsets.
    JMP _battle_effect_spell_set_random_oam_offsets                             ; $02F944 |/
+   LDA r_battle_effect_spell_special_mode.w                                    ; $02F947 |\
    CMP #BATTLE_SPELL_SPECIAL_MODE_PARTY_FIELD.b                                ; $02F94A | | If the special mode is not set to party field, branch ahead.
    BNE +                                                                       ; $02F94C |/
    LDX #0.w                                                                    ; $02F94E | Initialize the X register to zero.
    LDA #32.b                                                                   ; $02F951 |\ Initialize the current Y coordinate to 32.
    STA <r_battle_generic_tmp_index_lo                                          ; $02F953 |/
-   LDA #32.b                                                                   ; $02F955 |\
    JSR _battle_get_rng_lt_a                                                    ; $02F957 | | Set the X coordinate for this sprite to the X coordinate for the
    CLC                                                                         ; $02F95A | | front row of the party plus a random number from 0 to 31.
    ADC #BATTLE_COORDINATE_X_PARTY_FRONT_ROW.b                                  ; $02F95B | |
    STA r_battle_effect_spell_slot_coordinate_offsets.1.x.w,X                   ; $02F95D |/
    LDA <r_battle_generic_tmp_index_lo                                          ; $02F960 |\ Set the Y coordinate to the current Y coordinate.
    STA r_battle_effect_spell_slot_coordinate_offsets.1.y.w,X                   ; $02F962 |/
    CLC                                                                         ; $02F965 |\
    ADC #12.b                                                                   ; $02F966 | | Add 12 to the Y coordinate for the next iteration.
    STA <r_battle_generic_tmp_index_lo                                          ; $02F968 |/
    INX                                                                         ; $02F96A |\
    INX                                                                         ; $02F96B | | Increment the X register and loop until eight sets of coordinates
    CPX #_sizeof_r_battle_effect_spell_slot_coordinate_offsets.w                ; $02F96C | | have been written.
    BNE -                                                                       ; $02F96F |/
    RTS                                                                         ; $02F971 | Return once complete with the eight sprites.
+   CMP #BATTLE_SPELL_SPECIAL_MODE_MONSTER_FIELD.b                              ; $02F972 |\ Branch ahead if the special mode is not set to monster field.
    BNE +                                                                       ; $02F974 |/
    TDC                                                                         ; $02F976 |\ Initialize the X register to zero.
    TAX                                                                         ; $02F977 |/
    LDA #32.b                                                                   ; $02F978 |\ Initialize the Y coordinate to 32.
    STA <r_battle_generic_tmp_index_lo                                          ; $02F97A |/
-   LDA #144.b                                                                  ; $02F97C |\
    JSR _battle_get_rng_lt_a                                                    ; $02F97E | | Set the X coordinate to 24 plus a random number from 0 to 143.
    CLC                                                                         ; $02F981 | |
    ADC #24.b                                                                   ; $02F982 | |
    STA r_battle_effect_spell_slot_coordinate_offsets.1.x.w,X                   ; $02F984 |/
    LDA <r_battle_generic_tmp_index_lo                                          ; $02F987 |\ Set the Y coordinate to the current Y coordinate.
    STA r_battle_effect_spell_slot_coordinate_offsets.1.y.w,X                   ; $02F989 |/
    CLC                                                                         ; $02F98C |\
    ADC #12.b                                                                   ; $02F98D | | Add 12 to the Y coordinate for the next iteration.
    STA <r_battle_generic_tmp_index_lo                                          ; $02F98F |/
    INX                                                                         ; $02F991 |\
    INX                                                                         ; $02F992 | | Increment the X register twice and loop until eight sets of
    CPX #_sizeof_r_battle_effect_spell_slot_coordinate_offsets.w                ; $02F993 | | coordinates have been set.
    BNE -                                                                       ; $02F996 |/
    RTS                                                                         ; $02F998 | Return.
+   TDC                                                                         ; $02F999 |\ Initialize the X register to zero.
    TAX                                                                         ; $02F99A |/
    LDA r_battle_effect_target_palette_cycling_monster.w                        ; $02F99B |\ If target palette cycling is affecting monsters, branch ahead.
    BNE @monster                                                                ; $02F99E |/
-   LDA #8.b                                                                    ; $02F9A0 |\
    JSR _battle_get_rng_lt_a                                                    ; $02F9A2 | | Set the X coordinate to a random value from -4 to 3.
    SEC                                                                         ; $02F9A5 | |
    SBC #4.b                                                                    ; $02F9A6 | |
    STA r_battle_effect_spell_slot_coordinate_offsets.1.x.w,X                   ; $02F9A8 |/
    LDA #12.b                                                                   ; $02F9AB |\
    JSR _battle_get_rng_lt_a                                                    ; $02F9AD | | Set the Y coordinate to a random value from -6 to 5.
    SEC                                                                         ; $02F9B0 | |
    SBC #6.b                                                                    ; $02F9B1 | |
    STA r_battle_effect_spell_slot_coordinate_offsets.1.y.w,X                   ; $02F9B3 |/
    INX                                                                         ; $02F9B6 |\
    INX                                                                         ; $02F9B7 | | Loop until offsets for all five characters have been set.
    CPX #10.w                                                                   ; $02F9B8 | |
    BNE -                                                                       ; $02F9BB |/
    RTS                                                                         ; $02F9BD | Return.
@monster:
    LDA r_monster_size.w,X                                                      ; $02F9BE |\
    ASL A                                                                       ; $02F9C1 | | Set a temporary variable to half the monster's width or height
    ASL A                                                                       ; $02F9C2 | | in pixels (depending on the value of the X register).
    STA <r_battle_generic_tmp_index_lo                                          ; $02F9C3 |/
    ASL A                                                                       ; $02F9C5 |\
    JSR _battle_get_rng_lt_a                                                    ; $02F9C6 | | Set the current coordinate to a random value from -width to the
    SEC                                                                         ; $02F9C9 | | width-1 (or height, depending on the X register).
    SBC <r_battle_generic_tmp_index_lo                                          ; $02F9CA | |
    STA r_battle_effect_spell_slot_coordinate_offsets.w,X                       ; $02F9CC |/
    INX                                                                         ; $02F9CF |\
    CPX #_sizeof_r_battle_effect_spell_slot_coordinate_offsets.w                ; $02F9D0 | | Increment the X register and loop until all eight slots are set.
    BNE @monster                                                                ; $02F9D3 |/
    RTS                                                                         ; $02F9D5

; battle_animate_sixteen_hits ($02:F9D6)
;
; Animates sixteen hits on a target monster, including the sound effects. There
; is a two frame delay in between hits.
battle_animate_sixteen_hits:
    LDX #16.w                                                                   ; $02F9D6 | Initialize the X register to sixteen.
-   PHX                                                                         ; $02F9D9 | Preserve the value in the X register.
    JSR _battle_animate_single_hit                                              ; $02F9DA | Animate a single hit.
    JSR _battle_wait_next_frame_preserve_x_y                                    ; $02F9DD |\ Wait two frames.
    JSR _battle_wait_next_frame_preserve_x_y                                    ; $02F9E0 |/
    PLX                                                                         ; $02F9E3 | Restore the value in the X register.
    DEX                                                                         ; $02F9E4 |\ Decrement the X register and loop until it reaches zero.
    BNE -                                                                       ; $02F9E5 |/
    JSR _battle_reset_effect_oam_large                                          ; $02F9E7 | Reset the effect OAM.
    RTL                                                                         ; $02F9EA

; _battle_animate_single_hit ($02:F9EB)
;
; Using the effect sprites code, animates a single hit on a target monster,
; including the playing of the relevant sound effect.
_battle_animate_single_hit:
    LDA #AUDIO_EFFECT_PUNCH.b                                                   ; $02F9EB |\ Play the punch sound effect.
    JSR _battle_play_sound_effect                                               ; $02F9ED |/
    LDA #80.b                                                                   ; $02F9F0 |\ Set the base effect OAM index to 80.
    STA r_battle_effect_sprites_base_oam_index.w                                ; $02F9F2 |/
    LDA #BATTLE_EFFECT_PATTERN_SINGLE_TILE_60.b                                 ; $02F9F5 |\ Set the effect pattern to use a single centered tile.
    STA r_battle_effect_sprites_pattern_index.w                                 ; $02F9F7 |/
    STZ r_battle_effect_sprites_base_tile.w                                     ; $02F9FA | Set the effect base tile to zero (the pattern adds $60).
    LDA #EFFECT_OAM_RESET_MODE_NONE.b                                           ; $02F9FD |\ Set the effect reset mode to none.
    STA r_battle_effect_sprites_reset_mode.w                                    ; $02F9FF |/
    LDA #%00111110.b                                                            ; $02FA02 |\ Set the effect tile flags to use palette 7 and priority 3.
    STA r_battle_effect_sprites_tile_flags.w                                    ; $02FA04 |/
    LDA <r_battle_effect_target_slot                                            ; $02FA07 |\
    ASL A                                                                       ; $02FA09 | | Set the X register to the target slot times two.
    TAX                                                                         ; $02FA0A |/
    LDA r_monster_size.1.width.w,X                                              ; $02FA0B |\
    ASL A                                                                       ; $02FA0E | | Set the X coordinate of the effect sprite. Select a number from
    ASL A                                                                       ; $02FA0F | | zero to the width of the monster minus one. From that, subtract
    STA <r_battle_generic_tmp_index_lo                                          ; $02FA10 | | half the width of the monster, and then subtract half the width
    ASL A                                                                       ; $02FA12 | | of the sprite. Finally, add the center X coordinate of the
    JSR _battle_get_rng_lt_a                                                    ; $02FA13 | | monster. The result is a random X coordinate that ranges across
    SEC                                                                         ; $02FA16 | | the entire monster.
    SBC <r_battle_generic_tmp_index_lo                                          ; $02FA17 | |
    SBC #8.b                                                                    ; $02FA19 | |
    CLC                                                                         ; $02FA1B | |
    ADC r_battle_monster_coordinates_center.1.x.w,X                             ; $02FA1C | |
    STA r_battle_effect_sprites_coordinates.x.w                                 ; $02FA1F |/
    LDA r_monster_size.1.height.w,X                                             ; $02FA22 |\
    ASL A                                                                       ; $02FA25 | | Set the Y coordinate in a similar fashion.
    ASL A                                                                       ; $02FA26 | |
    STA <r_battle_generic_tmp_index_lo                                          ; $02FA27 | |
    ASL A                                                                       ; $02FA29 | |
    JSR _battle_get_rng_lt_a                                                    ; $02FA2A | |
    SEC                                                                         ; $02FA2D | |
    SBC <r_battle_generic_tmp_index_lo                                          ; $02FA2E | |
    SBC #8.b                                                                    ; $02FA30 | |
    CLC                                                                         ; $02FA32 | |
    ADC r_battle_monster_coordinates_center.1.y.w,X                             ; $02FA33 | |
    STA r_battle_effect_sprites_coordinates.y.w                                 ; $02FA36 |/
    LDA #1.b                                                                    ; $02FA39 |\ Flag an effect sprite as pending.
    STA r_battle_effect_sprites_pending.w                                       ; $02FA3B |/
    RTS                                                                         ; $02FA3E

; _battle_get_rng_lt_a ($02:FA3F)
;
; Returns a random number from zero to the value in the accumulator minus one.
_battle_get_rng_lt_a:
    STA <r_math_multiply_8bit_arg_1                                             ; $02FA3F |\
    JSR _battle_get_next_rng                                                    ; $02FA41 | | Multiply the passed value by the next RNG value and return the
    STA <r_math_multiply_8bit_arg_2                                             ; $02FA44 | | high byte.
    JSR _math_multiply_8bit                                                     ; $02FA46 | |
    LDA <r_math_multiply_8bit_result_hi                                         ; $02FA49 |/
    RTS                                                                         ; $02FA4B

; _battle_get_next_rng ($02:FA4C)
;
; Increments the battle RNG index and returns the next RNG value in the
; accumulator.
_battle_get_next_rng:
    INC <r_battle_rng_index                                                     ; $02FA4C | Increment the battle RNG index.
    LDA <r_battle_rng_index                                                     ; $02FA4E |\ Set the Y register to the updated index.
    TAY                                                                         ; $02FA50 |/
    LDA r_prng_data.w,Y                                                         ; $02FA51 | Read the RNG data for that index.
    RTS                                                                         ; $02FA54

; _battle_effect_set_x_offset_party ($02:FA55)
;
; Given an 8-bit offset in the accumulator, sets the X offset of all the
; affected characters.
_battle_effect_set_x_offset_party:
    LDX #0.w                                                                    ; $02FA55 | Initialize the X register to zero.
    STA <r_battle_generic_tmp_index_lo                                          ; $02FA58 | Save the desired offset to a temporary variable.
    LDA r_battle_effect_target_palette_cycling_target.w                         ; $02FA5A |\ Copy the targets into a temporary variable.
    STA <r_battle_generic_tmp_index_2_lo                                        ; $02FA5D |/
-   ASL <r_battle_generic_tmp_index_2_lo                                        ; $02FA5F |\ Skip this slot if not set in the target variable.
    BCC +                                                                       ; $02FA61 |/
    TXA                                                                         ; $02FA63 |\
    ASL A                                                                       ; $02FA64 | | Set the slot's X offset to the passed value.
    ASL A                                                                       ; $02FA65 | |
    ASL A                                                                       ; $02FA66 | |
    ASL A                                                                       ; $02FA67 | |
    TAY                                                                         ; $02FA68 | |
    LDA <r_battle_generic_tmp_index_lo                                          ; $02FA69 | |
    STA r_battle_character_visual_properties.1.x_offset.w,Y                     ; $02FA6B |/
+   INX                                                                         ; $02FA6E |\
    CPX #5.w                                                                    ; $02FA6F | | Loop until all five character slots have been checked.
    BNE -                                                                       ; $02FA72 |/
    RTS                                                                         ; $02FA74

; _battle_effect_spell_translate ($02:FA75)
;
; Given an 8-bit magnitude in $08, returns the associated translation factors in
; $06 and $07 for the horizontal and vertical, respectively. The translation
; mode is selected by passing twice the mode value in the X register.
_battle_effect_spell_translate:
    LDA r_battle_effect_spell_mirror.w                                          ; $02FA75 |\
    BEQ +                                                                       ; $02FA78 | | If the mirror flag is set, add 16 to the address, to read the
    TXA                                                                         ; $02FA7A | | horizontally flipped version.
    CLC                                                                         ; $02FA7B | |
    ADC #16.b                                                                   ; $02FA7C | |
    TAX                                                                         ; $02FA7E |/
+   LDA battle_effect_spell_translate_pointer_data.l + 0,X                      ; $02FA7F |\
    STA <r_battle_effect_spell_translate_tmp_ptr_lo                             ; $02FA83 | | Load the pointer from the provided index and jump to it.
    LDA battle_effect_spell_translate_pointer_data.l + 1,X                      ; $02FA85 | |
    STA <r_battle_effect_spell_translate_tmp_ptr_hi                             ; $02FA89 | |
    JMP (r_battle_effect_spell_translate_tmp_ptr.w)                             ; $02FA8B |/

; battle_effect_spell_translate_pointer_data ($02:FA8E)
;
; For each of the translation modes specified by a number between 0 and 7,
; contains the pointer to the function that handles that mode. The second set of
; pointers is horizontally flipped from the first set, which is used for
; mirroring effects.
battle_effect_spell_translate_pointer_data:
    .addr _battle_effect_spell_translate_negative_positive                      ; $02FA8E.FA8F | $00: -X,  X
    .addr _battle_effect_spell_translate_zero_positive                          ; $02FA90.FA91 | $01:  0,  X
    .addr _battle_effect_spell_translate_positive_positive                      ; $02FA92.FA93 | $02:  X,  X
    .addr _battle_effect_spell_translate_negative_zero                          ; $02FA94.FA95 | $03: -X,  0
    .addr _battle_effect_spell_translate_positive_zero                          ; $02FA96.FA97 | $04:  X,  0
    .addr _battle_effect_spell_translate_negative_negative                      ; $02FA98.FA99 | $05: -X, -X
    .addr _battle_effect_spell_translate_zero_negative                          ; $02FA9A.FA9B | $06:  0, -X
    .addr _battle_effect_spell_translate_positive_negative                      ; $02FA9C.FA9D | $07:  X, -X

    .addr _battle_effect_spell_translate_positive_positive                      ; $02FA9E.FA9F | $00:  X,  X
    .addr _battle_effect_spell_translate_zero_positive                          ; $02FAA0.FAA1 | $01:  0,  X
    .addr _battle_effect_spell_translate_negative_positive                      ; $02FAA2.FAA3 | $02: -X,  X
    .addr _battle_effect_spell_translate_positive_zero                          ; $02FAA4.FAA5 | $03:  X,  0
    .addr _battle_effect_spell_translate_negative_zero                          ; $02FAA6.FAA7 | $04: -X,  0
    .addr _battle_effect_spell_translate_positive_negative                      ; $02FAA8.FAA9 | $05:  X, -X
    .addr _battle_effect_spell_translate_zero_negative                          ; $02FAAA.FAAB | $06:  0, -X
    .addr _battle_effect_spell_translate_negative_negative                      ; $02FAAC.FAAD | $07: -X, -X

; _battle_effect_spell_translate_negative_positive ($02:FAAE)
;
; Given an 8-bit magnitude in $08, returns the negative magnitude in $06 and the
; magnitude in $07.
_battle_effect_spell_translate_negative_positive:
    TDC                                                                         ; $02FAAE |\
    SEC                                                                         ; $02FAAF | | Set the X translation value to zero minus the magnitude.
    SBC <r_battle_effect_spell_translate_arg_magnitude                          ; $02FAB0 | |
    STA <r_battle_effect_spell_translate_result.x                               ; $02FAB2 |/
    LDA <r_battle_effect_spell_translate_arg_magnitude                          ; $02FAB4 |\ Set the Y translation value to the magnitude.
    STA <r_battle_effect_spell_translate_result.y                               ; $02FAB6 |/
    RTS                                                                         ; $02FAB8

; _battle_effect_spell_translate_zero_positive ($02:FAB9)
;
; Given an 8-bit magnitude in $08, returns zero in $06 and the magnitude in $07.
_battle_effect_spell_translate_zero_positive:
    STZ <r_battle_effect_spell_translate_result.x                               ; $02FAB9 | Set the X translation value to zero.
    LDA <r_battle_effect_spell_translate_arg_magnitude                          ; $02FABB |\ Set the Y translation value to the magnitude.
    STA <r_battle_effect_spell_translate_result.y                               ; $02FABD |/
    RTS                                                                         ; $02FABF

; _battle_effect_spell_translate_positive_positive ($02:FAC0)
;
; Given an 8-bit magnitude in $08, returns the magnitude in both $06 and $07.
_battle_effect_spell_translate_positive_positive:
    LDA <r_battle_effect_spell_translate_arg_magnitude                          ; $02FAC0 |\ Set the X translation value to the magnitude.
    STA <r_battle_effect_spell_translate_result.x                               ; $02FAC2 |/
    STA <r_battle_effect_spell_translate_result.y                               ; $02FAC4 | Set the Y translation value to the magnitude.
    RTS                                                                         ; $02FAC6

; _battle_effect_spell_translate_negative_zero ($02:FAC7)
;
; Given an 8-bit magnitude in $08, returns the negative magnitude in $06 and
; zero in $07.
_battle_effect_spell_translate_negative_zero:
    TDC                                                                         ; $02FAC7 |\
    SEC                                                                         ; $02FAC8 | | Set the X translation value to zero minus the magnitude.
    SBC <r_battle_effect_spell_translate_arg_magnitude                          ; $02FAC9 | |
    STA <r_battle_effect_spell_translate_result.x                               ; $02FACB |/
    STZ <r_battle_effect_spell_translate_result.y                               ; $02FACD | Set the Y translation value to zero.
    RTS                                                                         ; $02FACF

; _battle_effect_spell_translate_positive_zero ($02:FAD0)
;
; Given an 8-bit magnitude in $08, returns the magnitude in $06 and zero in $07.
_battle_effect_spell_translate_positive_zero:
    LDA <r_battle_effect_spell_translate_arg_magnitude                          ; $02FAD0 |\ Set the X translation value to the magnitude.
    STA <r_battle_effect_spell_translate_result.x                               ; $02FAD2 |/
    STZ <r_battle_effect_spell_translate_result.y                               ; $02FAD4 | Set the Y translation value to zero.
    RTS                                                                         ; $02FAD6

; _battle_effect_spell_translate_negative_negative ($02:FAD7)
;
; Given an 8-bit magnitude in $08, returns the negative magnitude in both $06
; and $07.
_battle_effect_spell_translate_negative_negative:
    TDC                                                                         ; $02FAD7 |\
    SEC                                                                         ; $02FAD8 | | Set the X translation value to zero minus the magnitude.
    SBC <r_battle_effect_spell_translate_arg_magnitude                          ; $02FAD9 | |
    STA <r_battle_effect_spell_translate_result.x                               ; $02FADB |/
    STA <r_battle_effect_spell_translate_result.y                               ; $02FADD | Set the Y translation value to zero minus the magnitude.
    RTS                                                                         ; $02FADF

; _battle_effect_spell_translate_zero_negative ($02:FAE0)
;
; Given an 8-bit magnitude in $08, returns zero in $06 and the negative
; magnitude in $07.
_battle_effect_spell_translate_zero_negative:
    STZ <r_battle_effect_spell_translate_result.x                               ; $02FAE0 | Set the X translation value to zero.
    TDC                                                                         ; $02FAE2 |\
    SEC                                                                         ; $02FAE3 | | Set the Y translation value to zero minus the magnitude.
    SBC <r_battle_effect_spell_translate_arg_magnitude                          ; $02FAE4 | |
    STA <r_battle_effect_spell_translate_result.y                               ; $02FAE6 |/
    RTS                                                                         ; $02FAE8

; _battle_effect_spell_translate_positive_negative ($02:FAE9)
;
; Given an 8-bit magnitude in $08, returns the magnitude in $06 and the negative
; magnitude in $07.
_battle_effect_spell_translate_positive_negative:
    LDA <r_battle_effect_spell_translate_arg_magnitude                          ; $02FAE9 |\ Set the X translation value to the magnitude.
    STA <r_battle_effect_spell_translate_result.x                               ; $02FAEB |/
    TDC                                                                         ; $02FAED |\
    SEC                                                                         ; $02FAEE | | Set the Y translation value to the negative magnitude.
    SBC <r_battle_effect_spell_translate_arg_magnitude                          ; $02FAEF | |
    STA <r_battle_effect_spell_translate_result.y                               ; $02FAF1 |/
    RTS                                                                         ; $02FAF3

; _battle_effect_target_palette_cycling_cycle ($02:FAF4)
;
; Cycles palettes for either characters or the special monster palette.
_battle_effect_target_palette_cycling_cycle:
    LDA r_battle_effect_target_palette_cycling_active.w                         ; $02FAF4 |\ Skip this function if palette cycling is not enabled.
    BEQ @done                                                                   ; $02FAF7 |/
    LDA r_battle_effect_target_palette_cycling_monster.w                        ; $02FAF9 |\ Branch to the monster code if cycling monster palettes.
    BNE @monster                                                                ; $02FAFC |/
    LDA r_battle_effect_target_palette_cycling_party_active.w                   ; $02FAFE |\ Skip the party palette cycling if the party palette cycling is not
    BEQ @done                                                                   ; $02FB01 |/ enabled.
    LDX #0.w                                                                    ; $02FB03 | Initialize the X register to zero.
    LDA r_battle_effect_target_palette_cycling_target.w                         ; $02FB06 |\ Transfer the target value to a temporary variable.
    STA <r_battle_cycle_palettes_tmp_target                                     ; $02FB09 |/
@start:
    ASL <r_battle_cycle_palettes_tmp_target                                     ; $02FB0B |\ Skip the next slot if cycling its palette is not enabled.
    BCC @next                                                                   ; $02FB0D |/
    TXA                                                                         ; $02FB0F |\
    REP #FLAG_P_ACCUMULATOR                                                     ; $02FB10 | | Set the Y register to the slot number times 32, to index the
    ASL A                                                                       ; $02FB12 | | palette for that slot.
    ASL A                                                                       ; $02FB13 | |
    ASL A                                                                       ; $02FB14 | |
    ASL A                                                                       ; $02FB15 | |
    ASL A                                                                       ; $02FB16 | |
    TAY                                                                         ; $02FB17 |/
    LDA r_battle_cgram_data.10.color16.w,Y                                      ; $02FB18 |\ Save the last color in the palette.
    PHA                                                                         ; $02FB1B |/
    PHY                                                                         ; $02FB1C | Save the base value for the Y register.
    LDA #13.w                                                                   ; $02FB1D |\ Initialize the counter to 13.
    STA <r_battle_cycle_palettes_tmp_count                                      ; $02FB20 |/
    TYA                                                                         ; $02FB22 |\
    CLC                                                                         ; $02FB23 | | Add 28 to the base offset to start copying with the second to last
    ADC #28.w                                                                   ; $02FB24 | | color.
    TAY                                                                         ; $02FB27 |/
-   LDA r_battle_cgram_data.10.color1.w,Y                                       ; $02FB28 |\ Copy the value of the color to the next color.
    STA r_battle_cgram_data.10.color2.w,Y                                       ; $02FB2B |/
    DEY                                                                         ; $02FB2E |\
    DEY                                                                         ; $02FB2F | | Decrement the Y register and loop until all 13 colors have been
    DEC <r_battle_cycle_palettes_tmp_count                                      ; $02FB30 | | moved back.
    BNE -                                                                       ; $02FB32 |/
    PLY                                                                         ; $02FB34 |\
    PLA                                                                         ; $02FB35 | | Store what was the last color as the new third color (omitting the
    STA r_battle_cgram_data.10.color3.w,Y                                       ; $02FB36 | | first and second colors from the cycling).
    TDC                                                                         ; $02FB39 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $02FB3A |/
@next:
    INX                                                                         ; $02FB3C |\
    CPX #5.w                                                                    ; $02FB3D | | Increment the X register and loop through all five slots.
    BNE @start                                                                  ; $02FB40 |/
@done:
    RTS                                                                         ; $02FB42 | Return if done.
@monster:
    LDA r_battle_effect_target_palette_cycling_mode.w                           ; $02FB43 |\
    CMP #TARGET_PALETTE_CYCLING_MODE_CYCLE.b                                    ; $02FB46 | | Skip the rest of the function unless the mode is set to cycle.
    BNE +                                                                       ; $02FB48 |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $02FB4A |\
    LDA r_battle_cgram_data.8.color8.w                                          ; $02FB4C | | Preserve the color in the eighth position.
    PHA                                                                         ; $02FB4F |/
    LDX #6.w * 2                                                                ; $02FB50 | Set the X register to the index for the seventh color.
-   LDA r_battle_cgram_data.8.color1.w,X                                        ; $02FB53 |\ Move the color to the next spot.
    STA r_battle_cgram_data.8.color2.w,X                                        ; $02FB56 |/
    DEX                                                                         ; $02FB59 |\
    DEX                                                                         ; $02FB5A | | Loop until all colors (except 0) have been cycled.
    BNE -                                                                       ; $02FB5B |/
    PLA                                                                         ; $02FB5D |\
    STA r_battle_cgram_data.8.color2.w                                          ; $02FB5E | | Set the 2nd and 10th colors to the saved eighth color value.
    STA r_battle_cgram_data.8.color10.w                                         ; $02FB61 | |
    TDC                                                                         ; $02FB64 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $02FB65 |/
+   RTS                                                                         ; $02FB67

; _battle_effect_spell_draw ($02:FB68)
;
; Draws any currently active spell effects.
_battle_effect_spell_draw:
    LDA r_battle_effect_target_palette_cycling_automatic.w                      ; $02FB68 |\
    BEQ +                                                                       ; $02FB6B | | Cycle the target palettes if automatic cycling is enabled.
    JSR _battle_effect_target_palette_cycling_cycle                             ; $02FB6D |/
+   LDA r_battle_effect_spell_pending.w                                         ; $02FB70 |\
    BNE +                                                                       ; $02FB73 | | Return if the effect pending flag is not set.
    RTS                                                                         ; $02FB75 |/
+   STA r_battle_effect_target_palette_cycling_active.w                         ; $02FB76 |\ Enable the target palette cycling effect.
    JSR _battle_effect_target_palette_cycling_cycle                             ; $02FB79 |/
    LDA r_battle_effect_oam_reset_inhibit_counter.w                             ; $02FB7C |\
    DEC A                                                                       ; $02FB7F | | If the OAM reset inhibit counter is currently 1, reset the OAM
    BNE +                                                                       ; $02FB80 | | current entry to the base entry and reset the effect OAM to large
    LDA r_battle_effect_spell_base_oam_entry.w                                  ; $02FB82 | | sprites.
    STA r_battle_effect_spell_current_oam_entry.w                               ; $02FB85 |/
    JSR _battle_reset_effect_oam_large                                          ; $02FB88 | Reset the effect OAM to large sprites.
+   STZ r_battle_effect_spell_pending.w                                         ; $02FB8B | Unset the spell effect pending flag.
    LDA r_battle_effect_spell_wall_targets.w                                    ; $02FB8E |\ Copy the wall targets to another location for processing.
    STA r_battle_effect_spell_tmp_wall_targets.w                                ; $02FB91 |/
    STZ <r_battle_effect_spell_current_slot                                     ; $02FB94 | Initialize the current slot to zero.
    JSR _battle_effect_spell_load_frame                                         ; $02FB96 | Load the current spell effect frame.
    LDX r_battle_effect_spell_load_frame_result_oam_offset.w                    ; $02FB99 |\ Transfer the current OAM offset to a temporary variable to use as
    STX <r_battle_effect_spell_max_oam_offset                                   ; $02FB9C |/ a loop check.
    LDA r_battle_effect_spell_current_oam_entry.w                               ; $02FB9E |\
    REP #FLAG_P_ACCUMULATOR                                                     ; $02FBA1 | | Set the Y register to the offset to the current OAM entry to be
    ASL A                                                                       ; $02FBA3 | | written to.
    ASL A                                                                       ; $02FBA4 | |
    TAY                                                                         ; $02FBA5 | |
    TDC                                                                         ; $02FBA6 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $02FBA7 |/
@start:
    ASL r_battle_effect_spell_tmp_wall_targets.w                                ; $02FBA9 |\
    BCC +                                                                       ; $02FBAC | | If the current slot is set as a wall target, shift the value out
    ASL r_battle_effect_spell_tmp_targets.w                                     ; $02FBAE | | of the regular targets value, draw the wall, and then jupm to the
    JSR _battle_effect_spell_draw_wall                                          ; $02FBB1 | | next iteration.
    JMP @next                                                                   ; $02FBB4 |/
+   ASL r_battle_effect_spell_tmp_targets.w                                     ; $02FBB7 |\ Otherwise, shift out the target bit and branch to the effect
    BCS @draw                                                                   ; $02FBBA |/ drawing code if the target was set.
@next:
    INC <r_battle_effect_spell_current_slot                                     ; $02FBBC |\
    LDA <r_battle_effect_spell_current_slot                                     ; $02FBBE | | Increment the slot and loop until all eight have been processed.
    CMP #8.b                                                                    ; $02FBC0 | |
    BNE @start                                                                  ; $02FBC2 |/
    DEC r_battle_effect_oam_reset_inhibit_counter.w                             ; $02FBC4 |\
    BNE +                                                                       ; $02FBC7 | | Decrement the inhibit counter, and if the result is zero, reset
    LDA r_battle_effect_spell_base_oam_entry.w                                  ; $02FBC9 | | the current OAM entry to the base OAM entry, and then set the
    STA r_battle_effect_spell_current_oam_entry.w                               ; $02FBCC | | counter to the base value.
    LDA r_battle_effect_oam_reset_inhibit_counter_base.w                        ; $02FBCF | | NOTE: This may be always true. Perhaps it's an unused feature.
    STA r_battle_effect_oam_reset_inhibit_counter.w                             ; $02FBD2 |/
+   RTS                                                                         ; $02FBD5
@draw:
    LDX r_battle_effect_spell_load_frame_result_oam_offset.w                    ; $02FBD6 |\ If the effect didn't actually render anything, skip back to the
    BEQ @start                                                                  ; $02FBD9 |/ start of the loop.
    JSR _battle_effect_spell_copy_to_oam                                        ; $02FBDB | Copy the effect to the OAM for this slot.
    JMP @next                                                                   ; $02FBDE | Jump to the next iteration.

; _battle_effect_spell_copy_to_oam ($02:FBE1)
;
; Copies the effect sprites from the effect OAM to the actual OAM mirror to
; render the effect. Only operates on a single slot.
_battle_effect_spell_copy_to_oam:
    LDA <r_battle_effect_spell_current_slot                                     ; $02FBE1 |\
    ASL A                                                                       ; $02FBE3 | | Set the X register to the current slot times two.
    TAX                                                                         ; $02FBE4 |/
    LDA r_battle_effect_spell_slot_coordinates.1.x.w,X                          ; $02FBE5 |\
    CLC                                                                         ; $02FBE8 | | Calculate the X coordinate by adding the base coordinate to the
    ADC r_battle_effect_spell_slot_coordinate_offsets.1.x.w,X                   ; $02FBE9 | | offset.
    STA <r_battle_generic_tmp_coordinates.x                                     ; $02FBEC |/
    LDA r_battle_effect_spell_slot_coordinates.1.y.w,X                          ; $02FBEE |\
    CLC                                                                         ; $02FBF1 | | Calculate the Y coordinate by adding the base coordinate to the
    ADC r_battle_effect_spell_slot_coordinate_offsets.1.y.w,X                   ; $02FBF2 | | offset.
    STA <r_battle_generic_tmp_coordinates.y                                     ; $02FBF5 |/
    LDX #0.w                                                                    ; $02FBF7 | Initialize the X register to zero.
@loop_start:
    LDA r_formation_back_attack_copy.w                                          ; $02FBFA |\ If the battle is not a back attack, branch to the normal code.
    BEQ @normal                                                                 ; $02FBFD |/
    LDA r_battle_effect_oam.1.x.w,X                                             ; $02FBFF |\
    CLC                                                                         ; $02FC02 | | Add 15 to the OAM entry X coordinate to account for the mirror.
    ADC #15.b                                                                   ; $02FC03 |/
    BPL +                                                                       ; $02FC05 |\
    CLC                                                                         ; $02FC07 | | If the value is negative, add the slot X coordinate, and branch
    ADC <r_battle_generic_tmp_coordinates.x                                     ; $02FC08 | | depending on if the resulting value is less than zero or not.
    BCC +++                                                                     ; $02FC0A | |
    BRA ++                                                                      ; $02FC0C |/
+   CLC                                                                         ; $02FC0E |\
    ADC <r_battle_generic_tmp_coordinates.x                                     ; $02FC0F | | Otherwise, add the value and branch if it overflowed.
    BCS +++                                                                     ; $02FC11 |/
++  EOR #%11111111.b                                                            ; $02FC13 | Flip the bits to finish the negation of the value.
    STA r_oam.1.x.w,Y                                                           ; $02FC15 | Save the value to the real OAM mirror.
    LDA r_battle_effect_oam.1.y.w,X                                             ; $02FC18 |\
    CLC                                                                         ; $02FC1B | | Add the slot Y coordinate to the effect Y coordinate. If the
    ADC <r_battle_generic_tmp_coordinates.y                                     ; $02FC1C | | resulting value is less than 140 or 248 or greater, branch ahead.
    CMP #140.b                                                                  ; $02FC1E | | Otherwise, fall through to the code to handle off screen sprites.
    BCC +                                                                       ; $02FC20 | |
    CMP #248.b                                                                  ; $02FC22 | |
    BCS +                                                                       ; $02FC24 |/
+++ LDA #240.b                                                                  ; $02FC26 |\
    STA r_oam.1.x.w,Y                                                           ; $02FC28 | | Set the X and Y coordinates both explicitly to 240 and branch
    STA r_oam.1.y.w,Y                                                           ; $02FC2B | | ahead.
    BRA ++                                                                      ; $02FC2E |/
+   STA r_oam.1.y.w,Y                                                           ; $02FC30 | Store the calculated Y coordinate from above.
++  LDA r_battle_effect_oam.1.tile.w,X                                          ; $02FC33 |\ Copy the tile number directly.
    STA r_oam.1.tile.w,Y                                                        ; $02FC36 |/
    LDA r_battle_effect_oam.1.flags.w,X                                         ; $02FC39 |\
    EOR #%01000000.b                                                            ; $02FC3C | | Toggle the horizontal flip bit before setting the flags.
    STA r_oam.1.flags.w,Y                                                       ; $02FC3E |/
    JMP @next                                                                   ; $02FC41 | Jump to the next iteration.
@normal:
    LDA r_battle_effect_oam.1.x.w,X                                             ; $02FC44 |\
    BPL +                                                                       ; $02FC47 | | Set the X coordinate for the entry by adding the effect X
    CLC                                                                         ; $02FC49 | | coordinate to the slot X coordinate, and then checking for off-
    ADC <r_battle_generic_tmp_coordinates.x                                     ; $02FC4A | | screen values and branching accordingly.
    BCC +++                                                                     ; $02FC4C | |
    BRA ++                                                                      ; $02FC4E | |
+   CLC                                                                         ; $02FC50 | |
    ADC <r_battle_generic_tmp_coordinates.x                                     ; $02FC51 | |
    BCS +++                                                                     ; $02FC53 | |
++  STA r_oam.1.x.w,Y                                                           ; $02FC55 |/
    LDA r_battle_effect_oam.1.y.w,X                                             ; $02FC58 |\
    CLC                                                                         ; $02FC5B | | Repeat the procedure for the Y coordinate, verifying it is either
    ADC <r_battle_generic_tmp_coordinates.y                                     ; $02FC5C | | less than 140 or greater than or equal to 248.
    CMP #140.b                                                                  ; $02FC5E | |
    BCC +                                                                       ; $02FC60 | |
    CMP #248.b                                                                  ; $02FC62 | |
    BCS +                                                                       ; $02FC64 |/
+++ LDA #240.b                                                                  ; $02FC66 |\
    STA r_oam.1.x.w,Y                                                           ; $02FC68 | | If an off-screen value was found, set the coordinates explicitly
    STA r_oam.1.y.w,Y                                                           ; $02FC6B | | to 240 and branch ahead.
    BRA ++                                                                      ; $02FC6E |/
+   STA r_oam.1.y.w,Y                                                           ; $02FC70 | Otherwise, set the calculated Y coordinate value.
++  LDA r_battle_effect_oam.1.tile.w,X                                          ; $02FC73 |\ Copy the tile value to the OAM mirror.
    STA r_oam.1.tile.w,Y                                                        ; $02FC76 |/
    LDA r_battle_effect_oam.1.flags.w,X                                         ; $02FC79 |\ Copy the flags.
    STA r_oam.1.flags.w,Y                                                       ; $02FC7C |/
@next:
    INC r_battle_effect_spell_current_oam_entry.w                               ; $02FC7F | Increment the current OAM entry.
    INX                                                                         ; $02FC82 |\
    INX                                                                         ; $02FC83 | | Increment the X register by four to move to the next effect OAM
    INX                                                                         ; $02FC84 | | entry.
    INX                                                                         ; $02FC85 |/
    INY                                                                         ; $02FC86 |\
    INY                                                                         ; $02FC87 | | Increment the Y register by four to move to the next OAM entry.
    INY                                                                         ; $02FC88 | |
    INY                                                                         ; $02FC89 |/
    CPX <r_battle_effect_spell_max_oam_offset                                   ; $02FC8A |\
    BEQ +                                                                       ; $02FC8C | | Loop until all entries have been copied to the OAM.
    JMP @loop_start                                                             ; $02FC8E |/
+   RTS                                                                         ; $02FC91

; _battle_effect_spell_draw_wall ($02:FC92)
;
; Draws a wall on the currently being processed target. The target is assumed
; to be in the same group (i.e. monster or character) as the target palette
; cycling is applied to.
_battle_effect_spell_draw_wall:
    LDA <r_battle_effect_spell_current_slot                                     ; $02FC92 |\
    ASL A                                                                       ; $02FC94 | | Set the X register to the current slot times two.
    TAX                                                                         ; $02FC95 |/
    LDA r_battle_effect_target_palette_cycling_monster.w                        ; $02FC96 |\
    BNE +                                                                       ; $02FC99 | | If the target palette cycling effect is affecting characters, set
    LDA r_battle_character_cursor_coordinates_copy_2.1.x.w,X                    ; $02FC9B | | the X coordinate to the character's X coordinate and the Y
    STA <r_battle_generic_tmp_coordinates.x.b                                   ; $02FC9E | | coordinate to the character's Y coordinate plus six.
    LDA r_battle_character_cursor_coordinates_copy_2.1.y.w,X                    ; $02FCA0 | |
    CLC                                                                         ; $02FCA3 | |
    ADC #6.b                                                                    ; $02FCA4 | |
    STA <r_battle_generic_tmp_coordinates.y.b                                   ; $02FCA6 | |
    BRA ++                                                                      ; $02FCA8 |/
+   LDA r_battle_monster_coordinates_center.1.x.w,X                             ; $02FCAA |\
    STA <r_battle_generic_tmp_coordinates.x.b                                   ; $02FCAD | | Otherwise, set the coordinates to the monster's center
    LDA r_battle_monster_coordinates_center.1.y.w,X                             ; $02FCAF | | coordinates.
    STA <r_battle_generic_tmp_coordinates.y.b                                   ; $02FCB2 |/
++  LDX #0.w                                                                    ; $02FCB4 | Initialize the X register to zero.
@loop_start:
    LDA r_formation_back_attack_copy.w                                          ; $02FCB7 |\ If this is not a back attack, branch to separate code.
    BEQ +                                                                       ; $02FCBA |/
    LDA bank0D.battle_effect_wall_oam_data.l + oam_sprite.x,X                   ; $02FCBC |\
    CLC                                                                         ; $02FCC0 | | Set the X coordinate for the sprite to the read data from ROM,
    ADC <r_battle_generic_tmp_coordinates.x.b                                   ; $02FCC1 | | plus the calculated location for this slot, and then flip the bits
    EOR #%11111111.b                                                            ; $02FCC3 | | and subtract 15 (to handle the back attack).
    SEC                                                                         ; $02FCC5 | |
    SBC #15.b                                                                   ; $02FCC6 | |
    STA r_oam.1.x.w,Y                                                           ; $02FCC8 |/
    LDA bank0D.battle_effect_wall_oam_data.l + oam_sprite.y,X                   ; $02FCCB |\
    CLC                                                                         ; $02FCCF | | Set the Y coordinate to the read data from ROM plus the calculated
    ADC <r_battle_generic_tmp_coordinates.y.b                                   ; $02FCD0 | | location for this slot.
    STA r_oam.1.y.w,Y                                                           ; $02FCD2 |/
    LDA bank0D.battle_effect_wall_oam_data.l + oam_sprite.tile,X                ; $02FCD5 |\ Set the tile to the value loaded from ROM.
    STA r_oam.1.tile.w,Y                                                        ; $02FCD9 |/
    LDA bank0D.battle_effect_wall_oam_data.l + oam_sprite.flags.l,X             ; $02FCDC |\
    EOR #%01000000.b                                                            ; $02FCE0 | | Set the flags to the loaded value, toggling the horizontal flip.
    STA r_oam.1.flags.w,Y                                                       ; $02FCE2 |/
    JMP ++                                                                      ; $02FCE5 | Jump ahead to the next section.
+   LDA bank0D.battle_effect_wall_oam_data.l + oam_sprite.x,X                   ; $02FCE8 |\
    CLC                                                                         ; $02FCEC | | For normal attacks, set the X coordinate to the calculated value
    ADC <r_battle_generic_tmp_coordinates.x.b                                   ; $02FCED | | plus the value read from ROM.
    STA r_oam.1.x.w,Y                                                           ; $02FCEF |/
    LDA bank0D.battle_effect_wall_oam_data.l + oam_sprite.y,X                   ; $02FCF2 |\
    CLC                                                                         ; $02FCF6 | | Set the Y coordinate to the calculated value for the slot plus the
    ADC <r_battle_generic_tmp_coordinates.y.b                                   ; $02FCF7 | | value read from ROM.
    STA r_oam.1.y.w,Y                                                           ; $02FCF9 |/
    LDA bank0D.battle_effect_wall_oam_data.l + oam_sprite.tile,X                ; $02FCFC |\ Copy the tile number from ROM.
    STA r_oam.1.tile.w,Y                                                        ; $02FD00 |/
    LDA bank0D.battle_effect_wall_oam_data.l + oam_sprite.flags,X               ; $02FD03 |\ Copy the flags from ROM.
    STA r_oam.1.flags.w,Y                                                       ; $02FD07 |/
++  LDA r_battle_effect_target_palette_cycling_monster.w                        ; $02FD0A |\
    BEQ +                                                                       ; $02FD0D | | If monsters are being targeted, toggle the horizontal flip bit.
    LDA r_oam.1.flags.w,Y                                                       ; $02FD0F | |
    EOR #%01000000.b                                                            ; $02FD12 | |
    STA r_oam.1.flags.w,Y                                                       ; $02FD14 |/
+   INC r_battle_effect_spell_current_oam_entry.w                               ; $02FD17 | Increment the current OAM entry.
    INX                                                                         ; $02FD1A |\
    INX                                                                         ; $02FD1B | | Increment the X register by four to move to the next OAM entry in
    INX                                                                         ; $02FD1C | | ROM.
    INX                                                                         ; $02FD1D |/
    INY                                                                         ; $02FD1E |\
    INY                                                                         ; $02FD1F | | Increment the Y register by four to move to the next OAM entry.
    INY                                                                         ; $02FD20 | |
    INY                                                                         ; $02FD21 |/
    CPX #8.w                                                                    ; $02FD22 |\ Loop until both entries have been set.
    BNE @loop_start                                                             ; $02FD25 |/
    RTS                                                                         ; $02FD27

; _battle_effect_spell_load_frame ($02:FD28)
;
; Loads the current spell effect frame, specified by various variables in the
; $F248 to $F24E range.
_battle_effect_spell_load_frame:
    LDA r_battle_effect_spell_special_mode.w                                    ; $02FD28 |\
    CMP #BATTLE_SPELL_SPECIAL_MODE_BIG_BANG.b                                   ; $02FD2B | | If the special mode is set to either Big Bang, Quake or Meteo, set
    BEQ +                                                                       ; $02FD2D | | the tile priority to 2. Otherwise, set it to 3.
    CMP #BATTLE_SPELL_SPECIAL_MODE_QUAKE.b                                      ; $02FD2F | |
    BEQ +                                                                       ; $02FD31 | |
    CMP #BATTLE_SPELL_SPECIAL_MODE_METEO.b                                      ; $02FD33 | |
    BEQ +                                                                       ; $02FD35 | |
    LDA #(3 << 4).b                                                             ; $02FD37 | |
    JMP ++                                                                      ; $02FD39 | |
+   LDA #(2 << 4).b                                                             ; $02FD3C | |
++  STA <r_battle_effect_spell_tile_priority                                    ; $02FD3E |/
    LDA r_battle_effect_spell_size.width.w                                      ; $02FD40 |\
    ASL A                                                                       ; $02FD43 | | Calculate half of the width of the effect in pixels by multiplying
    ASL A                                                                       ; $02FD44 | | the width in tiles by eight.
    ASL A                                                                       ; $02FD45 | |
    STA <r_battle_effect_spell_current_coordinates.x                            ; $02FD46 |/
    LDA r_battle_effect_spell_size.height.w                                     ; $02FD48 |\
    ASL A                                                                       ; $02FD4B | | Calculate half of the height of the effect in pixels by
    ASL A                                                                       ; $02FD4C | | multiplying the height in tiles by eight.
    ASL A                                                                       ; $02FD4D | |
    STA <r_battle_effect_spell_current_coordinates.y                            ; $02FD4E |/
    LDA r_battle_effect_spell_coordinate_offsets.x.w                            ; $02FD50 |\
    SEC                                                                         ; $02FD53 | | Calculate the current X coordinate by subtracting half the width
    SBC <r_battle_effect_spell_current_coordinates.x                            ; $02FD54 | | from the X coordinate offset.
    STA <r_battle_effect_spell_current_coordinates.x                            ; $02FD56 |/
    LDA r_battle_effect_spell_coordinate_offsets.y.w                            ; $02FD58 |\
    SEC                                                                         ; $02FD5B | | Calculate the current Y coordinate by subtracting half the height
    SBC <r_battle_effect_spell_current_coordinates.y                            ; $02FD5C | | from the Y coordinate offset.
    STA <r_battle_effect_spell_current_coordinates.y                            ; $02FD5E |/
    LDA r_battle_effect_spell_frame_index.w                                     ; $02FD60 |\
    TAX                                                                         ; $02FD63 | | Calculate the frame's absolute index by multiplying the block
    STX <r_battle_effect_spell_frame_data_ptr_addr_lo                           ; $02FD64 | | number by 128 (as each block has 128 tiles) and adding the frame
    LDA r_battle_effect_spell_frame_block.w                                     ; $02FD66 | | index. Multiply that value by two and transfer it to the X
    REP #FLAG_P_ACCUMULATOR                                                     ; $02FD69 | | register to index the frame pointer data.
    ASL A                                                                       ; $02FD6B | |
    ASL A                                                                       ; $02FD6C | |
    ASL A                                                                       ; $02FD6D | |
    ASL A                                                                       ; $02FD6E | |
    ASL A                                                                       ; $02FD6F | |
    ASL A                                                                       ; $02FD70 | |
    ASL A                                                                       ; $02FD71 | |
    CLC                                                                         ; $02FD72 | |
    ADC <r_battle_effect_spell_frame_data_ptr_addr_lo                           ; $02FD73 | |
    ASL A                                                                       ; $02FD75 | |
    TAX                                                                         ; $02FD76 | |
    TDC                                                                         ; $02FD77 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $02FD78 |/
    LDA bank0F.battle_effect_spell_frame_offset_data.l + 0,X                    ; $02FD7A |\
    STA <r_battle_effect_spell_frame_data_ptr_addr_lo                           ; $02FD7E | | Set the pointer to the data for this frame by reading it from ROM.
    LDA bank0F.battle_effect_spell_frame_offset_data.l + 1,X                    ; $02FD80 | |
    STA <r_battle_effect_spell_frame_data_ptr_addr_hi                           ; $02FD84 | |
    LDA #:bank0F.battle_effect_spell_frame_offset_data.b                        ; $02FD86 | |
    STA <r_battle_effect_spell_frame_data_ptr_bank                              ; $02FD88 |/
    LDX r_battle_effect_spell_size.w                                            ; $02FD8A |\ Initialize the horizontal and vertical tiles remaining variables to
    STX <r_battle_effect_spell_tiles_remaining                                  ; $02FD8D |/ the width and height of the effect.
    LDX <r_battle_effect_spell_current_coordinates                              ; $02FD8F |\ Back up the current coordinates to the starting coordinates array.
    STX <r_battle_effect_spell_starting_coordinates                             ; $02FD91 |/
    LDY #0.w                                                                    ; $02FD93 | Initialize the Y register to zero (used as effect OAM index).
--  LDA [<r_battle_effect_spell_frame_data_ptr]                                 ; $02FD96 | Read the next byte of the frame data.
    BMI +                                                                       ; $02FD98 | If the high bit is set, branch to additional processing.
    LDX <r_battle_effect_spell_frame_data_ptr_addr                              ; $02FD9A |\
    INX                                                                         ; $02FD9C | | Otherwise, increment the pointer, and use that value directly to
    STX <r_battle_effect_spell_frame_data_ptr_addr                              ; $02FD9D | | set the current tile.
    JSL bank03.battle_effect_spell_set_oam_entry                                ; $02FD9F |/
    BCC @complete                                                               ; $02FDA3 | Branch to the next section if the grid is completely filled.
    JMP --                                                                      ; $02FDA5 | Otherwise, loop back to read the next byte.
+   CMP #$FF.b                                                                  ; $02FDA8 |\ If the next byte is $FF, branch to the next section.
    BEQ @complete                                                               ; $02FDAA |/
    STA <r_battle_effect_spell_current_tile                                     ; $02FDAC | Save the read byte for later use.
    LDX <r_battle_effect_spell_frame_data_ptr                                   ; $02FDAE |\
    INX                                                                         ; $02FDB0 | | Increment the pointer.
    STX <r_battle_effect_spell_frame_data_ptr                                   ; $02FDB1 |/
    LDA [<r_battle_effect_spell_frame_data_ptr]                                 ; $02FDB3 |\ Read the next byte and save that as the tile count.
    STA <r_battle_effect_spell_current_remaining                                ; $02FDB5 |/
    LDX <r_battle_effect_spell_frame_data_ptr_addr                              ; $02FDB7 |\
    INX                                                                         ; $02FDB9 | | Increment the pointer again.
    STX <r_battle_effect_spell_frame_data_ptr_addr                              ; $02FDBA |/
-   LDA <r_battle_effect_spell_current_tile                                     ; $02FDBC |\ Load the tile number byte and update the next tile.
    JSL bank03.battle_effect_spell_set_oam_entry                                ; $02FDBE |/
    BCC @complete                                                               ; $02FDC2 | If the grid is complete, branch to the next section.
    DEC <r_battle_effect_spell_current_remaining                                ; $02FDC4 |\ Otherwise, decrement the count of this tile that is remaining and
    BNE -                                                                       ; $02FDC6 |/ loop to copy it again.
    JMP --                                                                      ; $02FDC8 | Loop back to read the next byte.
@complete:
    STY r_battle_effect_spell_load_frame_result_oam_offset.w                    ; $02FDCB | Save the current OAM offset as a return value.
    LDA r_battle_effect_spell_sprite_pattern.w                                  ; $02FDCE |\
    CMP #BATTLE_SPELL_SPRITE_PATTERN_ROTATING_PAIR.b                            ; $02FDD1 | | If the sprite pattern isn't set to a mode that has individual
    BEQ +                                                                       ; $02FDD3 | | offsets for each sprite, branch ahead to the end.
    CMP #BATTLE_SPELL_SPRITE_PATTERN_FIRE3.b                                    ; $02FDD5 | |
    BEQ +                                                                       ; $02FDD7 | |
    CMP #BATTLE_SPELL_SPRITE_PATTERN_RANDOM.b                                   ; $02FDD9 | |
    BNE ++                                                                      ; $02FDDB |/
+   LDX #0.w                                                                    ; $02FDDD |\ Initialize the X and Y registers to zero.
    LDY #0.w                                                                    ; $02FDE0 |/
-   LDA r_battle_effect_oam.1.x.w,Y                                             ; $02FDE3 |\
    CLC                                                                         ; $02FDE6 | | Add the offset for this OAM entry to the X coordinate.
    ADC r_battle_effect_spell_oam_coordinate_offsets.1.x.w,X                    ; $02FDE7 | |
    STA r_battle_effect_oam.1.x.w,Y                                             ; $02FDEA |/
    LDA r_battle_effect_oam.1.y.w,Y                                             ; $02FDED |\
    CLC                                                                         ; $02FDF0 | | Add the offset for this OAM entry to the Y coordinate.
    ADC r_battle_effect_spell_oam_coordinate_offsets.1.y.w,X                    ; $02FDF1 | |
    STA r_battle_effect_oam.1.y.w,Y                                             ; $02FDF4 |/
    INX                                                                         ; $02FDF7 |\ Increment the X register twice to move to the next coordinate.
    INX                                                                         ; $02FDF8 |/
    INY                                                                         ; $02FDF9 |\
    INY                                                                         ; $02FDFA | | Increment the Y register four times to move to the next OAM entry.
    INY                                                                         ; $02FDFB | |
    INY                                                                         ; $02FDFC |/
    CPY #_sizeof_r_battle_effect_spell_oam_coordinate_offsets.w * 2             ; $02FDFD |\ Loop until nine entries have been updated.
    BNE -                                                                       ; $02FE00 |/
++  RTS                                                                         ; $02FE02

; _battle_load_casting_spell_tiles ($02:FE03)
;
; Given a class of magic in the accumulator, loads the spell tiles to display
; the casting animation for that class of spells. (0 is black, 1 is white and 2
; is call.)
_battle_load_casting_spell_tiles:
    TAX                                                                         ; $02FE03 |\
    LDA bank16.battle_cast_animation_tile_block_data.l,X                        ; $02FE04 | | Load spell tiles for the magic class passed in the accumulator.
    JMP _battle_load_spell_tiles_multiple_blocks                                ; $02FE08 |/

; battle_spell_block_fixed_size_data ($02:FE0B)
;
; For effect blocks 15-17, provides the number of tiles in ROM remaining that
; are available to be read, ensuring no block reads past the end of the data.
battle_spell_block_fixed_size_data:
    .dw $0060                                                                   ; $02FE0B.FE0C | $15
    .dw $0040                                                                   ; $02FE0D.FE0E | $16
    .dw $0020                                                                   ; $02FE0F.FE10 | $17

; _battle_load_spell_tiles_* ($02:FE11)
;
; Loads spell tiles from ROM to VRAM. Depending on the entry point, loads either
; a single block (of 8 16x16 tiles) or up to four blocks. (Blocks numbering $15
; or later automatically load fewer blocks.)
_battle_load_spell_tiles_multiple_blocks:
    LDY #(32 * 4).w                                                             ; $02FE11 |\
    STY r_battle_load_spell_tiles_arg_tiles.w                                   ; $02FE14 | | Configure the arguments to load up to 128 tiles from ROM and
    LDY #(32 * 4 * 32).w                                                        ; $02FE17 | | transfer those 128 tiles to VRAM, and then branch to the code to
    STY r_battle_load_spell_tiles_arg_bytes.w                                   ; $02FE1A | | load.
    BRA _battle_load_spell_tiles                                                ; $02FE1D |/
_battle_load_spell_tiles_single_block:
    LDY #32.w                                                                   ; $02FE1F |\
    STY r_battle_load_spell_tiles_arg_tiles.w                                   ; $02FE22 | | Configure the arguments to load 32 tiles from ROM and transfer
    LDY #(32 * 32).w                                                            ; $02FE25 | | them to VRAM, and then fall through to the loading code.
    STY r_battle_load_spell_tiles_arg_bytes.w                                   ; $02FE28 |/

; _battle_load_spell_tiles ($02:FE2B)
;
; Given a 16-bit number of tiles to load in $F469 and a 16-bit number of bytes
; to ultimately transfer to VRAM in $F4B6, copies the 3 bits per pixel spell
; tiles from ROM to VRAM. The tiles themselves are composed of four 8x8 tiles
; determined by composition data in bank $0C. The data is expanded to 4 bits per
; pixel while copying.
_battle_load_spell_tiles:
    PHA                                                                         ; $02FE2B | Preserve the initial block number on the stack.
    CMP #BATTLE_SPELL_BLOCK_FIRST_FIXED_SIZE.b                                  ; $02FE2C |\
    BCC +                                                                       ; $02FE2E | | If the block number parameter is $15 or greater, load the number
    SEC                                                                         ; $02FE30 | | of tiles to load from another array in ROM. Note that this does
    SBC #BATTLE_SPELL_BLOCK_FIRST_FIXED_SIZE.b                                  ; $02FE31 | | not affect the number of bytes that will be transferred to VRAM.
    PHX                                                                         ; $02FE33 | | The primary purpose seems to be nothing more than ensuring that
    REP #FLAG_P_ACCUMULATOR                                                     ; $02FE34 | | no block reads past the graphical tile data in ROM.
    ASL A                                                                       ; $02FE36 | |
    TAX                                                                         ; $02FE37 | |
    LDA battle_spell_block_fixed_size_data.l,X                                  ; $02FE38 | |
    STA r_battle_load_spell_tiles_arg_tiles.w                                   ; $02FE3C | |
    TDC                                                                         ; $02FE3F | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $02FE40 | |
    PLX                                                                         ; $02FE42 |/
+   LDA #:r_battle_spell_tile_offsets.b                                         ; $02FE43 |\
    STA <r_battle_load_spell_tiles_tmp_offset_ptr_bank                          ; $02FE45 | | Set the banks of the two 24-bit pointers (the offset pointer and
    LDA #:bank0C.battle_sprite_spell_tile_data.b                                ; $02FE47 | | the ROM pointer).
    STA <r_battle_load_spell_tiles_tmp_rom_ptr_bank                             ; $02FE49 |/
    PLA                                                                         ; $02FE4B |\
    REP #FLAG_P_ACCUMULATOR                                                     ; $02FE4C | | Set the X register to the block number times 64. (Each tile
    ASL A                                                                       ; $02FE4E | | offset is two bytes, and each block has 32 tiles, so this can
    ASL A                                                                       ; $02FE4F | | index the tile offset array.)
    ASL A                                                                       ; $02FE50 | |
    ASL A                                                                       ; $02FE51 | |
    ASL A                                                                       ; $02FE52 | |
    ASL A                                                                       ; $02FE53 | |
    TAX                                                                         ; $02FE54 |/
    LDA #r_battle_load_sprite_data.w                                            ; $02FE55 |\ Set the RAM pointer to the temporary array for sprite data in RAM.
    STA <r_battle_load_spell_tiles_tmp_ram_ptr                                  ; $02FE58 |/
    LDA #r_battle_spell_tile_offsets.w                                          ; $02FE5A |\ Set the offset pointer address to the base address for the offset
    STA <r_battle_load_spell_tiles_tmp_offset_ptr_addr                          ; $02FE5D |/ data.
    LDY r_battle_load_spell_tiles_arg_tiles.w                                   ; $02FE5F | Set the Y register to the total number of tiles to read.
@start:
    PHY                                                                         ; $02FE62 | Push the current remaining tile count to the stack.
    LDA bank0C.battle_sprite_spell_tile_composition_data.l,X                    ; $02FE63 |\
    PHA                                                                         ; $02FE67 | | Load the tile composition data and save it to the stack twice.
    PHA                                                                         ; $02FE68 |/
    AND #BATTLE_SPELL_TILE_COMPOSITION_TILE.w                                   ; $02FE69 |\
    ASL A                                                                       ; $02FE6C | | Load the offset for the associated tile and store it in the
    TAY                                                                         ; $02FE6D | | current ROM pointer.
    LDA [<r_battle_load_spell_tiles_tmp_offset_ptr],Y                           ; $02FE6E | |
    STA <r_battle_load_spell_tiles_tmp_rom_ptr_addr                             ; $02FE70 |/
    PLA                                                                         ; $02FE72 |\
    AND #BATTLE_SPELL_TILE_COMPOSITION_HORIZONTAL_FLIP.w                        ; $02FE73 | | Determine if the tile needs to be flipped horizontally.
    STA <r_battle_load_spell_tiles_tmp_horizontal_flip                          ; $02FE76 |/
    PLA                                                                         ; $02FE78 |\
    AND #BATTLE_SPELL_TILE_COMPOSITION_VERTICAL_FLIP.w                          ; $02FE79 | | If the tile needs to be flipped vertically, branch to that code.
    BNE @vertical_flip                                                          ; $02FE7C |/
    LDY #0.w                                                                    ; $02FE7E | Initialize the Y register to zero.
-   LDA [<r_battle_load_spell_tiles_tmp_rom_ptr]                                ; $02FE81 | Load the low bits in the first two bytes.
    JSR _battle_load_spell_tiles_flip_horizontal                                ; $02FE83 | Flip the data horizontally, if appropriate.
    STA (<r_battle_load_spell_tiles_tmp_ram_ptr),Y                              ; $02FE86 | Write the data to RAM.
    INC <r_battle_load_spell_tiles_tmp_rom_ptr_addr                             ; $02FE88 |\ Increment the ROM pointer by two to read the next byte.
    INC <r_battle_load_spell_tiles_tmp_rom_ptr_addr                             ; $02FE8A |/
    INY                                                                         ; $02FE8C |\ Increment the Y register to write the next two bytes.
    INY                                                                         ; $02FE8D |/
    CPY #16.w                                                                   ; $02FE8E |\ Loop until all sixteen bytes (two for each row) have been copied.
    BNE -                                                                       ; $02FE91 |/
-   LDA [<r_battle_load_spell_tiles_tmp_rom_ptr]                                ; $02FE93 | Read the next byte (actually two bytes).
    JSR _battle_load_spell_tiles_flip_horizontal                                ; $02FE95 | Flip the data horizontally if appropriate.
    AND #$00FF.w                                                                ; $02FE98 | Mask out only the byte currently cared about.
    STA (<r_battle_load_spell_tiles_tmp_ram_ptr),Y                              ; $02FE9B | Save the byte to RAM.
    INC <r_battle_load_spell_tiles_tmp_rom_ptr_addr                             ; $02FE9D | Increment the ROM pointer by one to move to the next byte.
    INY                                                                         ; $02FE9F |\ Increment the Y register twice (effectively expands the data from
    INY                                                                         ; $02FEA0 |/ 3 bits per pixel to 4 bits per pixel).
    CPY #32.w                                                                   ; $02FEA1 |\ Loop until the next sixteen bytes have been written.
    BNE -                                                                       ; $02FEA4 |/
    BRA @common                                                                 ; $02FEA6 | Branch to the common code.
@vertical_flip:
    LDY #14.w                                                                   ; $02FEA8 | Initialize the Y register to 14, to start at the bottom.
-   LDA [<r_battle_load_spell_tiles_tmp_rom_ptr]                                ; $02FEAB |\
    JSR _battle_load_spell_tiles_flip_horizontal                                ; $02FEAD | | Load the two bytes, flip if appropriate, and save to RAM.
    STA (<r_battle_load_spell_tiles_tmp_ram_ptr),Y                              ; $02FEB0 |/
    INC <r_battle_load_spell_tiles_tmp_rom_ptr_addr                             ; $02FEB2 |\ Increment the ROM pointer by two.
    INC <r_battle_load_spell_tiles_tmp_rom_ptr_addr                             ; $02FEB4 |/
    DEY                                                                         ; $02FEB6 |\ Decrement the Y register by two.
    DEY                                                                         ; $02FEB7 |/
    CPY #-2.w                                                                   ; $02FEB8 |\ Loop until all 8 rows have been copied.
    BNE -                                                                       ; $02FEBB |/
    LDY #30.w                                                                   ; $02FEBD | Initialize the Y register to 30 to start at the last row.
-   LDA [<r_battle_load_spell_tiles_tmp_rom_ptr]                                ; $02FEC0 |\
    JSR _battle_load_spell_tiles_flip_horizontal                                ; $02FEC2 | | Copy the next plane of data, expanding the data from 3 bits per
    AND #$00FF.w                                                                ; $02FEC5 | | pixel to 4 bits per pixel in the process.
    STA (<r_battle_load_spell_tiles_tmp_ram_ptr),Y                              ; $02FEC8 | |
    INC <r_battle_load_spell_tiles_tmp_rom_ptr_addr                             ; $02FECA | |
    DEY                                                                         ; $02FECC | |
    DEY                                                                         ; $02FECD | |
    CPY #14.w                                                                   ; $02FECE | |
    BNE -                                                                       ; $02FED1 |/
@common:
    LDA <r_battle_load_spell_tiles_tmp_ram_ptr                                  ; $02FED3 |\
    CLC                                                                         ; $02FED5 | | Increment the RAM pointer by 32 to move to the next tile.
    ADC #32.w                                                                   ; $02FED6 | |
    STA <r_battle_load_spell_tiles_tmp_ram_ptr                                  ; $02FED9 |/
    INX                                                                         ; $02FEDB |\ Increment the X register by two to move to the next tile.
    INX                                                                         ; $02FEDC |/
    PLY                                                                         ; $02FEDD |\
    DEY                                                                         ; $02FEDE | | Loop until the requested number of tiles have been copied.
    BNE @start                                                                  ; $02FEDF |/
    TDC                                                                         ; $02FEE1 |\
    SEP #FLAG_P_ACCUMULATOR.b                                                   ; $02FEE2 | | Switch back to 8-bit mode, and set the accumulator and X register
    TDC                                                                         ; $02FEE4 | | to zero.
    TAX                                                                         ; $02FEE5 |/
-   STA r_battle_load_sprite_data.w + 6 * (16 * 32) + 14 * 32.w,X               ; $02FEE6 |\
    STA r_battle_load_sprite_data.w + 7 * (16 * 32) + 14 * 32.w,X               ; $02FEE9 | | Write a 16x16 black tile in the very last spot in the tile data.
    INX                                                                         ; $02FEEC | |
    CPX #64.w                                                                   ; $02FEED | |
    BNE -                                                                       ; $02FEF0 |/
    LDY #$1800.w                                                                ; $02FEF2 |\
    LDX r_battle_load_spell_tiles_arg_bytes.w                                   ; $02FEF5 | | Copy the tile data from RAM to VRAM.
    STX <r_battle_load_spell_tiles_tmp_rom_ptr_addr                             ; $02FEF8 | |
    LDA #:r_battle_load_sprite_data.b                                           ; $02FEFA | |
    LDX #r_battle_load_sprite_data.w                                            ; $02FEFC | |
    JSR _battle_copy_to_vram                                                    ; $02FEFF |/
    JSR _battle_load_wall_spell_tiles                                           ; $02FF02 | Load the wall spell tiles (one 16x16 tile).
    RTS                                                                         ; $02FF05

; _battle_load_spell_tiles_flip_horizontal ($02:FF06)
;
; If the horizontal flip flag in $0A is non-zero, flips the 16-bit value in the
; accumulator as if it's planar tile data. In other words, the two bytes will
; be left in their relative positions, but the bits inside them will be flipped.
_battle_load_spell_tiles_flip_horizontal:
    PHA                                                                         ; $02FF06 |\
    LDA <r_battle_load_spell_tiles_tmp_horizontal_flip                          ; $02FF07 | | Skip this function unless the horizontal flip flag is set.
    BEQ +                                                                       ; $02FF09 | |
    PLA                                                                         ; $02FF0B |/
    XBA                                                                         ; $02FF0C |\ Swap the two bytes and save to a temporary variable (to ensure the
    STA <r_battle_load_spell_tiles_tmp                                          ; $02FF0D |/ two colors are in the right place after it's flipped).
    PHX                                                                         ; $02FF0F |\
    LDX #16.w                                                                   ; $02FF10 | | Flip the bits in the value, with an ultimate result of each plane
-   ASL <r_battle_load_spell_tiles_tmp                                          ; $02FF13 | | having been flipped.
    ROR A                                                                       ; $02FF15 | |
    DEX                                                                         ; $02FF16 | |
    BNE -                                                                       ; $02FF17 |/
    PLX                                                                         ; $02FF19 |\
    RTS                                                                         ; $02FF1A | | Code to handle returning from either path.
+   PLA                                                                         ; $02FF1B | |
    RTS                                                                         ; $02FF1C |/

; _battle_load_wall_spell_tiles ($02:FF1D)
;
; Copies the 16x16 spell tile used for the wall effect to VRAM.
_battle_load_wall_spell_tiles:
    LDX #BATTLE_SPELL_TILE_OFFSET_WALL_UPPER.w                                  ; $02FF1D |\
    JSR _battle_copy_spell_tile_pair_to_ram                                     ; $02FF20 | | Copy the upper two tiles of the 16x16 wall tile to VRAM.
    LDY #$1EC0.w                                                                ; $02FF23 | |
    JSR @copy                                                                   ; $02FF26 |/
    LDX #BATTLE_SPELL_TILE_OFFSET_WALL_LOWER.w                                  ; $02FF29 |\
    JSR _battle_copy_spell_tile_pair_to_ram                                     ; $02FF2C | | Copy the lower two tiles of the 16x16 wall tile to VRAM.
    LDY #$1FC0.w                                                                ; $02FF2F |/
@copy:
    LDX #64.w                                                                   ; $02FF32 |\
    STX <r_battle_copy_tile_to_vram_arg_bytes                                   ; $02FF35 | | Copy the pair of tiles from RAM to VRAM.
    LDA #:r_battle_load_sprite_data.b                                           ; $02FF37 | |
    LDX #r_battle_load_sprite_data.w                                            ; $02FF39 | |
    JMP _battle_copy_tile_to_vram                                               ; $02FF3C |/

; _battle_copy_spell_tile_pair_to_ram ($02:FF3F)
;
; Given a spell tile offset in the X register, copies that 8x8 tile and the next
; one to RAM in the array at $DBE6.
_battle_copy_spell_tile_pair_to_ram:
    REP #FLAG_P_ACCUMULATOR                                                     ; $02FF3F |\
    LDA bank0C.battle_sprite_spell_tile_composition_data.l,X                    ; $02FF41 | | Load the base tile offset for the specified tile and transfer it
    AND #$03FF.w                                                                ; $02FF45 | | to the Y register.
    ASL A                                                                       ; $02FF48 | |
    TAX                                                                         ; $02FF49 | |
    LDA r_battle_spell_tile_offsets.l,X                                         ; $02FF4A | |
    TAY                                                                         ; $02FF4E | |
    TDC                                                                         ; $02FF4F | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $02FF50 |/
    LDX #2.w                                                                    ; $02FF52 |\ Set the number of tiles to copy to two.
    STX <r_battle_copy_3bpp_to_ram_arg_tiles                                    ; $02FF55 |/
    LDX #r_battle_load_sprite_data.w                                            ; $02FF57 |\
    LDA #:bank0C.battle_sprite_spell_tile_data.b                                ; $02FF5A | | Copy two 3bpp tiles from ROM to RAM.
    JMP _battle_copy_3bpp_to_ram                                                ; $02FF5C |/

; _battle_copy_tile_to_vram ($02:FF5F)
;
; Given a source bank in the accumulator, a source address in the X register, a
; target VRAM address in the Y register, and a number of bytes to copy in $00,
; copies that data from the source to VRAM. The data is actually copied in
; blocks of 64, regardless of the number of bytes specified. This is used to
; copy pairs of 4bpp tiles to VRAM.
_battle_copy_tile_to_vram:
    PHA                                                                         ; $02FF5F |\
    PHX                                                                         ; $02FF60 | | Loop until there is no DMA pending, ensuring all the arguments are
    PHY                                                                         ; $02FF61 | | preserved.
    LDX <r_battle_copy_tile_to_vram_arg_bytes                                   ; $02FF62 | |
    PHX                                                                         ; $02FF64 | |
-   LDA r_battle_dma_1_pending.w                                                ; $02FF65 | |
    BEQ +                                                                       ; $02FF68 | |
    JSR _battle_wait_next_frame_preserve_x_y                                    ; $02FF6A | |
    BRA -                                                                       ; $02FF6D | |
+   PLX                                                                         ; $02FF6F | |
    STX <r_battle_copy_tile_to_vram_arg_bytes                                   ; $02FF70 | |
    PLY                                                                         ; $02FF72 | |
    PLX                                                                         ; $02FF73 | |
    PLA                                                                         ; $02FF74 |/
    STA r_battle_dma_1_source_bank.w                                            ; $02FF75 | Set the source bank to the value in the accumulator.
    STX r_battle_dma_1_source_address.w                                         ; $02FF78 | Set the source address from the X register.
    STY r_battle_dma_1_target_vram_address.w                                    ; $02FF7B | Set the target VRAM address from the Y register.
    LDX #64.w                                                                   ; $02FF7E |\ Configure the DMA to transfer 64 bytes (2 8x8 tiles).
    STX r_battle_dma_1_bytes.w                                                  ; $02FF81 |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $02FF84 |\
    LDA <r_battle_copy_tile_to_vram_arg_bytes                                   ; $02FF86 | | Set the number of DMA transfers to the number of bytes to transfer
    ASL A                                                                       ; $02FF88 | | times four divided by 256 (or in other words, divided by 64).
    ASL A                                                                       ; $02FF89 | |
    AND #$FF00.w                                                                ; $02FF8A | |
    STA <r_battle_copy_tile_to_vram_arg_bytes                                   ; $02FF8D | |
    TDC                                                                         ; $02FF8F | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $02FF90 | |
    LDA <r_battle_copy_tile_to_vram_arg_bytes_hi                                ; $02FF92 | |
    STA r_battle_dma_1_tmp_index.w                                              ; $02FF94 |/
-   INC r_battle_dma_1_pending.w                                                ; $02FF97 | Flag the DMA as pending.
    JSR _battle_wait_next_frame_preserve_x_y                                    ; $02FF9A | Wait a frame.
    DEC r_battle_dma_1_tmp_index.w                                              ; $02FF9D |\ If the DMA counter reaches zero, branch to the end.
    BEQ +                                                                       ; $02FFA0 |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $02FFA2 |\
    LDA r_battle_dma_1_source_address.w                                         ; $02FFA4 | | Add two tiles to each fo the source address and target VRAM
    CLC                                                                         ; $02FFA7 | | address to move to the next pair of tiles. Loop back to the
    ADC #64.w                                                                   ; $02FFA8 | | beginning of the loop.
    STA r_battle_dma_1_source_address.w                                         ; $02FFAB | |
    LDA r_battle_dma_1_target_vram_address.w                                    ; $02FFAE | |
    CLC                                                                         ; $02FFB1 | |
    ADC #32.w                                                                   ; $02FFB2 | |
    STA r_battle_dma_1_target_vram_address.w                                    ; $02FFB5 | |
    TDC                                                                         ; $02FFB8 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $02FFB9 | |
    BRA -                                                                       ; $02FFBB |/
+   RTS                                                                         ; $02FFBD

UNUSED_02FFBE:
.if FF4_REGION == "JAPAN"
.if FF4_EASYTYPE == 1
    .dsb $003C $FF                                                              ; $02FFC4.FFFF
.else
    .dsb $003F $FF                                                              ; $02FFC1.FFFF
.endif
.else
    .dsb $0042 $FF                                                              ; $02FFBE.FFFF
.endif

.ends
